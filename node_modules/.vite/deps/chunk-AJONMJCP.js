import {
  axios_default
} from "./chunk-S5GX4QAS.js";
import {
  bignumber_default
} from "./chunk-6YYWF2EP.js";
import {
  require_buffer
} from "./chunk-V4ZM3WID.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-BYPFWIQ6.js";

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long51;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long51(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long51.prototype.__isLong__;
    Object.defineProperty(Long51.prototype, "__isLong__", { value: true });
    function isLong2(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long51.isLong = isLong2;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long51.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long51.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long51(lowBits, highBits, unsigned);
    }
    Long51.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString2(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString2(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long51.fromString = fromString2;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString2(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long51.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long51.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long51.UZERO = UZERO;
    var ONE2 = fromInt(1);
    Long51.ONE = ONE2;
    var UONE = fromInt(1, true);
    Long51.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long51.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long51.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long51.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long51.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long51.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong2(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare3(other) {
      if (!isLong2(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE2);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong2(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong2(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong2(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE2) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE2;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE2 : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE2;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong2(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong2(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong2(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long51.fromBytes = function fromBytes2(bytes3, unsigned, le) {
      return le ? Long51.fromBytesLE(bytes3, unsigned) : Long51.fromBytesBE(bytes3, unsigned);
    };
    Long51.fromBytesLE = function fromBytesLE(bytes3, unsigned) {
      return new Long51(
        bytes3[0] | bytes3[1] << 8 | bytes3[2] << 16 | bytes3[3] << 24,
        bytes3[4] | bytes3[5] << 8 | bytes3[6] << 16 | bytes3[7] << 24,
        unsigned
      );
    };
    Long51.fromBytesBE = function fromBytesBE(bytes3, unsigned) {
      return new Long51(
        bytes3[4] << 24 | bytes3[5] << 16 | bytes3[6] << 8 | bytes3[7],
        bytes3[0] << 24 | bytes3[1] << 16 | bytes3[2] << 8 | bytes3[3],
        unsigned
      );
    };
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode8(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode10(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
        (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger2(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer5 = util.inquire("buffer").Buffer;
        return Buffer5.prototype.utf8Write ? Buffer5 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer5 = util.Buffer;
      if (!Buffer5) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer5.from !== Uint8Array.from && Buffer5.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer5(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer5.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer5(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create();
    Writer2.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer2.alloc = util.pool(Writer2.alloc, util.Array.prototype.subarray);
    Writer2.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer2.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer2.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer2.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer2.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer2.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader2;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader2(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader2.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader2.create = create();
    Reader2.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader2.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader2.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader2.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader2.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader2.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader2.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader2.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader2.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader2.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader2.prototype.string = function read_string() {
      var bytes3 = this.bytes();
      return utf8.read(bytes3, 0, bytes3.length);
    };
    Reader2.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader2.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader2._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader2.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader2.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader2 = require_reader();
    (BufferReader.prototype = Object.create(Reader2.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader2.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/@hashgraph/proto/lib/proto.js
var require_proto = __commonJS({
  "node_modules/@hashgraph/proto/lib/proto.js"(exports2) {
    "use strict";
    var $protobuf = _interopRequireWildcard(require_minimal2());
    Object.defineProperty(exports2, "__esModule", { value: true }), exports2.proto = exports2.google = exports2.default = exports2.com = void 0;
    function _getRequireWildcardCache(o) {
      if ("function" != typeof WeakMap)
        return null;
      var n = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(o2) {
        return o2 ? r2 : n;
      })(o);
    }
    function _interopRequireWildcard(o, e) {
      if (!e && o && o.__esModule)
        return o;
      if (null === o || "object" != typeof o && "function" != typeof o)
        return { default: o };
      var r2 = _getRequireWildcardCache(e);
      if (r2 && r2.has(o))
        return r2.get(o);
      var t = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var d in o)
        if ("default" != d && Object.prototype.hasOwnProperty.call(o, d)) {
          var a = n ? Object.getOwnPropertyDescriptor(o, d) : null;
          a && (a.get || a.set) ? Object.defineProperty(t, d, a) : t[d] = o[d];
        }
      return t.default = o, r2 && r2.set(o, t), t;
    }
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots.hashgraph || ($protobuf.roots.hashgraph = {});
    exports2.default = $root;
    var com3 = $root.com = (() => {
      const e = { hedera: function() {
        const e2 = { mirror: function() {
          const e3 = { api: function() {
            const e4 = { proto: function() {
              const e5 = { ConsensusTopicQuery: function() {
                function e6(e7) {
                  if (e7)
                    for (var o = Object.keys(e7), t = 0; t < o.length; ++t)
                      null != e7[o[t]] && (this[o[t]] = e7[o[t]]);
                }
                return e6.prototype.topicID = null, e6.prototype.consensusStartTime = null, e6.prototype.consensusEndTime = null, e6.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e6.create = function(o) {
                  return new e6(o);
                }, e6.encode = function(e7, o) {
                  return o || (o = $Writer.create()), null != e7.topicID && Object.hasOwnProperty.call(e7, "topicID") && $root.proto.TopicID.encode(e7.topicID, o.uint32(10).fork()).ldelim(), null != e7.consensusStartTime && Object.hasOwnProperty.call(e7, "consensusStartTime") && $root.proto.Timestamp.encode(e7.consensusStartTime, o.uint32(18).fork()).ldelim(), null != e7.consensusEndTime && Object.hasOwnProperty.call(e7, "consensusEndTime") && $root.proto.Timestamp.encode(e7.consensusEndTime, o.uint32(26).fork()).ldelim(), null != e7.limit && Object.hasOwnProperty.call(e7, "limit") && o.uint32(32).uint64(e7.limit), o;
                }, e6.decode = function(e7, o) {
                  e7 instanceof $Reader || (e7 = $Reader.create(e7));
                  for (var n = void 0 === o ? e7.len : e7.pos + o, i = new $root.com.hedera.mirror.api.proto.ConsensusTopicQuery(), d; e7.pos < n; )
                    switch (d = e7.uint32(), d >>> 3) {
                      case 1: {
                        i.topicID = $root.proto.TopicID.decode(e7, e7.uint32());
                        break;
                      }
                      case 2: {
                        i.consensusStartTime = $root.proto.Timestamp.decode(e7, e7.uint32());
                        break;
                      }
                      case 3: {
                        i.consensusEndTime = $root.proto.Timestamp.decode(e7, e7.uint32());
                        break;
                      }
                      case 4: {
                        i.limit = e7.uint64();
                        break;
                      }
                      default:
                        e7.skipType(7 & d);
                    }
                  return i;
                }, e6.getTypeUrl = function(e7) {
                  return void 0 === e7 && (e7 = "type.googleapis.com"), e7 + "/com.hedera.mirror.api.proto.ConsensusTopicQuery";
                }, e6;
              }(), ConsensusTopicResponse: function() {
                function e6(e7) {
                  if (e7)
                    for (var o = Object.keys(e7), t = 0; t < o.length; ++t)
                      null != e7[o[t]] && (this[o[t]] = e7[o[t]]);
                }
                return e6.prototype.consensusTimestamp = null, e6.prototype.message = $util.newBuffer([]), e6.prototype.runningHash = $util.newBuffer([]), e6.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e6.prototype.runningHashVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e6.prototype.chunkInfo = null, e6.create = function(o) {
                  return new e6(o);
                }, e6.encode = function(e7, o) {
                  return o || (o = $Writer.create()), null != e7.consensusTimestamp && Object.hasOwnProperty.call(e7, "consensusTimestamp") && $root.proto.Timestamp.encode(e7.consensusTimestamp, o.uint32(10).fork()).ldelim(), null != e7.message && Object.hasOwnProperty.call(e7, "message") && o.uint32(18).bytes(e7.message), null != e7.runningHash && Object.hasOwnProperty.call(e7, "runningHash") && o.uint32(26).bytes(e7.runningHash), null != e7.sequenceNumber && Object.hasOwnProperty.call(e7, "sequenceNumber") && o.uint32(32).uint64(e7.sequenceNumber), null != e7.runningHashVersion && Object.hasOwnProperty.call(e7, "runningHashVersion") && o.uint32(40).uint64(e7.runningHashVersion), null != e7.chunkInfo && Object.hasOwnProperty.call(e7, "chunkInfo") && $root.proto.ConsensusMessageChunkInfo.encode(e7.chunkInfo, o.uint32(50).fork()).ldelim(), o;
                }, e6.decode = function(e7, o) {
                  e7 instanceof $Reader || (e7 = $Reader.create(e7));
                  for (var n = void 0 === o ? e7.len : e7.pos + o, i = new $root.com.hedera.mirror.api.proto.ConsensusTopicResponse(), d; e7.pos < n; )
                    switch (d = e7.uint32(), d >>> 3) {
                      case 1: {
                        i.consensusTimestamp = $root.proto.Timestamp.decode(e7, e7.uint32());
                        break;
                      }
                      case 2: {
                        i.message = e7.bytes();
                        break;
                      }
                      case 3: {
                        i.runningHash = e7.bytes();
                        break;
                      }
                      case 4: {
                        i.sequenceNumber = e7.uint64();
                        break;
                      }
                      case 5: {
                        i.runningHashVersion = e7.uint64();
                        break;
                      }
                      case 6: {
                        i.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(e7, e7.uint32());
                        break;
                      }
                      default:
                        e7.skipType(7 & d);
                    }
                  return i;
                }, e6.getTypeUrl = function(e7) {
                  return void 0 === e7 && (e7 = "type.googleapis.com"), e7 + "/com.hedera.mirror.api.proto.ConsensusTopicResponse";
                }, e6;
              }(), ConsensusService: function() {
                function e6(e7, o, t) {
                  $protobuf.rpc.Service.call(this, e7, o, t);
                }
                return (e6.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e6, e6.create = function(e7, o, t) {
                  return new this(e7, o, t);
                }, Object.defineProperty(e6.prototype.subscribeTopic = function t(e7, o) {
                  return this.rpcCall(t, $root.com.hedera.mirror.api.proto.ConsensusTopicQuery, $root.com.hedera.mirror.api.proto.ConsensusTopicResponse, e7, o);
                }, "name", { value: "subscribeTopic" }), e6;
              }(), AddressBookQuery: function() {
                function e6(e7) {
                  if (e7)
                    for (var o = Object.keys(e7), t = 0; t < o.length; ++t)
                      null != e7[o[t]] && (this[o[t]] = e7[o[t]]);
                }
                return e6.prototype.fileId = null, e6.prototype.limit = 0, e6.create = function(o) {
                  return new e6(o);
                }, e6.encode = function(e7, o) {
                  return o || (o = $Writer.create()), null != e7.fileId && Object.hasOwnProperty.call(e7, "fileId") && $root.proto.FileID.encode(e7.fileId, o.uint32(10).fork()).ldelim(), null != e7.limit && Object.hasOwnProperty.call(e7, "limit") && o.uint32(16).int32(e7.limit), o;
                }, e6.decode = function(e7, o) {
                  e7 instanceof $Reader || (e7 = $Reader.create(e7));
                  for (var n = void 0 === o ? e7.len : e7.pos + o, i = new $root.com.hedera.mirror.api.proto.AddressBookQuery(), d; e7.pos < n; )
                    switch (d = e7.uint32(), d >>> 3) {
                      case 1: {
                        i.fileId = $root.proto.FileID.decode(e7, e7.uint32());
                        break;
                      }
                      case 2: {
                        i.limit = e7.int32();
                        break;
                      }
                      default:
                        e7.skipType(7 & d);
                    }
                  return i;
                }, e6.getTypeUrl = function(e7) {
                  return void 0 === e7 && (e7 = "type.googleapis.com"), e7 + "/com.hedera.mirror.api.proto.AddressBookQuery";
                }, e6;
              }(), NetworkService: function() {
                function e6(e7, o, t) {
                  $protobuf.rpc.Service.call(this, e7, o, t);
                }
                return (e6.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e6, e6.create = function(e7, o, t) {
                  return new this(e7, o, t);
                }, Object.defineProperty(e6.prototype.getNodes = function t(e7, o) {
                  return this.rpcCall(t, $root.com.hedera.mirror.api.proto.AddressBookQuery, $root.proto.NodeAddress, e7, o);
                }, "name", { value: "getNodes" }), e6;
              }() };
              return e5;
            }() };
            return e4;
          }() };
          return e3;
        }() };
        return e2;
      }() };
      return e;
    })();
    exports2.com = com3;
    var proto42 = $root.proto = (() => {
      const e = { TransactionList: function() {
        function e2(e3) {
          if (this.transactionList = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionList = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.transactionList && e3.transactionList.length)
            for (var t = 0; t < e3.transactionList.length; ++t)
              $root.proto.Transaction.encode(e3.transactionList[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transactionList && i.transactionList.length || (i.transactionList = []), i.transactionList.push($root.proto.Transaction.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionList";
        }, e2;
      }(), ShardID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ShardID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ShardID";
        }, e2;
      }(), RealmID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), null != e3.realmNum && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.RealmID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              case 2: {
                i.realmNum = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.RealmID";
        }, e2;
      }(), AccountID: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.accountNum = null, e2.prototype.alias = null;
        let o;
        return Object.defineProperty(e2.prototype, "account", { get: $util.oneOfGetter(o = ["accountNum", "alias"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o2.uint32(8).int64(e3.shardNum), null != e3.realmNum && Object.hasOwnProperty.call(e3, "realmNum") && o2.uint32(16).int64(e3.realmNum), null != e3.accountNum && Object.hasOwnProperty.call(e3, "accountNum") && o2.uint32(24).int64(e3.accountNum), null != e3.alias && Object.hasOwnProperty.call(e3, "alias") && o2.uint32(34).bytes(e3.alias), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.AccountID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              case 2: {
                i.realmNum = e3.int64();
                break;
              }
              case 3: {
                i.accountNum = e3.int64();
                break;
              }
              case 4: {
                i.alias = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.AccountID";
        }, e2;
      }(), NftID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token_ID = null, e2.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token_ID && Object.hasOwnProperty.call(e3, "token_ID") && $root.proto.TokenID.encode(e3.token_ID, o.uint32(10).fork()).ldelim(), null != e3.serialNumber && Object.hasOwnProperty.call(e3, "serialNumber") && o.uint32(16).int64(e3.serialNumber), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NftID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token_ID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.serialNumber = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NftID";
        }, e2;
      }(), FileID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.fileNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), null != e3.realmNum && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), null != e3.fileNum && Object.hasOwnProperty.call(e3, "fileNum") && o.uint32(24).int64(e3.fileNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              case 2: {
                i.realmNum = e3.int64();
                break;
              }
              case 3: {
                i.fileNum = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileID";
        }, e2;
      }(), ContractID: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.contractNum = null, e2.prototype.evmAddress = null;
        let o;
        return Object.defineProperty(e2.prototype, "contract", { get: $util.oneOfGetter(o = ["contractNum", "evmAddress"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o2.uint32(8).int64(e3.shardNum), null != e3.realmNum && Object.hasOwnProperty.call(e3, "realmNum") && o2.uint32(16).int64(e3.realmNum), null != e3.contractNum && Object.hasOwnProperty.call(e3, "contractNum") && o2.uint32(24).int64(e3.contractNum), null != e3.evmAddress && Object.hasOwnProperty.call(e3, "evmAddress") && o2.uint32(34).bytes(e3.evmAddress), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.ContractID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              case 2: {
                i.realmNum = e3.int64();
                break;
              }
              case 3: {
                i.contractNum = e3.int64();
                break;
              }
              case 4: {
                i.evmAddress = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractID";
        }, e2;
      }(), TransactionID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionValidStart = null, e2.prototype.accountID = null, e2.prototype.scheduled = false, e2.prototype.nonce = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.transactionValidStart && Object.hasOwnProperty.call(e3, "transactionValidStart") && $root.proto.Timestamp.encode(e3.transactionValidStart, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.scheduled && Object.hasOwnProperty.call(e3, "scheduled") && o.uint32(24).bool(e3.scheduled), null != e3.nonce && Object.hasOwnProperty.call(e3, "nonce") && o.uint32(32).int32(e3.nonce), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transactionValidStart = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.scheduled = e3.bool();
                break;
              }
              case 4: {
                i.nonce = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionID";
        }, e2;
      }(), AccountAmount: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.isApproval = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).sint64(e3.amount), null != e3.isApproval && Object.hasOwnProperty.call(e3, "isApproval") && o.uint32(24).bool(e3.isApproval), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.AccountAmount(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.amount = e3.sint64();
                break;
              }
              case 3: {
                i.isApproval = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.AccountAmount";
        }, e2;
      }(), TransferList: function() {
        function e2(e3) {
          if (this.accountAmounts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountAmounts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.accountAmounts && e3.accountAmounts.length)
            for (var t = 0; t < e3.accountAmounts.length; ++t)
              $root.proto.AccountAmount.encode(e3.accountAmounts[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransferList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountAmounts && i.accountAmounts.length || (i.accountAmounts = []), i.accountAmounts.push($root.proto.AccountAmount.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransferList";
        }, e2;
      }(), NftTransfer: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.senderAccountID = null, e2.prototype.receiverAccountID = null, e2.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.isApproval = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.senderAccountID && Object.hasOwnProperty.call(e3, "senderAccountID") && $root.proto.AccountID.encode(e3.senderAccountID, o.uint32(10).fork()).ldelim(), null != e3.receiverAccountID && Object.hasOwnProperty.call(e3, "receiverAccountID") && $root.proto.AccountID.encode(e3.receiverAccountID, o.uint32(18).fork()).ldelim(), null != e3.serialNumber && Object.hasOwnProperty.call(e3, "serialNumber") && o.uint32(24).int64(e3.serialNumber), null != e3.isApproval && Object.hasOwnProperty.call(e3, "isApproval") && o.uint32(32).bool(e3.isApproval), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NftTransfer(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.senderAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.receiverAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.serialNumber = e3.int64();
                break;
              }
              case 4: {
                i.isApproval = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NftTransfer";
        }, e2;
      }(), TokenTransferList: function() {
        function e2(e3) {
          if (this.transfers = [], this.nftTransfers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.transfers = $util.emptyArray, e2.prototype.nftTransfers = $util.emptyArray, e2.prototype.expectedDecimals = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.transfers && e3.transfers.length)
            for (var t = 0; t < e3.transfers.length; ++t)
              $root.proto.AccountAmount.encode(e3.transfers[t], o.uint32(18).fork()).ldelim();
          if (null != e3.nftTransfers && e3.nftTransfers.length)
            for (var t = 0; t < e3.nftTransfers.length; ++t)
              $root.proto.NftTransfer.encode(e3.nftTransfers[t], o.uint32(26).fork()).ldelim();
          return null != e3.expectedDecimals && Object.hasOwnProperty.call(e3, "expectedDecimals") && $root.google.protobuf.UInt32Value.encode(e3.expectedDecimals, o.uint32(34).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenTransferList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transfers && i.transfers.length || (i.transfers = []), i.transfers.push($root.proto.AccountAmount.decode(e3, e3.uint32()));
                break;
              }
              case 3: {
                i.nftTransfers && i.nftTransfers.length || (i.nftTransfers = []), i.nftTransfers.push($root.proto.NftTransfer.decode(e3, e3.uint32()));
                break;
              }
              case 4: {
                i.expectedDecimals = $root.google.protobuf.UInt32Value.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenTransferList";
        }, e2;
      }(), Fraction: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.numerator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.denominator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.numerator && Object.hasOwnProperty.call(e3, "numerator") && o.uint32(8).int64(e3.numerator), null != e3.denominator && Object.hasOwnProperty.call(e3, "denominator") && o.uint32(16).int64(e3.denominator), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.Fraction(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.numerator = e3.int64();
                break;
              }
              case 2: {
                i.denominator = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Fraction";
        }, e2;
      }(), TopicID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.topicNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), null != e3.realmNum && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), null != e3.topicNum && Object.hasOwnProperty.call(e3, "topicNum") && o.uint32(24).int64(e3.topicNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TopicID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              case 2: {
                i.realmNum = e3.int64();
                break;
              }
              case 3: {
                i.topicNum = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TopicID";
        }, e2;
      }(), TokenID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.tokenNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), null != e3.realmNum && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), null != e3.tokenNum && Object.hasOwnProperty.call(e3, "tokenNum") && o.uint32(24).int64(e3.tokenNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              case 2: {
                i.realmNum = e3.int64();
                break;
              }
              case 3: {
                i.tokenNum = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenID";
        }, e2;
      }(), ScheduleID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.scheduleNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.shardNum && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), null != e3.realmNum && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), null != e3.scheduleNum && Object.hasOwnProperty.call(e3, "scheduleNum") && o.uint32(24).int64(e3.scheduleNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ScheduleID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.shardNum = e3.int64();
                break;
              }
              case 2: {
                i.realmNum = e3.int64();
                break;
              }
              case 3: {
                i.scheduleNum = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ScheduleID";
        }, e2;
      }(), TokenType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "FUNGIBLE_COMMON"] = 0, o[e2[1] = "NON_FUNGIBLE_UNIQUE"] = 1, o;
      }(), SubType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "DEFAULT"] = 0, o[e2[1] = "TOKEN_FUNGIBLE_COMMON"] = 1, o[e2[2] = "TOKEN_NON_FUNGIBLE_UNIQUE"] = 2, o[e2[3] = "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"] = 3, o[e2[4] = "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"] = 4, o[e2[5] = "SCHEDULE_CREATE_CONTRACT_CALL"] = 5, o;
      }(), TokenSupplyType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "INFINITE"] = 0, o[e2[1] = "FINITE"] = 1, o;
      }(), TokenFreezeStatus: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "FreezeNotApplicable"] = 0, o[e2[1] = "Frozen"] = 1, o[e2[2] = "Unfrozen"] = 2, o;
      }(), TokenKycStatus: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "KycNotApplicable"] = 0, o[e2[1] = "Granted"] = 1, o[e2[2] = "Revoked"] = 2, o;
      }(), TokenPauseStatus: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "PauseNotApplicable"] = 0, o[e2[1] = "Paused"] = 1, o[e2[2] = "Unpaused"] = 2, o;
      }(), Key: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contractID = null, e2.prototype.ed25519 = null, e2.prototype.RSA_3072 = null, e2.prototype.ECDSA_384 = null, e2.prototype.thresholdKey = null, e2.prototype.keyList = null, e2.prototype.ECDSASecp256k1 = null, e2.prototype.delegatableContractId = null;
        let o;
        return Object.defineProperty(e2.prototype, "key", { get: $util.oneOfGetter(o = ["contractID", "ed25519", "RSA_3072", "ECDSA_384", "thresholdKey", "keyList", "ECDSASecp256k1", "delegatableContractId"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(10).fork()).ldelim(), null != e3.ed25519 && Object.hasOwnProperty.call(e3, "ed25519") && o2.uint32(18).bytes(e3.ed25519), null != e3.RSA_3072 && Object.hasOwnProperty.call(e3, "RSA_3072") && o2.uint32(26).bytes(e3.RSA_3072), null != e3.ECDSA_384 && Object.hasOwnProperty.call(e3, "ECDSA_384") && o2.uint32(34).bytes(e3.ECDSA_384), null != e3.thresholdKey && Object.hasOwnProperty.call(e3, "thresholdKey") && $root.proto.ThresholdKey.encode(e3.thresholdKey, o2.uint32(42).fork()).ldelim(), null != e3.keyList && Object.hasOwnProperty.call(e3, "keyList") && $root.proto.KeyList.encode(e3.keyList, o2.uint32(50).fork()).ldelim(), null != e3.ECDSASecp256k1 && Object.hasOwnProperty.call(e3, "ECDSASecp256k1") && o2.uint32(58).bytes(e3.ECDSASecp256k1), null != e3.delegatableContractId && Object.hasOwnProperty.call(e3, "delegatableContractId") && $root.proto.ContractID.encode(e3.delegatableContractId, o2.uint32(66).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.Key(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.ed25519 = e3.bytes();
                break;
              }
              case 3: {
                i.RSA_3072 = e3.bytes();
                break;
              }
              case 4: {
                i.ECDSA_384 = e3.bytes();
                break;
              }
              case 5: {
                i.thresholdKey = $root.proto.ThresholdKey.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.keyList = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.ECDSASecp256k1 = e3.bytes();
                break;
              }
              case 8: {
                i.delegatableContractId = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Key";
        }, e2;
      }(), ThresholdKey: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.threshold = 0, e2.prototype.keys = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.threshold && Object.hasOwnProperty.call(e3, "threshold") && o.uint32(8).uint32(e3.threshold), null != e3.keys && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ThresholdKey(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.threshold = e3.uint32();
                break;
              }
              case 2: {
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ThresholdKey";
        }, e2;
      }(), KeyList: function() {
        function e2(e3) {
          if (this.keys = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.keys = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.keys && e3.keys.length)
            for (var t = 0; t < e3.keys.length; ++t)
              $root.proto.Key.encode(e3.keys[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.KeyList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.keys && i.keys.length || (i.keys = []), i.keys.push($root.proto.Key.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.KeyList";
        }, e2;
      }(), Signature: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contract = null, e2.prototype.ed25519 = null, e2.prototype.RSA_3072 = null, e2.prototype.ECDSA_384 = null, e2.prototype.thresholdSignature = null, e2.prototype.signatureList = null;
        let o;
        return Object.defineProperty(e2.prototype, "signature", { get: $util.oneOfGetter(o = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.contract && Object.hasOwnProperty.call(e3, "contract") && o2.uint32(10).bytes(e3.contract), null != e3.ed25519 && Object.hasOwnProperty.call(e3, "ed25519") && o2.uint32(18).bytes(e3.ed25519), null != e3.RSA_3072 && Object.hasOwnProperty.call(e3, "RSA_3072") && o2.uint32(26).bytes(e3.RSA_3072), null != e3.ECDSA_384 && Object.hasOwnProperty.call(e3, "ECDSA_384") && o2.uint32(34).bytes(e3.ECDSA_384), null != e3.thresholdSignature && Object.hasOwnProperty.call(e3, "thresholdSignature") && $root.proto.ThresholdSignature.encode(e3.thresholdSignature, o2.uint32(42).fork()).ldelim(), null != e3.signatureList && Object.hasOwnProperty.call(e3, "signatureList") && $root.proto.SignatureList.encode(e3.signatureList, o2.uint32(50).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.Signature(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contract = e3.bytes();
                break;
              }
              case 2: {
                i.ed25519 = e3.bytes();
                break;
              }
              case 3: {
                i.RSA_3072 = e3.bytes();
                break;
              }
              case 4: {
                i.ECDSA_384 = e3.bytes();
                break;
              }
              case 5: {
                i.thresholdSignature = $root.proto.ThresholdSignature.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.signatureList = $root.proto.SignatureList.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Signature";
        }, e2;
      }(), ThresholdSignature: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.sigs = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.sigs && Object.hasOwnProperty.call(e3, "sigs") && $root.proto.SignatureList.encode(e3.sigs, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ThresholdSignature(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2: {
                i.sigs = $root.proto.SignatureList.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ThresholdSignature";
        }, e2;
      }(), SignatureList: function() {
        function e2(e3) {
          if (this.sigs = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.sigs = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.sigs && e3.sigs.length)
            for (var t = 0; t < e3.sigs.length; ++t)
              $root.proto.Signature.encode(e3.sigs[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SignatureList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2: {
                i.sigs && i.sigs.length || (i.sigs = []), i.sigs.push($root.proto.Signature.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SignatureList";
        }, e2;
      }(), SignaturePair: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.pubKeyPrefix = $util.newBuffer([]), e2.prototype.contract = null, e2.prototype.ed25519 = null, e2.prototype.RSA_3072 = null, e2.prototype.ECDSA_384 = null, e2.prototype.ECDSASecp256k1 = null;
        let o;
        return Object.defineProperty(e2.prototype, "signature", { get: $util.oneOfGetter(o = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "ECDSASecp256k1"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.pubKeyPrefix && Object.hasOwnProperty.call(e3, "pubKeyPrefix") && o2.uint32(10).bytes(e3.pubKeyPrefix), null != e3.contract && Object.hasOwnProperty.call(e3, "contract") && o2.uint32(18).bytes(e3.contract), null != e3.ed25519 && Object.hasOwnProperty.call(e3, "ed25519") && o2.uint32(26).bytes(e3.ed25519), null != e3.RSA_3072 && Object.hasOwnProperty.call(e3, "RSA_3072") && o2.uint32(34).bytes(e3.RSA_3072), null != e3.ECDSA_384 && Object.hasOwnProperty.call(e3, "ECDSA_384") && o2.uint32(42).bytes(e3.ECDSA_384), null != e3.ECDSASecp256k1 && Object.hasOwnProperty.call(e3, "ECDSASecp256k1") && o2.uint32(50).bytes(e3.ECDSASecp256k1), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.SignaturePair(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.pubKeyPrefix = e3.bytes();
                break;
              }
              case 2: {
                i.contract = e3.bytes();
                break;
              }
              case 3: {
                i.ed25519 = e3.bytes();
                break;
              }
              case 4: {
                i.RSA_3072 = e3.bytes();
                break;
              }
              case 5: {
                i.ECDSA_384 = e3.bytes();
                break;
              }
              case 6: {
                i.ECDSASecp256k1 = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SignaturePair";
        }, e2;
      }(), SignatureMap: function() {
        function e2(e3) {
          if (this.sigPair = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.sigPair = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.sigPair && e3.sigPair.length)
            for (var t = 0; t < e3.sigPair.length; ++t)
              $root.proto.SignaturePair.encode(e3.sigPair[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SignatureMap(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.sigPair && i.sigPair.length || (i.sigPair = []), i.sigPair.push($root.proto.SignaturePair.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SignatureMap";
        }, e2;
      }(), HederaFunctionality: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "NONE"] = 0, o[e2[1] = "CryptoTransfer"] = 1, o[e2[2] = "CryptoUpdate"] = 2, o[e2[3] = "CryptoDelete"] = 3, o[e2[4] = "CryptoAddLiveHash"] = 4, o[e2[5] = "CryptoDeleteLiveHash"] = 5, o[e2[6] = "ContractCall"] = 6, o[e2[7] = "ContractCreate"] = 7, o[e2[8] = "ContractUpdate"] = 8, o[e2[9] = "FileCreate"] = 9, o[e2[10] = "FileAppend"] = 10, o[e2[11] = "FileUpdate"] = 11, o[e2[12] = "FileDelete"] = 12, o[e2[13] = "CryptoGetAccountBalance"] = 13, o[e2[14] = "CryptoGetAccountRecords"] = 14, o[e2[15] = "CryptoGetInfo"] = 15, o[e2[16] = "ContractCallLocal"] = 16, o[e2[17] = "ContractGetInfo"] = 17, o[e2[18] = "ContractGetBytecode"] = 18, o[e2[19] = "GetBySolidityID"] = 19, o[e2[20] = "GetByKey"] = 20, o[e2[21] = "CryptoGetLiveHash"] = 21, o[e2[22] = "CryptoGetStakers"] = 22, o[e2[23] = "FileGetContents"] = 23, o[e2[24] = "FileGetInfo"] = 24, o[e2[25] = "TransactionGetRecord"] = 25, o[e2[26] = "ContractGetRecords"] = 26, o[e2[27] = "CryptoCreate"] = 27, o[e2[28] = "SystemDelete"] = 28, o[e2[29] = "SystemUndelete"] = 29, o[e2[30] = "ContractDelete"] = 30, o[e2[31] = "Freeze"] = 31, o[e2[32] = "CreateTransactionRecord"] = 32, o[e2[33] = "CryptoAccountAutoRenew"] = 33, o[e2[34] = "ContractAutoRenew"] = 34, o[e2[35] = "GetVersionInfo"] = 35, o[e2[36] = "TransactionGetReceipt"] = 36, o[e2[50] = "ConsensusCreateTopic"] = 50, o[e2[51] = "ConsensusUpdateTopic"] = 51, o[e2[52] = "ConsensusDeleteTopic"] = 52, o[e2[53] = "ConsensusGetTopicInfo"] = 53, o[e2[54] = "ConsensusSubmitMessage"] = 54, o[e2[55] = "UncheckedSubmit"] = 55, o[e2[56] = "TokenCreate"] = 56, o[e2[58] = "TokenGetInfo"] = 58, o[e2[59] = "TokenFreezeAccount"] = 59, o[e2[60] = "TokenUnfreezeAccount"] = 60, o[e2[61] = "TokenGrantKycToAccount"] = 61, o[e2[62] = "TokenRevokeKycFromAccount"] = 62, o[e2[63] = "TokenDelete"] = 63, o[e2[64] = "TokenUpdate"] = 64, o[e2[65] = "TokenMint"] = 65, o[e2[66] = "TokenBurn"] = 66, o[e2[67] = "TokenAccountWipe"] = 67, o[e2[68] = "TokenAssociateToAccount"] = 68, o[e2[69] = "TokenDissociateFromAccount"] = 69, o[e2[70] = "ScheduleCreate"] = 70, o[e2[71] = "ScheduleDelete"] = 71, o[e2[72] = "ScheduleSign"] = 72, o[e2[73] = "ScheduleGetInfo"] = 73, o[e2[74] = "TokenGetAccountNftInfos"] = 74, o[e2[75] = "TokenGetNftInfo"] = 75, o[e2[76] = "TokenGetNftInfos"] = 76, o[e2[77] = "TokenFeeScheduleUpdate"] = 77, o[e2[78] = "NetworkGetExecutionTime"] = 78, o[e2[79] = "TokenPause"] = 79, o[e2[80] = "TokenUnpause"] = 80, o[e2[81] = "CryptoApproveAllowance"] = 81, o[e2[82] = "CryptoDeleteAllowance"] = 82, o[e2[83] = "GetAccountDetails"] = 83, o[e2[84] = "EthereumTransaction"] = 84, o[e2[85] = "NodeStakeUpdate"] = 85, o[e2[86] = "UtilPrng"] = 86, o[e2[87] = "TransactionGetFastRecord"] = 87, o[e2[88] = "TokenUpdateNfts"] = 88, o;
      }(), FeeComponents: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.min = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.max = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.constant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.bpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.vpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.rbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.sbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.tv = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.bpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.sbpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.min && Object.hasOwnProperty.call(e3, "min") && o.uint32(8).int64(e3.min), null != e3.max && Object.hasOwnProperty.call(e3, "max") && o.uint32(16).int64(e3.max), null != e3.constant && Object.hasOwnProperty.call(e3, "constant") && o.uint32(24).int64(e3.constant), null != e3.bpt && Object.hasOwnProperty.call(e3, "bpt") && o.uint32(32).int64(e3.bpt), null != e3.vpt && Object.hasOwnProperty.call(e3, "vpt") && o.uint32(40).int64(e3.vpt), null != e3.rbh && Object.hasOwnProperty.call(e3, "rbh") && o.uint32(48).int64(e3.rbh), null != e3.sbh && Object.hasOwnProperty.call(e3, "sbh") && o.uint32(56).int64(e3.sbh), null != e3.gas && Object.hasOwnProperty.call(e3, "gas") && o.uint32(64).int64(e3.gas), null != e3.tv && Object.hasOwnProperty.call(e3, "tv") && o.uint32(72).int64(e3.tv), null != e3.bpr && Object.hasOwnProperty.call(e3, "bpr") && o.uint32(80).int64(e3.bpr), null != e3.sbpr && Object.hasOwnProperty.call(e3, "sbpr") && o.uint32(88).int64(e3.sbpr), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FeeComponents(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.min = e3.int64();
                break;
              }
              case 2: {
                i.max = e3.int64();
                break;
              }
              case 3: {
                i.constant = e3.int64();
                break;
              }
              case 4: {
                i.bpt = e3.int64();
                break;
              }
              case 5: {
                i.vpt = e3.int64();
                break;
              }
              case 6: {
                i.rbh = e3.int64();
                break;
              }
              case 7: {
                i.sbh = e3.int64();
                break;
              }
              case 8: {
                i.gas = e3.int64();
                break;
              }
              case 9: {
                i.tv = e3.int64();
                break;
              }
              case 10: {
                i.bpr = e3.int64();
                break;
              }
              case 11: {
                i.sbpr = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FeeComponents";
        }, e2;
      }(), TransactionFeeSchedule: function() {
        function e2(e3) {
          if (this.fees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.hederaFunctionality = 0, e2.prototype.feeData = null, e2.prototype.fees = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.hederaFunctionality && Object.hasOwnProperty.call(e3, "hederaFunctionality") && o.uint32(8).int32(e3.hederaFunctionality), null != e3.feeData && Object.hasOwnProperty.call(e3, "feeData") && $root.proto.FeeData.encode(e3.feeData, o.uint32(18).fork()).ldelim(), null != e3.fees && e3.fees.length)
            for (var t = 0; t < e3.fees.length; ++t)
              $root.proto.FeeData.encode(e3.fees[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionFeeSchedule(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.hederaFunctionality = e3.int32();
                break;
              }
              case 2: {
                i.feeData = $root.proto.FeeData.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.fees && i.fees.length || (i.fees = []), i.fees.push($root.proto.FeeData.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionFeeSchedule";
        }, e2;
      }(), FeeData: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodedata = null, e2.prototype.networkdata = null, e2.prototype.servicedata = null, e2.prototype.subType = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.nodedata && Object.hasOwnProperty.call(e3, "nodedata") && $root.proto.FeeComponents.encode(e3.nodedata, o.uint32(10).fork()).ldelim(), null != e3.networkdata && Object.hasOwnProperty.call(e3, "networkdata") && $root.proto.FeeComponents.encode(e3.networkdata, o.uint32(18).fork()).ldelim(), null != e3.servicedata && Object.hasOwnProperty.call(e3, "servicedata") && $root.proto.FeeComponents.encode(e3.servicedata, o.uint32(26).fork()).ldelim(), null != e3.subType && Object.hasOwnProperty.call(e3, "subType") && o.uint32(32).int32(e3.subType), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FeeData(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.nodedata = $root.proto.FeeComponents.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.networkdata = $root.proto.FeeComponents.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.servicedata = $root.proto.FeeComponents.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.subType = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FeeData";
        }, e2;
      }(), FeeSchedule: function() {
        function e2(e3) {
          if (this.transactionFeeSchedule = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionFeeSchedule = $util.emptyArray, e2.prototype.expiryTime = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.transactionFeeSchedule && e3.transactionFeeSchedule.length)
            for (var t = 0; t < e3.transactionFeeSchedule.length; ++t)
              $root.proto.TransactionFeeSchedule.encode(e3.transactionFeeSchedule[t], o.uint32(10).fork()).ldelim();
          return null != e3.expiryTime && Object.hasOwnProperty.call(e3, "expiryTime") && $root.proto.TimestampSeconds.encode(e3.expiryTime, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FeeSchedule(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transactionFeeSchedule && i.transactionFeeSchedule.length || (i.transactionFeeSchedule = []), i.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(e3, e3.uint32()));
                break;
              }
              case 2: {
                i.expiryTime = $root.proto.TimestampSeconds.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FeeSchedule";
        }, e2;
      }(), CurrentAndNextFeeSchedule: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.currentFeeSchedule = null, e2.prototype.nextFeeSchedule = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.currentFeeSchedule && Object.hasOwnProperty.call(e3, "currentFeeSchedule") && $root.proto.FeeSchedule.encode(e3.currentFeeSchedule, o.uint32(10).fork()).ldelim(), null != e3.nextFeeSchedule && Object.hasOwnProperty.call(e3, "nextFeeSchedule") && $root.proto.FeeSchedule.encode(e3.nextFeeSchedule, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CurrentAndNextFeeSchedule(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.currentFeeSchedule = $root.proto.FeeSchedule.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nextFeeSchedule = $root.proto.FeeSchedule.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CurrentAndNextFeeSchedule";
        }, e2;
      }(), ServiceEndpoint: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.ipAddressV4 = $util.newBuffer([]), e2.prototype.port = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.ipAddressV4 && Object.hasOwnProperty.call(e3, "ipAddressV4") && o.uint32(10).bytes(e3.ipAddressV4), null != e3.port && Object.hasOwnProperty.call(e3, "port") && o.uint32(16).int32(e3.port), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ServiceEndpoint(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.ipAddressV4 = e3.bytes();
                break;
              }
              case 2: {
                i.port = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ServiceEndpoint";
        }, e2;
      }(), NodeAddress: function() {
        function e2(e3) {
          if (this.serviceEndpoint = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.ipAddress = $util.newBuffer([]), e2.prototype.portno = 0, e2.prototype.memo = $util.newBuffer([]), e2.prototype.RSA_PubKey = "", e2.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.nodeAccountId = null, e2.prototype.nodeCertHash = $util.newBuffer([]), e2.prototype.serviceEndpoint = $util.emptyArray, e2.prototype.description = "", e2.prototype.stake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.ipAddress && Object.hasOwnProperty.call(e3, "ipAddress") && o.uint32(10).bytes(e3.ipAddress), null != e3.portno && Object.hasOwnProperty.call(e3, "portno") && o.uint32(16).int32(e3.portno), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o.uint32(26).bytes(e3.memo), null != e3.RSA_PubKey && Object.hasOwnProperty.call(e3, "RSA_PubKey") && o.uint32(34).string(e3.RSA_PubKey), null != e3.nodeId && Object.hasOwnProperty.call(e3, "nodeId") && o.uint32(40).int64(e3.nodeId), null != e3.nodeAccountId && Object.hasOwnProperty.call(e3, "nodeAccountId") && $root.proto.AccountID.encode(e3.nodeAccountId, o.uint32(50).fork()).ldelim(), null != e3.nodeCertHash && Object.hasOwnProperty.call(e3, "nodeCertHash") && o.uint32(58).bytes(e3.nodeCertHash), null != e3.serviceEndpoint && e3.serviceEndpoint.length)
            for (var t = 0; t < e3.serviceEndpoint.length; ++t)
              $root.proto.ServiceEndpoint.encode(e3.serviceEndpoint[t], o.uint32(66).fork()).ldelim();
          return null != e3.description && Object.hasOwnProperty.call(e3, "description") && o.uint32(74).string(e3.description), null != e3.stake && Object.hasOwnProperty.call(e3, "stake") && o.uint32(80).int64(e3.stake), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NodeAddress(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.ipAddress = e3.bytes();
                break;
              }
              case 2: {
                i.portno = e3.int32();
                break;
              }
              case 3: {
                i.memo = e3.bytes();
                break;
              }
              case 4: {
                i.RSA_PubKey = e3.string();
                break;
              }
              case 5: {
                i.nodeId = e3.int64();
                break;
              }
              case 6: {
                i.nodeAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.nodeCertHash = e3.bytes();
                break;
              }
              case 8: {
                i.serviceEndpoint && i.serviceEndpoint.length || (i.serviceEndpoint = []), i.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(e3, e3.uint32()));
                break;
              }
              case 9: {
                i.description = e3.string();
                break;
              }
              case 10: {
                i.stake = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NodeAddress";
        }, e2;
      }(), NodeAddressBook: function() {
        function e2(e3) {
          if (this.nodeAddress = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodeAddress = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.nodeAddress && e3.nodeAddress.length)
            for (var t = 0; t < e3.nodeAddress.length; ++t)
              $root.proto.NodeAddress.encode(e3.nodeAddress[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NodeAddressBook(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.nodeAddress && i.nodeAddress.length || (i.nodeAddress = []), i.nodeAddress.push($root.proto.NodeAddress.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NodeAddressBook";
        }, e2;
      }(), SemanticVersion: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.major = 0, e2.prototype.minor = 0, e2.prototype.patch = 0, e2.prototype.pre = "", e2.prototype.build = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.major && Object.hasOwnProperty.call(e3, "major") && o.uint32(8).int32(e3.major), null != e3.minor && Object.hasOwnProperty.call(e3, "minor") && o.uint32(16).int32(e3.minor), null != e3.patch && Object.hasOwnProperty.call(e3, "patch") && o.uint32(24).int32(e3.patch), null != e3.pre && Object.hasOwnProperty.call(e3, "pre") && o.uint32(34).string(e3.pre), null != e3.build && Object.hasOwnProperty.call(e3, "build") && o.uint32(42).string(e3.build), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SemanticVersion(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.major = e3.int32();
                break;
              }
              case 2: {
                i.minor = e3.int32();
                break;
              }
              case 3: {
                i.patch = e3.int32();
                break;
              }
              case 4: {
                i.pre = e3.string();
                break;
              }
              case 5: {
                i.build = e3.string();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SemanticVersion";
        }, e2;
      }(), Setting: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.name = "", e2.prototype.value = "", e2.prototype.data = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && o.uint32(10).string(e3.name), null != e3.value && Object.hasOwnProperty.call(e3, "value") && o.uint32(18).string(e3.value), null != e3.data && Object.hasOwnProperty.call(e3, "data") && o.uint32(26).bytes(e3.data), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.Setting(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.name = e3.string();
                break;
              }
              case 2: {
                i.value = e3.string();
                break;
              }
              case 3: {
                i.data = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Setting";
        }, e2;
      }(), ServicesConfigurationList: function() {
        function e2(e3) {
          if (this.nameValue = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nameValue = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.nameValue && e3.nameValue.length)
            for (var t = 0; t < e3.nameValue.length; ++t)
              $root.proto.Setting.encode(e3.nameValue[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ServicesConfigurationList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.nameValue && i.nameValue.length || (i.nameValue = []), i.nameValue.push($root.proto.Setting.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ServicesConfigurationList";
        }, e2;
      }(), TokenRelationship: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.symbol = "", e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.kycStatus = 0, e2.prototype.freezeStatus = 0, e2.prototype.decimals = 0, e2.prototype.automaticAssociation = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.symbol && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(18).string(e3.symbol), null != e3.balance && Object.hasOwnProperty.call(e3, "balance") && o.uint32(24).uint64(e3.balance), null != e3.kycStatus && Object.hasOwnProperty.call(e3, "kycStatus") && o.uint32(32).int32(e3.kycStatus), null != e3.freezeStatus && Object.hasOwnProperty.call(e3, "freezeStatus") && o.uint32(40).int32(e3.freezeStatus), null != e3.decimals && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(48).uint32(e3.decimals), null != e3.automaticAssociation && Object.hasOwnProperty.call(e3, "automaticAssociation") && o.uint32(56).bool(e3.automaticAssociation), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenRelationship(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.symbol = e3.string();
                break;
              }
              case 3: {
                i.balance = e3.uint64();
                break;
              }
              case 4: {
                i.kycStatus = e3.int32();
                break;
              }
              case 5: {
                i.freezeStatus = e3.int32();
                break;
              }
              case 6: {
                i.decimals = e3.uint32();
                break;
              }
              case 7: {
                i.automaticAssociation = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenRelationship";
        }, e2;
      }(), TokenBalance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.decimals = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.balance && Object.hasOwnProperty.call(e3, "balance") && o.uint32(16).uint64(e3.balance), null != e3.decimals && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(24).uint32(e3.decimals), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenBalance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.balance = e3.uint64();
                break;
              }
              case 3: {
                i.decimals = e3.uint32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenBalance";
        }, e2;
      }(), TokenBalances: function() {
        function e2(e3) {
          if (this.tokenBalances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenBalances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.tokenBalances && e3.tokenBalances.length)
            for (var t = 0; t < e3.tokenBalances.length; ++t)
              $root.proto.TokenBalance.encode(e3.tokenBalances[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenBalances(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenBalances && i.tokenBalances.length || (i.tokenBalances = []), i.tokenBalances.push($root.proto.TokenBalance.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenBalances";
        }, e2;
      }(), TokenAssociation: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.accountId = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.accountId && Object.hasOwnProperty.call(e3, "accountId") && $root.proto.AccountID.encode(e3.accountId, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenAssociation(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenAssociation";
        }, e2;
      }(), StakingInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.declineReward = false, e2.prototype.stakePeriodStart = null, e2.prototype.pendingReward = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stakedToMe = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stakedAccountId = null, e2.prototype.stakedNodeId = null;
        let o;
        return Object.defineProperty(e2.prototype, "stakedId", { get: $util.oneOfGetter(o = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.declineReward && Object.hasOwnProperty.call(e3, "declineReward") && o2.uint32(8).bool(e3.declineReward), null != e3.stakePeriodStart && Object.hasOwnProperty.call(e3, "stakePeriodStart") && $root.proto.Timestamp.encode(e3.stakePeriodStart, o2.uint32(18).fork()).ldelim(), null != e3.pendingReward && Object.hasOwnProperty.call(e3, "pendingReward") && o2.uint32(24).int64(e3.pendingReward), null != e3.stakedToMe && Object.hasOwnProperty.call(e3, "stakedToMe") && o2.uint32(32).int64(e3.stakedToMe), null != e3.stakedAccountId && Object.hasOwnProperty.call(e3, "stakedAccountId") && $root.proto.AccountID.encode(e3.stakedAccountId, o2.uint32(42).fork()).ldelim(), null != e3.stakedNodeId && Object.hasOwnProperty.call(e3, "stakedNodeId") && o2.uint32(48).int64(e3.stakedNodeId), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.StakingInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.declineReward = e3.bool();
                break;
              }
              case 2: {
                i.stakePeriodStart = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.pendingReward = e3.int64();
                break;
              }
              case 4: {
                i.stakedToMe = e3.int64();
                break;
              }
              case 5: {
                i.stakedAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.stakedNodeId = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.StakingInfo";
        }, e2;
      }(), Timestamp: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.nanos = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.seconds && Object.hasOwnProperty.call(e3, "seconds") && o.uint32(8).int64(e3.seconds), null != e3.nanos && Object.hasOwnProperty.call(e3, "nanos") && o.uint32(16).int32(e3.nanos), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.Timestamp(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.seconds = e3.int64();
                break;
              }
              case 2: {
                i.nanos = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Timestamp";
        }, e2;
      }(), TimestampSeconds: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.seconds && Object.hasOwnProperty.call(e3, "seconds") && o.uint32(8).int64(e3.seconds), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TimestampSeconds(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.seconds = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TimestampSeconds";
        }, e2;
      }(), ConsensusCreateTopicTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.memo = "", e2.prototype.adminKey = null, e2.prototype.submitKey = null, e2.prototype.autoRenewPeriod = null, e2.prototype.autoRenewAccount = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o.uint32(10).string(e3.memo), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(18).fork()).ldelim(), null != e3.submitKey && Object.hasOwnProperty.call(e3, "submitKey") && $root.proto.Key.encode(e3.submitKey, o.uint32(26).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(50).fork()).ldelim(), null != e3.autoRenewAccount && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(58).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusCreateTopicTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.memo = e3.string();
                break;
              }
              case 2: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.submitKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusCreateTopicTransactionBody";
        }, e2;
      }(), Duration: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.seconds && Object.hasOwnProperty.call(e3, "seconds") && o.uint32(8).int64(e3.seconds), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.Duration(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.seconds = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Duration";
        }, e2;
      }(), ConsensusDeleteTopicTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.topicID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.topicID && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusDeleteTopicTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusDeleteTopicTransactionBody";
        }, e2;
      }(), ConsensusGetTopicInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.topicID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.topicID && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusGetTopicInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusGetTopicInfoQuery";
        }, e2;
      }(), ConsensusGetTopicInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.topicID = null, e2.prototype.topicInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.topicID && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(18).fork()).ldelim(), null != e3.topicInfo && Object.hasOwnProperty.call(e3, "topicInfo") && $root.proto.ConsensusTopicInfo.encode(e3.topicInfo, o.uint32(42).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusGetTopicInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.topicInfo = $root.proto.ConsensusTopicInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusGetTopicInfoResponse";
        }, e2;
      }(), ResponseType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "ANSWER_ONLY"] = 0, o[e2[1] = "ANSWER_STATE_PROOF"] = 1, o[e2[2] = "COST_ANSWER"] = 2, o[e2[3] = "COST_ANSWER_STATE_PROOF"] = 3, o;
      }(), QueryHeader: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.payment = null, e2.prototype.responseType = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.payment && Object.hasOwnProperty.call(e3, "payment") && $root.proto.Transaction.encode(e3.payment, o.uint32(10).fork()).ldelim(), null != e3.responseType && Object.hasOwnProperty.call(e3, "responseType") && o.uint32(16).int32(e3.responseType), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.QueryHeader(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.payment = $root.proto.Transaction.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.responseType = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.QueryHeader";
        }, e2;
      }(), Transaction: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.body = null, e2.prototype.sigs = null, e2.prototype.sigMap = null, e2.prototype.bodyBytes = $util.newBuffer([]), e2.prototype.signedTransactionBytes = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.body && Object.hasOwnProperty.call(e3, "body") && $root.proto.TransactionBody.encode(e3.body, o.uint32(10).fork()).ldelim(), null != e3.sigs && Object.hasOwnProperty.call(e3, "sigs") && $root.proto.SignatureList.encode(e3.sigs, o.uint32(18).fork()).ldelim(), null != e3.sigMap && Object.hasOwnProperty.call(e3, "sigMap") && $root.proto.SignatureMap.encode(e3.sigMap, o.uint32(26).fork()).ldelim(), null != e3.bodyBytes && Object.hasOwnProperty.call(e3, "bodyBytes") && o.uint32(34).bytes(e3.bodyBytes), null != e3.signedTransactionBytes && Object.hasOwnProperty.call(e3, "signedTransactionBytes") && o.uint32(42).bytes(e3.signedTransactionBytes), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.Transaction(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.body = $root.proto.TransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.sigs = $root.proto.SignatureList.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.sigMap = $root.proto.SignatureMap.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.bodyBytes = e3.bytes();
                break;
              }
              case 5: {
                i.signedTransactionBytes = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Transaction";
        }, e2;
      }(), TransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.transactionID = null, e2.prototype.nodeAccountID = null, e2.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.transactionValidDuration = null, e2.prototype.generateRecord = false, e2.prototype.memo = "", e2.prototype.contractCall = null, e2.prototype.contractCreateInstance = null, e2.prototype.contractUpdateInstance = null, e2.prototype.contractDeleteInstance = null, e2.prototype.ethereumTransaction = null, e2.prototype.cryptoAddLiveHash = null, e2.prototype.cryptoApproveAllowance = null, e2.prototype.cryptoDeleteAllowance = null, e2.prototype.cryptoCreateAccount = null, e2.prototype.cryptoDelete = null, e2.prototype.cryptoDeleteLiveHash = null, e2.prototype.cryptoTransfer = null, e2.prototype.cryptoUpdateAccount = null, e2.prototype.fileAppend = null, e2.prototype.fileCreate = null, e2.prototype.fileDelete = null, e2.prototype.fileUpdate = null, e2.prototype.systemDelete = null, e2.prototype.systemUndelete = null, e2.prototype.freeze = null, e2.prototype.consensusCreateTopic = null, e2.prototype.consensusUpdateTopic = null, e2.prototype.consensusDeleteTopic = null, e2.prototype.consensusSubmitMessage = null, e2.prototype.uncheckedSubmit = null, e2.prototype.tokenCreation = null, e2.prototype.tokenFreeze = null, e2.prototype.tokenUnfreeze = null, e2.prototype.tokenGrantKyc = null, e2.prototype.tokenRevokeKyc = null, e2.prototype.tokenDeletion = null, e2.prototype.tokenUpdate = null, e2.prototype.tokenMint = null, e2.prototype.tokenBurn = null, e2.prototype.tokenWipe = null, e2.prototype.tokenAssociate = null, e2.prototype.tokenDissociate = null, e2.prototype.tokenFeeScheduleUpdate = null, e2.prototype.tokenPause = null, e2.prototype.tokenUnpause = null, e2.prototype.scheduleCreate = null, e2.prototype.scheduleDelete = null, e2.prototype.scheduleSign = null, e2.prototype.nodeStakeUpdate = null, e2.prototype.utilPrng = null, e2.prototype.tokenUpdateNfts = null;
        let o;
        return Object.defineProperty(e2.prototype, "data", { get: $util.oneOfGetter(o = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "ethereumTransaction", "cryptoAddLiveHash", "cryptoApproveAllowance", "cryptoDeleteAllowance", "cryptoCreateAccount", "cryptoDelete", "cryptoDeleteLiveHash", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "uncheckedSubmit", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "tokenFeeScheduleUpdate", "tokenPause", "tokenUnpause", "scheduleCreate", "scheduleDelete", "scheduleSign", "nodeStakeUpdate", "utilPrng", "tokenUpdateNfts"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.transactionID && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o2.uint32(10).fork()).ldelim(), null != e3.nodeAccountID && Object.hasOwnProperty.call(e3, "nodeAccountID") && $root.proto.AccountID.encode(e3.nodeAccountID, o2.uint32(18).fork()).ldelim(), null != e3.transactionFee && Object.hasOwnProperty.call(e3, "transactionFee") && o2.uint32(24).uint64(e3.transactionFee), null != e3.transactionValidDuration && Object.hasOwnProperty.call(e3, "transactionValidDuration") && $root.proto.Duration.encode(e3.transactionValidDuration, o2.uint32(34).fork()).ldelim(), null != e3.generateRecord && Object.hasOwnProperty.call(e3, "generateRecord") && o2.uint32(40).bool(e3.generateRecord), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(50).string(e3.memo), null != e3.contractCall && Object.hasOwnProperty.call(e3, "contractCall") && $root.proto.ContractCallTransactionBody.encode(e3.contractCall, o2.uint32(58).fork()).ldelim(), null != e3.contractCreateInstance && Object.hasOwnProperty.call(e3, "contractCreateInstance") && $root.proto.ContractCreateTransactionBody.encode(e3.contractCreateInstance, o2.uint32(66).fork()).ldelim(), null != e3.contractUpdateInstance && Object.hasOwnProperty.call(e3, "contractUpdateInstance") && $root.proto.ContractUpdateTransactionBody.encode(e3.contractUpdateInstance, o2.uint32(74).fork()).ldelim(), null != e3.cryptoAddLiveHash && Object.hasOwnProperty.call(e3, "cryptoAddLiveHash") && $root.proto.CryptoAddLiveHashTransactionBody.encode(e3.cryptoAddLiveHash, o2.uint32(82).fork()).ldelim(), null != e3.cryptoCreateAccount && Object.hasOwnProperty.call(e3, "cryptoCreateAccount") && $root.proto.CryptoCreateTransactionBody.encode(e3.cryptoCreateAccount, o2.uint32(90).fork()).ldelim(), null != e3.cryptoDelete && Object.hasOwnProperty.call(e3, "cryptoDelete") && $root.proto.CryptoDeleteTransactionBody.encode(e3.cryptoDelete, o2.uint32(98).fork()).ldelim(), null != e3.cryptoDeleteLiveHash && Object.hasOwnProperty.call(e3, "cryptoDeleteLiveHash") && $root.proto.CryptoDeleteLiveHashTransactionBody.encode(e3.cryptoDeleteLiveHash, o2.uint32(106).fork()).ldelim(), null != e3.cryptoTransfer && Object.hasOwnProperty.call(e3, "cryptoTransfer") && $root.proto.CryptoTransferTransactionBody.encode(e3.cryptoTransfer, o2.uint32(114).fork()).ldelim(), null != e3.cryptoUpdateAccount && Object.hasOwnProperty.call(e3, "cryptoUpdateAccount") && $root.proto.CryptoUpdateTransactionBody.encode(e3.cryptoUpdateAccount, o2.uint32(122).fork()).ldelim(), null != e3.fileAppend && Object.hasOwnProperty.call(e3, "fileAppend") && $root.proto.FileAppendTransactionBody.encode(e3.fileAppend, o2.uint32(130).fork()).ldelim(), null != e3.fileCreate && Object.hasOwnProperty.call(e3, "fileCreate") && $root.proto.FileCreateTransactionBody.encode(e3.fileCreate, o2.uint32(138).fork()).ldelim(), null != e3.fileDelete && Object.hasOwnProperty.call(e3, "fileDelete") && $root.proto.FileDeleteTransactionBody.encode(e3.fileDelete, o2.uint32(146).fork()).ldelim(), null != e3.fileUpdate && Object.hasOwnProperty.call(e3, "fileUpdate") && $root.proto.FileUpdateTransactionBody.encode(e3.fileUpdate, o2.uint32(154).fork()).ldelim(), null != e3.systemDelete && Object.hasOwnProperty.call(e3, "systemDelete") && $root.proto.SystemDeleteTransactionBody.encode(e3.systemDelete, o2.uint32(162).fork()).ldelim(), null != e3.systemUndelete && Object.hasOwnProperty.call(e3, "systemUndelete") && $root.proto.SystemUndeleteTransactionBody.encode(e3.systemUndelete, o2.uint32(170).fork()).ldelim(), null != e3.contractDeleteInstance && Object.hasOwnProperty.call(e3, "contractDeleteInstance") && $root.proto.ContractDeleteTransactionBody.encode(e3.contractDeleteInstance, o2.uint32(178).fork()).ldelim(), null != e3.freeze && Object.hasOwnProperty.call(e3, "freeze") && $root.proto.FreezeTransactionBody.encode(e3.freeze, o2.uint32(186).fork()).ldelim(), null != e3.consensusCreateTopic && Object.hasOwnProperty.call(e3, "consensusCreateTopic") && $root.proto.ConsensusCreateTopicTransactionBody.encode(e3.consensusCreateTopic, o2.uint32(194).fork()).ldelim(), null != e3.consensusUpdateTopic && Object.hasOwnProperty.call(e3, "consensusUpdateTopic") && $root.proto.ConsensusUpdateTopicTransactionBody.encode(e3.consensusUpdateTopic, o2.uint32(202).fork()).ldelim(), null != e3.consensusDeleteTopic && Object.hasOwnProperty.call(e3, "consensusDeleteTopic") && $root.proto.ConsensusDeleteTopicTransactionBody.encode(e3.consensusDeleteTopic, o2.uint32(210).fork()).ldelim(), null != e3.consensusSubmitMessage && Object.hasOwnProperty.call(e3, "consensusSubmitMessage") && $root.proto.ConsensusSubmitMessageTransactionBody.encode(e3.consensusSubmitMessage, o2.uint32(218).fork()).ldelim(), null != e3.uncheckedSubmit && Object.hasOwnProperty.call(e3, "uncheckedSubmit") && $root.proto.UncheckedSubmitBody.encode(e3.uncheckedSubmit, o2.uint32(226).fork()).ldelim(), null != e3.tokenCreation && Object.hasOwnProperty.call(e3, "tokenCreation") && $root.proto.TokenCreateTransactionBody.encode(e3.tokenCreation, o2.uint32(234).fork()).ldelim(), null != e3.tokenFreeze && Object.hasOwnProperty.call(e3, "tokenFreeze") && $root.proto.TokenFreezeAccountTransactionBody.encode(e3.tokenFreeze, o2.uint32(250).fork()).ldelim(), null != e3.tokenUnfreeze && Object.hasOwnProperty.call(e3, "tokenUnfreeze") && $root.proto.TokenUnfreezeAccountTransactionBody.encode(e3.tokenUnfreeze, o2.uint32(258).fork()).ldelim(), null != e3.tokenGrantKyc && Object.hasOwnProperty.call(e3, "tokenGrantKyc") && $root.proto.TokenGrantKycTransactionBody.encode(e3.tokenGrantKyc, o2.uint32(266).fork()).ldelim(), null != e3.tokenRevokeKyc && Object.hasOwnProperty.call(e3, "tokenRevokeKyc") && $root.proto.TokenRevokeKycTransactionBody.encode(e3.tokenRevokeKyc, o2.uint32(274).fork()).ldelim(), null != e3.tokenDeletion && Object.hasOwnProperty.call(e3, "tokenDeletion") && $root.proto.TokenDeleteTransactionBody.encode(e3.tokenDeletion, o2.uint32(282).fork()).ldelim(), null != e3.tokenUpdate && Object.hasOwnProperty.call(e3, "tokenUpdate") && $root.proto.TokenUpdateTransactionBody.encode(e3.tokenUpdate, o2.uint32(290).fork()).ldelim(), null != e3.tokenMint && Object.hasOwnProperty.call(e3, "tokenMint") && $root.proto.TokenMintTransactionBody.encode(e3.tokenMint, o2.uint32(298).fork()).ldelim(), null != e3.tokenBurn && Object.hasOwnProperty.call(e3, "tokenBurn") && $root.proto.TokenBurnTransactionBody.encode(e3.tokenBurn, o2.uint32(306).fork()).ldelim(), null != e3.tokenWipe && Object.hasOwnProperty.call(e3, "tokenWipe") && $root.proto.TokenWipeAccountTransactionBody.encode(e3.tokenWipe, o2.uint32(314).fork()).ldelim(), null != e3.tokenAssociate && Object.hasOwnProperty.call(e3, "tokenAssociate") && $root.proto.TokenAssociateTransactionBody.encode(e3.tokenAssociate, o2.uint32(322).fork()).ldelim(), null != e3.tokenDissociate && Object.hasOwnProperty.call(e3, "tokenDissociate") && $root.proto.TokenDissociateTransactionBody.encode(e3.tokenDissociate, o2.uint32(330).fork()).ldelim(), null != e3.scheduleCreate && Object.hasOwnProperty.call(e3, "scheduleCreate") && $root.proto.ScheduleCreateTransactionBody.encode(e3.scheduleCreate, o2.uint32(338).fork()).ldelim(), null != e3.scheduleDelete && Object.hasOwnProperty.call(e3, "scheduleDelete") && $root.proto.ScheduleDeleteTransactionBody.encode(e3.scheduleDelete, o2.uint32(346).fork()).ldelim(), null != e3.scheduleSign && Object.hasOwnProperty.call(e3, "scheduleSign") && $root.proto.ScheduleSignTransactionBody.encode(e3.scheduleSign, o2.uint32(354).fork()).ldelim(), null != e3.tokenFeeScheduleUpdate && Object.hasOwnProperty.call(e3, "tokenFeeScheduleUpdate") && $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(e3.tokenFeeScheduleUpdate, o2.uint32(362).fork()).ldelim(), null != e3.tokenPause && Object.hasOwnProperty.call(e3, "tokenPause") && $root.proto.TokenPauseTransactionBody.encode(e3.tokenPause, o2.uint32(370).fork()).ldelim(), null != e3.tokenUnpause && Object.hasOwnProperty.call(e3, "tokenUnpause") && $root.proto.TokenUnpauseTransactionBody.encode(e3.tokenUnpause, o2.uint32(378).fork()).ldelim(), null != e3.cryptoApproveAllowance && Object.hasOwnProperty.call(e3, "cryptoApproveAllowance") && $root.proto.CryptoApproveAllowanceTransactionBody.encode(e3.cryptoApproveAllowance, o2.uint32(386).fork()).ldelim(), null != e3.cryptoDeleteAllowance && Object.hasOwnProperty.call(e3, "cryptoDeleteAllowance") && $root.proto.CryptoDeleteAllowanceTransactionBody.encode(e3.cryptoDeleteAllowance, o2.uint32(394).fork()).ldelim(), null != e3.ethereumTransaction && Object.hasOwnProperty.call(e3, "ethereumTransaction") && $root.proto.EthereumTransactionBody.encode(e3.ethereumTransaction, o2.uint32(402).fork()).ldelim(), null != e3.nodeStakeUpdate && Object.hasOwnProperty.call(e3, "nodeStakeUpdate") && $root.proto.NodeStakeUpdateTransactionBody.encode(e3.nodeStakeUpdate, o2.uint32(410).fork()).ldelim(), null != e3.utilPrng && Object.hasOwnProperty.call(e3, "utilPrng") && $root.proto.UtilPrngTransactionBody.encode(e3.utilPrng, o2.uint32(418).fork()).ldelim(), null != e3.tokenUpdateNfts && Object.hasOwnProperty.call(e3, "tokenUpdateNfts") && $root.proto.TokenUpdateNftsTransactionBody.encode(e3.tokenUpdateNfts, o2.uint32(426).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.TransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nodeAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.transactionFee = e3.uint64();
                break;
              }
              case 4: {
                i.transactionValidDuration = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.generateRecord = e3.bool();
                break;
              }
              case 6: {
                i.memo = e3.string();
                break;
              }
              case 7: {
                i.contractCall = $root.proto.ContractCallTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 22: {
                i.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 50: {
                i.ethereumTransaction = $root.proto.EthereumTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 48: {
                i.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 49: {
                i.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 15: {
                i.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.fileAppend = $root.proto.FileAppendTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 17: {
                i.fileCreate = $root.proto.FileCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 18: {
                i.fileDelete = $root.proto.FileDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 19: {
                i.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 20: {
                i.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 21: {
                i.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 23: {
                i.freeze = $root.proto.FreezeTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 24: {
                i.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 25: {
                i.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 26: {
                i.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 27: {
                i.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 28: {
                i.uncheckedSubmit = $root.proto.UncheckedSubmitBody.decode(e3, e3.uint32());
                break;
              }
              case 29: {
                i.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 31: {
                i.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 32: {
                i.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 33: {
                i.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 34: {
                i.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 35: {
                i.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 36: {
                i.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 37: {
                i.tokenMint = $root.proto.TokenMintTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 38: {
                i.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 39: {
                i.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 40: {
                i.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 41: {
                i.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 45: {
                i.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 46: {
                i.tokenPause = $root.proto.TokenPauseTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 47: {
                i.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 42: {
                i.scheduleCreate = $root.proto.ScheduleCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 43: {
                i.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 44: {
                i.scheduleSign = $root.proto.ScheduleSignTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 51: {
                i.nodeStakeUpdate = $root.proto.NodeStakeUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 52: {
                i.utilPrng = $root.proto.UtilPrngTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 53: {
                i.tokenUpdateNfts = $root.proto.TokenUpdateNftsTransactionBody.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionBody";
        }, e2;
      }(), SystemDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.fileID = null, e2.prototype.contractID = null, e2.prototype.expirationTime = null;
        let o;
        return Object.defineProperty(e2.prototype, "id", { get: $util.oneOfGetter(o = ["fileID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(10).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(18).fork()).ldelim(), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.TimestampSeconds.encode(e3.expirationTime, o2.uint32(26).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.SystemDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.expirationTime = $root.proto.TimestampSeconds.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SystemDeleteTransactionBody";
        }, e2;
      }(), SystemUndeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.fileID = null, e2.prototype.contractID = null;
        let o;
        return Object.defineProperty(e2.prototype, "id", { get: $util.oneOfGetter(o = ["fileID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(10).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(18).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.SystemUndeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SystemUndeleteTransactionBody";
        }, e2;
      }(), FreezeTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.startHour = 0, e2.prototype.startMin = 0, e2.prototype.endHour = 0, e2.prototype.endMin = 0, e2.prototype.updateFile = null, e2.prototype.fileHash = $util.newBuffer([]), e2.prototype.startTime = null, e2.prototype.freezeType = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.startHour && Object.hasOwnProperty.call(e3, "startHour") && o.uint32(8).int32(e3.startHour), null != e3.startMin && Object.hasOwnProperty.call(e3, "startMin") && o.uint32(16).int32(e3.startMin), null != e3.endHour && Object.hasOwnProperty.call(e3, "endHour") && o.uint32(24).int32(e3.endHour), null != e3.endMin && Object.hasOwnProperty.call(e3, "endMin") && o.uint32(32).int32(e3.endMin), null != e3.updateFile && Object.hasOwnProperty.call(e3, "updateFile") && $root.proto.FileID.encode(e3.updateFile, o.uint32(42).fork()).ldelim(), null != e3.fileHash && Object.hasOwnProperty.call(e3, "fileHash") && o.uint32(50).bytes(e3.fileHash), null != e3.startTime && Object.hasOwnProperty.call(e3, "startTime") && $root.proto.Timestamp.encode(e3.startTime, o.uint32(58).fork()).ldelim(), null != e3.freezeType && Object.hasOwnProperty.call(e3, "freezeType") && o.uint32(64).int32(e3.freezeType), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FreezeTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.startHour = e3.int32();
                break;
              }
              case 2: {
                i.startMin = e3.int32();
                break;
              }
              case 3: {
                i.endHour = e3.int32();
                break;
              }
              case 4: {
                i.endMin = e3.int32();
                break;
              }
              case 5: {
                i.updateFile = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.fileHash = e3.bytes();
                break;
              }
              case 7: {
                i.startTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.freezeType = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FreezeTransactionBody";
        }, e2;
      }(), FreezeType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "UNKNOWN_FREEZE_TYPE"] = 0, o[e2[1] = "FREEZE_ONLY"] = 1, o[e2[2] = "PREPARE_UPGRADE"] = 2, o[e2[3] = "FREEZE_UPGRADE"] = 3, o[e2[4] = "FREEZE_ABORT"] = 4, o[e2[5] = "TELEMETRY_UPGRADE"] = 5, o;
      }(), ContractCallTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractID = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.functionParameters = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(10).fork()).ldelim(), null != e3.gas && Object.hasOwnProperty.call(e3, "gas") && o.uint32(16).int64(e3.gas), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(24).int64(e3.amount), null != e3.functionParameters && Object.hasOwnProperty.call(e3, "functionParameters") && o.uint32(34).bytes(e3.functionParameters), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractCallTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.gas = e3.int64();
                break;
              }
              case 3: {
                i.amount = e3.int64();
                break;
              }
              case 4: {
                i.functionParameters = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractCallTransactionBody";
        }, e2;
      }(), ContractCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.fileID = null, e2.prototype.initcode = null, e2.prototype.adminKey = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.proxyAccountID = null, e2.prototype.autoRenewPeriod = null, e2.prototype.constructorParameters = $util.newBuffer([]), e2.prototype.shardID = null, e2.prototype.realmID = null, e2.prototype.newRealmAdminKey = null, e2.prototype.memo = "", e2.prototype.maxAutomaticTokenAssociations = 0, e2.prototype.autoRenewAccountId = null, e2.prototype.stakedAccountId = null, e2.prototype.stakedNodeId = null, e2.prototype.declineReward = false;
        let o;
        return Object.defineProperty(e2.prototype, "initcodeSource", { get: $util.oneOfGetter(o = ["fileID", "initcode"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "stakedId", { get: $util.oneOfGetter(o = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(10).fork()).ldelim(), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o2.uint32(26).fork()).ldelim(), null != e3.gas && Object.hasOwnProperty.call(e3, "gas") && o2.uint32(32).int64(e3.gas), null != e3.initialBalance && Object.hasOwnProperty.call(e3, "initialBalance") && o2.uint32(40).int64(e3.initialBalance), null != e3.proxyAccountID && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o2.uint32(50).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o2.uint32(66).fork()).ldelim(), null != e3.constructorParameters && Object.hasOwnProperty.call(e3, "constructorParameters") && o2.uint32(74).bytes(e3.constructorParameters), null != e3.shardID && Object.hasOwnProperty.call(e3, "shardID") && $root.proto.ShardID.encode(e3.shardID, o2.uint32(82).fork()).ldelim(), null != e3.realmID && Object.hasOwnProperty.call(e3, "realmID") && $root.proto.RealmID.encode(e3.realmID, o2.uint32(90).fork()).ldelim(), null != e3.newRealmAdminKey && Object.hasOwnProperty.call(e3, "newRealmAdminKey") && $root.proto.Key.encode(e3.newRealmAdminKey, o2.uint32(98).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(106).string(e3.memo), null != e3.maxAutomaticTokenAssociations && Object.hasOwnProperty.call(e3, "maxAutomaticTokenAssociations") && o2.uint32(112).int32(e3.maxAutomaticTokenAssociations), null != e3.autoRenewAccountId && Object.hasOwnProperty.call(e3, "autoRenewAccountId") && $root.proto.AccountID.encode(e3.autoRenewAccountId, o2.uint32(122).fork()).ldelim(), null != e3.initcode && Object.hasOwnProperty.call(e3, "initcode") && o2.uint32(130).bytes(e3.initcode), null != e3.stakedAccountId && Object.hasOwnProperty.call(e3, "stakedAccountId") && $root.proto.AccountID.encode(e3.stakedAccountId, o2.uint32(138).fork()).ldelim(), null != e3.stakedNodeId && Object.hasOwnProperty.call(e3, "stakedNodeId") && o2.uint32(144).int64(e3.stakedNodeId), null != e3.declineReward && Object.hasOwnProperty.call(e3, "declineReward") && o2.uint32(152).bool(e3.declineReward), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.ContractCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.initcode = e3.bytes();
                break;
              }
              case 3: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.gas = e3.int64();
                break;
              }
              case 5: {
                i.initialBalance = e3.int64();
                break;
              }
              case 6: {
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.constructorParameters = e3.bytes();
                break;
              }
              case 10: {
                i.shardID = $root.proto.ShardID.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.realmID = $root.proto.RealmID.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.newRealmAdminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.memo = e3.string();
                break;
              }
              case 14: {
                i.maxAutomaticTokenAssociations = e3.int32();
                break;
              }
              case 15: {
                i.autoRenewAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 17: {
                i.stakedAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 18: {
                i.stakedNodeId = e3.int64();
                break;
              }
              case 19: {
                i.declineReward = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractCreateTransactionBody";
        }, e2;
      }(), ContractUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contractID = null, e2.prototype.expirationTime = null, e2.prototype.adminKey = null, e2.prototype.proxyAccountID = null, e2.prototype.autoRenewPeriod = null, e2.prototype.fileID = null, e2.prototype.memo = null, e2.prototype.memoWrapper = null, e2.prototype.maxAutomaticTokenAssociations = null, e2.prototype.autoRenewAccountId = null, e2.prototype.stakedAccountId = null, e2.prototype.stakedNodeId = null, e2.prototype.declineReward = null;
        let o;
        return Object.defineProperty(e2.prototype, "memoField", { get: $util.oneOfGetter(o = ["memo", "memoWrapper"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "stakedId", { get: $util.oneOfGetter(o = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(10).fork()).ldelim(), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o2.uint32(18).fork()).ldelim(), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o2.uint32(26).fork()).ldelim(), null != e3.proxyAccountID && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o2.uint32(50).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o2.uint32(58).fork()).ldelim(), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(66).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(74).string(e3.memo), null != e3.memoWrapper && Object.hasOwnProperty.call(e3, "memoWrapper") && $root.google.protobuf.StringValue.encode(e3.memoWrapper, o2.uint32(82).fork()).ldelim(), null != e3.maxAutomaticTokenAssociations && Object.hasOwnProperty.call(e3, "maxAutomaticTokenAssociations") && $root.google.protobuf.Int32Value.encode(e3.maxAutomaticTokenAssociations, o2.uint32(90).fork()).ldelim(), null != e3.autoRenewAccountId && Object.hasOwnProperty.call(e3, "autoRenewAccountId") && $root.proto.AccountID.encode(e3.autoRenewAccountId, o2.uint32(98).fork()).ldelim(), null != e3.stakedAccountId && Object.hasOwnProperty.call(e3, "stakedAccountId") && $root.proto.AccountID.encode(e3.stakedAccountId, o2.uint32(106).fork()).ldelim(), null != e3.stakedNodeId && Object.hasOwnProperty.call(e3, "stakedNodeId") && o2.uint32(112).int64(e3.stakedNodeId), null != e3.declineReward && Object.hasOwnProperty.call(e3, "declineReward") && $root.google.protobuf.BoolValue.encode(e3.declineReward, o2.uint32(122).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.ContractUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.memo = e3.string();
                break;
              }
              case 10: {
                i.memoWrapper = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.autoRenewAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.stakedAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.stakedNodeId = e3.int64();
                break;
              }
              case 15: {
                i.declineReward = $root.google.protobuf.BoolValue.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractUpdateTransactionBody";
        }, e2;
      }(), LiveHash: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountId = null, e2.prototype.hash = $util.newBuffer([]), e2.prototype.keys = null, e2.prototype.duration = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.accountId && Object.hasOwnProperty.call(e3, "accountId") && $root.proto.AccountID.encode(e3.accountId, o.uint32(10).fork()).ldelim(), null != e3.hash && Object.hasOwnProperty.call(e3, "hash") && o.uint32(18).bytes(e3.hash), null != e3.keys && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(26).fork()).ldelim(), null != e3.duration && Object.hasOwnProperty.call(e3, "duration") && $root.proto.Duration.encode(e3.duration, o.uint32(42).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.LiveHash(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.hash = e3.bytes();
                break;
              }
              case 3: {
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.duration = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.LiveHash";
        }, e2;
      }(), CryptoAddLiveHashTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.liveHash = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.liveHash && Object.hasOwnProperty.call(e3, "liveHash") && $root.proto.LiveHash.encode(e3.liveHash, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoAddLiveHashTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 3: {
                i.liveHash = $root.proto.LiveHash.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoAddLiveHashTransactionBody";
        }, e2;
      }(), CryptoCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.key = null, e2.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.proxyAccountID = null, e2.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.receiverSigRequired = false, e2.prototype.autoRenewPeriod = null, e2.prototype.shardID = null, e2.prototype.realmID = null, e2.prototype.newRealmAdminKey = null, e2.prototype.memo = "", e2.prototype.maxAutomaticTokenAssociations = 0, e2.prototype.stakedAccountId = null, e2.prototype.stakedNodeId = null, e2.prototype.declineReward = false, e2.prototype.alias = $util.newBuffer([]);
        let o;
        return Object.defineProperty(e2.prototype, "stakedId", { get: $util.oneOfGetter(o = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && $root.proto.Key.encode(e3.key, o2.uint32(10).fork()).ldelim(), null != e3.initialBalance && Object.hasOwnProperty.call(e3, "initialBalance") && o2.uint32(16).uint64(e3.initialBalance), null != e3.proxyAccountID && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o2.uint32(26).fork()).ldelim(), null != e3.sendRecordThreshold && Object.hasOwnProperty.call(e3, "sendRecordThreshold") && o2.uint32(48).uint64(e3.sendRecordThreshold), null != e3.receiveRecordThreshold && Object.hasOwnProperty.call(e3, "receiveRecordThreshold") && o2.uint32(56).uint64(e3.receiveRecordThreshold), null != e3.receiverSigRequired && Object.hasOwnProperty.call(e3, "receiverSigRequired") && o2.uint32(64).bool(e3.receiverSigRequired), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o2.uint32(74).fork()).ldelim(), null != e3.shardID && Object.hasOwnProperty.call(e3, "shardID") && $root.proto.ShardID.encode(e3.shardID, o2.uint32(82).fork()).ldelim(), null != e3.realmID && Object.hasOwnProperty.call(e3, "realmID") && $root.proto.RealmID.encode(e3.realmID, o2.uint32(90).fork()).ldelim(), null != e3.newRealmAdminKey && Object.hasOwnProperty.call(e3, "newRealmAdminKey") && $root.proto.Key.encode(e3.newRealmAdminKey, o2.uint32(98).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(106).string(e3.memo), null != e3.maxAutomaticTokenAssociations && Object.hasOwnProperty.call(e3, "maxAutomaticTokenAssociations") && o2.uint32(112).int32(e3.maxAutomaticTokenAssociations), null != e3.stakedAccountId && Object.hasOwnProperty.call(e3, "stakedAccountId") && $root.proto.AccountID.encode(e3.stakedAccountId, o2.uint32(122).fork()).ldelim(), null != e3.stakedNodeId && Object.hasOwnProperty.call(e3, "stakedNodeId") && o2.uint32(128).int64(e3.stakedNodeId), null != e3.declineReward && Object.hasOwnProperty.call(e3, "declineReward") && o2.uint32(136).bool(e3.declineReward), null != e3.alias && Object.hasOwnProperty.call(e3, "alias") && o2.uint32(146).bytes(e3.alias), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.CryptoCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.key = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.initialBalance = e3.uint64();
                break;
              }
              case 3: {
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.sendRecordThreshold = e3.uint64();
                break;
              }
              case 7: {
                i.receiveRecordThreshold = e3.uint64();
                break;
              }
              case 8: {
                i.receiverSigRequired = e3.bool();
                break;
              }
              case 9: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.shardID = $root.proto.ShardID.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.realmID = $root.proto.RealmID.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.newRealmAdminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.memo = e3.string();
                break;
              }
              case 14: {
                i.maxAutomaticTokenAssociations = e3.int32();
                break;
              }
              case 15: {
                i.stakedAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.stakedNodeId = e3.int64();
                break;
              }
              case 17: {
                i.declineReward = e3.bool();
                break;
              }
              case 18: {
                i.alias = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoCreateTransactionBody";
        }, e2;
      }(), CryptoDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transferAccountID = null, e2.prototype.deleteAccountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.transferAccountID && Object.hasOwnProperty.call(e3, "transferAccountID") && $root.proto.AccountID.encode(e3.transferAccountID, o.uint32(10).fork()).ldelim(), null != e3.deleteAccountID && Object.hasOwnProperty.call(e3, "deleteAccountID") && $root.proto.AccountID.encode(e3.deleteAccountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transferAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.deleteAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoDeleteTransactionBody";
        }, e2;
      }(), CryptoDeleteLiveHashTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountOfLiveHash = null, e2.prototype.liveHashToDelete = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.accountOfLiveHash && Object.hasOwnProperty.call(e3, "accountOfLiveHash") && $root.proto.AccountID.encode(e3.accountOfLiveHash, o.uint32(10).fork()).ldelim(), null != e3.liveHashToDelete && Object.hasOwnProperty.call(e3, "liveHashToDelete") && o.uint32(18).bytes(e3.liveHashToDelete), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoDeleteLiveHashTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountOfLiveHash = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.liveHashToDelete = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoDeleteLiveHashTransactionBody";
        }, e2;
      }(), CryptoTransferTransactionBody: function() {
        function e2(e3) {
          if (this.tokenTransfers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transfers = null, e2.prototype.tokenTransfers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.transfers && Object.hasOwnProperty.call(e3, "transfers") && $root.proto.TransferList.encode(e3.transfers, o.uint32(10).fork()).ldelim(), null != e3.tokenTransfers && e3.tokenTransfers.length)
            for (var t = 0; t < e3.tokenTransfers.length; ++t)
              $root.proto.TokenTransferList.encode(e3.tokenTransfers[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoTransferTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transfers = $root.proto.TransferList.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.tokenTransfers && i.tokenTransfers.length || (i.tokenTransfers = []), i.tokenTransfers.push($root.proto.TokenTransferList.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoTransferTransactionBody";
        }, e2;
      }(), CryptoUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.accountIDToUpdate = null, e2.prototype.key = null, e2.prototype.proxyAccountID = null, e2.prototype.proxyFraction = 0, e2.prototype.sendRecordThreshold = null, e2.prototype.sendRecordThresholdWrapper = null, e2.prototype.receiveRecordThreshold = null, e2.prototype.receiveRecordThresholdWrapper = null, e2.prototype.autoRenewPeriod = null, e2.prototype.expirationTime = null, e2.prototype.receiverSigRequired = null, e2.prototype.receiverSigRequiredWrapper = null, e2.prototype.memo = null, e2.prototype.maxAutomaticTokenAssociations = null, e2.prototype.stakedAccountId = null, e2.prototype.stakedNodeId = null, e2.prototype.declineReward = null;
        let o;
        return Object.defineProperty(e2.prototype, "sendRecordThresholdField", { get: $util.oneOfGetter(o = ["sendRecordThreshold", "sendRecordThresholdWrapper"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "receiveRecordThresholdField", { get: $util.oneOfGetter(o = ["receiveRecordThreshold", "receiveRecordThresholdWrapper"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "receiverSigRequiredField", { get: $util.oneOfGetter(o = ["receiverSigRequired", "receiverSigRequiredWrapper"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "stakedId", { get: $util.oneOfGetter(o = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.accountIDToUpdate && Object.hasOwnProperty.call(e3, "accountIDToUpdate") && $root.proto.AccountID.encode(e3.accountIDToUpdate, o2.uint32(18).fork()).ldelim(), null != e3.key && Object.hasOwnProperty.call(e3, "key") && $root.proto.Key.encode(e3.key, o2.uint32(26).fork()).ldelim(), null != e3.proxyAccountID && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o2.uint32(34).fork()).ldelim(), null != e3.proxyFraction && Object.hasOwnProperty.call(e3, "proxyFraction") && o2.uint32(40).int32(e3.proxyFraction), null != e3.sendRecordThreshold && Object.hasOwnProperty.call(e3, "sendRecordThreshold") && o2.uint32(48).uint64(e3.sendRecordThreshold), null != e3.receiveRecordThreshold && Object.hasOwnProperty.call(e3, "receiveRecordThreshold") && o2.uint32(56).uint64(e3.receiveRecordThreshold), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o2.uint32(66).fork()).ldelim(), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o2.uint32(74).fork()).ldelim(), null != e3.receiverSigRequired && Object.hasOwnProperty.call(e3, "receiverSigRequired") && o2.uint32(80).bool(e3.receiverSigRequired), null != e3.sendRecordThresholdWrapper && Object.hasOwnProperty.call(e3, "sendRecordThresholdWrapper") && $root.google.protobuf.UInt64Value.encode(e3.sendRecordThresholdWrapper, o2.uint32(90).fork()).ldelim(), null != e3.receiveRecordThresholdWrapper && Object.hasOwnProperty.call(e3, "receiveRecordThresholdWrapper") && $root.google.protobuf.UInt64Value.encode(e3.receiveRecordThresholdWrapper, o2.uint32(98).fork()).ldelim(), null != e3.receiverSigRequiredWrapper && Object.hasOwnProperty.call(e3, "receiverSigRequiredWrapper") && $root.google.protobuf.BoolValue.encode(e3.receiverSigRequiredWrapper, o2.uint32(106).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o2.uint32(114).fork()).ldelim(), null != e3.maxAutomaticTokenAssociations && Object.hasOwnProperty.call(e3, "maxAutomaticTokenAssociations") && $root.google.protobuf.Int32Value.encode(e3.maxAutomaticTokenAssociations, o2.uint32(122).fork()).ldelim(), null != e3.stakedAccountId && Object.hasOwnProperty.call(e3, "stakedAccountId") && $root.proto.AccountID.encode(e3.stakedAccountId, o2.uint32(130).fork()).ldelim(), null != e3.stakedNodeId && Object.hasOwnProperty.call(e3, "stakedNodeId") && o2.uint32(136).int64(e3.stakedNodeId), null != e3.declineReward && Object.hasOwnProperty.call(e3, "declineReward") && $root.google.protobuf.BoolValue.encode(e3.declineReward, o2.uint32(146).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.CryptoUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2: {
                i.accountIDToUpdate = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.key = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.proxyFraction = e3.int32();
                break;
              }
              case 6: {
                i.sendRecordThreshold = e3.uint64();
                break;
              }
              case 11: {
                i.sendRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.receiveRecordThreshold = e3.uint64();
                break;
              }
              case 12: {
                i.receiveRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.receiverSigRequired = e3.bool();
                break;
              }
              case 13: {
                i.receiverSigRequiredWrapper = $root.google.protobuf.BoolValue.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              }
              case 15: {
                i.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.stakedAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 17: {
                i.stakedNodeId = e3.int64();
                break;
              }
              case 18: {
                i.declineReward = $root.google.protobuf.BoolValue.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoUpdateTransactionBody";
        }, e2;
      }(), CryptoApproveAllowanceTransactionBody: function() {
        function e2(e3) {
          if (this.cryptoAllowances = [], this.nftAllowances = [], this.tokenAllowances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.cryptoAllowances = $util.emptyArray, e2.prototype.nftAllowances = $util.emptyArray, e2.prototype.tokenAllowances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.cryptoAllowances && e3.cryptoAllowances.length)
            for (var t = 0; t < e3.cryptoAllowances.length; ++t)
              $root.proto.CryptoAllowance.encode(e3.cryptoAllowances[t], o.uint32(10).fork()).ldelim();
          if (null != e3.nftAllowances && e3.nftAllowances.length)
            for (var t = 0; t < e3.nftAllowances.length; ++t)
              $root.proto.NftAllowance.encode(e3.nftAllowances[t], o.uint32(18).fork()).ldelim();
          if (null != e3.tokenAllowances && e3.tokenAllowances.length)
            for (var t = 0; t < e3.tokenAllowances.length; ++t)
              $root.proto.TokenAllowance.encode(e3.tokenAllowances[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoApproveAllowanceTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.cryptoAllowances && i.cryptoAllowances.length || (i.cryptoAllowances = []), i.cryptoAllowances.push($root.proto.CryptoAllowance.decode(e3, e3.uint32()));
                break;
              }
              case 2: {
                i.nftAllowances && i.nftAllowances.length || (i.nftAllowances = []), i.nftAllowances.push($root.proto.NftAllowance.decode(e3, e3.uint32()));
                break;
              }
              case 3: {
                i.tokenAllowances && i.tokenAllowances.length || (i.tokenAllowances = []), i.tokenAllowances.push($root.proto.TokenAllowance.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoApproveAllowanceTransactionBody";
        }, e2;
      }(), CryptoAllowance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.owner = null, e2.prototype.spender = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.owner && Object.hasOwnProperty.call(e3, "owner") && $root.proto.AccountID.encode(e3.owner, o.uint32(10).fork()).ldelim(), null != e3.spender && Object.hasOwnProperty.call(e3, "spender") && $root.proto.AccountID.encode(e3.spender, o.uint32(18).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(24).int64(e3.amount), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoAllowance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.owner = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.spender = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.amount = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoAllowance";
        }, e2;
      }(), NftAllowance: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.owner = null, e2.prototype.spender = null, e2.prototype.serialNumbers = $util.emptyArray, e2.prototype.approvedForAll = null, e2.prototype.delegatingSpender = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.owner && Object.hasOwnProperty.call(e3, "owner") && $root.proto.AccountID.encode(e3.owner, o.uint32(18).fork()).ldelim(), null != e3.spender && Object.hasOwnProperty.call(e3, "spender") && $root.proto.AccountID.encode(e3.spender, o.uint32(26).fork()).ldelim(), null != e3.serialNumbers && e3.serialNumbers.length) {
            o.uint32(34).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return null != e3.approvedForAll && Object.hasOwnProperty.call(e3, "approvedForAll") && $root.google.protobuf.BoolValue.encode(e3.approvedForAll, o.uint32(42).fork()).ldelim(), null != e3.delegatingSpender && Object.hasOwnProperty.call(e3, "delegatingSpender") && $root.proto.AccountID.encode(e3.delegatingSpender, o.uint32(50).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NftAllowance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.owner = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.spender = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              }
              case 5: {
                i.approvedForAll = $root.google.protobuf.BoolValue.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.delegatingSpender = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NftAllowance";
        }, e2;
      }(), TokenAllowance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.owner = null, e2.prototype.spender = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.owner && Object.hasOwnProperty.call(e3, "owner") && $root.proto.AccountID.encode(e3.owner, o.uint32(18).fork()).ldelim(), null != e3.spender && Object.hasOwnProperty.call(e3, "spender") && $root.proto.AccountID.encode(e3.spender, o.uint32(26).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(32).int64(e3.amount), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenAllowance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.owner = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.spender = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.amount = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenAllowance";
        }, e2;
      }(), CryptoDeleteAllowanceTransactionBody: function() {
        function e2(e3) {
          if (this.nftAllowances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nftAllowances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.nftAllowances && e3.nftAllowances.length)
            for (var t = 0; t < e3.nftAllowances.length; ++t)
              $root.proto.NftRemoveAllowance.encode(e3.nftAllowances[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoDeleteAllowanceTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2: {
                i.nftAllowances && i.nftAllowances.length || (i.nftAllowances = []), i.nftAllowances.push($root.proto.NftRemoveAllowance.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoDeleteAllowanceTransactionBody";
        }, e2;
      }(), NftRemoveAllowance: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.owner = null, e2.prototype.serialNumbers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.owner && Object.hasOwnProperty.call(e3, "owner") && $root.proto.AccountID.encode(e3.owner, o.uint32(18).fork()).ldelim(), null != e3.serialNumbers && e3.serialNumbers.length) {
            o.uint32(26).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NftRemoveAllowance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.owner = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NftRemoveAllowance";
        }, e2;
      }(), EthereumTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.ethereumData = $util.newBuffer([]), e2.prototype.callData = null, e2.prototype.maxGasAllowance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.ethereumData && Object.hasOwnProperty.call(e3, "ethereumData") && o.uint32(10).bytes(e3.ethereumData), null != e3.callData && Object.hasOwnProperty.call(e3, "callData") && $root.proto.FileID.encode(e3.callData, o.uint32(18).fork()).ldelim(), null != e3.maxGasAllowance && Object.hasOwnProperty.call(e3, "maxGasAllowance") && o.uint32(24).int64(e3.maxGasAllowance), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.EthereumTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.ethereumData = e3.bytes();
                break;
              }
              case 2: {
                i.callData = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.maxGasAllowance = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.EthereumTransactionBody";
        }, e2;
      }(), FileAppendTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileID = null, e2.prototype.contents = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), null != e3.contents && Object.hasOwnProperty.call(e3, "contents") && o.uint32(34).bytes(e3.contents), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileAppendTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contents = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileAppendTransactionBody";
        }, e2;
      }(), FileCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.expirationTime = null, e2.prototype.keys = null, e2.prototype.contents = $util.newBuffer([]), e2.prototype.shardID = null, e2.prototype.realmID = null, e2.prototype.newRealmAdminKey = null, e2.prototype.memo = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(18).fork()).ldelim(), null != e3.keys && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(26).fork()).ldelim(), null != e3.contents && Object.hasOwnProperty.call(e3, "contents") && o.uint32(34).bytes(e3.contents), null != e3.shardID && Object.hasOwnProperty.call(e3, "shardID") && $root.proto.ShardID.encode(e3.shardID, o.uint32(42).fork()).ldelim(), null != e3.realmID && Object.hasOwnProperty.call(e3, "realmID") && $root.proto.RealmID.encode(e3.realmID, o.uint32(50).fork()).ldelim(), null != e3.newRealmAdminKey && Object.hasOwnProperty.call(e3, "newRealmAdminKey") && $root.proto.Key.encode(e3.newRealmAdminKey, o.uint32(58).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o.uint32(66).string(e3.memo), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contents = e3.bytes();
                break;
              }
              case 5: {
                i.shardID = $root.proto.ShardID.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.realmID = $root.proto.RealmID.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.newRealmAdminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.memo = e3.string();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileCreateTransactionBody";
        }, e2;
      }(), FileDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileDeleteTransactionBody";
        }, e2;
      }(), FileUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileID = null, e2.prototype.expirationTime = null, e2.prototype.keys = null, e2.prototype.contents = $util.newBuffer([]), e2.prototype.memo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(10).fork()).ldelim(), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(18).fork()).ldelim(), null != e3.keys && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(26).fork()).ldelim(), null != e3.contents && Object.hasOwnProperty.call(e3, "contents") && o.uint32(34).bytes(e3.contents), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o.uint32(42).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contents = e3.bytes();
                break;
              }
              case 5: {
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileUpdateTransactionBody";
        }, e2;
      }(), ContractDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contractID = null, e2.prototype.transferAccountID = null, e2.prototype.transferContractID = null, e2.prototype.permanentRemoval = false;
        let o;
        return Object.defineProperty(e2.prototype, "obtainers", { get: $util.oneOfGetter(o = ["transferAccountID", "transferContractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(10).fork()).ldelim(), null != e3.transferAccountID && Object.hasOwnProperty.call(e3, "transferAccountID") && $root.proto.AccountID.encode(e3.transferAccountID, o2.uint32(18).fork()).ldelim(), null != e3.transferContractID && Object.hasOwnProperty.call(e3, "transferContractID") && $root.proto.ContractID.encode(e3.transferContractID, o2.uint32(26).fork()).ldelim(), null != e3.permanentRemoval && Object.hasOwnProperty.call(e3, "permanentRemoval") && o2.uint32(32).bool(e3.permanentRemoval), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.ContractDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transferAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.transferContractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.permanentRemoval = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractDeleteTransactionBody";
        }, e2;
      }(), ConsensusUpdateTopicTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.topicID = null, e2.prototype.memo = null, e2.prototype.expirationTime = null, e2.prototype.adminKey = null, e2.prototype.submitKey = null, e2.prototype.autoRenewPeriod = null, e2.prototype.autoRenewAccount = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.topicID && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(10).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o.uint32(18).fork()).ldelim(), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(34).fork()).ldelim(), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(50).fork()).ldelim(), null != e3.submitKey && Object.hasOwnProperty.call(e3, "submitKey") && $root.proto.Key.encode(e3.submitKey, o.uint32(58).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(66).fork()).ldelim(), null != e3.autoRenewAccount && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(74).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusUpdateTopicTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.submitKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusUpdateTopicTransactionBody";
        }, e2;
      }(), ConsensusMessageChunkInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.initialTransactionID = null, e2.prototype.total = 0, e2.prototype.number = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.initialTransactionID && Object.hasOwnProperty.call(e3, "initialTransactionID") && $root.proto.TransactionID.encode(e3.initialTransactionID, o.uint32(10).fork()).ldelim(), null != e3.total && Object.hasOwnProperty.call(e3, "total") && o.uint32(16).int32(e3.total), null != e3.number && Object.hasOwnProperty.call(e3, "number") && o.uint32(24).int32(e3.number), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusMessageChunkInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.initialTransactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.total = e3.int32();
                break;
              }
              case 3: {
                i.number = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusMessageChunkInfo";
        }, e2;
      }(), ConsensusSubmitMessageTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.topicID = null, e2.prototype.message = $util.newBuffer([]), e2.prototype.chunkInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.topicID && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(10).fork()).ldelim(), null != e3.message && Object.hasOwnProperty.call(e3, "message") && o.uint32(18).bytes(e3.message), null != e3.chunkInfo && Object.hasOwnProperty.call(e3, "chunkInfo") && $root.proto.ConsensusMessageChunkInfo.encode(e3.chunkInfo, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusSubmitMessageTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.message = e3.bytes();
                break;
              }
              case 3: {
                i.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusSubmitMessageTransactionBody";
        }, e2;
      }(), UncheckedSubmitBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionBytes = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.transactionBytes && Object.hasOwnProperty.call(e3, "transactionBytes") && o.uint32(10).bytes(e3.transactionBytes), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.UncheckedSubmitBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transactionBytes = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.UncheckedSubmitBody";
        }, e2;
      }(), TokenCreateTransactionBody: function() {
        function e2(e3) {
          if (this.customFees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.name = "", e2.prototype.symbol = "", e2.prototype.decimals = 0, e2.prototype.initialSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.treasury = null, e2.prototype.adminKey = null, e2.prototype.kycKey = null, e2.prototype.freezeKey = null, e2.prototype.wipeKey = null, e2.prototype.supplyKey = null, e2.prototype.freezeDefault = false, e2.prototype.expiry = null, e2.prototype.autoRenewAccount = null, e2.prototype.autoRenewPeriod = null, e2.prototype.memo = "", e2.prototype.tokenType = 0, e2.prototype.supplyType = 0, e2.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.feeScheduleKey = null, e2.prototype.customFees = $util.emptyArray, e2.prototype.pauseKey = null, e2.prototype.metadata = $util.newBuffer([]), e2.prototype.metadataKey = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && o.uint32(10).string(e3.name), null != e3.symbol && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(18).string(e3.symbol), null != e3.decimals && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(24).uint32(e3.decimals), null != e3.initialSupply && Object.hasOwnProperty.call(e3, "initialSupply") && o.uint32(32).uint64(e3.initialSupply), null != e3.treasury && Object.hasOwnProperty.call(e3, "treasury") && $root.proto.AccountID.encode(e3.treasury, o.uint32(42).fork()).ldelim(), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(50).fork()).ldelim(), null != e3.kycKey && Object.hasOwnProperty.call(e3, "kycKey") && $root.proto.Key.encode(e3.kycKey, o.uint32(58).fork()).ldelim(), null != e3.freezeKey && Object.hasOwnProperty.call(e3, "freezeKey") && $root.proto.Key.encode(e3.freezeKey, o.uint32(66).fork()).ldelim(), null != e3.wipeKey && Object.hasOwnProperty.call(e3, "wipeKey") && $root.proto.Key.encode(e3.wipeKey, o.uint32(74).fork()).ldelim(), null != e3.supplyKey && Object.hasOwnProperty.call(e3, "supplyKey") && $root.proto.Key.encode(e3.supplyKey, o.uint32(82).fork()).ldelim(), null != e3.freezeDefault && Object.hasOwnProperty.call(e3, "freezeDefault") && o.uint32(88).bool(e3.freezeDefault), null != e3.expiry && Object.hasOwnProperty.call(e3, "expiry") && $root.proto.Timestamp.encode(e3.expiry, o.uint32(106).fork()).ldelim(), null != e3.autoRenewAccount && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(114).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(122).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o.uint32(130).string(e3.memo), null != e3.tokenType && Object.hasOwnProperty.call(e3, "tokenType") && o.uint32(136).int32(e3.tokenType), null != e3.supplyType && Object.hasOwnProperty.call(e3, "supplyType") && o.uint32(144).int32(e3.supplyType), null != e3.maxSupply && Object.hasOwnProperty.call(e3, "maxSupply") && o.uint32(152).int64(e3.maxSupply), null != e3.feeScheduleKey && Object.hasOwnProperty.call(e3, "feeScheduleKey") && $root.proto.Key.encode(e3.feeScheduleKey, o.uint32(162).fork()).ldelim(), null != e3.customFees && e3.customFees.length)
            for (var t = 0; t < e3.customFees.length; ++t)
              $root.proto.CustomFee.encode(e3.customFees[t], o.uint32(170).fork()).ldelim();
          return null != e3.pauseKey && Object.hasOwnProperty.call(e3, "pauseKey") && $root.proto.Key.encode(e3.pauseKey, o.uint32(178).fork()).ldelim(), null != e3.metadata && Object.hasOwnProperty.call(e3, "metadata") && o.uint32(186).bytes(e3.metadata), null != e3.metadataKey && Object.hasOwnProperty.call(e3, "metadataKey") && $root.proto.Key.encode(e3.metadataKey, o.uint32(194).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.name = e3.string();
                break;
              }
              case 2: {
                i.symbol = e3.string();
                break;
              }
              case 3: {
                i.decimals = e3.uint32();
                break;
              }
              case 4: {
                i.initialSupply = e3.uint64();
                break;
              }
              case 5: {
                i.treasury = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.kycKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.freezeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.wipeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.supplyKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.freezeDefault = e3.bool();
                break;
              }
              case 13: {
                i.expiry = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 15: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.memo = e3.string();
                break;
              }
              case 17: {
                i.tokenType = e3.int32();
                break;
              }
              case 18: {
                i.supplyType = e3.int32();
                break;
              }
              case 19: {
                i.maxSupply = e3.int64();
                break;
              }
              case 20: {
                i.feeScheduleKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 21: {
                i.customFees && i.customFees.length || (i.customFees = []), i.customFees.push($root.proto.CustomFee.decode(e3, e3.uint32()));
                break;
              }
              case 22: {
                i.pauseKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 23: {
                i.metadata = e3.bytes();
                break;
              }
              case 24: {
                i.metadataKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenCreateTransactionBody";
        }, e2;
      }(), FractionalFee: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fractionalAmount = null, e2.prototype.minimumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.maximumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.netOfTransfers = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.fractionalAmount && Object.hasOwnProperty.call(e3, "fractionalAmount") && $root.proto.Fraction.encode(e3.fractionalAmount, o.uint32(10).fork()).ldelim(), null != e3.minimumAmount && Object.hasOwnProperty.call(e3, "minimumAmount") && o.uint32(16).int64(e3.minimumAmount), null != e3.maximumAmount && Object.hasOwnProperty.call(e3, "maximumAmount") && o.uint32(24).int64(e3.maximumAmount), null != e3.netOfTransfers && Object.hasOwnProperty.call(e3, "netOfTransfers") && o.uint32(32).bool(e3.netOfTransfers), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FractionalFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.fractionalAmount = $root.proto.Fraction.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.minimumAmount = e3.int64();
                break;
              }
              case 3: {
                i.maximumAmount = e3.int64();
                break;
              }
              case 4: {
                i.netOfTransfers = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FractionalFee";
        }, e2;
      }(), FixedFee: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.denominatingTokenId = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(8).int64(e3.amount), null != e3.denominatingTokenId && Object.hasOwnProperty.call(e3, "denominatingTokenId") && $root.proto.TokenID.encode(e3.denominatingTokenId, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FixedFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.amount = e3.int64();
                break;
              }
              case 2: {
                i.denominatingTokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FixedFee";
        }, e2;
      }(), RoyaltyFee: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.exchangeValueFraction = null, e2.prototype.fallbackFee = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.exchangeValueFraction && Object.hasOwnProperty.call(e3, "exchangeValueFraction") && $root.proto.Fraction.encode(e3.exchangeValueFraction, o.uint32(10).fork()).ldelim(), null != e3.fallbackFee && Object.hasOwnProperty.call(e3, "fallbackFee") && $root.proto.FixedFee.encode(e3.fallbackFee, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.RoyaltyFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.exchangeValueFraction = $root.proto.Fraction.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.fallbackFee = $root.proto.FixedFee.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.RoyaltyFee";
        }, e2;
      }(), CustomFee: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.fixedFee = null, e2.prototype.fractionalFee = null, e2.prototype.royaltyFee = null, e2.prototype.feeCollectorAccountId = null, e2.prototype.allCollectorsAreExempt = false;
        let o;
        return Object.defineProperty(e2.prototype, "fee", { get: $util.oneOfGetter(o = ["fixedFee", "fractionalFee", "royaltyFee"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.fixedFee && Object.hasOwnProperty.call(e3, "fixedFee") && $root.proto.FixedFee.encode(e3.fixedFee, o2.uint32(10).fork()).ldelim(), null != e3.fractionalFee && Object.hasOwnProperty.call(e3, "fractionalFee") && $root.proto.FractionalFee.encode(e3.fractionalFee, o2.uint32(18).fork()).ldelim(), null != e3.feeCollectorAccountId && Object.hasOwnProperty.call(e3, "feeCollectorAccountId") && $root.proto.AccountID.encode(e3.feeCollectorAccountId, o2.uint32(26).fork()).ldelim(), null != e3.royaltyFee && Object.hasOwnProperty.call(e3, "royaltyFee") && $root.proto.RoyaltyFee.encode(e3.royaltyFee, o2.uint32(34).fork()).ldelim(), null != e3.allCollectorsAreExempt && Object.hasOwnProperty.call(e3, "allCollectorsAreExempt") && o2.uint32(40).bool(e3.allCollectorsAreExempt), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.CustomFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.fixedFee = $root.proto.FixedFee.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.fractionalFee = $root.proto.FractionalFee.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.royaltyFee = $root.proto.RoyaltyFee.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.feeCollectorAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.allCollectorsAreExempt = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CustomFee";
        }, e2;
      }(), AssessedCustomFee: function() {
        function e2(e3) {
          if (this.effectivePayerAccountId = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.tokenId = null, e2.prototype.feeCollectorAccountId = null, e2.prototype.effectivePayerAccountId = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(8).int64(e3.amount), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(18).fork()).ldelim(), null != e3.feeCollectorAccountId && Object.hasOwnProperty.call(e3, "feeCollectorAccountId") && $root.proto.AccountID.encode(e3.feeCollectorAccountId, o.uint32(26).fork()).ldelim(), null != e3.effectivePayerAccountId && e3.effectivePayerAccountId.length)
            for (var t = 0; t < e3.effectivePayerAccountId.length; ++t)
              $root.proto.AccountID.encode(e3.effectivePayerAccountId[t], o.uint32(34).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.AssessedCustomFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.amount = e3.int64();
                break;
              }
              case 2: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.feeCollectorAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.effectivePayerAccountId && i.effectivePayerAccountId.length || (i.effectivePayerAccountId = []), i.effectivePayerAccountId.push($root.proto.AccountID.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.AssessedCustomFee";
        }, e2;
      }(), TokenFreezeAccountTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.account && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenFreezeAccountTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenFreezeAccountTransactionBody";
        }, e2;
      }(), TokenUnfreezeAccountTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.account && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenUnfreezeAccountTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenUnfreezeAccountTransactionBody";
        }, e2;
      }(), TokenGrantKycTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.account && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGrantKycTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGrantKycTransactionBody";
        }, e2;
      }(), TokenRevokeKycTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.account && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenRevokeKycTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenRevokeKycTransactionBody";
        }, e2;
      }(), TokenDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenDeleteTransactionBody";
        }, e2;
      }(), TokenUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.symbol = "", e2.prototype.name = "", e2.prototype.treasury = null, e2.prototype.adminKey = null, e2.prototype.kycKey = null, e2.prototype.freezeKey = null, e2.prototype.wipeKey = null, e2.prototype.supplyKey = null, e2.prototype.autoRenewAccount = null, e2.prototype.autoRenewPeriod = null, e2.prototype.expiry = null, e2.prototype.memo = null, e2.prototype.feeScheduleKey = null, e2.prototype.pauseKey = null, e2.prototype.metadata = null, e2.prototype.metadataKey = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.symbol && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(18).string(e3.symbol), null != e3.name && Object.hasOwnProperty.call(e3, "name") && o.uint32(26).string(e3.name), null != e3.treasury && Object.hasOwnProperty.call(e3, "treasury") && $root.proto.AccountID.encode(e3.treasury, o.uint32(34).fork()).ldelim(), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(42).fork()).ldelim(), null != e3.kycKey && Object.hasOwnProperty.call(e3, "kycKey") && $root.proto.Key.encode(e3.kycKey, o.uint32(50).fork()).ldelim(), null != e3.freezeKey && Object.hasOwnProperty.call(e3, "freezeKey") && $root.proto.Key.encode(e3.freezeKey, o.uint32(58).fork()).ldelim(), null != e3.wipeKey && Object.hasOwnProperty.call(e3, "wipeKey") && $root.proto.Key.encode(e3.wipeKey, o.uint32(66).fork()).ldelim(), null != e3.supplyKey && Object.hasOwnProperty.call(e3, "supplyKey") && $root.proto.Key.encode(e3.supplyKey, o.uint32(74).fork()).ldelim(), null != e3.autoRenewAccount && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(82).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(90).fork()).ldelim(), null != e3.expiry && Object.hasOwnProperty.call(e3, "expiry") && $root.proto.Timestamp.encode(e3.expiry, o.uint32(98).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o.uint32(106).fork()).ldelim(), null != e3.feeScheduleKey && Object.hasOwnProperty.call(e3, "feeScheduleKey") && $root.proto.Key.encode(e3.feeScheduleKey, o.uint32(114).fork()).ldelim(), null != e3.pauseKey && Object.hasOwnProperty.call(e3, "pauseKey") && $root.proto.Key.encode(e3.pauseKey, o.uint32(122).fork()).ldelim(), null != e3.metadata && Object.hasOwnProperty.call(e3, "metadata") && $root.google.protobuf.BytesValue.encode(e3.metadata, o.uint32(130).fork()).ldelim(), null != e3.metadataKey && Object.hasOwnProperty.call(e3, "metadataKey") && $root.proto.Key.encode(e3.metadataKey, o.uint32(138).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.symbol = e3.string();
                break;
              }
              case 3: {
                i.name = e3.string();
                break;
              }
              case 4: {
                i.treasury = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.kycKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.freezeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.wipeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.supplyKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.expiry = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.feeScheduleKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 15: {
                i.pauseKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.metadata = $root.google.protobuf.BytesValue.decode(e3, e3.uint32());
                break;
              }
              case 17: {
                i.metadataKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenUpdateTransactionBody";
        }, e2;
      }(), TokenMintTransactionBody: function() {
        function e2(e3) {
          if (this.metadata = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.metadata = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).uint64(e3.amount), null != e3.metadata && e3.metadata.length)
            for (var t = 0; t < e3.metadata.length; ++t)
              o.uint32(26).bytes(e3.metadata[t]);
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenMintTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.amount = e3.uint64();
                break;
              }
              case 3: {
                i.metadata && i.metadata.length || (i.metadata = []), i.metadata.push(e3.bytes());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenMintTransactionBody";
        }, e2;
      }(), TokenBurnTransactionBody: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.serialNumbers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).uint64(e3.amount), null != e3.serialNumbers && e3.serialNumbers.length) {
            o.uint32(26).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenBurnTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.amount = e3.uint64();
                break;
              }
              case 3: {
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenBurnTransactionBody";
        }, e2;
      }(), TokenWipeAccountTransactionBody: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.serialNumbers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.account && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(24).uint64(e3.amount), null != e3.serialNumbers && e3.serialNumbers.length) {
            o.uint32(34).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenWipeAccountTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.amount = e3.uint64();
                break;
              }
              case 4: {
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenWipeAccountTransactionBody";
        }, e2;
      }(), TokenAssociateTransactionBody: function() {
        function e2(e3) {
          if (this.tokens = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.account = null, e2.prototype.tokens = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.account && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(10).fork()).ldelim(), null != e3.tokens && e3.tokens.length)
            for (var t = 0; t < e3.tokens.length; ++t)
              $root.proto.TokenID.encode(e3.tokens[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenAssociateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.tokens && i.tokens.length || (i.tokens = []), i.tokens.push($root.proto.TokenID.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenAssociateTransactionBody";
        }, e2;
      }(), TokenDissociateTransactionBody: function() {
        function e2(e3) {
          if (this.tokens = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.account = null, e2.prototype.tokens = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.account && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(10).fork()).ldelim(), null != e3.tokens && e3.tokens.length)
            for (var t = 0; t < e3.tokens.length; ++t)
              $root.proto.TokenID.encode(e3.tokens[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenDissociateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.tokens && i.tokens.length || (i.tokens = []), i.tokens.push($root.proto.TokenID.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenDissociateTransactionBody";
        }, e2;
      }(), TokenFeeScheduleUpdateTransactionBody: function() {
        function e2(e3) {
          if (this.customFees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.customFees = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.customFees && e3.customFees.length)
            for (var t = 0; t < e3.customFees.length; ++t)
              $root.proto.CustomFee.encode(e3.customFees[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenFeeScheduleUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.customFees && i.customFees.length || (i.customFees = []), i.customFees.push($root.proto.CustomFee.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenFeeScheduleUpdateTransactionBody";
        }, e2;
      }(), TokenPauseTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenPauseTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenPauseTransactionBody";
        }, e2;
      }(), TokenUnpauseTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenUnpauseTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenUnpauseTransactionBody";
        }, e2;
      }(), TokenUpdateNftsTransactionBody: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.serialNumbers = $util.emptyArray, e2.prototype.metadata = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), null != e3.serialNumbers && e3.serialNumbers.length) {
            o.uint32(18).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return null != e3.metadata && Object.hasOwnProperty.call(e3, "metadata") && $root.google.protobuf.BytesValue.encode(e3.metadata, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenUpdateNftsTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              }
              case 3: {
                i.metadata = $root.google.protobuf.BytesValue.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenUpdateNftsTransactionBody";
        }, e2;
      }(), ScheduleCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.scheduledTransactionBody = null, e2.prototype.memo = "", e2.prototype.adminKey = null, e2.prototype.payerAccountID = null, e2.prototype.expirationTime = null, e2.prototype.waitForExpiry = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.scheduledTransactionBody && Object.hasOwnProperty.call(e3, "scheduledTransactionBody") && $root.proto.SchedulableTransactionBody.encode(e3.scheduledTransactionBody, o.uint32(10).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o.uint32(18).string(e3.memo), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(26).fork()).ldelim(), null != e3.payerAccountID && Object.hasOwnProperty.call(e3, "payerAccountID") && $root.proto.AccountID.encode(e3.payerAccountID, o.uint32(34).fork()).ldelim(), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(42).fork()).ldelim(), null != e3.waitForExpiry && Object.hasOwnProperty.call(e3, "waitForExpiry") && o.uint32(104).bool(e3.waitForExpiry), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ScheduleCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.memo = e3.string();
                break;
              }
              case 3: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.payerAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.waitForExpiry = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ScheduleCreateTransactionBody";
        }, e2;
      }(), SchedulableTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.memo = "", e2.prototype.contractCall = null, e2.prototype.contractCreateInstance = null, e2.prototype.contractUpdateInstance = null, e2.prototype.contractDeleteInstance = null, e2.prototype.cryptoApproveAllowance = null, e2.prototype.cryptoDeleteAllowance = null, e2.prototype.cryptoCreateAccount = null, e2.prototype.cryptoDelete = null, e2.prototype.cryptoTransfer = null, e2.prototype.cryptoUpdateAccount = null, e2.prototype.fileAppend = null, e2.prototype.fileCreate = null, e2.prototype.fileDelete = null, e2.prototype.fileUpdate = null, e2.prototype.systemDelete = null, e2.prototype.systemUndelete = null, e2.prototype.freeze = null, e2.prototype.consensusCreateTopic = null, e2.prototype.consensusUpdateTopic = null, e2.prototype.consensusDeleteTopic = null, e2.prototype.consensusSubmitMessage = null, e2.prototype.tokenCreation = null, e2.prototype.tokenFreeze = null, e2.prototype.tokenUnfreeze = null, e2.prototype.tokenGrantKyc = null, e2.prototype.tokenRevokeKyc = null, e2.prototype.tokenDeletion = null, e2.prototype.tokenUpdate = null, e2.prototype.tokenMint = null, e2.prototype.tokenBurn = null, e2.prototype.tokenWipe = null, e2.prototype.tokenAssociate = null, e2.prototype.tokenDissociate = null, e2.prototype.tokenFeeScheduleUpdate = null, e2.prototype.tokenPause = null, e2.prototype.tokenUnpause = null, e2.prototype.scheduleDelete = null, e2.prototype.utilPrng = null, e2.prototype.tokenUpdateNfts = null;
        let o;
        return Object.defineProperty(e2.prototype, "data", { get: $util.oneOfGetter(o = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoApproveAllowance", "cryptoDeleteAllowance", "cryptoCreateAccount", "cryptoDelete", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "tokenFeeScheduleUpdate", "tokenPause", "tokenUnpause", "scheduleDelete", "utilPrng", "tokenUpdateNfts"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.transactionFee && Object.hasOwnProperty.call(e3, "transactionFee") && o2.uint32(8).uint64(e3.transactionFee), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(18).string(e3.memo), null != e3.contractCall && Object.hasOwnProperty.call(e3, "contractCall") && $root.proto.ContractCallTransactionBody.encode(e3.contractCall, o2.uint32(26).fork()).ldelim(), null != e3.contractCreateInstance && Object.hasOwnProperty.call(e3, "contractCreateInstance") && $root.proto.ContractCreateTransactionBody.encode(e3.contractCreateInstance, o2.uint32(34).fork()).ldelim(), null != e3.contractUpdateInstance && Object.hasOwnProperty.call(e3, "contractUpdateInstance") && $root.proto.ContractUpdateTransactionBody.encode(e3.contractUpdateInstance, o2.uint32(42).fork()).ldelim(), null != e3.contractDeleteInstance && Object.hasOwnProperty.call(e3, "contractDeleteInstance") && $root.proto.ContractDeleteTransactionBody.encode(e3.contractDeleteInstance, o2.uint32(50).fork()).ldelim(), null != e3.cryptoCreateAccount && Object.hasOwnProperty.call(e3, "cryptoCreateAccount") && $root.proto.CryptoCreateTransactionBody.encode(e3.cryptoCreateAccount, o2.uint32(58).fork()).ldelim(), null != e3.cryptoDelete && Object.hasOwnProperty.call(e3, "cryptoDelete") && $root.proto.CryptoDeleteTransactionBody.encode(e3.cryptoDelete, o2.uint32(66).fork()).ldelim(), null != e3.cryptoTransfer && Object.hasOwnProperty.call(e3, "cryptoTransfer") && $root.proto.CryptoTransferTransactionBody.encode(e3.cryptoTransfer, o2.uint32(74).fork()).ldelim(), null != e3.cryptoUpdateAccount && Object.hasOwnProperty.call(e3, "cryptoUpdateAccount") && $root.proto.CryptoUpdateTransactionBody.encode(e3.cryptoUpdateAccount, o2.uint32(82).fork()).ldelim(), null != e3.fileAppend && Object.hasOwnProperty.call(e3, "fileAppend") && $root.proto.FileAppendTransactionBody.encode(e3.fileAppend, o2.uint32(90).fork()).ldelim(), null != e3.fileCreate && Object.hasOwnProperty.call(e3, "fileCreate") && $root.proto.FileCreateTransactionBody.encode(e3.fileCreate, o2.uint32(98).fork()).ldelim(), null != e3.fileDelete && Object.hasOwnProperty.call(e3, "fileDelete") && $root.proto.FileDeleteTransactionBody.encode(e3.fileDelete, o2.uint32(106).fork()).ldelim(), null != e3.fileUpdate && Object.hasOwnProperty.call(e3, "fileUpdate") && $root.proto.FileUpdateTransactionBody.encode(e3.fileUpdate, o2.uint32(114).fork()).ldelim(), null != e3.systemDelete && Object.hasOwnProperty.call(e3, "systemDelete") && $root.proto.SystemDeleteTransactionBody.encode(e3.systemDelete, o2.uint32(122).fork()).ldelim(), null != e3.systemUndelete && Object.hasOwnProperty.call(e3, "systemUndelete") && $root.proto.SystemUndeleteTransactionBody.encode(e3.systemUndelete, o2.uint32(130).fork()).ldelim(), null != e3.freeze && Object.hasOwnProperty.call(e3, "freeze") && $root.proto.FreezeTransactionBody.encode(e3.freeze, o2.uint32(138).fork()).ldelim(), null != e3.consensusCreateTopic && Object.hasOwnProperty.call(e3, "consensusCreateTopic") && $root.proto.ConsensusCreateTopicTransactionBody.encode(e3.consensusCreateTopic, o2.uint32(146).fork()).ldelim(), null != e3.consensusUpdateTopic && Object.hasOwnProperty.call(e3, "consensusUpdateTopic") && $root.proto.ConsensusUpdateTopicTransactionBody.encode(e3.consensusUpdateTopic, o2.uint32(154).fork()).ldelim(), null != e3.consensusDeleteTopic && Object.hasOwnProperty.call(e3, "consensusDeleteTopic") && $root.proto.ConsensusDeleteTopicTransactionBody.encode(e3.consensusDeleteTopic, o2.uint32(162).fork()).ldelim(), null != e3.consensusSubmitMessage && Object.hasOwnProperty.call(e3, "consensusSubmitMessage") && $root.proto.ConsensusSubmitMessageTransactionBody.encode(e3.consensusSubmitMessage, o2.uint32(170).fork()).ldelim(), null != e3.tokenCreation && Object.hasOwnProperty.call(e3, "tokenCreation") && $root.proto.TokenCreateTransactionBody.encode(e3.tokenCreation, o2.uint32(178).fork()).ldelim(), null != e3.tokenFreeze && Object.hasOwnProperty.call(e3, "tokenFreeze") && $root.proto.TokenFreezeAccountTransactionBody.encode(e3.tokenFreeze, o2.uint32(186).fork()).ldelim(), null != e3.tokenUnfreeze && Object.hasOwnProperty.call(e3, "tokenUnfreeze") && $root.proto.TokenUnfreezeAccountTransactionBody.encode(e3.tokenUnfreeze, o2.uint32(194).fork()).ldelim(), null != e3.tokenGrantKyc && Object.hasOwnProperty.call(e3, "tokenGrantKyc") && $root.proto.TokenGrantKycTransactionBody.encode(e3.tokenGrantKyc, o2.uint32(202).fork()).ldelim(), null != e3.tokenRevokeKyc && Object.hasOwnProperty.call(e3, "tokenRevokeKyc") && $root.proto.TokenRevokeKycTransactionBody.encode(e3.tokenRevokeKyc, o2.uint32(210).fork()).ldelim(), null != e3.tokenDeletion && Object.hasOwnProperty.call(e3, "tokenDeletion") && $root.proto.TokenDeleteTransactionBody.encode(e3.tokenDeletion, o2.uint32(218).fork()).ldelim(), null != e3.tokenUpdate && Object.hasOwnProperty.call(e3, "tokenUpdate") && $root.proto.TokenUpdateTransactionBody.encode(e3.tokenUpdate, o2.uint32(226).fork()).ldelim(), null != e3.tokenMint && Object.hasOwnProperty.call(e3, "tokenMint") && $root.proto.TokenMintTransactionBody.encode(e3.tokenMint, o2.uint32(234).fork()).ldelim(), null != e3.tokenBurn && Object.hasOwnProperty.call(e3, "tokenBurn") && $root.proto.TokenBurnTransactionBody.encode(e3.tokenBurn, o2.uint32(242).fork()).ldelim(), null != e3.tokenWipe && Object.hasOwnProperty.call(e3, "tokenWipe") && $root.proto.TokenWipeAccountTransactionBody.encode(e3.tokenWipe, o2.uint32(250).fork()).ldelim(), null != e3.tokenAssociate && Object.hasOwnProperty.call(e3, "tokenAssociate") && $root.proto.TokenAssociateTransactionBody.encode(e3.tokenAssociate, o2.uint32(258).fork()).ldelim(), null != e3.tokenDissociate && Object.hasOwnProperty.call(e3, "tokenDissociate") && $root.proto.TokenDissociateTransactionBody.encode(e3.tokenDissociate, o2.uint32(266).fork()).ldelim(), null != e3.scheduleDelete && Object.hasOwnProperty.call(e3, "scheduleDelete") && $root.proto.ScheduleDeleteTransactionBody.encode(e3.scheduleDelete, o2.uint32(274).fork()).ldelim(), null != e3.tokenPause && Object.hasOwnProperty.call(e3, "tokenPause") && $root.proto.TokenPauseTransactionBody.encode(e3.tokenPause, o2.uint32(282).fork()).ldelim(), null != e3.tokenUnpause && Object.hasOwnProperty.call(e3, "tokenUnpause") && $root.proto.TokenUnpauseTransactionBody.encode(e3.tokenUnpause, o2.uint32(290).fork()).ldelim(), null != e3.cryptoApproveAllowance && Object.hasOwnProperty.call(e3, "cryptoApproveAllowance") && $root.proto.CryptoApproveAllowanceTransactionBody.encode(e3.cryptoApproveAllowance, o2.uint32(298).fork()).ldelim(), null != e3.cryptoDeleteAllowance && Object.hasOwnProperty.call(e3, "cryptoDeleteAllowance") && $root.proto.CryptoDeleteAllowanceTransactionBody.encode(e3.cryptoDeleteAllowance, o2.uint32(306).fork()).ldelim(), null != e3.tokenFeeScheduleUpdate && Object.hasOwnProperty.call(e3, "tokenFeeScheduleUpdate") && $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(e3.tokenFeeScheduleUpdate, o2.uint32(314).fork()).ldelim(), null != e3.utilPrng && Object.hasOwnProperty.call(e3, "utilPrng") && $root.proto.UtilPrngTransactionBody.encode(e3.utilPrng, o2.uint32(322).fork()).ldelim(), null != e3.tokenUpdateNfts && Object.hasOwnProperty.call(e3, "tokenUpdateNfts") && $root.proto.TokenUpdateNftsTransactionBody.encode(e3.tokenUpdateNfts, o2.uint32(330).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.SchedulableTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transactionFee = e3.uint64();
                break;
              }
              case 2: {
                i.memo = e3.string();
                break;
              }
              case 3: {
                i.contractCall = $root.proto.ContractCallTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 37: {
                i.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 38: {
                i.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.fileAppend = $root.proto.FileAppendTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.fileCreate = $root.proto.FileCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.fileDelete = $root.proto.FileDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 15: {
                i.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 17: {
                i.freeze = $root.proto.FreezeTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 18: {
                i.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 19: {
                i.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 20: {
                i.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 21: {
                i.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 22: {
                i.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 23: {
                i.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 24: {
                i.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 25: {
                i.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 26: {
                i.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 27: {
                i.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 28: {
                i.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 29: {
                i.tokenMint = $root.proto.TokenMintTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 30: {
                i.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 31: {
                i.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 32: {
                i.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 33: {
                i.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 39: {
                i.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 35: {
                i.tokenPause = $root.proto.TokenPauseTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 36: {
                i.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 34: {
                i.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 40: {
                i.utilPrng = $root.proto.UtilPrngTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 41: {
                i.tokenUpdateNfts = $root.proto.TokenUpdateNftsTransactionBody.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SchedulableTransactionBody";
        }, e2;
      }(), ScheduleDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.scheduleID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.scheduleID && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ScheduleDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ScheduleDeleteTransactionBody";
        }, e2;
      }(), UtilPrngTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.range = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.range && Object.hasOwnProperty.call(e3, "range") && o.uint32(8).int32(e3.range), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.UtilPrngTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.range = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.UtilPrngTransactionBody";
        }, e2;
      }(), ScheduleSignTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.scheduleID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.scheduleID && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ScheduleSignTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ScheduleSignTransactionBody";
        }, e2;
      }(), NodeStakeUpdateTransactionBody: function() {
        function e2(e3) {
          if (this.nodeStake = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.endOfStakingPeriod = null, e2.prototype.nodeStake = $util.emptyArray, e2.prototype.maxStakingRewardRatePerHbar = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.nodeRewardFeeFraction = null, e2.prototype.stakingPeriodsStored = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stakingPeriod = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stakingRewardFeeFraction = null, e2.prototype.stakingStartThreshold = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stakingRewardRate = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.reservedStakingRewards = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.unreservedStakingRewardBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.rewardBalanceThreshold = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.maxStakeRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.maxTotalReward = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.endOfStakingPeriod && Object.hasOwnProperty.call(e3, "endOfStakingPeriod") && $root.proto.Timestamp.encode(e3.endOfStakingPeriod, o.uint32(10).fork()).ldelim(), null != e3.nodeStake && e3.nodeStake.length)
            for (var t = 0; t < e3.nodeStake.length; ++t)
              $root.proto.NodeStake.encode(e3.nodeStake[t], o.uint32(18).fork()).ldelim();
          return null != e3.maxStakingRewardRatePerHbar && Object.hasOwnProperty.call(e3, "maxStakingRewardRatePerHbar") && o.uint32(24).int64(e3.maxStakingRewardRatePerHbar), null != e3.nodeRewardFeeFraction && Object.hasOwnProperty.call(e3, "nodeRewardFeeFraction") && $root.proto.Fraction.encode(e3.nodeRewardFeeFraction, o.uint32(34).fork()).ldelim(), null != e3.stakingPeriodsStored && Object.hasOwnProperty.call(e3, "stakingPeriodsStored") && o.uint32(40).int64(e3.stakingPeriodsStored), null != e3.stakingPeriod && Object.hasOwnProperty.call(e3, "stakingPeriod") && o.uint32(48).int64(e3.stakingPeriod), null != e3.stakingRewardFeeFraction && Object.hasOwnProperty.call(e3, "stakingRewardFeeFraction") && $root.proto.Fraction.encode(e3.stakingRewardFeeFraction, o.uint32(58).fork()).ldelim(), null != e3.stakingStartThreshold && Object.hasOwnProperty.call(e3, "stakingStartThreshold") && o.uint32(64).int64(e3.stakingStartThreshold), null != e3.stakingRewardRate && Object.hasOwnProperty.call(e3, "stakingRewardRate") && o.uint32(72).int64(e3.stakingRewardRate), null != e3.reservedStakingRewards && Object.hasOwnProperty.call(e3, "reservedStakingRewards") && o.uint32(80).int64(e3.reservedStakingRewards), null != e3.unreservedStakingRewardBalance && Object.hasOwnProperty.call(e3, "unreservedStakingRewardBalance") && o.uint32(88).int64(e3.unreservedStakingRewardBalance), null != e3.rewardBalanceThreshold && Object.hasOwnProperty.call(e3, "rewardBalanceThreshold") && o.uint32(96).int64(e3.rewardBalanceThreshold), null != e3.maxStakeRewarded && Object.hasOwnProperty.call(e3, "maxStakeRewarded") && o.uint32(104).int64(e3.maxStakeRewarded), null != e3.maxTotalReward && Object.hasOwnProperty.call(e3, "maxTotalReward") && o.uint32(112).int64(e3.maxTotalReward), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NodeStakeUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.endOfStakingPeriod = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nodeStake && i.nodeStake.length || (i.nodeStake = []), i.nodeStake.push($root.proto.NodeStake.decode(e3, e3.uint32()));
                break;
              }
              case 3: {
                i.maxStakingRewardRatePerHbar = e3.int64();
                break;
              }
              case 4: {
                i.nodeRewardFeeFraction = $root.proto.Fraction.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.stakingPeriodsStored = e3.int64();
                break;
              }
              case 6: {
                i.stakingPeriod = e3.int64();
                break;
              }
              case 7: {
                i.stakingRewardFeeFraction = $root.proto.Fraction.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.stakingStartThreshold = e3.int64();
                break;
              }
              case 9: {
                i.stakingRewardRate = e3.int64();
                break;
              }
              case 10: {
                i.reservedStakingRewards = e3.int64();
                break;
              }
              case 11: {
                i.unreservedStakingRewardBalance = e3.int64();
                break;
              }
              case 12: {
                i.rewardBalanceThreshold = e3.int64();
                break;
              }
              case 13: {
                i.maxStakeRewarded = e3.int64();
                break;
              }
              case 14: {
                i.maxTotalReward = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NodeStakeUpdateTransactionBody";
        }, e2;
      }(), NodeStake: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.maxStake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.minStake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.rewardRate = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stakeNotRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.stakeRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.maxStake && Object.hasOwnProperty.call(e3, "maxStake") && o.uint32(8).int64(e3.maxStake), null != e3.minStake && Object.hasOwnProperty.call(e3, "minStake") && o.uint32(16).int64(e3.minStake), null != e3.nodeId && Object.hasOwnProperty.call(e3, "nodeId") && o.uint32(24).int64(e3.nodeId), null != e3.rewardRate && Object.hasOwnProperty.call(e3, "rewardRate") && o.uint32(32).int64(e3.rewardRate), null != e3.stake && Object.hasOwnProperty.call(e3, "stake") && o.uint32(40).int64(e3.stake), null != e3.stakeNotRewarded && Object.hasOwnProperty.call(e3, "stakeNotRewarded") && o.uint32(48).int64(e3.stakeNotRewarded), null != e3.stakeRewarded && Object.hasOwnProperty.call(e3, "stakeRewarded") && o.uint32(56).int64(e3.stakeRewarded), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NodeStake(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.maxStake = e3.int64();
                break;
              }
              case 2: {
                i.minStake = e3.int64();
                break;
              }
              case 3: {
                i.nodeId = e3.int64();
                break;
              }
              case 4: {
                i.rewardRate = e3.int64();
                break;
              }
              case 5: {
                i.stake = e3.int64();
                break;
              }
              case 6: {
                i.stakeNotRewarded = e3.int64();
                break;
              }
              case 7: {
                i.stakeRewarded = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NodeStake";
        }, e2;
      }(), ResponseHeader: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodeTransactionPrecheckCode = 0, e2.prototype.responseType = 0, e2.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.stateProof = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.nodeTransactionPrecheckCode && Object.hasOwnProperty.call(e3, "nodeTransactionPrecheckCode") && o.uint32(8).int32(e3.nodeTransactionPrecheckCode), null != e3.responseType && Object.hasOwnProperty.call(e3, "responseType") && o.uint32(16).int32(e3.responseType), null != e3.cost && Object.hasOwnProperty.call(e3, "cost") && o.uint32(24).uint64(e3.cost), null != e3.stateProof && Object.hasOwnProperty.call(e3, "stateProof") && o.uint32(34).bytes(e3.stateProof), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ResponseHeader(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.nodeTransactionPrecheckCode = e3.int32();
                break;
              }
              case 2: {
                i.responseType = e3.int32();
                break;
              }
              case 3: {
                i.cost = e3.uint64();
                break;
              }
              case 4: {
                i.stateProof = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ResponseHeader";
        }, e2;
      }(), ResponseCodeEnum: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "OK"] = 0, o[e2[1] = "INVALID_TRANSACTION"] = 1, o[e2[2] = "PAYER_ACCOUNT_NOT_FOUND"] = 2, o[e2[3] = "INVALID_NODE_ACCOUNT"] = 3, o[e2[4] = "TRANSACTION_EXPIRED"] = 4, o[e2[5] = "INVALID_TRANSACTION_START"] = 5, o[e2[6] = "INVALID_TRANSACTION_DURATION"] = 6, o[e2[7] = "INVALID_SIGNATURE"] = 7, o[e2[8] = "MEMO_TOO_LONG"] = 8, o[e2[9] = "INSUFFICIENT_TX_FEE"] = 9, o[e2[10] = "INSUFFICIENT_PAYER_BALANCE"] = 10, o[e2[11] = "DUPLICATE_TRANSACTION"] = 11, o[e2[12] = "BUSY"] = 12, o[e2[13] = "NOT_SUPPORTED"] = 13, o[e2[14] = "INVALID_FILE_ID"] = 14, o[e2[15] = "INVALID_ACCOUNT_ID"] = 15, o[e2[16] = "INVALID_CONTRACT_ID"] = 16, o[e2[17] = "INVALID_TRANSACTION_ID"] = 17, o[e2[18] = "RECEIPT_NOT_FOUND"] = 18, o[e2[19] = "RECORD_NOT_FOUND"] = 19, o[e2[20] = "INVALID_SOLIDITY_ID"] = 20, o[e2[21] = "UNKNOWN"] = 21, o[e2[22] = "SUCCESS"] = 22, o[e2[23] = "FAIL_INVALID"] = 23, o[e2[24] = "FAIL_FEE"] = 24, o[e2[25] = "FAIL_BALANCE"] = 25, o[e2[26] = "KEY_REQUIRED"] = 26, o[e2[27] = "BAD_ENCODING"] = 27, o[e2[28] = "INSUFFICIENT_ACCOUNT_BALANCE"] = 28, o[e2[29] = "INVALID_SOLIDITY_ADDRESS"] = 29, o[e2[30] = "INSUFFICIENT_GAS"] = 30, o[e2[31] = "CONTRACT_SIZE_LIMIT_EXCEEDED"] = 31, o[e2[32] = "LOCAL_CALL_MODIFICATION_EXCEPTION"] = 32, o[e2[33] = "CONTRACT_REVERT_EXECUTED"] = 33, o[e2[34] = "CONTRACT_EXECUTION_EXCEPTION"] = 34, o[e2[35] = "INVALID_RECEIVING_NODE_ACCOUNT"] = 35, o[e2[36] = "MISSING_QUERY_HEADER"] = 36, o[e2[37] = "ACCOUNT_UPDATE_FAILED"] = 37, o[e2[38] = "INVALID_KEY_ENCODING"] = 38, o[e2[39] = "NULL_SOLIDITY_ADDRESS"] = 39, o[e2[40] = "CONTRACT_UPDATE_FAILED"] = 40, o[e2[41] = "INVALID_QUERY_HEADER"] = 41, o[e2[42] = "INVALID_FEE_SUBMITTED"] = 42, o[e2[43] = "INVALID_PAYER_SIGNATURE"] = 43, o[e2[44] = "KEY_NOT_PROVIDED"] = 44, o[e2[45] = "INVALID_EXPIRATION_TIME"] = 45, o[e2[46] = "NO_WACL_KEY"] = 46, o[e2[47] = "FILE_CONTENT_EMPTY"] = 47, o[e2[48] = "INVALID_ACCOUNT_AMOUNTS"] = 48, o[e2[49] = "EMPTY_TRANSACTION_BODY"] = 49, o[e2[50] = "INVALID_TRANSACTION_BODY"] = 50, o[e2[51] = "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"] = 51, o[e2[52] = "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"] = 52, o[e2[53] = "EMPTY_LIVE_HASH_BODY"] = 53, o[e2[54] = "EMPTY_LIVE_HASH"] = 54, o[e2[55] = "EMPTY_LIVE_HASH_KEYS"] = 55, o[e2[56] = "INVALID_LIVE_HASH_SIZE"] = 56, o[e2[57] = "EMPTY_QUERY_BODY"] = 57, o[e2[58] = "EMPTY_LIVE_HASH_QUERY"] = 58, o[e2[59] = "LIVE_HASH_NOT_FOUND"] = 59, o[e2[60] = "ACCOUNT_ID_DOES_NOT_EXIST"] = 60, o[e2[61] = "LIVE_HASH_ALREADY_EXISTS"] = 61, o[e2[62] = "INVALID_FILE_WACL"] = 62, o[e2[63] = "SERIALIZATION_FAILED"] = 63, o[e2[64] = "TRANSACTION_OVERSIZE"] = 64, o[e2[65] = "TRANSACTION_TOO_MANY_LAYERS"] = 65, o[e2[66] = "CONTRACT_DELETED"] = 66, o[e2[67] = "PLATFORM_NOT_ACTIVE"] = 67, o[e2[68] = "KEY_PREFIX_MISMATCH"] = 68, o[e2[69] = "PLATFORM_TRANSACTION_NOT_CREATED"] = 69, o[e2[70] = "INVALID_RENEWAL_PERIOD"] = 70, o[e2[71] = "INVALID_PAYER_ACCOUNT_ID"] = 71, o[e2[72] = "ACCOUNT_DELETED"] = 72, o[e2[73] = "FILE_DELETED"] = 73, o[e2[74] = "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"] = 74, o[e2[75] = "SETTING_NEGATIVE_ACCOUNT_BALANCE"] = 75, o[e2[76] = "OBTAINER_REQUIRED"] = 76, o[e2[77] = "OBTAINER_SAME_CONTRACT_ID"] = 77, o[e2[78] = "OBTAINER_DOES_NOT_EXIST"] = 78, o[e2[79] = "MODIFYING_IMMUTABLE_CONTRACT"] = 79, o[e2[80] = "FILE_SYSTEM_EXCEPTION"] = 80, o[e2[81] = "AUTORENEW_DURATION_NOT_IN_RANGE"] = 81, o[e2[82] = "ERROR_DECODING_BYTESTRING"] = 82, o[e2[83] = "CONTRACT_FILE_EMPTY"] = 83, o[e2[84] = "CONTRACT_BYTECODE_EMPTY"] = 84, o[e2[85] = "INVALID_INITIAL_BALANCE"] = 85, o[e2[86] = "INVALID_RECEIVE_RECORD_THRESHOLD"] = 86, o[e2[87] = "INVALID_SEND_RECORD_THRESHOLD"] = 87, o[e2[88] = "ACCOUNT_IS_NOT_GENESIS_ACCOUNT"] = 88, o[e2[89] = "PAYER_ACCOUNT_UNAUTHORIZED"] = 89, o[e2[90] = "INVALID_FREEZE_TRANSACTION_BODY"] = 90, o[e2[91] = "FREEZE_TRANSACTION_BODY_NOT_FOUND"] = 91, o[e2[92] = "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 92, o[e2[93] = "RESULT_SIZE_LIMIT_EXCEEDED"] = 93, o[e2[94] = "NOT_SPECIAL_ACCOUNT"] = 94, o[e2[95] = "CONTRACT_NEGATIVE_GAS"] = 95, o[e2[96] = "CONTRACT_NEGATIVE_VALUE"] = 96, o[e2[97] = "INVALID_FEE_FILE"] = 97, o[e2[98] = "INVALID_EXCHANGE_RATE_FILE"] = 98, o[e2[99] = "INSUFFICIENT_LOCAL_CALL_GAS"] = 99, o[e2[100] = "ENTITY_NOT_ALLOWED_TO_DELETE"] = 100, o[e2[101] = "AUTHORIZATION_FAILED"] = 101, o[e2[102] = "FILE_UPLOADED_PROTO_INVALID"] = 102, o[e2[103] = "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"] = 103, o[e2[104] = "FEE_SCHEDULE_FILE_PART_UPLOADED"] = 104, o[e2[105] = "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"] = 105, o[e2[106] = "MAX_CONTRACT_STORAGE_EXCEEDED"] = 106, o[e2[107] = "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"] = 107, o[e2[108] = "TOTAL_LEDGER_BALANCE_INVALID"] = 108, o[e2[110] = "EXPIRATION_REDUCTION_NOT_ALLOWED"] = 110, o[e2[111] = "MAX_GAS_LIMIT_EXCEEDED"] = 111, o[e2[112] = "MAX_FILE_SIZE_EXCEEDED"] = 112, o[e2[113] = "RECEIVER_SIG_REQUIRED"] = 113, o[e2[150] = "INVALID_TOPIC_ID"] = 150, o[e2[155] = "INVALID_ADMIN_KEY"] = 155, o[e2[156] = "INVALID_SUBMIT_KEY"] = 156, o[e2[157] = "UNAUTHORIZED"] = 157, o[e2[158] = "INVALID_TOPIC_MESSAGE"] = 158, o[e2[159] = "INVALID_AUTORENEW_ACCOUNT"] = 159, o[e2[160] = "AUTORENEW_ACCOUNT_NOT_ALLOWED"] = 160, o[e2[162] = "TOPIC_EXPIRED"] = 162, o[e2[163] = "INVALID_CHUNK_NUMBER"] = 163, o[e2[164] = "INVALID_CHUNK_TRANSACTION_ID"] = 164, o[e2[165] = "ACCOUNT_FROZEN_FOR_TOKEN"] = 165, o[e2[166] = "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"] = 166, o[e2[167] = "INVALID_TOKEN_ID"] = 167, o[e2[168] = "INVALID_TOKEN_DECIMALS"] = 168, o[e2[169] = "INVALID_TOKEN_INITIAL_SUPPLY"] = 169, o[e2[170] = "INVALID_TREASURY_ACCOUNT_FOR_TOKEN"] = 170, o[e2[171] = "INVALID_TOKEN_SYMBOL"] = 171, o[e2[172] = "TOKEN_HAS_NO_FREEZE_KEY"] = 172, o[e2[173] = "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"] = 173, o[e2[174] = "MISSING_TOKEN_SYMBOL"] = 174, o[e2[175] = "TOKEN_SYMBOL_TOO_LONG"] = 175, o[e2[176] = "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"] = 176, o[e2[177] = "TOKEN_HAS_NO_KYC_KEY"] = 177, o[e2[178] = "INSUFFICIENT_TOKEN_BALANCE"] = 178, o[e2[179] = "TOKEN_WAS_DELETED"] = 179, o[e2[180] = "TOKEN_HAS_NO_SUPPLY_KEY"] = 180, o[e2[181] = "TOKEN_HAS_NO_WIPE_KEY"] = 181, o[e2[182] = "INVALID_TOKEN_MINT_AMOUNT"] = 182, o[e2[183] = "INVALID_TOKEN_BURN_AMOUNT"] = 183, o[e2[184] = "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"] = 184, o[e2[185] = "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"] = 185, o[e2[186] = "INVALID_KYC_KEY"] = 186, o[e2[187] = "INVALID_WIPE_KEY"] = 187, o[e2[188] = "INVALID_FREEZE_KEY"] = 188, o[e2[189] = "INVALID_SUPPLY_KEY"] = 189, o[e2[190] = "MISSING_TOKEN_NAME"] = 190, o[e2[191] = "TOKEN_NAME_TOO_LONG"] = 191, o[e2[192] = "INVALID_WIPING_AMOUNT"] = 192, o[e2[193] = "TOKEN_IS_IMMUTABLE"] = 193, o[e2[194] = "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"] = 194, o[e2[195] = "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"] = 195, o[e2[196] = "ACCOUNT_IS_TREASURY"] = 196, o[e2[197] = "TOKEN_ID_REPEATED_IN_TOKEN_LIST"] = 197, o[e2[198] = "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 198, o[e2[199] = "EMPTY_TOKEN_TRANSFER_BODY"] = 199, o[e2[200] = "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"] = 200, o[e2[201] = "INVALID_SCHEDULE_ID"] = 201, o[e2[202] = "SCHEDULE_IS_IMMUTABLE"] = 202, o[e2[203] = "INVALID_SCHEDULE_PAYER_ID"] = 203, o[e2[204] = "INVALID_SCHEDULE_ACCOUNT_ID"] = 204, o[e2[205] = "NO_NEW_VALID_SIGNATURES"] = 205, o[e2[206] = "UNRESOLVABLE_REQUIRED_SIGNERS"] = 206, o[e2[207] = "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"] = 207, o[e2[208] = "SOME_SIGNATURES_WERE_INVALID"] = 208, o[e2[209] = "TRANSACTION_ID_FIELD_NOT_ALLOWED"] = 209, o[e2[210] = "IDENTICAL_SCHEDULE_ALREADY_CREATED"] = 210, o[e2[211] = "INVALID_ZERO_BYTE_IN_STRING"] = 211, o[e2[212] = "SCHEDULE_ALREADY_DELETED"] = 212, o[e2[213] = "SCHEDULE_ALREADY_EXECUTED"] = 213, o[e2[214] = "MESSAGE_SIZE_TOO_LARGE"] = 214, o[e2[215] = "OPERATION_REPEATED_IN_BUCKET_GROUPS"] = 215, o[e2[216] = "BUCKET_CAPACITY_OVERFLOW"] = 216, o[e2[217] = "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"] = 217, o[e2[218] = "BUCKET_HAS_NO_THROTTLE_GROUPS"] = 218, o[e2[219] = "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"] = 219, o[e2[220] = "SUCCESS_BUT_MISSING_EXPECTED_OPERATION"] = 220, o[e2[221] = "UNPARSEABLE_THROTTLE_DEFINITIONS"] = 221, o[e2[222] = "INVALID_THROTTLE_DEFINITIONS"] = 222, o[e2[223] = "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"] = 223, o[e2[224] = "INVALID_TOKEN_MAX_SUPPLY"] = 224, o[e2[225] = "INVALID_TOKEN_NFT_SERIAL_NUMBER"] = 225, o[e2[226] = "INVALID_NFT_ID"] = 226, o[e2[227] = "METADATA_TOO_LONG"] = 227, o[e2[228] = "BATCH_SIZE_LIMIT_EXCEEDED"] = 228, o[e2[229] = "INVALID_QUERY_RANGE"] = 229, o[e2[230] = "FRACTION_DIVIDES_BY_ZERO"] = 230, o[e2[231] = "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"] = 231, o[e2[232] = "CUSTOM_FEES_LIST_TOO_LONG"] = 232, o[e2[233] = "INVALID_CUSTOM_FEE_COLLECTOR"] = 233, o[e2[234] = "INVALID_TOKEN_ID_IN_CUSTOM_FEES"] = 234, o[e2[235] = "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"] = 235, o[e2[236] = "TOKEN_MAX_SUPPLY_REACHED"] = 236, o[e2[237] = "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"] = 237, o[e2[238] = "CUSTOM_FEE_NOT_FULLY_SPECIFIED"] = 238, o[e2[239] = "CUSTOM_FEE_MUST_BE_POSITIVE"] = 239, o[e2[240] = "TOKEN_HAS_NO_FEE_SCHEDULE_KEY"] = 240, o[e2[241] = "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"] = 241, o[e2[242] = "ROYALTY_FRACTION_CANNOT_EXCEED_ONE"] = 242, o[e2[243] = "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"] = 243, o[e2[244] = "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"] = 244, o[e2[245] = "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"] = 245, o[e2[246] = "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 246, o[e2[247] = "INVALID_CUSTOM_FEE_SCHEDULE_KEY"] = 247, o[e2[248] = "INVALID_TOKEN_MINT_METADATA"] = 248, o[e2[249] = "INVALID_TOKEN_BURN_METADATA"] = 249, o[e2[250] = "CURRENT_TREASURY_STILL_OWNS_NFTS"] = 250, o[e2[251] = "ACCOUNT_STILL_OWNS_NFTS"] = 251, o[e2[252] = "TREASURY_MUST_OWN_BURNED_NFT"] = 252, o[e2[253] = "ACCOUNT_DOES_NOT_OWN_WIPED_NFT"] = 253, o[e2[254] = "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 254, o[e2[255] = "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"] = 255, o[e2[256] = "PAYER_ACCOUNT_DELETED"] = 256, o[e2[257] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"] = 257, o[e2[258] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"] = 258, o[e2[259] = "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"] = 259, o[e2[260] = "SERIAL_NUMBER_LIMIT_REACHED"] = 260, o[e2[261] = "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"] = 261, o[e2[262] = "NO_REMAINING_AUTOMATIC_ASSOCIATIONS"] = 262, o[e2[263] = "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT"] = 263, o[e2[264] = "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT"] = 264, o[e2[265] = "TOKEN_IS_PAUSED"] = 265, o[e2[266] = "TOKEN_HAS_NO_PAUSE_KEY"] = 266, o[e2[267] = "INVALID_PAUSE_KEY"] = 267, o[e2[268] = "FREEZE_UPDATE_FILE_DOES_NOT_EXIST"] = 268, o[e2[269] = "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH"] = 269, o[e2[270] = "NO_UPGRADE_HAS_BEEN_PREPARED"] = 270, o[e2[271] = "NO_FREEZE_IS_SCHEDULED"] = 271, o[e2[272] = "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE"] = 272, o[e2[273] = "FREEZE_START_TIME_MUST_BE_FUTURE"] = 273, o[e2[274] = "PREPARED_UPDATE_FILE_IS_IMMUTABLE"] = 274, o[e2[275] = "FREEZE_ALREADY_SCHEDULED"] = 275, o[e2[276] = "FREEZE_UPGRADE_IN_PROGRESS"] = 276, o[e2[277] = "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED"] = 277, o[e2[278] = "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED"] = 278, o[e2[279] = "CONSENSUS_GAS_EXHAUSTED"] = 279, o[e2[280] = "REVERTED_SUCCESS"] = 280, o[e2[281] = "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED"] = 281, o[e2[282] = "INVALID_ALIAS_KEY"] = 282, o[e2[283] = "UNEXPECTED_TOKEN_DECIMALS"] = 283, o[e2[284] = "INVALID_PROXY_ACCOUNT_ID"] = 284, o[e2[285] = "INVALID_TRANSFER_ACCOUNT_ID"] = 285, o[e2[286] = "INVALID_FEE_COLLECTOR_ACCOUNT_ID"] = 286, o[e2[287] = "ALIAS_IS_IMMUTABLE"] = 287, o[e2[288] = "SPENDER_ACCOUNT_SAME_AS_OWNER"] = 288, o[e2[289] = "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY"] = 289, o[e2[290] = "NEGATIVE_ALLOWANCE_AMOUNT"] = 290, o[e2[291] = "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON"] = 291, o[e2[292] = "SPENDER_DOES_NOT_HAVE_ALLOWANCE"] = 292, o[e2[293] = "AMOUNT_EXCEEDS_ALLOWANCE"] = 293, o[e2[294] = "MAX_ALLOWANCES_EXCEEDED"] = 294, o[e2[295] = "EMPTY_ALLOWANCES"] = 295, o[e2[296] = "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES"] = 296, o[e2[297] = "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES"] = 297, o[e2[298] = "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES"] = 298, o[e2[299] = "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES"] = 299, o[e2[300] = "INVALID_ALLOWANCE_OWNER_ID"] = 300, o[e2[301] = "INVALID_ALLOWANCE_SPENDER_ID"] = 301, o[e2[302] = "REPEATED_ALLOWANCES_TO_DELETE"] = 302, o[e2[303] = "INVALID_DELEGATING_SPENDER"] = 303, o[e2[304] = "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL"] = 304, o[e2[305] = "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL"] = 305, o[e2[306] = "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE"] = 306, o[e2[307] = "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME"] = 307, o[e2[308] = "SCHEDULE_FUTURE_THROTTLE_EXCEEDED"] = 308, o[e2[309] = "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED"] = 309, o[e2[310] = "INVALID_ETHEREUM_TRANSACTION"] = 310, o[e2[311] = "WRONG_CHAIN_ID"] = 311, o[e2[312] = "WRONG_NONCE"] = 312, o[e2[313] = "ACCESS_LIST_UNSUPPORTED"] = 313, o[e2[314] = "SCHEDULE_PENDING_EXPIRATION"] = 314, o[e2[315] = "CONTRACT_IS_TOKEN_TREASURY"] = 315, o[e2[316] = "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES"] = 316, o[e2[317] = "CONTRACT_EXPIRED_AND_PENDING_REMOVAL"] = 317, o[e2[318] = "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT"] = 318, o[e2[319] = "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION"] = 319, o[e2[320] = "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED"] = 320, o[e2[321] = "SELF_STAKING_IS_NOT_ALLOWED"] = 321, o[e2[322] = "INVALID_STAKING_ID"] = 322, o[e2[323] = "STAKING_NOT_ENABLED"] = 323, o[e2[324] = "INVALID_PRNG_RANGE"] = 324, o[e2[325] = "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED"] = 325, o[e2[326] = "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE"] = 326, o[e2[327] = "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT"] = 327, o[e2[328] = "MAX_CHILD_RECORDS_EXCEEDED"] = 328, o[e2[329] = "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES"] = 329, o[e2[330] = "TRANSACTION_HAS_UNKNOWN_FIELDS"] = 330, o[e2[331] = "ACCOUNT_IS_IMMUTABLE"] = 331, o[e2[332] = "ALIAS_ALREADY_ASSIGNED"] = 332, o[e2[333] = "INVALID_METADATA_KEY"] = 333, o[e2[334] = "TOKEN_HAS_NO_METADATA_KEY"] = 334, o[e2[335] = "MISSING_TOKEN_METADATA"] = 335, o[e2[336] = "MISSING_SERIAL_NUMBERS"] = 336, o;
      }(), ConsensusTopicInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.memo = "", e2.prototype.runningHash = $util.newBuffer([]), e2.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.expirationTime = null, e2.prototype.adminKey = null, e2.prototype.submitKey = null, e2.prototype.autoRenewPeriod = null, e2.prototype.autoRenewAccount = null, e2.prototype.ledgerId = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o.uint32(10).string(e3.memo), null != e3.runningHash && Object.hasOwnProperty.call(e3, "runningHash") && o.uint32(18).bytes(e3.runningHash), null != e3.sequenceNumber && Object.hasOwnProperty.call(e3, "sequenceNumber") && o.uint32(24).uint64(e3.sequenceNumber), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(34).fork()).ldelim(), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(42).fork()).ldelim(), null != e3.submitKey && Object.hasOwnProperty.call(e3, "submitKey") && $root.proto.Key.encode(e3.submitKey, o.uint32(50).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(58).fork()).ldelim(), null != e3.autoRenewAccount && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(66).fork()).ldelim(), null != e3.ledgerId && Object.hasOwnProperty.call(e3, "ledgerId") && o.uint32(74).bytes(e3.ledgerId), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ConsensusTopicInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.memo = e3.string();
                break;
              }
              case 2: {
                i.runningHash = e3.bytes();
                break;
              }
              case 3: {
                i.sequenceNumber = e3.uint64();
                break;
              }
              case 4: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.submitKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.ledgerId = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ConsensusTopicInfo";
        }, e2;
      }(), ConsensusService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createTopic = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "createTopic" }), Object.defineProperty(e2.prototype.updateTopic = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "updateTopic" }), Object.defineProperty(e2.prototype.deleteTopic = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "deleteTopic" }), Object.defineProperty(e2.prototype.getTopicInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getTopicInfo" }), Object.defineProperty(e2.prototype.submitMessage = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "submitMessage" }), e2;
      }(), Query: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.getByKey = null, e2.prototype.getBySolidityID = null, e2.prototype.contractCallLocal = null, e2.prototype.contractGetInfo = null, e2.prototype.contractGetBytecode = null, e2.prototype.ContractGetRecords = null, e2.prototype.cryptogetAccountBalance = null, e2.prototype.cryptoGetAccountRecords = null, e2.prototype.cryptoGetInfo = null, e2.prototype.cryptoGetLiveHash = null, e2.prototype.cryptoGetProxyStakers = null, e2.prototype.fileGetContents = null, e2.prototype.fileGetInfo = null, e2.prototype.transactionGetReceipt = null, e2.prototype.transactionGetRecord = null, e2.prototype.transactionGetFastRecord = null, e2.prototype.consensusGetTopicInfo = null, e2.prototype.networkGetVersionInfo = null, e2.prototype.tokenGetInfo = null, e2.prototype.scheduleGetInfo = null, e2.prototype.tokenGetAccountNftInfos = null, e2.prototype.tokenGetNftInfo = null, e2.prototype.tokenGetNftInfos = null, e2.prototype.networkGetExecutionTime = null, e2.prototype.accountDetails = null;
        let o;
        return Object.defineProperty(e2.prototype, "query", { get: $util.oneOfGetter(o = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetInfo", "contractGetBytecode", "ContractGetRecords", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime", "accountDetails"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.getByKey && Object.hasOwnProperty.call(e3, "getByKey") && $root.proto.GetByKeyQuery.encode(e3.getByKey, o2.uint32(10).fork()).ldelim(), null != e3.getBySolidityID && Object.hasOwnProperty.call(e3, "getBySolidityID") && $root.proto.GetBySolidityIDQuery.encode(e3.getBySolidityID, o2.uint32(18).fork()).ldelim(), null != e3.contractCallLocal && Object.hasOwnProperty.call(e3, "contractCallLocal") && $root.proto.ContractCallLocalQuery.encode(e3.contractCallLocal, o2.uint32(26).fork()).ldelim(), null != e3.contractGetInfo && Object.hasOwnProperty.call(e3, "contractGetInfo") && $root.proto.ContractGetInfoQuery.encode(e3.contractGetInfo, o2.uint32(34).fork()).ldelim(), null != e3.contractGetBytecode && Object.hasOwnProperty.call(e3, "contractGetBytecode") && $root.proto.ContractGetBytecodeQuery.encode(e3.contractGetBytecode, o2.uint32(42).fork()).ldelim(), null != e3.ContractGetRecords && Object.hasOwnProperty.call(e3, "ContractGetRecords") && $root.proto.ContractGetRecordsQuery.encode(e3.ContractGetRecords, o2.uint32(50).fork()).ldelim(), null != e3.cryptogetAccountBalance && Object.hasOwnProperty.call(e3, "cryptogetAccountBalance") && $root.proto.CryptoGetAccountBalanceQuery.encode(e3.cryptogetAccountBalance, o2.uint32(58).fork()).ldelim(), null != e3.cryptoGetAccountRecords && Object.hasOwnProperty.call(e3, "cryptoGetAccountRecords") && $root.proto.CryptoGetAccountRecordsQuery.encode(e3.cryptoGetAccountRecords, o2.uint32(66).fork()).ldelim(), null != e3.cryptoGetInfo && Object.hasOwnProperty.call(e3, "cryptoGetInfo") && $root.proto.CryptoGetInfoQuery.encode(e3.cryptoGetInfo, o2.uint32(74).fork()).ldelim(), null != e3.cryptoGetLiveHash && Object.hasOwnProperty.call(e3, "cryptoGetLiveHash") && $root.proto.CryptoGetLiveHashQuery.encode(e3.cryptoGetLiveHash, o2.uint32(82).fork()).ldelim(), null != e3.cryptoGetProxyStakers && Object.hasOwnProperty.call(e3, "cryptoGetProxyStakers") && $root.proto.CryptoGetStakersQuery.encode(e3.cryptoGetProxyStakers, o2.uint32(90).fork()).ldelim(), null != e3.fileGetContents && Object.hasOwnProperty.call(e3, "fileGetContents") && $root.proto.FileGetContentsQuery.encode(e3.fileGetContents, o2.uint32(98).fork()).ldelim(), null != e3.fileGetInfo && Object.hasOwnProperty.call(e3, "fileGetInfo") && $root.proto.FileGetInfoQuery.encode(e3.fileGetInfo, o2.uint32(106).fork()).ldelim(), null != e3.transactionGetReceipt && Object.hasOwnProperty.call(e3, "transactionGetReceipt") && $root.proto.TransactionGetReceiptQuery.encode(e3.transactionGetReceipt, o2.uint32(114).fork()).ldelim(), null != e3.transactionGetRecord && Object.hasOwnProperty.call(e3, "transactionGetRecord") && $root.proto.TransactionGetRecordQuery.encode(e3.transactionGetRecord, o2.uint32(122).fork()).ldelim(), null != e3.transactionGetFastRecord && Object.hasOwnProperty.call(e3, "transactionGetFastRecord") && $root.proto.TransactionGetFastRecordQuery.encode(e3.transactionGetFastRecord, o2.uint32(130).fork()).ldelim(), null != e3.consensusGetTopicInfo && Object.hasOwnProperty.call(e3, "consensusGetTopicInfo") && $root.proto.ConsensusGetTopicInfoQuery.encode(e3.consensusGetTopicInfo, o2.uint32(402).fork()).ldelim(), null != e3.networkGetVersionInfo && Object.hasOwnProperty.call(e3, "networkGetVersionInfo") && $root.proto.NetworkGetVersionInfoQuery.encode(e3.networkGetVersionInfo, o2.uint32(410).fork()).ldelim(), null != e3.tokenGetInfo && Object.hasOwnProperty.call(e3, "tokenGetInfo") && $root.proto.TokenGetInfoQuery.encode(e3.tokenGetInfo, o2.uint32(418).fork()).ldelim(), null != e3.scheduleGetInfo && Object.hasOwnProperty.call(e3, "scheduleGetInfo") && $root.proto.ScheduleGetInfoQuery.encode(e3.scheduleGetInfo, o2.uint32(426).fork()).ldelim(), null != e3.tokenGetAccountNftInfos && Object.hasOwnProperty.call(e3, "tokenGetAccountNftInfos") && $root.proto.TokenGetAccountNftInfosQuery.encode(e3.tokenGetAccountNftInfos, o2.uint32(434).fork()).ldelim(), null != e3.tokenGetNftInfo && Object.hasOwnProperty.call(e3, "tokenGetNftInfo") && $root.proto.TokenGetNftInfoQuery.encode(e3.tokenGetNftInfo, o2.uint32(442).fork()).ldelim(), null != e3.tokenGetNftInfos && Object.hasOwnProperty.call(e3, "tokenGetNftInfos") && $root.proto.TokenGetNftInfosQuery.encode(e3.tokenGetNftInfos, o2.uint32(450).fork()).ldelim(), null != e3.networkGetExecutionTime && Object.hasOwnProperty.call(e3, "networkGetExecutionTime") && $root.proto.NetworkGetExecutionTimeQuery.encode(e3.networkGetExecutionTime, o2.uint32(458).fork()).ldelim(), null != e3.accountDetails && Object.hasOwnProperty.call(e3, "accountDetails") && $root.proto.GetAccountDetailsQuery.encode(e3.accountDetails, o2.uint32(466).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.Query(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.getByKey = $root.proto.GetByKeyQuery.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.getBySolidityID = $root.proto.GetBySolidityIDQuery.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.contractCallLocal = $root.proto.ContractCallLocalQuery.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contractGetInfo = $root.proto.ContractGetInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.ContractGetRecords = $root.proto.ContractGetRecordsQuery.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.fileGetContents = $root.proto.FileGetContentsQuery.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.fileGetInfo = $root.proto.FileGetInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.decode(e3, e3.uint32());
                break;
              }
              case 15: {
                i.transactionGetRecord = $root.proto.TransactionGetRecordQuery.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.decode(e3, e3.uint32());
                break;
              }
              case 50: {
                i.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 51: {
                i.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 52: {
                i.tokenGetInfo = $root.proto.TokenGetInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 53: {
                i.scheduleGetInfo = $root.proto.ScheduleGetInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 54: {
                i.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosQuery.decode(e3, e3.uint32());
                break;
              }
              case 55: {
                i.tokenGetNftInfo = $root.proto.TokenGetNftInfoQuery.decode(e3, e3.uint32());
                break;
              }
              case 56: {
                i.tokenGetNftInfos = $root.proto.TokenGetNftInfosQuery.decode(e3, e3.uint32());
                break;
              }
              case 57: {
                i.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeQuery.decode(e3, e3.uint32());
                break;
              }
              case 58: {
                i.accountDetails = $root.proto.GetAccountDetailsQuery.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Query";
        }, e2;
      }(), GetByKeyQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.key = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.key && Object.hasOwnProperty.call(e3, "key") && $root.proto.Key.encode(e3.key, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GetByKeyQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.key = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GetByKeyQuery";
        }, e2;
      }(), EntityID: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.accountID = null, e2.prototype.liveHash = null, e2.prototype.fileID = null, e2.prototype.contractID = null;
        let o;
        return Object.defineProperty(e2.prototype, "entity", { get: $util.oneOfGetter(o = ["accountID", "liveHash", "fileID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o2.uint32(10).fork()).ldelim(), null != e3.liveHash && Object.hasOwnProperty.call(e3, "liveHash") && $root.proto.LiveHash.encode(e3.liveHash, o2.uint32(18).fork()).ldelim(), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(26).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(34).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.EntityID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.liveHash = $root.proto.LiveHash.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.EntityID";
        }, e2;
      }(), GetByKeyResponse: function() {
        function e2(e3) {
          if (this.entities = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.entities = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.entities && e3.entities.length)
            for (var t = 0; t < e3.entities.length; ++t)
              $root.proto.EntityID.encode(e3.entities[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GetByKeyResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.entities && i.entities.length || (i.entities = []), i.entities.push($root.proto.EntityID.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GetByKeyResponse";
        }, e2;
      }(), GetBySolidityIDQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.solidityID = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.solidityID && Object.hasOwnProperty.call(e3, "solidityID") && o.uint32(18).string(e3.solidityID), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GetBySolidityIDQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.solidityID = e3.string();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GetBySolidityIDQuery";
        }, e2;
      }(), GetBySolidityIDResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.fileID = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(26).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(34).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GetBySolidityIDResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GetBySolidityIDResponse";
        }, e2;
      }(), ContractLoginfo: function() {
        function e2(e3) {
          if (this.topic = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractID = null, e2.prototype.bloom = $util.newBuffer([]), e2.prototype.topic = $util.emptyArray, e2.prototype.data = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(10).fork()).ldelim(), null != e3.bloom && Object.hasOwnProperty.call(e3, "bloom") && o.uint32(18).bytes(e3.bloom), null != e3.topic && e3.topic.length)
            for (var t = 0; t < e3.topic.length; ++t)
              o.uint32(26).bytes(e3.topic[t]);
          return null != e3.data && Object.hasOwnProperty.call(e3, "data") && o.uint32(34).bytes(e3.data), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractLoginfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.bloom = e3.bytes();
                break;
              }
              case 3: {
                i.topic && i.topic.length || (i.topic = []), i.topic.push(e3.bytes());
                break;
              }
              case 4: {
                i.data = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractLoginfo";
        }, e2;
      }(), ContractFunctionResult: function() {
        function e2(e3) {
          if (this.logInfo = [], this.createdContractIDs = [], this.contractNonces = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractID = null, e2.prototype.contractCallResult = $util.newBuffer([]), e2.prototype.errorMessage = "", e2.prototype.bloom = $util.newBuffer([]), e2.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.logInfo = $util.emptyArray, e2.prototype.createdContractIDs = $util.emptyArray, e2.prototype.evmAddress = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.functionParameters = $util.newBuffer([]), e2.prototype.senderId = null, e2.prototype.contractNonces = $util.emptyArray, e2.prototype.signerNonce = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(10).fork()).ldelim(), null != e3.contractCallResult && Object.hasOwnProperty.call(e3, "contractCallResult") && o.uint32(18).bytes(e3.contractCallResult), null != e3.errorMessage && Object.hasOwnProperty.call(e3, "errorMessage") && o.uint32(26).string(e3.errorMessage), null != e3.bloom && Object.hasOwnProperty.call(e3, "bloom") && o.uint32(34).bytes(e3.bloom), null != e3.gasUsed && Object.hasOwnProperty.call(e3, "gasUsed") && o.uint32(40).uint64(e3.gasUsed), null != e3.logInfo && e3.logInfo.length)
            for (var t = 0; t < e3.logInfo.length; ++t)
              $root.proto.ContractLoginfo.encode(e3.logInfo[t], o.uint32(50).fork()).ldelim();
          if (null != e3.createdContractIDs && e3.createdContractIDs.length)
            for (var t = 0; t < e3.createdContractIDs.length; ++t)
              $root.proto.ContractID.encode(e3.createdContractIDs[t], o.uint32(58).fork()).ldelim();
          if (null != e3.evmAddress && Object.hasOwnProperty.call(e3, "evmAddress") && $root.google.protobuf.BytesValue.encode(e3.evmAddress, o.uint32(74).fork()).ldelim(), null != e3.gas && Object.hasOwnProperty.call(e3, "gas") && o.uint32(80).int64(e3.gas), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(88).int64(e3.amount), null != e3.functionParameters && Object.hasOwnProperty.call(e3, "functionParameters") && o.uint32(98).bytes(e3.functionParameters), null != e3.senderId && Object.hasOwnProperty.call(e3, "senderId") && $root.proto.AccountID.encode(e3.senderId, o.uint32(106).fork()).ldelim(), null != e3.contractNonces && e3.contractNonces.length)
            for (var t = 0; t < e3.contractNonces.length; ++t)
              $root.proto.ContractNonceInfo.encode(e3.contractNonces[t], o.uint32(114).fork()).ldelim();
          return null != e3.signerNonce && Object.hasOwnProperty.call(e3, "signerNonce") && $root.google.protobuf.Int64Value.encode(e3.signerNonce, o.uint32(122).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractFunctionResult(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractCallResult = e3.bytes();
                break;
              }
              case 3: {
                i.errorMessage = e3.string();
                break;
              }
              case 4: {
                i.bloom = e3.bytes();
                break;
              }
              case 5: {
                i.gasUsed = e3.uint64();
                break;
              }
              case 6: {
                i.logInfo && i.logInfo.length || (i.logInfo = []), i.logInfo.push($root.proto.ContractLoginfo.decode(e3, e3.uint32()));
                break;
              }
              case 7: {
                i.createdContractIDs && i.createdContractIDs.length || (i.createdContractIDs = []), i.createdContractIDs.push($root.proto.ContractID.decode(e3, e3.uint32()));
                break;
              }
              case 9: {
                i.evmAddress = $root.google.protobuf.BytesValue.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.gas = e3.int64();
                break;
              }
              case 11: {
                i.amount = e3.int64();
                break;
              }
              case 12: {
                i.functionParameters = e3.bytes();
                break;
              }
              case 13: {
                i.senderId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.contractNonces && i.contractNonces.length || (i.contractNonces = []), i.contractNonces.push($root.proto.ContractNonceInfo.decode(e3, e3.uint32()));
                break;
              }
              case 15: {
                i.signerNonce = $root.google.protobuf.Int64Value.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractFunctionResult";
        }, e2;
      }(), ContractCallLocalQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.functionParameters = $util.newBuffer([]), e2.prototype.maxResultSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.senderId = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), null != e3.gas && Object.hasOwnProperty.call(e3, "gas") && o.uint32(24).int64(e3.gas), null != e3.functionParameters && Object.hasOwnProperty.call(e3, "functionParameters") && o.uint32(34).bytes(e3.functionParameters), null != e3.maxResultSize && Object.hasOwnProperty.call(e3, "maxResultSize") && o.uint32(40).int64(e3.maxResultSize), null != e3.senderId && Object.hasOwnProperty.call(e3, "senderId") && $root.proto.AccountID.encode(e3.senderId, o.uint32(50).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractCallLocalQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.gas = e3.int64();
                break;
              }
              case 4: {
                i.functionParameters = e3.bytes();
                break;
              }
              case 5: {
                i.maxResultSize = e3.int64();
                break;
              }
              case 6: {
                i.senderId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractCallLocalQuery";
        }, e2;
      }(), ContractCallLocalResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.functionResult = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.functionResult && Object.hasOwnProperty.call(e3, "functionResult") && $root.proto.ContractFunctionResult.encode(e3.functionResult, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractCallLocalResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.functionResult = $root.proto.ContractFunctionResult.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractCallLocalResponse";
        }, e2;
      }(), ContractNonceInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractId = null, e2.prototype.nonce = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.contractId && Object.hasOwnProperty.call(e3, "contractId") && $root.proto.ContractID.encode(e3.contractId, o.uint32(10).fork()).ldelim(), null != e3.nonce && Object.hasOwnProperty.call(e3, "nonce") && o.uint32(16).int64(e3.nonce), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractNonceInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractId = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nonce = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractNonceInfo";
        }, e2;
      }(), ContractGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractGetInfoQuery";
        }, e2;
      }(), ContractGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.contractInfo && Object.hasOwnProperty.call(e3, "contractInfo") && $root.proto.ContractGetInfoResponse.ContractInfo.encode(e3.contractInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractGetInfoResponse";
        }, e2.ContractInfo = function() {
          function e3(e4) {
            if (this.tokenRelationships = [], e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.contractID = null, e3.prototype.accountID = null, e3.prototype.contractAccountID = "", e3.prototype.adminKey = null, e3.prototype.expirationTime = null, e3.prototype.autoRenewPeriod = null, e3.prototype.storage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.memo = "", e3.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.deleted = false, e3.prototype.tokenRelationships = $util.emptyArray, e3.prototype.ledgerId = $util.newBuffer([]), e3.prototype.autoRenewAccountId = null, e3.prototype.maxAutomaticTokenAssociations = 0, e3.prototype.stakingInfo = null, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            if (o || (o = $Writer.create()), null != e4.contractID && Object.hasOwnProperty.call(e4, "contractID") && $root.proto.ContractID.encode(e4.contractID, o.uint32(10).fork()).ldelim(), null != e4.accountID && Object.hasOwnProperty.call(e4, "accountID") && $root.proto.AccountID.encode(e4.accountID, o.uint32(18).fork()).ldelim(), null != e4.contractAccountID && Object.hasOwnProperty.call(e4, "contractAccountID") && o.uint32(26).string(e4.contractAccountID), null != e4.adminKey && Object.hasOwnProperty.call(e4, "adminKey") && $root.proto.Key.encode(e4.adminKey, o.uint32(34).fork()).ldelim(), null != e4.expirationTime && Object.hasOwnProperty.call(e4, "expirationTime") && $root.proto.Timestamp.encode(e4.expirationTime, o.uint32(42).fork()).ldelim(), null != e4.autoRenewPeriod && Object.hasOwnProperty.call(e4, "autoRenewPeriod") && $root.proto.Duration.encode(e4.autoRenewPeriod, o.uint32(50).fork()).ldelim(), null != e4.storage && Object.hasOwnProperty.call(e4, "storage") && o.uint32(56).int64(e4.storage), null != e4.memo && Object.hasOwnProperty.call(e4, "memo") && o.uint32(66).string(e4.memo), null != e4.balance && Object.hasOwnProperty.call(e4, "balance") && o.uint32(72).uint64(e4.balance), null != e4.deleted && Object.hasOwnProperty.call(e4, "deleted") && o.uint32(80).bool(e4.deleted), null != e4.tokenRelationships && e4.tokenRelationships.length)
              for (var t = 0; t < e4.tokenRelationships.length; ++t)
                $root.proto.TokenRelationship.encode(e4.tokenRelationships[t], o.uint32(90).fork()).ldelim();
            return null != e4.ledgerId && Object.hasOwnProperty.call(e4, "ledgerId") && o.uint32(98).bytes(e4.ledgerId), null != e4.autoRenewAccountId && Object.hasOwnProperty.call(e4, "autoRenewAccountId") && $root.proto.AccountID.encode(e4.autoRenewAccountId, o.uint32(106).fork()).ldelim(), null != e4.maxAutomaticTokenAssociations && Object.hasOwnProperty.call(e4, "maxAutomaticTokenAssociations") && o.uint32(112).int32(e4.maxAutomaticTokenAssociations), null != e4.stakingInfo && Object.hasOwnProperty.call(e4, "stakingInfo") && $root.proto.StakingInfo.encode(e4.stakingInfo, o.uint32(122).fork()).ldelim(), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.proto.ContractGetInfoResponse.ContractInfo(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.contractID = $root.proto.ContractID.decode(e4, e4.uint32());
                  break;
                }
                case 2: {
                  i.accountID = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                }
                case 3: {
                  i.contractAccountID = e4.string();
                  break;
                }
                case 4: {
                  i.adminKey = $root.proto.Key.decode(e4, e4.uint32());
                  break;
                }
                case 5: {
                  i.expirationTime = $root.proto.Timestamp.decode(e4, e4.uint32());
                  break;
                }
                case 6: {
                  i.autoRenewPeriod = $root.proto.Duration.decode(e4, e4.uint32());
                  break;
                }
                case 7: {
                  i.storage = e4.int64();
                  break;
                }
                case 8: {
                  i.memo = e4.string();
                  break;
                }
                case 9: {
                  i.balance = e4.uint64();
                  break;
                }
                case 10: {
                  i.deleted = e4.bool();
                  break;
                }
                case 11: {
                  i.tokenRelationships && i.tokenRelationships.length || (i.tokenRelationships = []), i.tokenRelationships.push($root.proto.TokenRelationship.decode(e4, e4.uint32()));
                  break;
                }
                case 12: {
                  i.ledgerId = e4.bytes();
                  break;
                }
                case 13: {
                  i.autoRenewAccountId = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                }
                case 14: {
                  i.maxAutomaticTokenAssociations = e4.int32();
                  break;
                }
                case 15: {
                  i.stakingInfo = $root.proto.StakingInfo.decode(e4, e4.uint32());
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/proto.ContractGetInfoResponse.ContractInfo";
          }, e3;
        }(), e2;
      }(), ContractGetBytecodeQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractGetBytecodeQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractGetBytecodeQuery";
        }, e2;
      }(), ContractGetBytecodeResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.bytecode = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.bytecode && Object.hasOwnProperty.call(e3, "bytecode") && o.uint32(50).bytes(e3.bytecode), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractGetBytecodeResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.bytecode = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractGetBytecodeResponse";
        }, e2;
      }(), ContractGetRecordsQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractGetRecordsQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractGetRecordsQuery";
        }, e2;
      }(), ContractGetRecordsResponse: function() {
        function e2(e3) {
          if (this.records = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.prototype.records = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), null != e3.records && e3.records.length)
            for (var t = 0; t < e3.records.length; ++t)
              $root.proto.TransactionRecord.encode(e3.records[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractGetRecordsResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.records && i.records.length || (i.records = []), i.records.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractGetRecordsResponse";
        }, e2;
      }(), TransactionRecord: function() {
        function e2(e3) {
          if (this.tokenTransferLists = [], this.assessedCustomFees = [], this.automaticTokenAssociations = [], this.paidStakingRewards = [], e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.receipt = null, e2.prototype.transactionHash = $util.newBuffer([]), e2.prototype.consensusTimestamp = null, e2.prototype.transactionID = null, e2.prototype.memo = "", e2.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.contractCallResult = null, e2.prototype.contractCreateResult = null, e2.prototype.transferList = null, e2.prototype.tokenTransferLists = $util.emptyArray, e2.prototype.scheduleRef = null, e2.prototype.assessedCustomFees = $util.emptyArray, e2.prototype.automaticTokenAssociations = $util.emptyArray, e2.prototype.parentConsensusTimestamp = null, e2.prototype.alias = $util.newBuffer([]), e2.prototype.ethereumHash = $util.newBuffer([]), e2.prototype.paidStakingRewards = $util.emptyArray, e2.prototype.prngBytes = null, e2.prototype.prngNumber = null, e2.prototype.evmAddress = $util.newBuffer([]);
        let o;
        return Object.defineProperty(e2.prototype, "body", { get: $util.oneOfGetter(o = ["contractCallResult", "contractCreateResult"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "entropy", { get: $util.oneOfGetter(o = ["prngBytes", "prngNumber"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          if (o2 || (o2 = $Writer.create()), null != e3.receipt && Object.hasOwnProperty.call(e3, "receipt") && $root.proto.TransactionReceipt.encode(e3.receipt, o2.uint32(10).fork()).ldelim(), null != e3.transactionHash && Object.hasOwnProperty.call(e3, "transactionHash") && o2.uint32(18).bytes(e3.transactionHash), null != e3.consensusTimestamp && Object.hasOwnProperty.call(e3, "consensusTimestamp") && $root.proto.Timestamp.encode(e3.consensusTimestamp, o2.uint32(26).fork()).ldelim(), null != e3.transactionID && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o2.uint32(34).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(42).string(e3.memo), null != e3.transactionFee && Object.hasOwnProperty.call(e3, "transactionFee") && o2.uint32(48).uint64(e3.transactionFee), null != e3.contractCallResult && Object.hasOwnProperty.call(e3, "contractCallResult") && $root.proto.ContractFunctionResult.encode(e3.contractCallResult, o2.uint32(58).fork()).ldelim(), null != e3.contractCreateResult && Object.hasOwnProperty.call(e3, "contractCreateResult") && $root.proto.ContractFunctionResult.encode(e3.contractCreateResult, o2.uint32(66).fork()).ldelim(), null != e3.transferList && Object.hasOwnProperty.call(e3, "transferList") && $root.proto.TransferList.encode(e3.transferList, o2.uint32(82).fork()).ldelim(), null != e3.tokenTransferLists && e3.tokenTransferLists.length)
            for (var t = 0; t < e3.tokenTransferLists.length; ++t)
              $root.proto.TokenTransferList.encode(e3.tokenTransferLists[t], o2.uint32(90).fork()).ldelim();
          if (null != e3.scheduleRef && Object.hasOwnProperty.call(e3, "scheduleRef") && $root.proto.ScheduleID.encode(e3.scheduleRef, o2.uint32(98).fork()).ldelim(), null != e3.assessedCustomFees && e3.assessedCustomFees.length)
            for (var t = 0; t < e3.assessedCustomFees.length; ++t)
              $root.proto.AssessedCustomFee.encode(e3.assessedCustomFees[t], o2.uint32(106).fork()).ldelim();
          if (null != e3.automaticTokenAssociations && e3.automaticTokenAssociations.length)
            for (var t = 0; t < e3.automaticTokenAssociations.length; ++t)
              $root.proto.TokenAssociation.encode(e3.automaticTokenAssociations[t], o2.uint32(114).fork()).ldelim();
          if (null != e3.parentConsensusTimestamp && Object.hasOwnProperty.call(e3, "parentConsensusTimestamp") && $root.proto.Timestamp.encode(e3.parentConsensusTimestamp, o2.uint32(122).fork()).ldelim(), null != e3.alias && Object.hasOwnProperty.call(e3, "alias") && o2.uint32(130).bytes(e3.alias), null != e3.ethereumHash && Object.hasOwnProperty.call(e3, "ethereumHash") && o2.uint32(138).bytes(e3.ethereumHash), null != e3.paidStakingRewards && e3.paidStakingRewards.length)
            for (var t = 0; t < e3.paidStakingRewards.length; ++t)
              $root.proto.AccountAmount.encode(e3.paidStakingRewards[t], o2.uint32(146).fork()).ldelim();
          return null != e3.prngBytes && Object.hasOwnProperty.call(e3, "prngBytes") && o2.uint32(154).bytes(e3.prngBytes), null != e3.prngNumber && Object.hasOwnProperty.call(e3, "prngNumber") && o2.uint32(160).int32(e3.prngNumber), null != e3.evmAddress && Object.hasOwnProperty.call(e3, "evmAddress") && o2.uint32(170).bytes(e3.evmAddress), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.TransactionRecord(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.receipt = $root.proto.TransactionReceipt.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transactionHash = e3.bytes();
                break;
              }
              case 3: {
                i.consensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.memo = e3.string();
                break;
              }
              case 6: {
                i.transactionFee = e3.uint64();
                break;
              }
              case 7: {
                i.contractCallResult = $root.proto.ContractFunctionResult.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.contractCreateResult = $root.proto.ContractFunctionResult.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.transferList = $root.proto.TransferList.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.tokenTransferLists && i.tokenTransferLists.length || (i.tokenTransferLists = []), i.tokenTransferLists.push($root.proto.TokenTransferList.decode(e3, e3.uint32()));
                break;
              }
              case 12: {
                i.scheduleRef = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.assessedCustomFees && i.assessedCustomFees.length || (i.assessedCustomFees = []), i.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(e3, e3.uint32()));
                break;
              }
              case 14: {
                i.automaticTokenAssociations && i.automaticTokenAssociations.length || (i.automaticTokenAssociations = []), i.automaticTokenAssociations.push($root.proto.TokenAssociation.decode(e3, e3.uint32()));
                break;
              }
              case 15: {
                i.parentConsensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.alias = e3.bytes();
                break;
              }
              case 17: {
                i.ethereumHash = e3.bytes();
                break;
              }
              case 18: {
                i.paidStakingRewards && i.paidStakingRewards.length || (i.paidStakingRewards = []), i.paidStakingRewards.push($root.proto.AccountAmount.decode(e3, e3.uint32()));
                break;
              }
              case 19: {
                i.prngBytes = e3.bytes();
                break;
              }
              case 20: {
                i.prngNumber = e3.int32();
                break;
              }
              case 21: {
                i.evmAddress = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionRecord";
        }, e2;
      }(), TransactionReceipt: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.status = 0, e2.prototype.accountID = null, e2.prototype.fileID = null, e2.prototype.contractID = null, e2.prototype.exchangeRate = null, e2.prototype.topicID = null, e2.prototype.topicSequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.topicRunningHash = $util.newBuffer([]), e2.prototype.topicRunningHashVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.tokenID = null, e2.prototype.newTotalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.scheduleID = null, e2.prototype.scheduledTransactionID = null, e2.prototype.serialNumbers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.status && Object.hasOwnProperty.call(e3, "status") && o.uint32(8).int32(e3.status), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(26).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(34).fork()).ldelim(), null != e3.exchangeRate && Object.hasOwnProperty.call(e3, "exchangeRate") && $root.proto.ExchangeRateSet.encode(e3.exchangeRate, o.uint32(42).fork()).ldelim(), null != e3.topicID && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(50).fork()).ldelim(), null != e3.topicSequenceNumber && Object.hasOwnProperty.call(e3, "topicSequenceNumber") && o.uint32(56).uint64(e3.topicSequenceNumber), null != e3.topicRunningHash && Object.hasOwnProperty.call(e3, "topicRunningHash") && o.uint32(66).bytes(e3.topicRunningHash), null != e3.topicRunningHashVersion && Object.hasOwnProperty.call(e3, "topicRunningHashVersion") && o.uint32(72).uint64(e3.topicRunningHashVersion), null != e3.tokenID && Object.hasOwnProperty.call(e3, "tokenID") && $root.proto.TokenID.encode(e3.tokenID, o.uint32(82).fork()).ldelim(), null != e3.newTotalSupply && Object.hasOwnProperty.call(e3, "newTotalSupply") && o.uint32(88).uint64(e3.newTotalSupply), null != e3.scheduleID && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(98).fork()).ldelim(), null != e3.scheduledTransactionID && Object.hasOwnProperty.call(e3, "scheduledTransactionID") && $root.proto.TransactionID.encode(e3.scheduledTransactionID, o.uint32(106).fork()).ldelim(), null != e3.serialNumbers && e3.serialNumbers.length) {
            o.uint32(114).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionReceipt(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.status = e3.int32();
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.exchangeRate = $root.proto.ExchangeRateSet.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.topicSequenceNumber = e3.uint64();
                break;
              }
              case 8: {
                i.topicRunningHash = e3.bytes();
                break;
              }
              case 9: {
                i.topicRunningHashVersion = e3.uint64();
                break;
              }
              case 10: {
                i.tokenID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.newTotalSupply = e3.uint64();
                break;
              }
              case 12: {
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.scheduledTransactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionReceipt";
        }, e2;
      }(), ExchangeRate: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.hbarEquiv = 0, e2.prototype.centEquiv = 0, e2.prototype.expirationTime = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.hbarEquiv && Object.hasOwnProperty.call(e3, "hbarEquiv") && o.uint32(8).int32(e3.hbarEquiv), null != e3.centEquiv && Object.hasOwnProperty.call(e3, "centEquiv") && o.uint32(16).int32(e3.centEquiv), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.TimestampSeconds.encode(e3.expirationTime, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ExchangeRate(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.hbarEquiv = e3.int32();
                break;
              }
              case 2: {
                i.centEquiv = e3.int32();
                break;
              }
              case 3: {
                i.expirationTime = $root.proto.TimestampSeconds.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ExchangeRate";
        }, e2;
      }(), ExchangeRateSet: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.currentRate = null, e2.prototype.nextRate = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.currentRate && Object.hasOwnProperty.call(e3, "currentRate") && $root.proto.ExchangeRate.encode(e3.currentRate, o.uint32(10).fork()).ldelim(), null != e3.nextRate && Object.hasOwnProperty.call(e3, "nextRate") && $root.proto.ExchangeRate.encode(e3.nextRate, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ExchangeRateSet(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.currentRate = $root.proto.ExchangeRate.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nextRate = $root.proto.ExchangeRate.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ExchangeRateSet";
        }, e2;
      }(), CryptoGetAccountBalanceQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.contractID = null;
        let o;
        return Object.defineProperty(e2.prototype, "balanceSource", { get: $util.oneOfGetter(o = ["accountID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o2.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o2.uint32(18).fork()).ldelim(), null != e3.contractID && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(26).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.CryptoGetAccountBalanceQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetAccountBalanceQuery";
        }, e2;
      }(), CryptoGetAccountBalanceResponse: function() {
        function e2(e3) {
          if (this.tokenBalances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.tokenBalances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.balance && Object.hasOwnProperty.call(e3, "balance") && o.uint32(24).uint64(e3.balance), null != e3.tokenBalances && e3.tokenBalances.length)
            for (var t = 0; t < e3.tokenBalances.length; ++t)
              $root.proto.TokenBalance.encode(e3.tokenBalances[t], o.uint32(34).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetAccountBalanceResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.balance = e3.uint64();
                break;
              }
              case 4: {
                i.tokenBalances && i.tokenBalances.length || (i.tokenBalances = []), i.tokenBalances.push($root.proto.TokenBalance.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetAccountBalanceResponse";
        }, e2;
      }(), CryptoGetAccountRecordsQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetAccountRecordsQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetAccountRecordsQuery";
        }, e2;
      }(), CryptoGetAccountRecordsResponse: function() {
        function e2(e3) {
          if (this.records = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.records = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.records && e3.records.length)
            for (var t = 0; t < e3.records.length; ++t)
              $root.proto.TransactionRecord.encode(e3.records[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetAccountRecordsResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.records && i.records.length || (i.records = []), i.records.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetAccountRecordsResponse";
        }, e2;
      }(), CryptoGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetInfoQuery";
        }, e2;
      }(), CryptoGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountInfo && Object.hasOwnProperty.call(e3, "accountInfo") && $root.proto.CryptoGetInfoResponse.AccountInfo.encode(e3.accountInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetInfoResponse";
        }, e2.AccountInfo = function() {
          function e3(e4) {
            if (this.liveHashes = [], this.tokenRelationships = [], e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.accountID = null, e3.prototype.contractAccountID = "", e3.prototype.deleted = false, e3.prototype.proxyAccountID = null, e3.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.key = null, e3.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.generateSendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.generateReceiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.receiverSigRequired = false, e3.prototype.expirationTime = null, e3.prototype.autoRenewPeriod = null, e3.prototype.liveHashes = $util.emptyArray, e3.prototype.tokenRelationships = $util.emptyArray, e3.prototype.memo = "", e3.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.maxAutomaticTokenAssociations = 0, e3.prototype.alias = $util.newBuffer([]), e3.prototype.ledgerId = $util.newBuffer([]), e3.prototype.ethereumNonce = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.stakingInfo = null, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            if (o || (o = $Writer.create()), null != e4.accountID && Object.hasOwnProperty.call(e4, "accountID") && $root.proto.AccountID.encode(e4.accountID, o.uint32(10).fork()).ldelim(), null != e4.contractAccountID && Object.hasOwnProperty.call(e4, "contractAccountID") && o.uint32(18).string(e4.contractAccountID), null != e4.deleted && Object.hasOwnProperty.call(e4, "deleted") && o.uint32(24).bool(e4.deleted), null != e4.proxyAccountID && Object.hasOwnProperty.call(e4, "proxyAccountID") && $root.proto.AccountID.encode(e4.proxyAccountID, o.uint32(34).fork()).ldelim(), null != e4.proxyReceived && Object.hasOwnProperty.call(e4, "proxyReceived") && o.uint32(48).int64(e4.proxyReceived), null != e4.key && Object.hasOwnProperty.call(e4, "key") && $root.proto.Key.encode(e4.key, o.uint32(58).fork()).ldelim(), null != e4.balance && Object.hasOwnProperty.call(e4, "balance") && o.uint32(64).uint64(e4.balance), null != e4.generateSendRecordThreshold && Object.hasOwnProperty.call(e4, "generateSendRecordThreshold") && o.uint32(72).uint64(e4.generateSendRecordThreshold), null != e4.generateReceiveRecordThreshold && Object.hasOwnProperty.call(e4, "generateReceiveRecordThreshold") && o.uint32(80).uint64(e4.generateReceiveRecordThreshold), null != e4.receiverSigRequired && Object.hasOwnProperty.call(e4, "receiverSigRequired") && o.uint32(88).bool(e4.receiverSigRequired), null != e4.expirationTime && Object.hasOwnProperty.call(e4, "expirationTime") && $root.proto.Timestamp.encode(e4.expirationTime, o.uint32(98).fork()).ldelim(), null != e4.autoRenewPeriod && Object.hasOwnProperty.call(e4, "autoRenewPeriod") && $root.proto.Duration.encode(e4.autoRenewPeriod, o.uint32(106).fork()).ldelim(), null != e4.liveHashes && e4.liveHashes.length)
              for (var t = 0; t < e4.liveHashes.length; ++t)
                $root.proto.LiveHash.encode(e4.liveHashes[t], o.uint32(114).fork()).ldelim();
            if (null != e4.tokenRelationships && e4.tokenRelationships.length)
              for (var t = 0; t < e4.tokenRelationships.length; ++t)
                $root.proto.TokenRelationship.encode(e4.tokenRelationships[t], o.uint32(122).fork()).ldelim();
            return null != e4.memo && Object.hasOwnProperty.call(e4, "memo") && o.uint32(130).string(e4.memo), null != e4.ownedNfts && Object.hasOwnProperty.call(e4, "ownedNfts") && o.uint32(136).int64(e4.ownedNfts), null != e4.maxAutomaticTokenAssociations && Object.hasOwnProperty.call(e4, "maxAutomaticTokenAssociations") && o.uint32(144).int32(e4.maxAutomaticTokenAssociations), null != e4.alias && Object.hasOwnProperty.call(e4, "alias") && o.uint32(154).bytes(e4.alias), null != e4.ledgerId && Object.hasOwnProperty.call(e4, "ledgerId") && o.uint32(162).bytes(e4.ledgerId), null != e4.ethereumNonce && Object.hasOwnProperty.call(e4, "ethereumNonce") && o.uint32(168).int64(e4.ethereumNonce), null != e4.stakingInfo && Object.hasOwnProperty.call(e4, "stakingInfo") && $root.proto.StakingInfo.encode(e4.stakingInfo, o.uint32(178).fork()).ldelim(), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.proto.CryptoGetInfoResponse.AccountInfo(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.accountID = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                }
                case 2: {
                  i.contractAccountID = e4.string();
                  break;
                }
                case 3: {
                  i.deleted = e4.bool();
                  break;
                }
                case 4: {
                  i.proxyAccountID = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                }
                case 6: {
                  i.proxyReceived = e4.int64();
                  break;
                }
                case 7: {
                  i.key = $root.proto.Key.decode(e4, e4.uint32());
                  break;
                }
                case 8: {
                  i.balance = e4.uint64();
                  break;
                }
                case 9: {
                  i.generateSendRecordThreshold = e4.uint64();
                  break;
                }
                case 10: {
                  i.generateReceiveRecordThreshold = e4.uint64();
                  break;
                }
                case 11: {
                  i.receiverSigRequired = e4.bool();
                  break;
                }
                case 12: {
                  i.expirationTime = $root.proto.Timestamp.decode(e4, e4.uint32());
                  break;
                }
                case 13: {
                  i.autoRenewPeriod = $root.proto.Duration.decode(e4, e4.uint32());
                  break;
                }
                case 14: {
                  i.liveHashes && i.liveHashes.length || (i.liveHashes = []), i.liveHashes.push($root.proto.LiveHash.decode(e4, e4.uint32()));
                  break;
                }
                case 15: {
                  i.tokenRelationships && i.tokenRelationships.length || (i.tokenRelationships = []), i.tokenRelationships.push($root.proto.TokenRelationship.decode(e4, e4.uint32()));
                  break;
                }
                case 16: {
                  i.memo = e4.string();
                  break;
                }
                case 17: {
                  i.ownedNfts = e4.int64();
                  break;
                }
                case 18: {
                  i.maxAutomaticTokenAssociations = e4.int32();
                  break;
                }
                case 19: {
                  i.alias = e4.bytes();
                  break;
                }
                case 20: {
                  i.ledgerId = e4.bytes();
                  break;
                }
                case 21: {
                  i.ethereumNonce = e4.int64();
                  break;
                }
                case 22: {
                  i.stakingInfo = $root.proto.StakingInfo.decode(e4, e4.uint32());
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/proto.CryptoGetInfoResponse.AccountInfo";
          }, e3;
        }(), e2;
      }(), CryptoGetLiveHashQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.hash = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.hash && Object.hasOwnProperty.call(e3, "hash") && o.uint32(26).bytes(e3.hash), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetLiveHashQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.hash = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetLiveHashQuery";
        }, e2;
      }(), CryptoGetLiveHashResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.liveHash = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.liveHash && Object.hasOwnProperty.call(e3, "liveHash") && $root.proto.LiveHash.encode(e3.liveHash, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetLiveHashResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.liveHash = $root.proto.LiveHash.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetLiveHashResponse";
        }, e2;
      }(), CryptoGetStakersQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetStakersQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetStakersQuery";
        }, e2;
      }(), ProxyStaker: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).int64(e3.amount), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ProxyStaker(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.amount = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ProxyStaker";
        }, e2;
      }(), AllProxyStakers: function() {
        function e2(e3) {
          if (this.proxyStaker = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.proxyStaker = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), null != e3.proxyStaker && e3.proxyStaker.length)
            for (var t = 0; t < e3.proxyStaker.length; ++t)
              $root.proto.ProxyStaker.encode(e3.proxyStaker[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.AllProxyStakers(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.proxyStaker && i.proxyStaker.length || (i.proxyStaker = []), i.proxyStaker.push($root.proto.ProxyStaker.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.AllProxyStakers";
        }, e2;
      }(), CryptoGetStakersResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.stakers = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.stakers && Object.hasOwnProperty.call(e3, "stakers") && $root.proto.AllProxyStakers.encode(e3.stakers, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetStakersResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.stakers = $root.proto.AllProxyStakers.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.CryptoGetStakersResponse";
        }, e2;
      }(), FileGetContentsQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileGetContentsQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileGetContentsQuery";
        }, e2;
      }(), FileGetContentsResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileContents = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.fileContents && Object.hasOwnProperty.call(e3, "fileContents") && $root.proto.FileGetContentsResponse.FileContents.encode(e3.fileContents, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileGetContentsResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.fileContents = $root.proto.FileGetContentsResponse.FileContents.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileGetContentsResponse";
        }, e2.FileContents = function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.fileID = null, e3.prototype.contents = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.fileID && Object.hasOwnProperty.call(e4, "fileID") && $root.proto.FileID.encode(e4.fileID, o.uint32(10).fork()).ldelim(), null != e4.contents && Object.hasOwnProperty.call(e4, "contents") && o.uint32(18).bytes(e4.contents), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.proto.FileGetContentsResponse.FileContents(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.fileID = $root.proto.FileID.decode(e4, e4.uint32());
                  break;
                }
                case 2: {
                  i.contents = e4.bytes();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/proto.FileGetContentsResponse.FileContents";
          }, e3;
        }(), e2;
      }(), FileGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.fileID && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileGetInfoQuery";
        }, e2;
      }(), FileGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.fileInfo && Object.hasOwnProperty.call(e3, "fileInfo") && $root.proto.FileGetInfoResponse.FileInfo.encode(e3.fileInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.FileGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.FileGetInfoResponse";
        }, e2.FileInfo = function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.fileID = null, e3.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.expirationTime = null, e3.prototype.deleted = false, e3.prototype.keys = null, e3.prototype.memo = "", e3.prototype.ledgerId = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.fileID && Object.hasOwnProperty.call(e4, "fileID") && $root.proto.FileID.encode(e4.fileID, o.uint32(10).fork()).ldelim(), null != e4.size && Object.hasOwnProperty.call(e4, "size") && o.uint32(16).int64(e4.size), null != e4.expirationTime && Object.hasOwnProperty.call(e4, "expirationTime") && $root.proto.Timestamp.encode(e4.expirationTime, o.uint32(26).fork()).ldelim(), null != e4.deleted && Object.hasOwnProperty.call(e4, "deleted") && o.uint32(32).bool(e4.deleted), null != e4.keys && Object.hasOwnProperty.call(e4, "keys") && $root.proto.KeyList.encode(e4.keys, o.uint32(42).fork()).ldelim(), null != e4.memo && Object.hasOwnProperty.call(e4, "memo") && o.uint32(50).string(e4.memo), null != e4.ledgerId && Object.hasOwnProperty.call(e4, "ledgerId") && o.uint32(58).bytes(e4.ledgerId), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.proto.FileGetInfoResponse.FileInfo(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.fileID = $root.proto.FileID.decode(e4, e4.uint32());
                  break;
                }
                case 2: {
                  i.size = e4.int64();
                  break;
                }
                case 3: {
                  i.expirationTime = $root.proto.Timestamp.decode(e4, e4.uint32());
                  break;
                }
                case 4: {
                  i.deleted = e4.bool();
                  break;
                }
                case 5: {
                  i.keys = $root.proto.KeyList.decode(e4, e4.uint32());
                  break;
                }
                case 6: {
                  i.memo = e4.string();
                  break;
                }
                case 7: {
                  i.ledgerId = e4.bytes();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/proto.FileGetInfoResponse.FileInfo";
          }, e3;
        }(), e2;
      }(), TransactionGetReceiptQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionID = null, e2.prototype.includeDuplicates = false, e2.prototype.includeChildReceipts = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.transactionID && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o.uint32(18).fork()).ldelim(), null != e3.includeDuplicates && Object.hasOwnProperty.call(e3, "includeDuplicates") && o.uint32(24).bool(e3.includeDuplicates), null != e3.includeChildReceipts && Object.hasOwnProperty.call(e3, "includeChildReceipts") && o.uint32(32).bool(e3.includeChildReceipts), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetReceiptQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.includeDuplicates = e3.bool();
                break;
              }
              case 4: {
                i.includeChildReceipts = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionGetReceiptQuery";
        }, e2;
      }(), TransactionGetReceiptResponse: function() {
        function e2(e3) {
          if (this.duplicateTransactionReceipts = [], this.childTransactionReceipts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.receipt = null, e2.prototype.duplicateTransactionReceipts = $util.emptyArray, e2.prototype.childTransactionReceipts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.receipt && Object.hasOwnProperty.call(e3, "receipt") && $root.proto.TransactionReceipt.encode(e3.receipt, o.uint32(18).fork()).ldelim(), null != e3.duplicateTransactionReceipts && e3.duplicateTransactionReceipts.length)
            for (var t = 0; t < e3.duplicateTransactionReceipts.length; ++t)
              $root.proto.TransactionReceipt.encode(e3.duplicateTransactionReceipts[t], o.uint32(34).fork()).ldelim();
          if (null != e3.childTransactionReceipts && e3.childTransactionReceipts.length)
            for (var t = 0; t < e3.childTransactionReceipts.length; ++t)
              $root.proto.TransactionReceipt.encode(e3.childTransactionReceipts[t], o.uint32(42).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetReceiptResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.receipt = $root.proto.TransactionReceipt.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.duplicateTransactionReceipts && i.duplicateTransactionReceipts.length || (i.duplicateTransactionReceipts = []), i.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(e3, e3.uint32()));
                break;
              }
              case 5: {
                i.childTransactionReceipts && i.childTransactionReceipts.length || (i.childTransactionReceipts = []), i.childTransactionReceipts.push($root.proto.TransactionReceipt.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionGetReceiptResponse";
        }, e2;
      }(), TransactionGetRecordQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionID = null, e2.prototype.includeDuplicates = false, e2.prototype.includeChildRecords = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.transactionID && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o.uint32(18).fork()).ldelim(), null != e3.includeDuplicates && Object.hasOwnProperty.call(e3, "includeDuplicates") && o.uint32(24).bool(e3.includeDuplicates), null != e3.includeChildRecords && Object.hasOwnProperty.call(e3, "includeChildRecords") && o.uint32(32).bool(e3.includeChildRecords), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetRecordQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.includeDuplicates = e3.bool();
                break;
              }
              case 4: {
                i.includeChildRecords = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionGetRecordQuery";
        }, e2;
      }(), TransactionGetRecordResponse: function() {
        function e2(e3) {
          if (this.duplicateTransactionRecords = [], this.childTransactionRecords = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionRecord = null, e2.prototype.duplicateTransactionRecords = $util.emptyArray, e2.prototype.childTransactionRecords = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.transactionRecord && Object.hasOwnProperty.call(e3, "transactionRecord") && $root.proto.TransactionRecord.encode(e3.transactionRecord, o.uint32(26).fork()).ldelim(), null != e3.duplicateTransactionRecords && e3.duplicateTransactionRecords.length)
            for (var t = 0; t < e3.duplicateTransactionRecords.length; ++t)
              $root.proto.TransactionRecord.encode(e3.duplicateTransactionRecords[t], o.uint32(34).fork()).ldelim();
          if (null != e3.childTransactionRecords && e3.childTransactionRecords.length)
            for (var t = 0; t < e3.childTransactionRecords.length; ++t)
              $root.proto.TransactionRecord.encode(e3.childTransactionRecords[t], o.uint32(42).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetRecordResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.transactionRecord = $root.proto.TransactionRecord.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.duplicateTransactionRecords && i.duplicateTransactionRecords.length || (i.duplicateTransactionRecords = []), i.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              }
              case 5: {
                i.childTransactionRecords && i.childTransactionRecords.length || (i.childTransactionRecords = []), i.childTransactionRecords.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionGetRecordResponse";
        }, e2;
      }(), TransactionGetFastRecordQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.transactionID && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetFastRecordQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionGetFastRecordQuery";
        }, e2;
      }(), TransactionGetFastRecordResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionRecord = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.transactionRecord && Object.hasOwnProperty.call(e3, "transactionRecord") && $root.proto.TransactionRecord.encode(e3.transactionRecord, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetFastRecordResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transactionRecord = $root.proto.TransactionRecord.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionGetFastRecordResponse";
        }, e2;
      }(), NetworkGetVersionInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetVersionInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NetworkGetVersionInfoQuery";
        }, e2;
      }(), NetworkGetVersionInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.hapiProtoVersion = null, e2.prototype.hederaServicesVersion = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.hapiProtoVersion && Object.hasOwnProperty.call(e3, "hapiProtoVersion") && $root.proto.SemanticVersion.encode(e3.hapiProtoVersion, o.uint32(18).fork()).ldelim(), null != e3.hederaServicesVersion && Object.hasOwnProperty.call(e3, "hederaServicesVersion") && $root.proto.SemanticVersion.encode(e3.hederaServicesVersion, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetVersionInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.hapiProtoVersion = $root.proto.SemanticVersion.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.hederaServicesVersion = $root.proto.SemanticVersion.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NetworkGetVersionInfoResponse";
        }, e2;
      }(), NetworkGetExecutionTimeQuery: function() {
        function e2(e3) {
          if (this.transactionIds = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionIds = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.transactionIds && e3.transactionIds.length)
            for (var t = 0; t < e3.transactionIds.length; ++t)
              $root.proto.TransactionID.encode(e3.transactionIds[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetExecutionTimeQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.transactionIds && i.transactionIds.length || (i.transactionIds = []), i.transactionIds.push($root.proto.TransactionID.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NetworkGetExecutionTimeQuery";
        }, e2;
      }(), NetworkGetExecutionTimeResponse: function() {
        function e2(e3) {
          if (this.executionTimes = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.executionTimes = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.executionTimes && e3.executionTimes.length) {
            o.uint32(18).fork();
            for (var t = 0; t < e3.executionTimes.length; ++t)
              o.uint64(e3.executionTimes[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetExecutionTimeResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                if (i.executionTimes && i.executionTimes.length || (i.executionTimes = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.executionTimes.push(e3.uint64());
                else
                  i.executionTimes.push(e3.uint64());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.NetworkGetExecutionTimeResponse";
        }, e2;
      }(), TokenGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.token && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetInfoQuery";
        }, e2;
      }(), TokenInfo: function() {
        function e2(e3) {
          if (this.customFees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.name = "", e2.prototype.symbol = "", e2.prototype.decimals = 0, e2.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.treasury = null, e2.prototype.adminKey = null, e2.prototype.kycKey = null, e2.prototype.freezeKey = null, e2.prototype.wipeKey = null, e2.prototype.supplyKey = null, e2.prototype.defaultFreezeStatus = 0, e2.prototype.defaultKycStatus = 0, e2.prototype.deleted = false, e2.prototype.autoRenewAccount = null, e2.prototype.autoRenewPeriod = null, e2.prototype.expiry = null, e2.prototype.memo = "", e2.prototype.tokenType = 0, e2.prototype.supplyType = 0, e2.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.feeScheduleKey = null, e2.prototype.customFees = $util.emptyArray, e2.prototype.pauseKey = null, e2.prototype.pauseStatus = 0, e2.prototype.ledgerId = $util.newBuffer([]), e2.prototype.metadata = $util.newBuffer([]), e2.prototype.metadataKey = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.name && Object.hasOwnProperty.call(e3, "name") && o.uint32(18).string(e3.name), null != e3.symbol && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(26).string(e3.symbol), null != e3.decimals && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(32).uint32(e3.decimals), null != e3.totalSupply && Object.hasOwnProperty.call(e3, "totalSupply") && o.uint32(40).uint64(e3.totalSupply), null != e3.treasury && Object.hasOwnProperty.call(e3, "treasury") && $root.proto.AccountID.encode(e3.treasury, o.uint32(50).fork()).ldelim(), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(58).fork()).ldelim(), null != e3.kycKey && Object.hasOwnProperty.call(e3, "kycKey") && $root.proto.Key.encode(e3.kycKey, o.uint32(66).fork()).ldelim(), null != e3.freezeKey && Object.hasOwnProperty.call(e3, "freezeKey") && $root.proto.Key.encode(e3.freezeKey, o.uint32(74).fork()).ldelim(), null != e3.wipeKey && Object.hasOwnProperty.call(e3, "wipeKey") && $root.proto.Key.encode(e3.wipeKey, o.uint32(82).fork()).ldelim(), null != e3.supplyKey && Object.hasOwnProperty.call(e3, "supplyKey") && $root.proto.Key.encode(e3.supplyKey, o.uint32(90).fork()).ldelim(), null != e3.defaultFreezeStatus && Object.hasOwnProperty.call(e3, "defaultFreezeStatus") && o.uint32(96).int32(e3.defaultFreezeStatus), null != e3.defaultKycStatus && Object.hasOwnProperty.call(e3, "defaultKycStatus") && o.uint32(104).int32(e3.defaultKycStatus), null != e3.deleted && Object.hasOwnProperty.call(e3, "deleted") && o.uint32(112).bool(e3.deleted), null != e3.autoRenewAccount && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(122).fork()).ldelim(), null != e3.autoRenewPeriod && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(130).fork()).ldelim(), null != e3.expiry && Object.hasOwnProperty.call(e3, "expiry") && $root.proto.Timestamp.encode(e3.expiry, o.uint32(138).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o.uint32(146).string(e3.memo), null != e3.tokenType && Object.hasOwnProperty.call(e3, "tokenType") && o.uint32(152).int32(e3.tokenType), null != e3.supplyType && Object.hasOwnProperty.call(e3, "supplyType") && o.uint32(160).int32(e3.supplyType), null != e3.maxSupply && Object.hasOwnProperty.call(e3, "maxSupply") && o.uint32(168).int64(e3.maxSupply), null != e3.feeScheduleKey && Object.hasOwnProperty.call(e3, "feeScheduleKey") && $root.proto.Key.encode(e3.feeScheduleKey, o.uint32(178).fork()).ldelim(), null != e3.customFees && e3.customFees.length)
            for (var t = 0; t < e3.customFees.length; ++t)
              $root.proto.CustomFee.encode(e3.customFees[t], o.uint32(186).fork()).ldelim();
          return null != e3.pauseKey && Object.hasOwnProperty.call(e3, "pauseKey") && $root.proto.Key.encode(e3.pauseKey, o.uint32(194).fork()).ldelim(), null != e3.pauseStatus && Object.hasOwnProperty.call(e3, "pauseStatus") && o.uint32(200).int32(e3.pauseStatus), null != e3.ledgerId && Object.hasOwnProperty.call(e3, "ledgerId") && o.uint32(210).bytes(e3.ledgerId), null != e3.metadata && Object.hasOwnProperty.call(e3, "metadata") && o.uint32(218).bytes(e3.metadata), null != e3.metadataKey && Object.hasOwnProperty.call(e3, "metadataKey") && $root.proto.Key.encode(e3.metadataKey, o.uint32(226).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.name = e3.string();
                break;
              }
              case 3: {
                i.symbol = e3.string();
                break;
              }
              case 4: {
                i.decimals = e3.uint32();
                break;
              }
              case 5: {
                i.totalSupply = e3.uint64();
                break;
              }
              case 6: {
                i.treasury = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.kycKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.freezeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.wipeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.supplyKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.defaultFreezeStatus = e3.int32();
                break;
              }
              case 13: {
                i.defaultKycStatus = e3.int32();
                break;
              }
              case 14: {
                i.deleted = e3.bool();
                break;
              }
              case 15: {
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              }
              case 17: {
                i.expiry = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 18: {
                i.memo = e3.string();
                break;
              }
              case 19: {
                i.tokenType = e3.int32();
                break;
              }
              case 20: {
                i.supplyType = e3.int32();
                break;
              }
              case 21: {
                i.maxSupply = e3.int64();
                break;
              }
              case 22: {
                i.feeScheduleKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 23: {
                i.customFees && i.customFees.length || (i.customFees = []), i.customFees.push($root.proto.CustomFee.decode(e3, e3.uint32()));
                break;
              }
              case 24: {
                i.pauseKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 25: {
                i.pauseStatus = e3.int32();
                break;
              }
              case 26: {
                i.ledgerId = e3.bytes();
                break;
              }
              case 27: {
                i.metadata = e3.bytes();
                break;
              }
              case 28: {
                i.metadataKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenInfo";
        }, e2;
      }(), TokenGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.tokenInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.tokenInfo && Object.hasOwnProperty.call(e3, "tokenInfo") && $root.proto.TokenInfo.encode(e3.tokenInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.tokenInfo = $root.proto.TokenInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetInfoResponse";
        }, e2;
      }(), ScheduleGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.scheduleID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.scheduleID && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ScheduleGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ScheduleGetInfoQuery";
        }, e2;
      }(), ScheduleInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.scheduleID = null, e2.prototype.deletionTime = null, e2.prototype.executionTime = null, e2.prototype.expirationTime = null, e2.prototype.scheduledTransactionBody = null, e2.prototype.memo = "", e2.prototype.adminKey = null, e2.prototype.signers = null, e2.prototype.creatorAccountID = null, e2.prototype.payerAccountID = null, e2.prototype.scheduledTransactionID = null, e2.prototype.ledgerId = $util.newBuffer([]), e2.prototype.waitForExpiry = false;
        let o;
        return Object.defineProperty(e2.prototype, "data", { get: $util.oneOfGetter(o = ["deletionTime", "executionTime"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.scheduleID && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o2.uint32(10).fork()).ldelim(), null != e3.deletionTime && Object.hasOwnProperty.call(e3, "deletionTime") && $root.proto.Timestamp.encode(e3.deletionTime, o2.uint32(18).fork()).ldelim(), null != e3.executionTime && Object.hasOwnProperty.call(e3, "executionTime") && $root.proto.Timestamp.encode(e3.executionTime, o2.uint32(26).fork()).ldelim(), null != e3.expirationTime && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o2.uint32(34).fork()).ldelim(), null != e3.scheduledTransactionBody && Object.hasOwnProperty.call(e3, "scheduledTransactionBody") && $root.proto.SchedulableTransactionBody.encode(e3.scheduledTransactionBody, o2.uint32(42).fork()).ldelim(), null != e3.memo && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(50).string(e3.memo), null != e3.adminKey && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o2.uint32(58).fork()).ldelim(), null != e3.signers && Object.hasOwnProperty.call(e3, "signers") && $root.proto.KeyList.encode(e3.signers, o2.uint32(66).fork()).ldelim(), null != e3.creatorAccountID && Object.hasOwnProperty.call(e3, "creatorAccountID") && $root.proto.AccountID.encode(e3.creatorAccountID, o2.uint32(74).fork()).ldelim(), null != e3.payerAccountID && Object.hasOwnProperty.call(e3, "payerAccountID") && $root.proto.AccountID.encode(e3.payerAccountID, o2.uint32(82).fork()).ldelim(), null != e3.scheduledTransactionID && Object.hasOwnProperty.call(e3, "scheduledTransactionID") && $root.proto.TransactionID.encode(e3.scheduledTransactionID, o2.uint32(90).fork()).ldelim(), null != e3.ledgerId && Object.hasOwnProperty.call(e3, "ledgerId") && o2.uint32(98).bytes(e3.ledgerId), null != e3.waitForExpiry && Object.hasOwnProperty.call(e3, "waitForExpiry") && o2.uint32(104).bool(e3.waitForExpiry), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.ScheduleInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.deletionTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.executionTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.memo = e3.string();
                break;
              }
              case 7: {
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.signers = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.creatorAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.payerAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.scheduledTransactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.ledgerId = e3.bytes();
                break;
              }
              case 13: {
                i.waitForExpiry = e3.bool();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ScheduleInfo";
        }, e2;
      }(), ScheduleGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.scheduleInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.scheduleInfo && Object.hasOwnProperty.call(e3, "scheduleInfo") && $root.proto.ScheduleInfo.encode(e3.scheduleInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ScheduleGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.scheduleInfo = $root.proto.ScheduleInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ScheduleGetInfoResponse";
        }, e2;
      }(), TokenGetAccountNftInfosQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.start && Object.hasOwnProperty.call(e3, "start") && o.uint32(24).int64(e3.start), null != e3.end && Object.hasOwnProperty.call(e3, "end") && o.uint32(32).int64(e3.end), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetAccountNftInfosQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.start = e3.int64();
                break;
              }
              case 4: {
                i.end = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetAccountNftInfosQuery";
        }, e2;
      }(), TokenGetAccountNftInfosResponse: function() {
        function e2(e3) {
          if (this.nfts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.nfts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.nfts && e3.nfts.length)
            for (var t = 0; t < e3.nfts.length; ++t)
              $root.proto.TokenNftInfo.encode(e3.nfts[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetAccountNftInfosResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nfts && i.nfts.length || (i.nfts = []), i.nfts.push($root.proto.TokenNftInfo.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetAccountNftInfosResponse";
        }, e2;
      }(), TokenGetNftInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.nftID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.nftID && Object.hasOwnProperty.call(e3, "nftID") && $root.proto.NftID.encode(e3.nftID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nftID = $root.proto.NftID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetNftInfoQuery";
        }, e2;
      }(), TokenNftInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nftID = null, e2.prototype.accountID = null, e2.prototype.creationTime = null, e2.prototype.metadata = $util.newBuffer([]), e2.prototype.ledgerId = $util.newBuffer([]), e2.prototype.spenderId = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.nftID && Object.hasOwnProperty.call(e3, "nftID") && $root.proto.NftID.encode(e3.nftID, o.uint32(10).fork()).ldelim(), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), null != e3.creationTime && Object.hasOwnProperty.call(e3, "creationTime") && $root.proto.Timestamp.encode(e3.creationTime, o.uint32(26).fork()).ldelim(), null != e3.metadata && Object.hasOwnProperty.call(e3, "metadata") && o.uint32(34).bytes(e3.metadata), null != e3.ledgerId && Object.hasOwnProperty.call(e3, "ledgerId") && o.uint32(42).bytes(e3.ledgerId), null != e3.spenderId && Object.hasOwnProperty.call(e3, "spenderId") && $root.proto.AccountID.encode(e3.spenderId, o.uint32(50).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenNftInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.nftID = $root.proto.NftID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.creationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.metadata = e3.bytes();
                break;
              }
              case 5: {
                i.ledgerId = e3.bytes();
                break;
              }
              case 6: {
                i.spenderId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenNftInfo";
        }, e2;
      }(), TokenGetNftInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.nft = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.nft && Object.hasOwnProperty.call(e3, "nft") && $root.proto.TokenNftInfo.encode(e3.nft, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.nft = $root.proto.TokenNftInfo.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetNftInfoResponse";
        }, e2;
      }(), TokenGetNftInfosQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.tokenID = null, e2.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.tokenID && Object.hasOwnProperty.call(e3, "tokenID") && $root.proto.TokenID.encode(e3.tokenID, o.uint32(18).fork()).ldelim(), null != e3.start && Object.hasOwnProperty.call(e3, "start") && o.uint32(24).int64(e3.start), null != e3.end && Object.hasOwnProperty.call(e3, "end") && o.uint32(32).int64(e3.end), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfosQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.tokenID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.start = e3.int64();
                break;
              }
              case 4: {
                i.end = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetNftInfosQuery";
        }, e2;
      }(), TokenGetNftInfosResponse: function() {
        function e2(e3) {
          if (this.nfts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.tokenID = null, e2.prototype.nfts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.tokenID && Object.hasOwnProperty.call(e3, "tokenID") && $root.proto.TokenID.encode(e3.tokenID, o.uint32(18).fork()).ldelim(), null != e3.nfts && e3.nfts.length)
            for (var t = 0; t < e3.nfts.length; ++t)
              $root.proto.TokenNftInfo.encode(e3.nfts[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfosResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.tokenID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.nfts && i.nfts.length || (i.nfts = []), i.nfts.push($root.proto.TokenNftInfo.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenGetNftInfosResponse";
        }, e2;
      }(), GetAccountDetailsQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountId = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountId && Object.hasOwnProperty.call(e3, "accountId") && $root.proto.AccountID.encode(e3.accountId, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GetAccountDetailsQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GetAccountDetailsQuery";
        }, e2;
      }(), GetAccountDetailsResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountDetails = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.header && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), null != e3.accountDetails && Object.hasOwnProperty.call(e3, "accountDetails") && $root.proto.GetAccountDetailsResponse.AccountDetails.encode(e3.accountDetails, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GetAccountDetailsResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.accountDetails = $root.proto.GetAccountDetailsResponse.AccountDetails.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GetAccountDetailsResponse";
        }, e2.AccountDetails = function() {
          function e3(e4) {
            if (this.tokenRelationships = [], this.grantedCryptoAllowances = [], this.grantedNftAllowances = [], this.grantedTokenAllowances = [], e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.accountId = null, e3.prototype.contractAccountId = "", e3.prototype.deleted = false, e3.prototype.proxyAccountId = null, e3.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.key = null, e3.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.receiverSigRequired = false, e3.prototype.expirationTime = null, e3.prototype.autoRenewPeriod = null, e3.prototype.tokenRelationships = $util.emptyArray, e3.prototype.memo = "", e3.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.maxAutomaticTokenAssociations = 0, e3.prototype.alias = $util.newBuffer([]), e3.prototype.ledgerId = $util.newBuffer([]), e3.prototype.grantedCryptoAllowances = $util.emptyArray, e3.prototype.grantedNftAllowances = $util.emptyArray, e3.prototype.grantedTokenAllowances = $util.emptyArray, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            if (o || (o = $Writer.create()), null != e4.accountId && Object.hasOwnProperty.call(e4, "accountId") && $root.proto.AccountID.encode(e4.accountId, o.uint32(10).fork()).ldelim(), null != e4.contractAccountId && Object.hasOwnProperty.call(e4, "contractAccountId") && o.uint32(18).string(e4.contractAccountId), null != e4.deleted && Object.hasOwnProperty.call(e4, "deleted") && o.uint32(24).bool(e4.deleted), null != e4.proxyAccountId && Object.hasOwnProperty.call(e4, "proxyAccountId") && $root.proto.AccountID.encode(e4.proxyAccountId, o.uint32(34).fork()).ldelim(), null != e4.proxyReceived && Object.hasOwnProperty.call(e4, "proxyReceived") && o.uint32(40).int64(e4.proxyReceived), null != e4.key && Object.hasOwnProperty.call(e4, "key") && $root.proto.Key.encode(e4.key, o.uint32(50).fork()).ldelim(), null != e4.balance && Object.hasOwnProperty.call(e4, "balance") && o.uint32(56).uint64(e4.balance), null != e4.receiverSigRequired && Object.hasOwnProperty.call(e4, "receiverSigRequired") && o.uint32(64).bool(e4.receiverSigRequired), null != e4.expirationTime && Object.hasOwnProperty.call(e4, "expirationTime") && $root.proto.Timestamp.encode(e4.expirationTime, o.uint32(74).fork()).ldelim(), null != e4.autoRenewPeriod && Object.hasOwnProperty.call(e4, "autoRenewPeriod") && $root.proto.Duration.encode(e4.autoRenewPeriod, o.uint32(82).fork()).ldelim(), null != e4.tokenRelationships && e4.tokenRelationships.length)
              for (var t = 0; t < e4.tokenRelationships.length; ++t)
                $root.proto.TokenRelationship.encode(e4.tokenRelationships[t], o.uint32(90).fork()).ldelim();
            if (null != e4.memo && Object.hasOwnProperty.call(e4, "memo") && o.uint32(98).string(e4.memo), null != e4.ownedNfts && Object.hasOwnProperty.call(e4, "ownedNfts") && o.uint32(104).int64(e4.ownedNfts), null != e4.maxAutomaticTokenAssociations && Object.hasOwnProperty.call(e4, "maxAutomaticTokenAssociations") && o.uint32(112).int32(e4.maxAutomaticTokenAssociations), null != e4.alias && Object.hasOwnProperty.call(e4, "alias") && o.uint32(122).bytes(e4.alias), null != e4.ledgerId && Object.hasOwnProperty.call(e4, "ledgerId") && o.uint32(130).bytes(e4.ledgerId), null != e4.grantedCryptoAllowances && e4.grantedCryptoAllowances.length)
              for (var t = 0; t < e4.grantedCryptoAllowances.length; ++t)
                $root.proto.GrantedCryptoAllowance.encode(e4.grantedCryptoAllowances[t], o.uint32(138).fork()).ldelim();
            if (null != e4.grantedNftAllowances && e4.grantedNftAllowances.length)
              for (var t = 0; t < e4.grantedNftAllowances.length; ++t)
                $root.proto.GrantedNftAllowance.encode(e4.grantedNftAllowances[t], o.uint32(146).fork()).ldelim();
            if (null != e4.grantedTokenAllowances && e4.grantedTokenAllowances.length)
              for (var t = 0; t < e4.grantedTokenAllowances.length; ++t)
                $root.proto.GrantedTokenAllowance.encode(e4.grantedTokenAllowances[t], o.uint32(154).fork()).ldelim();
            return o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.proto.GetAccountDetailsResponse.AccountDetails(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.accountId = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                }
                case 2: {
                  i.contractAccountId = e4.string();
                  break;
                }
                case 3: {
                  i.deleted = e4.bool();
                  break;
                }
                case 4: {
                  i.proxyAccountId = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                }
                case 5: {
                  i.proxyReceived = e4.int64();
                  break;
                }
                case 6: {
                  i.key = $root.proto.Key.decode(e4, e4.uint32());
                  break;
                }
                case 7: {
                  i.balance = e4.uint64();
                  break;
                }
                case 8: {
                  i.receiverSigRequired = e4.bool();
                  break;
                }
                case 9: {
                  i.expirationTime = $root.proto.Timestamp.decode(e4, e4.uint32());
                  break;
                }
                case 10: {
                  i.autoRenewPeriod = $root.proto.Duration.decode(e4, e4.uint32());
                  break;
                }
                case 11: {
                  i.tokenRelationships && i.tokenRelationships.length || (i.tokenRelationships = []), i.tokenRelationships.push($root.proto.TokenRelationship.decode(e4, e4.uint32()));
                  break;
                }
                case 12: {
                  i.memo = e4.string();
                  break;
                }
                case 13: {
                  i.ownedNfts = e4.int64();
                  break;
                }
                case 14: {
                  i.maxAutomaticTokenAssociations = e4.int32();
                  break;
                }
                case 15: {
                  i.alias = e4.bytes();
                  break;
                }
                case 16: {
                  i.ledgerId = e4.bytes();
                  break;
                }
                case 17: {
                  i.grantedCryptoAllowances && i.grantedCryptoAllowances.length || (i.grantedCryptoAllowances = []), i.grantedCryptoAllowances.push($root.proto.GrantedCryptoAllowance.decode(e4, e4.uint32()));
                  break;
                }
                case 18: {
                  i.grantedNftAllowances && i.grantedNftAllowances.length || (i.grantedNftAllowances = []), i.grantedNftAllowances.push($root.proto.GrantedNftAllowance.decode(e4, e4.uint32()));
                  break;
                }
                case 19: {
                  i.grantedTokenAllowances && i.grantedTokenAllowances.length || (i.grantedTokenAllowances = []), i.grantedTokenAllowances.push($root.proto.GrantedTokenAllowance.decode(e4, e4.uint32()));
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/proto.GetAccountDetailsResponse.AccountDetails";
          }, e3;
        }(), e2;
      }(), GrantedCryptoAllowance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.spender = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.spender && Object.hasOwnProperty.call(e3, "spender") && $root.proto.AccountID.encode(e3.spender, o.uint32(10).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).int64(e3.amount), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GrantedCryptoAllowance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.spender = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.amount = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GrantedCryptoAllowance";
        }, e2;
      }(), GrantedNftAllowance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.spender = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.spender && Object.hasOwnProperty.call(e3, "spender") && $root.proto.AccountID.encode(e3.spender, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GrantedNftAllowance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.spender = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GrantedNftAllowance";
        }, e2;
      }(), GrantedTokenAllowance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.spender = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.spender && Object.hasOwnProperty.call(e3, "spender") && $root.proto.AccountID.encode(e3.spender, o.uint32(18).fork()).ldelim(), null != e3.amount && Object.hasOwnProperty.call(e3, "amount") && o.uint32(24).int64(e3.amount), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.GrantedTokenAllowance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.spender = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.amount = e3.int64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.GrantedTokenAllowance";
        }, e2;
      }(), Response: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.getByKey = null, e2.prototype.getBySolidityID = null, e2.prototype.contractCallLocal = null, e2.prototype.contractGetBytecodeResponse = null, e2.prototype.contractGetInfo = null, e2.prototype.contractGetRecordsResponse = null, e2.prototype.cryptogetAccountBalance = null, e2.prototype.cryptoGetAccountRecords = null, e2.prototype.cryptoGetInfo = null, e2.prototype.cryptoGetLiveHash = null, e2.prototype.cryptoGetProxyStakers = null, e2.prototype.fileGetContents = null, e2.prototype.fileGetInfo = null, e2.prototype.transactionGetReceipt = null, e2.prototype.transactionGetRecord = null, e2.prototype.transactionGetFastRecord = null, e2.prototype.consensusGetTopicInfo = null, e2.prototype.networkGetVersionInfo = null, e2.prototype.tokenGetInfo = null, e2.prototype.scheduleGetInfo = null, e2.prototype.tokenGetAccountNftInfos = null, e2.prototype.tokenGetNftInfo = null, e2.prototype.tokenGetNftInfos = null, e2.prototype.networkGetExecutionTime = null, e2.prototype.accountDetails = null;
        let o;
        return Object.defineProperty(e2.prototype, "response", { get: $util.oneOfGetter(o = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetBytecodeResponse", "contractGetInfo", "contractGetRecordsResponse", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime", "accountDetails"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.getByKey && Object.hasOwnProperty.call(e3, "getByKey") && $root.proto.GetByKeyResponse.encode(e3.getByKey, o2.uint32(10).fork()).ldelim(), null != e3.getBySolidityID && Object.hasOwnProperty.call(e3, "getBySolidityID") && $root.proto.GetBySolidityIDResponse.encode(e3.getBySolidityID, o2.uint32(18).fork()).ldelim(), null != e3.contractCallLocal && Object.hasOwnProperty.call(e3, "contractCallLocal") && $root.proto.ContractCallLocalResponse.encode(e3.contractCallLocal, o2.uint32(26).fork()).ldelim(), null != e3.contractGetInfo && Object.hasOwnProperty.call(e3, "contractGetInfo") && $root.proto.ContractGetInfoResponse.encode(e3.contractGetInfo, o2.uint32(34).fork()).ldelim(), null != e3.contractGetBytecodeResponse && Object.hasOwnProperty.call(e3, "contractGetBytecodeResponse") && $root.proto.ContractGetBytecodeResponse.encode(e3.contractGetBytecodeResponse, o2.uint32(42).fork()).ldelim(), null != e3.contractGetRecordsResponse && Object.hasOwnProperty.call(e3, "contractGetRecordsResponse") && $root.proto.ContractGetRecordsResponse.encode(e3.contractGetRecordsResponse, o2.uint32(50).fork()).ldelim(), null != e3.cryptogetAccountBalance && Object.hasOwnProperty.call(e3, "cryptogetAccountBalance") && $root.proto.CryptoGetAccountBalanceResponse.encode(e3.cryptogetAccountBalance, o2.uint32(58).fork()).ldelim(), null != e3.cryptoGetAccountRecords && Object.hasOwnProperty.call(e3, "cryptoGetAccountRecords") && $root.proto.CryptoGetAccountRecordsResponse.encode(e3.cryptoGetAccountRecords, o2.uint32(66).fork()).ldelim(), null != e3.cryptoGetInfo && Object.hasOwnProperty.call(e3, "cryptoGetInfo") && $root.proto.CryptoGetInfoResponse.encode(e3.cryptoGetInfo, o2.uint32(74).fork()).ldelim(), null != e3.cryptoGetLiveHash && Object.hasOwnProperty.call(e3, "cryptoGetLiveHash") && $root.proto.CryptoGetLiveHashResponse.encode(e3.cryptoGetLiveHash, o2.uint32(82).fork()).ldelim(), null != e3.cryptoGetProxyStakers && Object.hasOwnProperty.call(e3, "cryptoGetProxyStakers") && $root.proto.CryptoGetStakersResponse.encode(e3.cryptoGetProxyStakers, o2.uint32(90).fork()).ldelim(), null != e3.fileGetContents && Object.hasOwnProperty.call(e3, "fileGetContents") && $root.proto.FileGetContentsResponse.encode(e3.fileGetContents, o2.uint32(98).fork()).ldelim(), null != e3.fileGetInfo && Object.hasOwnProperty.call(e3, "fileGetInfo") && $root.proto.FileGetInfoResponse.encode(e3.fileGetInfo, o2.uint32(106).fork()).ldelim(), null != e3.transactionGetReceipt && Object.hasOwnProperty.call(e3, "transactionGetReceipt") && $root.proto.TransactionGetReceiptResponse.encode(e3.transactionGetReceipt, o2.uint32(114).fork()).ldelim(), null != e3.transactionGetRecord && Object.hasOwnProperty.call(e3, "transactionGetRecord") && $root.proto.TransactionGetRecordResponse.encode(e3.transactionGetRecord, o2.uint32(122).fork()).ldelim(), null != e3.transactionGetFastRecord && Object.hasOwnProperty.call(e3, "transactionGetFastRecord") && $root.proto.TransactionGetFastRecordResponse.encode(e3.transactionGetFastRecord, o2.uint32(130).fork()).ldelim(), null != e3.consensusGetTopicInfo && Object.hasOwnProperty.call(e3, "consensusGetTopicInfo") && $root.proto.ConsensusGetTopicInfoResponse.encode(e3.consensusGetTopicInfo, o2.uint32(1202).fork()).ldelim(), null != e3.networkGetVersionInfo && Object.hasOwnProperty.call(e3, "networkGetVersionInfo") && $root.proto.NetworkGetVersionInfoResponse.encode(e3.networkGetVersionInfo, o2.uint32(1210).fork()).ldelim(), null != e3.tokenGetInfo && Object.hasOwnProperty.call(e3, "tokenGetInfo") && $root.proto.TokenGetInfoResponse.encode(e3.tokenGetInfo, o2.uint32(1218).fork()).ldelim(), null != e3.scheduleGetInfo && Object.hasOwnProperty.call(e3, "scheduleGetInfo") && $root.proto.ScheduleGetInfoResponse.encode(e3.scheduleGetInfo, o2.uint32(1226).fork()).ldelim(), null != e3.tokenGetAccountNftInfos && Object.hasOwnProperty.call(e3, "tokenGetAccountNftInfos") && $root.proto.TokenGetAccountNftInfosResponse.encode(e3.tokenGetAccountNftInfos, o2.uint32(1234).fork()).ldelim(), null != e3.tokenGetNftInfo && Object.hasOwnProperty.call(e3, "tokenGetNftInfo") && $root.proto.TokenGetNftInfoResponse.encode(e3.tokenGetNftInfo, o2.uint32(1242).fork()).ldelim(), null != e3.tokenGetNftInfos && Object.hasOwnProperty.call(e3, "tokenGetNftInfos") && $root.proto.TokenGetNftInfosResponse.encode(e3.tokenGetNftInfos, o2.uint32(1250).fork()).ldelim(), null != e3.networkGetExecutionTime && Object.hasOwnProperty.call(e3, "networkGetExecutionTime") && $root.proto.NetworkGetExecutionTimeResponse.encode(e3.networkGetExecutionTime, o2.uint32(1258).fork()).ldelim(), null != e3.accountDetails && Object.hasOwnProperty.call(e3, "accountDetails") && $root.proto.GetAccountDetailsResponse.encode(e3.accountDetails, o2.uint32(1266).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.Response(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.getByKey = $root.proto.GetByKeyResponse.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.getBySolidityID = $root.proto.GetBySolidityIDResponse.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.contractCallLocal = $root.proto.ContractCallLocalResponse.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.contractGetInfo = $root.proto.ContractGetInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 6: {
                i.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.decode(e3, e3.uint32());
                break;
              }
              case 9: {
                i.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 10: {
                i.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.decode(e3, e3.uint32());
                break;
              }
              case 11: {
                i.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.decode(e3, e3.uint32());
                break;
              }
              case 12: {
                i.fileGetContents = $root.proto.FileGetContentsResponse.decode(e3, e3.uint32());
                break;
              }
              case 13: {
                i.fileGetInfo = $root.proto.FileGetInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 14: {
                i.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.decode(e3, e3.uint32());
                break;
              }
              case 15: {
                i.transactionGetRecord = $root.proto.TransactionGetRecordResponse.decode(e3, e3.uint32());
                break;
              }
              case 16: {
                i.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.decode(e3, e3.uint32());
                break;
              }
              case 150: {
                i.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 151: {
                i.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 152: {
                i.tokenGetInfo = $root.proto.TokenGetInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 153: {
                i.scheduleGetInfo = $root.proto.ScheduleGetInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 154: {
                i.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosResponse.decode(e3, e3.uint32());
                break;
              }
              case 155: {
                i.tokenGetNftInfo = $root.proto.TokenGetNftInfoResponse.decode(e3, e3.uint32());
                break;
              }
              case 156: {
                i.tokenGetNftInfos = $root.proto.TokenGetNftInfosResponse.decode(e3, e3.uint32());
                break;
              }
              case 157: {
                i.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeResponse.decode(e3, e3.uint32());
                break;
              }
              case 158: {
                i.accountDetails = $root.proto.GetAccountDetailsResponse.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.Response";
        }, e2;
      }(), TransactionResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodeTransactionPrecheckCode = 0, e2.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.nodeTransactionPrecheckCode && Object.hasOwnProperty.call(e3, "nodeTransactionPrecheckCode") && o.uint32(8).int32(e3.nodeTransactionPrecheckCode), null != e3.cost && Object.hasOwnProperty.call(e3, "cost") && o.uint32(16).uint64(e3.cost), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TransactionResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.nodeTransactionPrecheckCode = e3.int32();
                break;
              }
              case 2: {
                i.cost = e3.uint64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionResponse";
        }, e2;
      }(), CryptoService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createAccount = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "createAccount" }), Object.defineProperty(e2.prototype.updateAccount = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "updateAccount" }), Object.defineProperty(e2.prototype.cryptoTransfer = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "cryptoTransfer" }), Object.defineProperty(e2.prototype.cryptoDelete = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "cryptoDelete" }), Object.defineProperty(e2.prototype.approveAllowances = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "approveAllowances" }), Object.defineProperty(e2.prototype.deleteAllowances = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "deleteAllowances" }), Object.defineProperty(e2.prototype.addLiveHash = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "addLiveHash" }), Object.defineProperty(e2.prototype.deleteLiveHash = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "deleteLiveHash" }), Object.defineProperty(e2.prototype.getLiveHash = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getLiveHash" }), Object.defineProperty(e2.prototype.getAccountRecords = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getAccountRecords" }), Object.defineProperty(e2.prototype.cryptoGetBalance = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "cryptoGetBalance" }), Object.defineProperty(e2.prototype.getAccountInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getAccountInfo" }), Object.defineProperty(e2.prototype.getTransactionReceipts = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getTransactionReceipts" }), Object.defineProperty(e2.prototype.getFastTransactionRecord = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getFastTransactionRecord" }), Object.defineProperty(e2.prototype.getTxRecordByTxID = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getTxRecordByTxID" }), Object.defineProperty(e2.prototype.getStakersByAccountID = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getStakersByAccountID" }), e2;
      }(), FileService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createFile = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "createFile" }), Object.defineProperty(e2.prototype.updateFile = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "updateFile" }), Object.defineProperty(e2.prototype.deleteFile = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "deleteFile" }), Object.defineProperty(e2.prototype.appendContent = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "appendContent" }), Object.defineProperty(e2.prototype.getFileContent = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getFileContent" }), Object.defineProperty(e2.prototype.getFileInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getFileInfo" }), Object.defineProperty(e2.prototype.systemDelete = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "systemDelete" }), Object.defineProperty(e2.prototype.systemUndelete = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "systemUndelete" }), e2;
      }(), FreezeService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.freeze = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "freeze" }), e2;
      }(), NetworkService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.getVersionInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getVersionInfo" }), Object.defineProperty(e2.prototype.getExecutionTime = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getExecutionTime" }), Object.defineProperty(e2.prototype.uncheckedSubmit = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "uncheckedSubmit" }), Object.defineProperty(e2.prototype.getAccountDetails = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getAccountDetails" }), e2;
      }(), ScheduleService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createSchedule = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "createSchedule" }), Object.defineProperty(e2.prototype.signSchedule = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "signSchedule" }), Object.defineProperty(e2.prototype.deleteSchedule = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "deleteSchedule" }), Object.defineProperty(e2.prototype.getScheduleInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getScheduleInfo" }), e2;
      }(), SmartContractService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createContract = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "createContract" }), Object.defineProperty(e2.prototype.updateContract = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "updateContract" }), Object.defineProperty(e2.prototype.contractCallMethod = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "contractCallMethod" }), Object.defineProperty(e2.prototype.getContractInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getContractInfo" }), Object.defineProperty(e2.prototype.contractCallLocalMethod = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "contractCallLocalMethod" }), Object.defineProperty(e2.prototype.contractGetBytecode = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "ContractGetBytecode" }), Object.defineProperty(e2.prototype.getBySolidityID = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getBySolidityID" }), Object.defineProperty(e2.prototype.getTxRecordByContractID = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getTxRecordByContractID" }), Object.defineProperty(e2.prototype.deleteContract = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "deleteContract" }), Object.defineProperty(e2.prototype.systemDelete = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "systemDelete" }), Object.defineProperty(e2.prototype.systemUndelete = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "systemUndelete" }), Object.defineProperty(e2.prototype.callEthereum = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "callEthereum" }), e2;
      }(), ThrottleGroup: function() {
        function e2(e3) {
          if (this.operations = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.operations = $util.emptyArray, e2.prototype.milliOpsPerSec = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.operations && e3.operations.length) {
            o.uint32(10).fork();
            for (var t = 0; t < e3.operations.length; ++t)
              o.int32(e3.operations[t]);
            o.ldelim();
          }
          return null != e3.milliOpsPerSec && Object.hasOwnProperty.call(e3, "milliOpsPerSec") && o.uint32(16).uint64(e3.milliOpsPerSec), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ThrottleGroup(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                if (i.operations && i.operations.length || (i.operations = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.operations.push(e3.int32());
                else
                  i.operations.push(e3.int32());
                break;
              }
              case 2: {
                i.milliOpsPerSec = e3.uint64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ThrottleGroup";
        }, e2;
      }(), ThrottleBucket: function() {
        function e2(e3) {
          if (this.throttleGroups = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.name = "", e2.prototype.burstPeriodMs = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.throttleGroups = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && o.uint32(10).string(e3.name), null != e3.burstPeriodMs && Object.hasOwnProperty.call(e3, "burstPeriodMs") && o.uint32(16).uint64(e3.burstPeriodMs), null != e3.throttleGroups && e3.throttleGroups.length)
            for (var t = 0; t < e3.throttleGroups.length; ++t)
              $root.proto.ThrottleGroup.encode(e3.throttleGroups[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ThrottleBucket(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.name = e3.string();
                break;
              }
              case 2: {
                i.burstPeriodMs = e3.uint64();
                break;
              }
              case 3: {
                i.throttleGroups && i.throttleGroups.length || (i.throttleGroups = []), i.throttleGroups.push($root.proto.ThrottleGroup.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ThrottleBucket";
        }, e2;
      }(), ThrottleDefinitions: function() {
        function e2(e3) {
          if (this.throttleBuckets = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.throttleBuckets = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.throttleBuckets && e3.throttleBuckets.length)
            for (var t = 0; t < e3.throttleBuckets.length; ++t)
              $root.proto.ThrottleBucket.encode(e3.throttleBuckets[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ThrottleDefinitions(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.throttleBuckets && i.throttleBuckets.length || (i.throttleBuckets = []), i.throttleBuckets.push($root.proto.ThrottleBucket.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ThrottleDefinitions";
        }, e2;
      }(), TokenService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createToken = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "createToken" }), Object.defineProperty(e2.prototype.updateToken = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "updateToken" }), Object.defineProperty(e2.prototype.mintToken = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "mintToken" }), Object.defineProperty(e2.prototype.burnToken = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "burnToken" }), Object.defineProperty(e2.prototype.deleteToken = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "deleteToken" }), Object.defineProperty(e2.prototype.wipeTokenAccount = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "wipeTokenAccount" }), Object.defineProperty(e2.prototype.freezeTokenAccount = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "freezeTokenAccount" }), Object.defineProperty(e2.prototype.unfreezeTokenAccount = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "unfreezeTokenAccount" }), Object.defineProperty(e2.prototype.grantKycToTokenAccount = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "grantKycToTokenAccount" }), Object.defineProperty(e2.prototype.revokeKycFromTokenAccount = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "revokeKycFromTokenAccount" }), Object.defineProperty(e2.prototype.associateTokens = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "associateTokens" }), Object.defineProperty(e2.prototype.dissociateTokens = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "dissociateTokens" }), Object.defineProperty(e2.prototype.updateTokenFeeSchedule = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "updateTokenFeeSchedule" }), Object.defineProperty(e2.prototype.getTokenInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getTokenInfo" }), Object.defineProperty(e2.prototype.getAccountNftInfos = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getAccountNftInfos" }), Object.defineProperty(e2.prototype.getTokenNftInfo = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getTokenNftInfo" }), Object.defineProperty(e2.prototype.getTokenNftInfos = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Query, $root.proto.Response, e3, o);
        }, "name", { value: "getTokenNftInfos" }), Object.defineProperty(e2.prototype.pauseToken = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "pauseToken" }), Object.defineProperty(e2.prototype.unpauseToken = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "unpauseToken" }), Object.defineProperty(e2.prototype.updateNfts = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "updateNfts" }), e2;
      }(), TokenUpdateNftTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nftId = null, e2.prototype.metadata = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.nftId && Object.hasOwnProperty.call(e3, "nftId") && $root.proto.NftID.encode(e3.nftId, o.uint32(10).fork()).ldelim(), null != e3.metadata && Object.hasOwnProperty.call(e3, "metadata") && $root.google.protobuf.BytesValue.encode(e3.metadata, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenUpdateNftTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.nftId = $root.proto.NftID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.metadata = $root.google.protobuf.BytesValue.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenUpdateNftTransactionBody";
        }, e2;
      }(), SignedTransaction: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.bodyBytes = $util.newBuffer([]), e2.prototype.sigMap = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.bodyBytes && Object.hasOwnProperty.call(e3, "bodyBytes") && o.uint32(10).bytes(e3.bodyBytes), null != e3.sigMap && Object.hasOwnProperty.call(e3, "sigMap") && $root.proto.SignatureMap.encode(e3.sigMap, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SignedTransaction(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.bodyBytes = e3.bytes();
                break;
              }
              case 2: {
                i.sigMap = $root.proto.SignatureMap.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SignedTransaction";
        }, e2;
      }(), UtilService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.prng = function t(e3, o) {
          return this.rpcCall(t, $root.proto.Transaction, $root.proto.TransactionResponse, e3, o);
        }, "name", { value: "prng" }), e2;
      }(), TokenUnitBalance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.tokenId && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), null != e3.balance && Object.hasOwnProperty.call(e3, "balance") && o.uint32(16).uint64(e3.balance), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.TokenUnitBalance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.balance = e3.uint64();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TokenUnitBalance";
        }, e2;
      }(), SingleAccountBalances: function() {
        function e2(e3) {
          if (this.tokenUnitBalances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.hbarBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.tokenUnitBalances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.accountID && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), null != e3.hbarBalance && Object.hasOwnProperty.call(e3, "hbarBalance") && o.uint32(16).uint64(e3.hbarBalance), null != e3.tokenUnitBalances && e3.tokenUnitBalances.length)
            for (var t = 0; t < e3.tokenUnitBalances.length; ++t)
              $root.proto.TokenUnitBalance.encode(e3.tokenUnitBalances[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SingleAccountBalances(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.hbarBalance = e3.uint64();
                break;
              }
              case 3: {
                i.tokenUnitBalances && i.tokenUnitBalances.length || (i.tokenUnitBalances = []), i.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SingleAccountBalances";
        }, e2;
      }(), AllAccountBalances: function() {
        function e2(e3) {
          if (this.allAccounts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.consensusTimestamp = null, e2.prototype.allAccounts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.consensusTimestamp && Object.hasOwnProperty.call(e3, "consensusTimestamp") && $root.proto.Timestamp.encode(e3.consensusTimestamp, o.uint32(10).fork()).ldelim(), null != e3.allAccounts && e3.allAccounts.length)
            for (var t = 0; t < e3.allAccounts.length; ++t)
              $root.proto.SingleAccountBalances.encode(e3.allAccounts[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.AllAccountBalances(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.consensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.allAccounts && i.allAccounts.length || (i.allAccounts = []), i.allAccounts.push($root.proto.SingleAccountBalances.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.AllAccountBalances";
        }, e2;
      }(), ContractActions: function() {
        function e2(e3) {
          if (this.contractActions = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractActions = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.contractActions && e3.contractActions.length)
            for (var t = 0; t < e3.contractActions.length; ++t)
              $root.proto.ContractAction.encode(e3.contractActions[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractActions(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractActions && i.contractActions.length || (i.contractActions = []), i.contractActions.push($root.proto.ContractAction.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractActions";
        }, e2;
      }(), ContractActionType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "NO_ACTION"] = 0, o[e2[1] = "CALL"] = 1, o[e2[2] = "CREATE"] = 2, o[e2[3] = "PRECOMPILE"] = 3, o[e2[4] = "SYSTEM"] = 4, o;
      }(), CallOperationType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "OP_UNKNOWN"] = 0, o[e2[1] = "OP_CALL"] = 1, o[e2[2] = "OP_CALLCODE"] = 2, o[e2[3] = "OP_DELEGATECALL"] = 3, o[e2[4] = "OP_STATICCALL"] = 4, o[e2[5] = "OP_CREATE"] = 5, o[e2[6] = "OP_CREATE2"] = 6, o;
      }(), ContractAction: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.callType = 0, e2.prototype.callingAccount = null, e2.prototype.callingContract = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.input = $util.newBuffer([]), e2.prototype.recipientAccount = null, e2.prototype.recipientContract = null, e2.prototype.targetedAddress = null, e2.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.output = null, e2.prototype.revertReason = null, e2.prototype.error = null, e2.prototype.callDepth = 0, e2.prototype.callOperationType = 0;
        let o;
        return Object.defineProperty(e2.prototype, "caller", { get: $util.oneOfGetter(o = ["callingAccount", "callingContract"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "recipient", { get: $util.oneOfGetter(o = ["recipientAccount", "recipientContract", "targetedAddress"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "resultData", { get: $util.oneOfGetter(o = ["output", "revertReason", "error"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.callType && Object.hasOwnProperty.call(e3, "callType") && o2.uint32(8).int32(e3.callType), null != e3.callingAccount && Object.hasOwnProperty.call(e3, "callingAccount") && $root.proto.AccountID.encode(e3.callingAccount, o2.uint32(18).fork()).ldelim(), null != e3.callingContract && Object.hasOwnProperty.call(e3, "callingContract") && $root.proto.ContractID.encode(e3.callingContract, o2.uint32(26).fork()).ldelim(), null != e3.gas && Object.hasOwnProperty.call(e3, "gas") && o2.uint32(32).int64(e3.gas), null != e3.input && Object.hasOwnProperty.call(e3, "input") && o2.uint32(42).bytes(e3.input), null != e3.recipientAccount && Object.hasOwnProperty.call(e3, "recipientAccount") && $root.proto.AccountID.encode(e3.recipientAccount, o2.uint32(50).fork()).ldelim(), null != e3.recipientContract && Object.hasOwnProperty.call(e3, "recipientContract") && $root.proto.ContractID.encode(e3.recipientContract, o2.uint32(58).fork()).ldelim(), null != e3.targetedAddress && Object.hasOwnProperty.call(e3, "targetedAddress") && o2.uint32(66).bytes(e3.targetedAddress), null != e3.value && Object.hasOwnProperty.call(e3, "value") && o2.uint32(72).int64(e3.value), null != e3.gasUsed && Object.hasOwnProperty.call(e3, "gasUsed") && o2.uint32(80).int64(e3.gasUsed), null != e3.output && Object.hasOwnProperty.call(e3, "output") && o2.uint32(90).bytes(e3.output), null != e3.revertReason && Object.hasOwnProperty.call(e3, "revertReason") && o2.uint32(98).bytes(e3.revertReason), null != e3.error && Object.hasOwnProperty.call(e3, "error") && o2.uint32(106).bytes(e3.error), null != e3.callDepth && Object.hasOwnProperty.call(e3, "callDepth") && o2.uint32(112).int32(e3.callDepth), null != e3.callOperationType && Object.hasOwnProperty.call(e3, "callOperationType") && o2.uint32(120).int32(e3.callOperationType), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.ContractAction(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.callType = e3.int32();
                break;
              }
              case 2: {
                i.callingAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.callingContract = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.gas = e3.int64();
                break;
              }
              case 5: {
                i.input = e3.bytes();
                break;
              }
              case 6: {
                i.recipientAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              }
              case 7: {
                i.recipientContract = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 8: {
                i.targetedAddress = e3.bytes();
                break;
              }
              case 9: {
                i.value = e3.int64();
                break;
              }
              case 10: {
                i.gasUsed = e3.int64();
                break;
              }
              case 11: {
                i.output = e3.bytes();
                break;
              }
              case 12: {
                i.revertReason = e3.bytes();
                break;
              }
              case 13: {
                i.error = e3.bytes();
                break;
              }
              case 14: {
                i.callDepth = e3.int32();
                break;
              }
              case 15: {
                i.callOperationType = e3.int32();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractAction";
        }, e2;
      }(), ContractBytecode: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractId = null, e2.prototype.initcode = $util.newBuffer([]), e2.prototype.runtimeBytecode = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.contractId && Object.hasOwnProperty.call(e3, "contractId") && $root.proto.ContractID.encode(e3.contractId, o.uint32(10).fork()).ldelim(), null != e3.initcode && Object.hasOwnProperty.call(e3, "initcode") && o.uint32(18).bytes(e3.initcode), null != e3.runtimeBytecode && Object.hasOwnProperty.call(e3, "runtimeBytecode") && o.uint32(26).bytes(e3.runtimeBytecode), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractBytecode(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractId = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.initcode = e3.bytes();
                break;
              }
              case 3: {
                i.runtimeBytecode = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractBytecode";
        }, e2;
      }(), ContractStateChanges: function() {
        function e2(e3) {
          if (this.contractStateChanges = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractStateChanges = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.contractStateChanges && e3.contractStateChanges.length)
            for (var t = 0; t < e3.contractStateChanges.length; ++t)
              $root.proto.ContractStateChange.encode(e3.contractStateChanges[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractStateChanges(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractStateChanges && i.contractStateChanges.length || (i.contractStateChanges = []), i.contractStateChanges.push($root.proto.ContractStateChange.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractStateChanges";
        }, e2;
      }(), ContractStateChange: function() {
        function e2(e3) {
          if (this.storageChanges = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractId = null, e2.prototype.storageChanges = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.contractId && Object.hasOwnProperty.call(e3, "contractId") && $root.proto.ContractID.encode(e3.contractId, o.uint32(10).fork()).ldelim(), null != e3.storageChanges && e3.storageChanges.length)
            for (var t = 0; t < e3.storageChanges.length; ++t)
              $root.proto.StorageChange.encode(e3.storageChanges[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.ContractStateChange(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.contractId = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.storageChanges && i.storageChanges.length || (i.storageChanges = []), i.storageChanges.push($root.proto.StorageChange.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.ContractStateChange";
        }, e2;
      }(), StorageChange: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.slot = $util.newBuffer([]), e2.prototype.valueRead = $util.newBuffer([]), e2.prototype.valueWritten = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.slot && Object.hasOwnProperty.call(e3, "slot") && o.uint32(10).bytes(e3.slot), null != e3.valueRead && Object.hasOwnProperty.call(e3, "valueRead") && o.uint32(18).bytes(e3.valueRead), null != e3.valueWritten && Object.hasOwnProperty.call(e3, "valueWritten") && $root.google.protobuf.BytesValue.encode(e3.valueWritten, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.StorageChange(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.slot = e3.bytes();
                break;
              }
              case 2: {
                i.valueRead = e3.bytes();
                break;
              }
              case 3: {
                i.valueWritten = $root.google.protobuf.BytesValue.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.StorageChange";
        }, e2;
      }(), HashAlgorithm: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "HASH_ALGORITHM_UNKNOWN"] = 0, o[e2[1] = "SHA_384"] = 1, o;
      }(), HashObject: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.algorithm = 0, e2.prototype.length = 0, e2.prototype.hash = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.algorithm && Object.hasOwnProperty.call(e3, "algorithm") && o.uint32(8).int32(e3.algorithm), null != e3.length && Object.hasOwnProperty.call(e3, "length") && o.uint32(16).int32(e3.length), null != e3.hash && Object.hasOwnProperty.call(e3, "hash") && o.uint32(26).bytes(e3.hash), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.HashObject(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.algorithm = e3.int32();
                break;
              }
              case 2: {
                i.length = e3.int32();
                break;
              }
              case 3: {
                i.hash = e3.bytes();
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.HashObject";
        }, e2;
      }(), RecordStreamFile: function() {
        function e2(e3) {
          if (this.recordStreamItems = [], this.sidecars = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.hapiProtoVersion = null, e2.prototype.startObjectRunningHash = null, e2.prototype.recordStreamItems = $util.emptyArray, e2.prototype.endObjectRunningHash = null, e2.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.sidecars = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.hapiProtoVersion && Object.hasOwnProperty.call(e3, "hapiProtoVersion") && $root.proto.SemanticVersion.encode(e3.hapiProtoVersion, o.uint32(10).fork()).ldelim(), null != e3.startObjectRunningHash && Object.hasOwnProperty.call(e3, "startObjectRunningHash") && $root.proto.HashObject.encode(e3.startObjectRunningHash, o.uint32(18).fork()).ldelim(), null != e3.recordStreamItems && e3.recordStreamItems.length)
            for (var t = 0; t < e3.recordStreamItems.length; ++t)
              $root.proto.RecordStreamItem.encode(e3.recordStreamItems[t], o.uint32(26).fork()).ldelim();
          if (null != e3.endObjectRunningHash && Object.hasOwnProperty.call(e3, "endObjectRunningHash") && $root.proto.HashObject.encode(e3.endObjectRunningHash, o.uint32(34).fork()).ldelim(), null != e3.blockNumber && Object.hasOwnProperty.call(e3, "blockNumber") && o.uint32(40).int64(e3.blockNumber), null != e3.sidecars && e3.sidecars.length)
            for (var t = 0; t < e3.sidecars.length; ++t)
              $root.proto.SidecarMetadata.encode(e3.sidecars[t], o.uint32(50).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.RecordStreamFile(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.hapiProtoVersion = $root.proto.SemanticVersion.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.startObjectRunningHash = $root.proto.HashObject.decode(e3, e3.uint32());
                break;
              }
              case 3: {
                i.recordStreamItems && i.recordStreamItems.length || (i.recordStreamItems = []), i.recordStreamItems.push($root.proto.RecordStreamItem.decode(e3, e3.uint32()));
                break;
              }
              case 4: {
                i.endObjectRunningHash = $root.proto.HashObject.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.blockNumber = e3.int64();
                break;
              }
              case 6: {
                i.sidecars && i.sidecars.length || (i.sidecars = []), i.sidecars.push($root.proto.SidecarMetadata.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.RecordStreamFile";
        }, e2;
      }(), RecordStreamItem: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transaction = null, e2.prototype.record = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.transaction && Object.hasOwnProperty.call(e3, "transaction") && $root.proto.Transaction.encode(e3.transaction, o.uint32(10).fork()).ldelim(), null != e3.record && Object.hasOwnProperty.call(e3, "record") && $root.proto.TransactionRecord.encode(e3.record, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.RecordStreamItem(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.transaction = $root.proto.Transaction.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.record = $root.proto.TransactionRecord.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.RecordStreamItem";
        }, e2;
      }(), SidecarMetadata: function() {
        function e2(e3) {
          if (this.types = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.hash = null, e2.prototype.id = 0, e2.prototype.types = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.hash && Object.hasOwnProperty.call(e3, "hash") && $root.proto.HashObject.encode(e3.hash, o.uint32(10).fork()).ldelim(), null != e3.id && Object.hasOwnProperty.call(e3, "id") && o.uint32(16).int32(e3.id), null != e3.types && e3.types.length) {
            o.uint32(26).fork();
            for (var t = 0; t < e3.types.length; ++t)
              o.int32(e3.types[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SidecarMetadata(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.hash = $root.proto.HashObject.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.id = e3.int32();
                break;
              }
              case 3: {
                if (i.types && i.types.length || (i.types = []), 2 == (7 & d))
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.types.push(e3.int32());
                else
                  i.types.push(e3.int32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SidecarMetadata";
        }, e2;
      }(), SidecarType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "SIDECAR_TYPE_UNKNOWN"] = 0, o[e2[1] = "CONTRACT_STATE_CHANGE"] = 1, o[e2[2] = "CONTRACT_ACTION"] = 2, o[e2[3] = "CONTRACT_BYTECODE"] = 3, o;
      }(), SidecarFile: function() {
        function e2(e3) {
          if (this.sidecarRecords = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.sidecarRecords = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), null != e3.sidecarRecords && e3.sidecarRecords.length)
            for (var t = 0; t < e3.sidecarRecords.length; ++t)
              $root.proto.TransactionSidecarRecord.encode(e3.sidecarRecords[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SidecarFile(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.sidecarRecords && i.sidecarRecords.length || (i.sidecarRecords = []), i.sidecarRecords.push($root.proto.TransactionSidecarRecord.decode(e3, e3.uint32()));
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SidecarFile";
        }, e2;
      }(), TransactionSidecarRecord: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              null != e3[o2[t]] && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.consensusTimestamp = null, e2.prototype.migration = false, e2.prototype.stateChanges = null, e2.prototype.actions = null, e2.prototype.bytecode = null;
        let o;
        return Object.defineProperty(e2.prototype, "sidecarRecords", { get: $util.oneOfGetter(o = ["stateChanges", "actions", "bytecode"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), null != e3.consensusTimestamp && Object.hasOwnProperty.call(e3, "consensusTimestamp") && $root.proto.Timestamp.encode(e3.consensusTimestamp, o2.uint32(10).fork()).ldelim(), null != e3.migration && Object.hasOwnProperty.call(e3, "migration") && o2.uint32(16).bool(e3.migration), null != e3.stateChanges && Object.hasOwnProperty.call(e3, "stateChanges") && $root.proto.ContractStateChanges.encode(e3.stateChanges, o2.uint32(26).fork()).ldelim(), null != e3.actions && Object.hasOwnProperty.call(e3, "actions") && $root.proto.ContractActions.encode(e3.actions, o2.uint32(34).fork()).ldelim(), null != e3.bytecode && Object.hasOwnProperty.call(e3, "bytecode") && $root.proto.ContractBytecode.encode(e3.bytecode, o2.uint32(42).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o2 ? e3.len : e3.pos + o2, i = new $root.proto.TransactionSidecarRecord(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.consensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.migration = e3.bool();
                break;
              }
              case 3: {
                i.stateChanges = $root.proto.ContractStateChanges.decode(e3, e3.uint32());
                break;
              }
              case 4: {
                i.actions = $root.proto.ContractActions.decode(e3, e3.uint32());
                break;
              }
              case 5: {
                i.bytecode = $root.proto.ContractBytecode.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.TransactionSidecarRecord";
        }, e2;
      }(), SignatureFile: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileSignature = null, e2.prototype.metadataSignature = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.fileSignature && Object.hasOwnProperty.call(e3, "fileSignature") && $root.proto.SignatureObject.encode(e3.fileSignature, o.uint32(10).fork()).ldelim(), null != e3.metadataSignature && Object.hasOwnProperty.call(e3, "metadataSignature") && $root.proto.SignatureObject.encode(e3.metadataSignature, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SignatureFile(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.fileSignature = $root.proto.SignatureObject.decode(e3, e3.uint32());
                break;
              }
              case 2: {
                i.metadataSignature = $root.proto.SignatureObject.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SignatureFile";
        }, e2;
      }(), SignatureObject: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              null != e3[o[t]] && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.type = 0, e2.prototype.length = 0, e2.prototype.checksum = 0, e2.prototype.signature = $util.newBuffer([]), e2.prototype.hashObject = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), null != e3.type && Object.hasOwnProperty.call(e3, "type") && o.uint32(8).int32(e3.type), null != e3.length && Object.hasOwnProperty.call(e3, "length") && o.uint32(16).int32(e3.length), null != e3.checksum && Object.hasOwnProperty.call(e3, "checksum") && o.uint32(24).int32(e3.checksum), null != e3.signature && Object.hasOwnProperty.call(e3, "signature") && o.uint32(34).bytes(e3.signature), null != e3.hashObject && Object.hasOwnProperty.call(e3, "hashObject") && $root.proto.HashObject.encode(e3.hashObject, o.uint32(42).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = void 0 === o ? e3.len : e3.pos + o, i = new $root.proto.SignatureObject(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1: {
                i.type = e3.int32();
                break;
              }
              case 2: {
                i.length = e3.int32();
                break;
              }
              case 3: {
                i.checksum = e3.int32();
                break;
              }
              case 4: {
                i.signature = e3.bytes();
                break;
              }
              case 5: {
                i.hashObject = $root.proto.HashObject.decode(e3, e3.uint32());
                break;
              }
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.getTypeUrl = function(e3) {
          return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/proto.SignatureObject";
        }, e2;
      }(), SignatureType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "SIGNATURE_TYPE_UNKNOWN"] = 0, o[e2[1] = "SHA_384_WITH_RSA"] = 1, o;
      }() };
      return e;
    })();
    exports2.proto = proto42;
    var google = $root.google = (() => {
      const e = { protobuf: function() {
        const e2 = { DoubleValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(9).double(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.DoubleValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.double();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.DoubleValue";
          }, e3;
        }(), FloatValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(13).float(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.FloatValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.float();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.FloatValue";
          }, e3;
        }(), Int64Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).int64(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.Int64Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.int64();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.Int64Value";
          }, e3;
        }(), UInt64Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).uint64(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.UInt64Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.uint64();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.UInt64Value";
          }, e3;
        }(), Int32Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).int32(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.Int32Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.int32();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.Int32Value";
          }, e3;
        }(), UInt32Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).uint32(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.UInt32Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.uint32();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.UInt32Value";
          }, e3;
        }(), BoolValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = false, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).bool(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.BoolValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.bool();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.BoolValue";
          }, e3;
        }(), StringValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = "", e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(10).string(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.StringValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.string();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.StringValue";
          }, e3;
        }(), BytesValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                null != e4[o[t]] && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), null != e4.value && Object.hasOwnProperty.call(e4, "value") && o.uint32(10).bytes(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = void 0 === o ? e4.len : e4.pos + o, i = new $root.google.protobuf.BytesValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1: {
                  i.value = e4.bytes();
                  break;
                }
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3.getTypeUrl = function(e4) {
            return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/google.protobuf.BytesValue";
          }, e3;
        }() };
        return e2;
      }() };
      return e;
    })();
    exports2.google = google;
  }
});

// node_modules/@hashgraph/proto/lib/index.js
var require_lib = __commonJS({
  "node_modules/@hashgraph/proto/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true }), exports2.proto = exports2.google = exports2.com = exports2.Writer = exports2.Reader = void 0;
    var $protobuf = _interopRequireWildcard(require_minimal2());
    var _long = _interopRequireDefault(require_long());
    var $proto = _interopRequireWildcard(require_proto());
    function _interopRequireDefault(a) {
      return a && a.__esModule ? a : { default: a };
    }
    function _getRequireWildcardCache(a) {
      if ("function" != typeof WeakMap)
        return null;
      var b = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(a2) {
        return a2 ? c : b;
      })(a);
    }
    function _interopRequireWildcard(b, c) {
      if (!c && b && b.__esModule)
        return b;
      if (null === b || "object" != typeof b && "function" != typeof b)
        return { default: b };
      var d = _getRequireWildcardCache(c);
      if (d && d.has(b))
        return d.get(b);
      var e = { __proto__: null }, f3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var a in b)
        if ("default" != a && Object.prototype.hasOwnProperty.call(b, a)) {
          var g = f3 ? Object.getOwnPropertyDescriptor(b, a) : null;
          g && (g.get || g.set) ? Object.defineProperty(e, a, g) : e[a] = b[a];
        }
      return e.default = b, d && d.set(b, e), e;
    }
    (() => {
      var a = $protobuf.util;
      null == a.Long && (console.log(`Patching Protobuf Long.js instance...`), a.Long = _long.default, null != $protobuf.Reader._configure && $protobuf.Reader._configure($protobuf.BufferReader));
    })();
    var Reader2 = $protobuf.Reader;
    exports2.Reader = Reader2;
    var Writer2 = $protobuf.Writer;
    exports2.Writer = Writer2;
    var proto42 = $proto.proto;
    exports2.proto = proto42;
    var com3 = $proto.com;
    exports2.com = com3;
    var google = $proto.google;
    exports2.google = google;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl5) {
      "use strict";
      var gf = function(init) {
        var i, r2 = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r2[i] = init[i];
        return r2;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes3) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes3 >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes3 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f3, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f3 = this.h[0] + this.pad[0];
        this.h[0] = f3 & 65535;
        for (i = 1; i < 8; i++) {
          f3 = (this.h[i] + this.pad[i] | 0) + (f3 >>> 16) | 0;
          this.h[i] = f3 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes3) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes3)
            want = bytes3;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes3 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes3 >= 16) {
          want = bytes3 - bytes3 % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes3 -= want;
        }
        if (bytes3) {
          for (i = 0; i < bytes3; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes3;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r2, a) {
        var i;
        for (i = 0; i < 16; i++)
          r2[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r2, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f3 = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r2 = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r2);
          sel25519(c, d, r2);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f3, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f3);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f3);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r2);
          sel25519(c, d, r2);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f3 = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f3, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f3);
        M(p[1], h, g);
        M(p[2], g, f3);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack2(r2, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r2, ty);
        r2[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack2(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r2, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r2[i] = x[i] & 255;
        }
      }
      function reduce(r2) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r2[i];
        for (i = 0; i < 64; i++)
          r2[i] = 0;
        modL(r2, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r2 = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r2, sm.subarray(32), n + 32);
        reduce(r2);
        scalarbase(p, r2);
        pack2(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r2[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r2, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r2[2], gf1);
        unpack25519(r2[1], p);
        S(num, r2[1]);
        M(den, num, D);
        Z(num, num, r2[2]);
        A(den, r2[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r2[0], t, den);
        S(chk, r2[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r2[0], r2[0], I);
        S(chk, r2[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r2[0]) === p[31] >> 7)
          Z(r2[0], gf0, r2[0]);
        M(r2[3], r2[0], r2[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack2(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl5.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl5.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl5.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl5.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl5.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl5.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl5.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl5.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl5.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl5.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl5.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl5.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox(msg, nonce, k);
      };
      nacl5.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl5.box.after = nacl5.secretbox;
      nacl5.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox.open(msg, nonce, k);
      };
      nacl5.box.open.after = nacl5.secretbox.open;
      nacl5.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl5.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl5.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl5.box.nonceLength = crypto_box_NONCEBYTES;
      nacl5.box.overheadLength = nacl5.secretbox.overheadLength;
      nacl5.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl5.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl5.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl5.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl5.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl5.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl5.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl5.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl5.sign.signatureLength = crypto_sign_BYTES;
      nacl5.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl5.hash.hashLength = crypto_hash_BYTES;
      nacl5.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl5.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl5.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl5.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i = 0;
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length; ++i) {
          for (var j = 0, carry = input[i]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
          output += first;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet[digits[i]];
        }
      }
      if (maxline) {
        var regex2 = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex2).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i = 0; i < alphabet.length; ++i) {
          table[alphabet.charCodeAt(i)] = i;
        }
      }
      input = input.replace(/\s/g, "");
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var bytes3 = [0];
      for (var i = 0; i < input.length; i++) {
        var value = table[input.charCodeAt(i)];
        if (value === void 0) {
          return;
        }
        for (var j = 0, carry = value; j < bytes3.length; ++j) {
          carry += bytes3[j] * base;
          bytes3[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes3.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
        bytes3.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes3.reverse());
      }
      return new Uint8Array(bytes3.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i = 0;
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length(); ++i) {
        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      var output = "";
      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
        output += first;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet[digits[i]];
      }
      return output;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge4 = require_forge();
    var baseN = require_baseN();
    var util = module2.exports = forge4.util = forge4.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i = 0; i < arr.length; ++i) {
              this.putByte(arr[i]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes3) {
      this.data += bytes3;
      this._optimizeConstructedString(bytes3.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      var bytes3 = "";
      do {
        n -= 8;
        bytes3 += String.fromCharCode(i >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes3);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b);
      var isArrayBufferView = util.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes3, encoding) {
      if (util.isArrayBufferView(bytes3)) {
        var src = new Uint8Array(bytes3.buffer, bytes3.byteOffset, bytes3.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes3)) {
        var src = new Uint8Array(bytes3);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes3 instanceof util.DataBuffer || typeof bytes3 === "object" && typeof bytes3.read === "number" && typeof bytes3.write === "number" && util.isArrayBufferView(bytes3.data)) {
        var src = new Uint8Array(bytes3.data.byteLength, bytes3.read, bytes3.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes3.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes3 instanceof util.ByteStringBuffer) {
        bytes3 = bytes3.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes3 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes3.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes3.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes3 = util.encodeUtf8(bytes3);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes3.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes3.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes3);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 65535);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.data.setInt16(this.write, i >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 255);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i = 0;
      if (hex.length & true) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes3) {
      return util.createBuffer(bytes3).toHex();
    };
    util.int32ToBytes = function(i) {
      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes3) {
      return String.fromCharCode.apply(null, bytes3);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0, j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? j - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i = 0, j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.text.utf8.decode = function(bytes3) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes3));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util.text.utf16.decode = function(bytes3) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes3.buffer));
    };
    util.deflate = function(api, bytes3, raw) {
      bytes3 = util.decode64(api.deflate(util.encode64(bytes3)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes3.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes3 = bytes3.substring(start, bytes3.length - 4);
      }
      return bytes3;
    };
    util.inflate = function(api, bytes3, raw) {
      var rval = api.inflate(util.encode64(bytes3)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id2, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id2);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id2, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id2) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id2);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id2, key, data) {
      var obj = _getStorageObject(api, id2);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id2, obj);
    };
    var _getItem = function(api, id2, key) {
      var rval = _getStorageObject(api, id2);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id2, key) {
      var obj = _getStorageObject(api, id2);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = true;
        for (var prop in obj) {
          empty = false;
          break;
        }
        if (empty) {
          obj = null;
        }
        _setStorageObject(api, id2, obj);
      }
    };
    var _clearItems = function(api, id2) {
      _setStorageObject(api, id2, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id2, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id2, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id2, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id2, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re.exec(format)) {
        part = format.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code = match[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format.substring(last));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i.length > 3 ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros2 = (8 - ip.length + blanks) * 2;
      var b = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros2);
          zeros2 = 0;
          continue;
        }
        var bytes3 = util.hexToBytes(ip[i]);
        if (bytes3.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes3);
      }
      return b.getBytes();
    };
    util.bytesToIP = function(bytes3) {
      if (bytes3.length === 4) {
        return util.bytesToIPv4(bytes3);
      }
      if (bytes3.length === 16) {
        return util.bytesToIPv6(bytes3);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes3) {
      if (bytes3.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes3.length; ++i) {
        ip.push(bytes3.charCodeAt(i));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes3) {
      if (bytes3.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes3.length; i += 2) {
        var hex = util.bytesToHex(bytes3[i] + bytes3[i + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        (function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et)
              ;
            self.postMessage({ st, et });
          });
        }).toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    module2.exports = forge4.cipher = forge4.cipher || {};
    forge4.cipher.algorithms = forge4.cipher.algorithms || {};
    forge4.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge4.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge4.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge4.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge4.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge4.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge4.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge4.cipher.algorithms[name] = algorithm;
    };
    forge4.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge4.cipher.algorithms) {
        return forge4.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge4.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge4.util.createBuffer();
      this.output = options.output || forge4.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    forge4.cipher = forge4.cipher || {};
    var modes = module2.exports = forge4.cipher.modes = forge4.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding2 = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding2, padding2);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding2 = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding2, padding2);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge4.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge4.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge4.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge4.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge4.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge4.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge4.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge4.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge4.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge4.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = i / 8 | 0;
        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = i / perInt | 0;
        var shft = (perInt - 1 - i % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m[2 * i], m[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m[i];
          var m_j = m[j];
          m[i + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m[i ^ half];
        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge4.util.createBuffer(iv);
      }
      if (forge4.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge4.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge4.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i = 0; i < blocks; ++i) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge4 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge4.aes = forge4.aes || {};
    forge4.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge4.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge4.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge4.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge4.aes.Algorithm = function(name, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge4.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge4.util.createBuffer(key);
      } else if (forge4.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge4.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge4.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge4.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge4.aes._expandKey = function(key, decrypt) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt);
    };
    forge4.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge4.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge4.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge4.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge4.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge4.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge4.cipher.modes.gcm);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge4.aes.Algorithm(name, mode);
      };
      forge4.cipher.registerAlgorithm(name, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = i + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
        (e ^ e8) << 16 ^ // 9
        (e ^ e4 ^ e8) << 8 ^ // D (13)
        (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt) {
      var w = key.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i] = w[i - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === end - Nb) {
            wnew[i] = w[wi];
            wnew[i + 1] = w[wi + 3];
            wnew[i + 2] = w[wi + 2];
            wnew[i + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt ? 1 : 3] ^ w[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
      output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
      output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge4.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge4.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge4.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge4 = require_forge();
    forge4.pki = forge4.pki || {};
    var oids = module2.exports = forge4.pki.oids = forge4.oids = forge4.oids || {};
    function _IN(id2, name) {
      oids[id2] = name;
      oids[name] = id2;
    }
    function _I_(id2, name) {
      oids[id2] = name;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge4.asn1 = forge4.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge4.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== void 0) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge4.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge4.util.isArray(obj)) {
        copy = [];
        for (var i = 0; i < obj.length; ++i) {
          copy.push(asn1.copy(obj[i], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge4.util.isArray(obj1)) {
        if (!forge4.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i = 0; i < obj1.length; ++i) {
          if (!asn1.equals(obj1[i], obj2[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length;
      var longForm = b2 & 128;
      if (!longForm) {
        length = b2;
      } else {
        length = b.getInt((b2 & 127) << 3);
      }
      return length;
    };
    function _checkBufferLength(bytes3, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes3.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes3, remaining) {
      var b2 = bytes3.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length;
      var longForm = b2 & 128;
      if (!longForm) {
        length = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes3, remaining, longFormBytes);
        length = bytes3.getInt(longFormBytes << 3);
      }
      if (length < 0) {
        throw new Error("Negative length: " + length);
      }
      return length;
    };
    asn1.fromDer = function(bytes3, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes3 === "string") {
        bytes3 = forge4.util.createBuffer(bytes3);
      }
      var byteCount = bytes3.length();
      var value = _fromDer(bytes3, bytes3.length(), 0, options);
      if (options.parseAllBytes && bytes3.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes3.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes3, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes3, remaining, 2);
      var b1 = bytes3.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes3.length();
      var length = _getValueLength(bytes3, remaining);
      remaining -= start - bytes3.length();
      if (length !== void 0 && length > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes3.length();
          error.remaining = remaining;
          error.requested = length;
          throw error;
        }
        length = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes3, remaining, 2);
            if (bytes3.bytes(2) === String.fromCharCode(0, 0)) {
              bytes3.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes3.length();
            value.push(_fromDer(bytes3, remaining, depth + 1, options));
            remaining -= start - bytes3.length();
          }
        } else {
          while (length > 0) {
            start = bytes3.length();
            value.push(_fromDer(bytes3, length, depth + 1, options));
            remaining -= start - bytes3.length();
            length -= start - bytes3.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes3.bytes(length);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length > 1) {
        var savedRead = bytes3.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes3, remaining, 1);
          unused = bytes3.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes3.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes3, remaining, depth + 1, subOptions);
            var used = start - bytes3.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes3.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length > 0; length -= 2) {
            _checkBufferLength(bytes3, remaining, 2);
            value += String.fromCharCode(bytes3.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes3.getBytes(length);
          remaining -= length;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes3 = forge4.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge4.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes3.putByte(b1);
      if (value.length() <= 127) {
        bytes3.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes3.putByte(lenBytes.length | 128);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes3.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes3.putBuffer(value);
      return bytes3;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes3 = forge4.util.createBuffer();
      bytes3.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b;
      for (var i = 2; i < values.length; ++i) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i], 10);
        do {
          b = value & 127;
          value = value >>> 7;
          if (!last) {
            b |= 128;
          }
          valueBytes.push(b);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes3.putByte(valueBytes[n]);
        }
      }
      return bytes3;
    };
    asn1.derToOid = function(bytes3) {
      var oid;
      if (typeof bytes3 === "string") {
        bytes3 = forge4.util.createBuffer(bytes3);
      }
      var b = bytes3.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value = 0;
      while (bytes3.length() > 0) {
        b = bytes3.getByte();
        value = value << 7;
        if (b & 128) {
          value += b & 127;
        } else {
          oid += "." + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge4.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes3) {
      if (typeof bytes3 === "string") {
        bytes3 = forge4.util.createBuffer(bytes3);
      }
      var n = bytes3.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes3.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge4.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v.tagClass) {
          errors.push(
            "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v.type) {
          errors.push(
            "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i = 0; i < level * indentation; ++i) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if (i + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge4.pki && forge4.pki.oids) {
            if (oid in forge4.pki.oids) {
              rval += " (" + forge4.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge4.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge4.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge4.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge4.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge4.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge4.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge4 = require_forge();
    module2.exports = forge4.md = forge4.md || {};
    forge4.md.algorithms = forge4.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge4 = require_forge();
    require_md();
    require_util();
    var hmac = module2.exports = forge4.hmac = forge4.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge4.md.algorithms) {
              _md = forge4.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge4.util.createBuffer(key);
          } else if (forge4.util.isArray(key)) {
            var tmp = key;
            key = forge4.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge4.util.createBuffer();
          _opadding = forge4.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes3) {
        _md.update(bytes3);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/md5.js
var require_md5 = __commonJS({
  "node_modules/node-forge/lib/md5.js"(exports2, module2) {
    var forge4 = require_forge();
    require_md();
    require_util();
    var md5 = module2.exports = forge4.md5 = forge4.md5 || {};
    forge4.md.md5 = forge4.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge4.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge4.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge4.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge4.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var bits, carry = 0;
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          bits = md.fullMessageLength[i] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, finalBlock);
        var rval = forge4.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _g = null;
    var _r = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge4.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i = 0; i < 64; ++i) {
        _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
      }
      _initialized = true;
    }
    function _update(s, w, bytes3) {
      var t, a, b, c, d, f3, r2, i;
      var len = bytes3.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        for (i = 0; i < 16; ++i) {
          w[i] = bytes3.getInt32Le();
          f3 = d ^ b & (c ^ d);
          t = a + f3 + _k[i] + w[i];
          r2 = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r2 | t >>> 32 - r2;
        }
        for (; i < 32; ++i) {
          f3 = c ^ d & (b ^ c);
          t = a + f3 + _k[i] + w[_g[i]];
          r2 = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r2 | t >>> 32 - r2;
        }
        for (; i < 48; ++i) {
          f3 = b ^ c ^ d;
          t = a + f3 + _k[i] + w[_g[i]];
          r2 = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r2 | t >>> 32 - r2;
        }
        for (; i < 64; ++i) {
          f3 = c ^ (b | ~d);
          t = a + f3 + _k[i] + w[_g[i]];
          r2 = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r2 | t >>> 32 - r2;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    var pem = module2.exports = forge4.pem = forge4.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge4.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge4.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length = i - candidate - 1;
          candidate = -1;
          ++i;
        } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
          candidate = i;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge4 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge4.des = forge4.des || {};
    forge4.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge4.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge4.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge4.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge4.des.Algorithm = function(name, mode) {
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge4.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge4.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge4.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge4.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge4.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge4.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge4.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge4.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge4.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge4.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge4.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge4.cipher.modes.ctr);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge4.des.Algorithm(name, mode);
      };
      forge4.cipher.registerAlgorithm(name, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys[i];
          var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge4.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge4.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge4.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge4 = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge4.pkcs5 = forge4.pkcs5 || {};
    var crypto2;
    if (forge4.util.isNodejs && !forge4.options.usePureJavaScript) {
      crypto2 = require_crypto();
    }
    module2.exports = forge4.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge4.util.isNodejs && !forge4.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p, s, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge4.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge4.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge4.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge4.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge4.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i < len ? xor : xor.substr(0, r2);
        }
        return dk;
      }
      var i = 1, j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge4.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge4.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge4.util.setImmediate(inner);
        }
        dk += i < len ? xor : xor.substr(0, r2);
        ++i;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge4 = require_forge();
    require_md();
    require_util();
    var sha256 = module2.exports = forge4.sha256 = forge4.sha256 || {};
    forge4.md.sha256 = forge4.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge4.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge4.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge4.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge4.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge4.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge4.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes3) {
      var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f3, g, h;
      var len = bytes3.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w[i] = bytes3.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w[i - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f3 = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f3 ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i] + w[i];
          t2 = s0 + maj;
          h = g;
          g = f3;
          f3 = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f3 | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    var _crypto = null;
    if (forge4.util.isNodejs && !forge4.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto();
    }
    var prng = module2.exports = forge4.prng = forge4.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge4.util.createBuffer();
        ctx.key = null;
        generate2();
        function generate2(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge4.util.nextTick(function() {
              _reseed(generate2);
            });
          }
          var bytes3 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes3.length;
          b.putBytes(bytes3);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge4.util.setImmediate(generate2);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge4.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes3 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes3.length;
          b.putBytes(bytes3);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes3) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes3);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge4.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge4.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i2 = 0; i2 < entropy.length; ++i2) {
                b.putInt32(entropy[i2]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i2 = 0; i2 < 3; ++i2) {
              next = seed >>> (i2 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes3) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes3.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes3) {
        var count = bytes3.length;
        for (var i2 = 0; i2 < count; ++i2) {
          ctx.pools[ctx.pool].update(bytes3.substr(i2, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i2, n) {
        var bytes3 = "";
        for (var x = 0; x < n; x += 8) {
          bytes3 += String.fromCharCode(i2 >> x & 255);
        }
        ctx.collect(bytes3);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes3) {
                worker.postMessage({ forge: { prng: { err, bytes: bytes3 } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge4 = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge4.random && forge4.random.getBytes) {
        module2.exports = forge4.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge4.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge4.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge4.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge4.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge4.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge4.md.sha256;
        function spawnPrng() {
          var ctx = forge4.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge4.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge4.options.usePureJavaScript || !forge4.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge4.random) {
          forge4.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge4.random[key] = _ctx[key];
          }
        }
        forge4.random.createInstance = spawnPrng;
        module2.exports = forge4.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge4.rc2 = forge4.rc2 || {};
    forge4.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge4.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i, j, K = [];
      key = forge4.rc2.expandKey(key, bits);
      for (i = 0; i < 64; i++) {
        K.push(key.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge4.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge4.util.createBuffer();
          _output = output || new forge4.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt) {
            if (pad) {
              rval = pad(8, _input, !encrypt);
            } else {
              var padding2 = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding2, padding2);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge4.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge4.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge4.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge4.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge4.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge4.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge4 = require_forge();
    module2.exports = forge4.jsbn = forge4.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    forge4.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 32767;
        var h = this.data[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 16383;
        var h = this.data[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r2) {
      for (var i = this.t - 1; i >= 0; --i)
        r2.data[i] = this.data[i];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r2 = nbi();
      r2.fromInt(i);
      return r2;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r2 = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) > 0) {
          m = true;
          r2 = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this.data[i] & (1 << p) - 1) << k - p;
            d |= this.data[--i] >> (p += this.DB - k);
          } else {
            d = this.data[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r2 += int2char(d);
        }
      }
      return m ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r2 = this.s - a.s;
      if (r2 != 0)
        return r2;
      var i = this.t;
      r2 = i - a.t;
      if (r2 != 0)
        return this.s < 0 ? -r2 : r2;
      while (--i >= 0)
        if ((r2 = this.data[i] - a.data[i]) != 0)
          return r2;
      return 0;
    }
    function nbits(x) {
      var r2 = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r2 += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r2 += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r2 += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r2 += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r2) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r2.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i)
        r2.data[i] = 0;
      r2.t = this.t + n;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n, r2) {
      for (var i = n; i < this.t; ++i)
        r2.data[i - n] = this.data[i];
      r2.t = Math.max(this.t - n, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n, r2) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r2.data[i + ds + 1] = this.data[i] >> cbs | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r2.data[i] = 0;
      r2.data[ds] = c;
      r2.t = this.t + ds + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n, r2) {
      r2.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r2.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r2.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r2.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r2.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0)
        r2.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r2.t = this.t - ds;
      r2.clamp();
    }
    function bnpSubTo(a, r2) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] - a.data[i];
        r2.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r2.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r2.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r2.s = c < 0 ? -1 : 0;
      if (c < -1)
        r2.data[i++] = this.DV + c;
      else if (c > 0)
        r2.data[i++] = c;
      r2.t = i;
      r2.clamp();
    }
    function bnpMultiplyTo(a, r2) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r2.t = i + y.t;
      while (--i >= 0)
        r2.data[i] = 0;
      for (i = 0; i < y.t; ++i)
        r2.data[i + x.t] = x.am(0, y.data[i], r2, i, 0, x.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x = this.abs();
      var i = r2.t = 2 * x.t;
      while (--i >= 0)
        r2.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r2, 2 * i, 0, 1);
        if ((r2.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r2, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r2.data[i + x.t] -= x.DV;
          r2.data[i + x.t + 1] = 1;
        }
      }
      if (r2.t > 0)
        r2.data[r2.t - 1] += x.am(i, x.data[i], r2, 2 * i, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m, q, r2) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r2 != null)
          this.copyTo(r2);
        return;
      }
      if (r2 == null)
        r2 = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r2);
      } else {
        pm.copyTo(y);
        pt.copyTo(r2);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r2.t, j = i - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r2.compareTo(t) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t, r2);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r2.data[--i] == y0 ? this.DM : Math.floor(r2.data[i] * d1 + (r2.data[i - 1] + e) * d2);
        if ((r2.data[i] += y.am(0, qd, r2, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r2.subTo(t, r2);
          while (r2.data[i] < --qd)
            r2.subTo(t, r2);
        }
      }
      if (q != null) {
        r2.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r2.t = ys;
      r2.clamp();
      if (nsh > 0)
        r2.rShiftTo(nsh, r2);
      if (ts < 0)
        BigInteger.ZERO.subTo(r2, r2);
    }
    function bnMod(a) {
      var r2 = nbi();
      this.abs().divRemTo(a, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r2, r2);
      return r2;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r2) {
      x.multiplyTo(y, r2);
      this.reduce(r2);
    }
    function cSqrTo(x, r2) {
      x.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r2 = nbi();
      x.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x) {
      var r2 = nbi();
      x.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r2) {
      x.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x, y, r2) {
      x.multiplyTo(y, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r2 = nbi(), r22 = nbi(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r2);
      while (--i >= 0) {
        z.sqrTo(r2, r22);
        if ((e & 1 << i) > 0)
          z.mulTo(r22, g, r2);
        else {
          var t = r2;
          r2 = r22;
          r22 = t;
        }
      }
      return z.revert(r2);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r2 = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r2 = (a + z.intValue()).toString(b).substr(1) + r2;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r2;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r2 = new Array();
      r2[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
          r2[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this.data[i] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d = this.data[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r2[k++] = d;
        }
      }
      return r2;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r2) {
      var i, f3, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r2.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f3 = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r2.data[i] = op(this.data[i], f3);
        r2.t = this.t;
      } else {
        f3 = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r2.data[i] = op(f3, a.data[i]);
        r2.t = a.t;
      }
      r2.s = op(this.s, a.s);
      r2.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_and, r2);
      return r2;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_or, r2);
      return r2;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_xor, r2);
      return r2;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r2 = nbi();
      this.bitwiseTo(a, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i = 0; i < this.t; ++i)
        r2.data[i] = this.DM & ~this.data[i];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n) {
      var r2 = nbi();
      if (n < 0)
        this.rShiftTo(-n, r2);
      else
        this.lShiftTo(n, r2);
      return r2;
    }
    function bnShiftRight(n) {
      var r2 = nbi();
      if (n < 0)
        this.lShiftTo(-n, r2);
      else
        this.rShiftTo(n, r2);
      return r2;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r2 = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r2 += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r2 += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r2 += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r2 += 2;
      }
      if ((x & 1) == 0)
        ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0)
          return i * this.DB + lbit(this.data[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r2 = 0;
      while (x != 0) {
        x &= x - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r2 += cbit(this.data[i] ^ x);
      return r2;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r2 = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r2, op, r2);
      return r2;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r2) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] + a.data[i];
        r2.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r2.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r2.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r2.s = c < 0 ? -1 : 0;
      if (c > 0)
        r2.data[i++] = c;
      else if (c < -1)
        r2.data[i++] = this.DV + c;
      r2.t = i;
      r2.clamp();
    }
    function bnAdd(a) {
      var r2 = nbi();
      this.addTo(a, r2);
      return r2;
    }
    function bnSubtract(a) {
      var r2 = nbi();
      this.subTo(a, r2);
      return r2;
    }
    function bnMultiply(a) {
      var r2 = nbi();
      this.multiplyTo(a, r2);
      return r2;
    }
    function bnDivide(a) {
      var r2 = nbi();
      this.divRemTo(a, r2, null);
      return r2;
    }
    function bnRemainder(a) {
      var r2 = nbi();
      this.divRemTo(a, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r2 = nbi();
      this.divRemTo(a, q, r2);
      return new Array(q, r2);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r2) {
      x.multiplyTo(y, r2);
    }
    function nSqrTo(x, r2) {
      x.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r2) {
      var i = Math.min(this.t + a.t, n);
      r2.s = 0;
      r2.t = i;
      while (i > 0)
        r2.data[--i] = 0;
      var j;
      for (j = r2.t - this.t; i < j; ++i)
        r2.data[i + this.t] = this.am(0, a.data[i], r2, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a.data[i], r2, i, 0, n - i);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r2) {
      --n;
      var i = r2.t = this.t + a.t - n;
      r2.s = 0;
      while (--i >= 0)
        r2.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r2.data[this.t + i - n] = this.am(n - i, a.data[i], r2, 0, 0, this.t + i - n);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r2 = nbi();
        x.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r2) {
      x.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x, y, r2) {
      x.multiplyTo(y, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r2 = nbv(1), z;
      if (i <= 0)
        return r2;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r22 = nbi(), t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e.data[j] >> i - k1 & km;
        else {
          w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e.data[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r2);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r2, r22);
            z.sqrTo(r22, r2);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r2, r22);
          else {
            t = r2;
            r2 = r22;
            r22 = t;
          }
          z.mulTo(r22, g[w], r2);
        }
        while (j >= 0 && (e.data[j] & 1 << i) == 0) {
          z.sqrTo(r2, r22);
          t = r2;
          r2 = r22;
          r22 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r2);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r2 = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r2 = this.data[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r2 = (d * r2 + this.data[i]) % n;
      return r2;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r2 = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r2, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge4 = require_forge();
    require_md();
    require_util();
    var sha1 = module2.exports = forge4.sha1 = forge4.sha1 || {};
    forge4.md.sha1 = forge4.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge4.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge4.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge4.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge4.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge4.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge4.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes3) {
      var t, a, b, c, d, e, f3, i;
      var len = bytes3.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes3.getInt32();
          w[i] = t;
          f3 = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f3 + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f3 = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f3 + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f3 = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f3 + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f3 = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f3 + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f3 = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f3 + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f3 = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f3 + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge4.pkcs1 = forge4.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge4.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i = 0; i < PS_length; i++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge4.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge4.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge4.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge4.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge4.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge4.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y !== "\0";
      for (var i = 0; i < md.digestLength; ++i) {
        error |= lHash.charAt(i) !== lHashPrime.charAt(i);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code = db.charCodeAt(j);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash2) {
      if (!hash2) {
        hash2 = forge4.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash2.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode(
          i >> 24 & 255,
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
        );
        hash2.start();
        hash2.update(seed + c);
        t += hash2.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge4.prime) {
        module2.exports = forge4.prime;
        return;
      }
      var prime = module2.exports = forge4.prime = forge4.prime || {};
      var BigInteger = forge4.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge4.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge4.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge4.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate2();
          });
        }
        generate2();
        function generate2() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i = 0; i < numWorkers; ++i) {
            workers[i] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i2 = 0; i2 < workers.length; ++i2) {
                workers[i2].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge4 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge4.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge4.util.isNodejs ? require_crypto() : null;
    var asn1 = forge4.asn1;
    var util = forge4.util;
    forge4.pki = forge4.pki || {};
    module2.exports = forge4.pki.rsa = forge4.rsa = forge4.rsa || {};
    var pki = forge4.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge4.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest3 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest3);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r2;
      do {
        r2 = new BigInteger(
          forge4.util.bytesToHex(forge4.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r2.compareTo(key.n) >= 0 || !r2.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r2.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r2.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge4.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge4.util.createBuffer();
      var zeros2 = k - Math.ceil(yhex.length / 2);
      while (zeros2 > 0) {
        ed.putByte(0);
        --zeros2;
      }
      ed.putBytes(forge4.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge4.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge4.util.createBuffer();
      var zeros2 = k - Math.ceil(xhex.length / 2);
      while (zeros2 > 0) {
        eb.putByte(0);
        --zeros2;
      }
      eb.putBytes(forge4.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge4.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge4.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge4.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair = e2.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge4.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge4.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest3, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest4, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge4.oids.md2 || oid === forge4.oids.md5 || oid === forge4.oids.sha1 || oid === forge4.oids.sha224 || oid === forge4.oids.sha256 || oid === forge4.oids.sha384 || oid === forge4.oids.sha512 || oid === forge4.oids["sha512-224"] || oid === forge4.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge4.oids.md2 || oid === forge4.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest4 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest4, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest4 === d2;
            }
          };
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest3, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge4.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge4.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge4.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge4.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge4.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge4.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge4.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge4.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge4.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge4.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d, 16),
        new BigInteger(p, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n = forge4.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge4.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge4.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge4.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge4.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate2();
      function generate2() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge4.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate2();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate2();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes3 = forge4.util.hexToBytes(hex);
      if (bytes3.length > 1 && // leading 0x00 for positive integer
      (bytes3.charCodeAt(0) === 0 && (bytes3.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes3.charCodeAt(0) === 255 && (bytes3.charCodeAt(1) & 128) === 128)) {
        return bytes3.substr(1);
      }
      return bytes3;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge4.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes3 = forge4.util.hexToBytes(x.toString(16));
      var buffer = new Uint8Array(bytes3.length);
      for (var i = 0; i < bytes3.length; ++i) {
        buffer[i] = bytes3.charCodeAt(i);
      }
      return buffer;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge4 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge4.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge4.asn1;
    var pki = forge4.pki = forge4.pki || {};
    module2.exports = pki.pbe = forge4.pbe = forge4.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge4.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge4.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge4.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge4.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge4.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge4.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge4.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge4.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge4.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge4.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge4.random.getBytesSync(16);
          cipherFn = forge4.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge4.random.getBytesSync(16);
          cipherFn = forge4.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge4.random.getBytesSync(16);
          cipherFn = forge4.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge4.random.getBytesSync(8);
          cipherFn = forge4.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge4.random.getBytesSync(8);
          cipherFn = forge4.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge4.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge4.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge4.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge4.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge4.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge4.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge4.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge4.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge4.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge4.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge4.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge4.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge4.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge4.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id2, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge4.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge4.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge4.util.ByteBuffer();
      var passBuf = new forge4.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge4.util.ByteBuffer();
      D.fillWithByte(id2, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge4.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge4.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf = new forge4.util.ByteBuffer();
        buf.putBytes(D.bytes());
        buf.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B = new forge4.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge4.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge4.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge4.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge4.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge4.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge4.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge4.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge4.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge4.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge4.util.createBuffer(capture.salt);
      var count = forge4.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge4.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge4.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge4.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge4.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash2(md, password + salt)];
      for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
        digests.push(hash2(md, digests[i - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash2(md, bytes3) {
      return md.start().update(bytes3).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge4.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge4.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge4.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    var forge4 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge4.asn1;
    var p7v = module2.exports = forge4.pkcs7asn1 = forge4.pkcs7asn1 || {};
    forge4.pkcs7 = forge4.pkcs7 || {};
    forge4.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    forge4.mgf = forge4.mgf || {};
    var mgf1 = module2.exports = forge4.mgf.mgf1 = forge4.mgf1 = forge4.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: function(seed, maskLen) {
          var t = new forge4.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge4.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    var forge4 = require_forge();
    require_mgf1();
    module2.exports = forge4.mgf = forge4.mgf || {};
    forge4.mgf.mgf1 = forge4.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports2, module2) {
    var forge4 = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge4.pss = forge4.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash2 = options.md;
      var mgf = options.mgf;
      var hLen = hash2.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge4.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge4.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge4.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h = hash2.digest().getBytes();
        var ps = new forge4.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen2 = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen2; i++) {
          if (db.charCodeAt(i) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen2) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge4.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h_ = hash2.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports2, module2) {
    var forge4 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge4.asn1;
    var pki = module2.exports = forge4.pki = forge4.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge4.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i = 0; i < set.value.length; ++i) {
          obj = {};
          attr = set.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge4.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge4.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge4.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge4.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge4.md.sha512.create();
        case "RSASSA-PSS":
          return forge4.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash2, mgf;
          hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash2 === void 0 || forge4.md[hash2] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash2;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge4.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge4.mgf[mgf].create(forge4.md[hash2].create());
          hash2 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash2 === void 0 || forge4.md[hash2] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash2;
            throw error;
          }
          scheme = forge4.pss.create(
            forge4.md[hash2].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge4.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes3;
      switch (type) {
        case "RSAPublicKey":
          bytes3 = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes3 = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes3);
      var digest3 = md.digest();
      if (options.encoding === "hex") {
        var hex = digest3.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest3.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest3;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = /* @__PURE__ */ new Date();
      cert.validity.notAfter = /* @__PURE__ */ new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge4.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes3 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes3.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes3 = asn1.toDer(tbsCertificate);
          md.update(bytes3.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i = cert.issuer;
        var s = parent.subject;
        if (i.hash && s.hash) {
          rval = i.hash === s.hash;
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge4.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge4.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge4.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge4.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes3 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes3.getBytes());
      }
      var imd = forge4.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge4.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge4.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge4.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge4.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge4.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes3 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes3.getBytes());
      }
      var smd = forge4.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge4.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes3 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes3.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes3 = asn1.toDer(cri);
          md.update(bytes3.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge4.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge4.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge4.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge4.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge4.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge4.util.hexToBytes(cert.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge4.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge4.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge4.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge4.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash2 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash2)) {
            var value = caStore.certs[hash2];
            if (!forge4.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i2 = 0; i2 < value.length; ++i2) {
                certList.push(value[i2]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge4.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge4.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            result = match[i2];
            match.splice(i2, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge4.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = /* @__PURE__ */ new Date();
      }
      var first = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge4.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent && !cert.isIssuer(parent)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge4.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS({
  "node_modules/node-forge/lib/pkcs12.js"(exports2, module2) {
    var forge4 = require_forge();
    require_asn1();
    require_hmac();
    require_oids();
    require_pkcs7asn1();
    require_pbe();
    require_random();
    require_rsa();
    require_sha1();
    require_util();
    require_x509();
    var asn1 = forge4.asn1;
    var pki = forge4.pki;
    var p12 = module2.exports = forge4.pkcs12 = forge4.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      // a ContentInfo
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            // DigestInfo
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              // DigestAlgorithmIdentifier
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        /* So far we only support X.509 certificates (which are wrapped in
           an OCTET STRING, hence hard code that here). */
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i = 0; i < safeContents.length; i++) {
        for (var j = 0; j < safeContents[i].safeBags.length; j++) {
          var bag = safeContents[i].safeBags[j];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        /**
         * Gets bags with matching attributes.
         *
         * @param filter the attributes to filter by:
         *          [localKeyId] the localKeyId to search for.
         *          [localKeyIdHex] the localKeyId in hex to search for.
         *          [friendlyName] the friendly name to search for.
         *          [bagType] bag type to narrow each attribute search by.
         *
         * @return a map of attribute type to an array of matching bags or, if no
         *           attribute was given but a bag type, the map key will be the
         *           bag type.
         */
        getBags: function(filter) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter) {
            localKeyId = filter.localKeyId;
          } else if ("localKeyIdHex" in filter) {
            localKeyId = forge4.util.hexToBytes(filter.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
            rval[filter.bagType] = _getBagsByAttribute(
              pfx.safeContents,
              null,
              null,
              filter.bagType
            );
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(
              pfx.safeContents,
              "localKeyId",
              localKeyId,
              filter.bagType
            );
          }
          if ("friendlyName" in filter) {
            rval.friendlyName = _getBagsByAttribute(
              pfx.safeContents,
              "friendlyName",
              filter.friendlyName,
              filter.bagType
            );
          }
          return rval;
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching friendlyName attribute.
         *
         * @param friendlyName the friendly name to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching friendlyName attribute.
         */
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "friendlyName",
            friendlyName,
            bagType
          );
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching localKeyId attribute.
         *
         * @param localKeyId the localKeyId to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching localKeyId attribute.
         */
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "localKeyId",
            localKeyId,
            bagType
          );
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md = forge4.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md = forge4.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md = forge4.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md = forge4.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md = forge4.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge4.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge4.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(
          password,
          macSalt,
          3,
          macIterations,
          macKeyBytes,
          md
        );
        var mac = forge4.hmac.create();
        mac.start(md, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge4.util.createBuffer();
        for (var i = 0; i < data.value.length; ++i) {
          value.putBytes(data.value[i].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i = 0; i < authSafe.value.length; i++) {
        var contentInfo = authSafe.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error("Unsupported PKCS#12 contentType.");
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(
        data,
        forge4.pkcs7.asn1.encryptedDataValidator,
        capture,
        errors
      )) {
        var error = new Error("Cannot read EncryptedContentInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error = new Error(
          "PKCS#12 EncryptedContentInfo ContentType is not Data."
        );
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge4.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error(
          "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
        );
      }
      var res = [];
      for (var i = 0; i < safeContents.value.length; i++) {
        var safeBag = safeContents.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error("Cannot read SafeBag.");
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error(
                "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
              );
            }
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error2 = new Error(
                  "Unsupported certificate type, only X.509 supported."
                );
                error2.oid = asn1.derToOid(capture.certId);
                throw error2;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error("Unsupported PKCS#12 SafeBag type.");
            error.oid = bag.type;
            throw error;
        }
        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 " + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i = 0; i < attributes.length; ++i) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 BagAttribute.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j = 0; j < capture.values.length; ++j) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key, cert, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
      if (!("useMac" in options)) {
        options.useMac = true;
      }
      if (!("localKeyId" in options)) {
        options.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge4.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge4.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === "string") {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha1 = forge4.md.sha1.create();
          sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha1.digest().getBytes();
        } else {
          localKeyId = forge4.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(
          // localKeyID
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.localKeyId).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                localKeyId
              )
            ])
          ])
        );
      }
      if ("friendlyName" in options) {
        attrs.push(
          // friendlyName
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.friendlyName).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BMPSTRING,
                false,
                options.friendlyName
              )
            ])
          ])
        );
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge4.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i = 0; i < chain.length; ++i) {
        cert = chain[i];
        if (typeof cert === "string") {
          cert = pki.certificateFromPem(cert);
        }
        var certBagAttrs = i === 0 ? bagAttrs : void 0;
        var certAsn1 = pki.certificateToAsn1(cert);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // bagId
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.certBag).getBytes()
          ),
          // bagValue
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            // CertBag
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // certId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.x509Certificate).getBytes()
              ),
              // certValue (x509Certificate)
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(certAsn1).getBytes()
                )
              ])
            ])
          ]),
          // bagAttributes (OPTIONAL)
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          certSafeBags
        );
        var certCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(certSafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.keyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // PrivateKeyInfo
              pkAsn1
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // EncryptedPrivateKeyInfo
              pki.encryptPrivateKeyInfo(pkAsn1, password, options)
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(keySafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(keyCI);
      }
      var safe = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        contents
      );
      var macData;
      if (options.useMac) {
        var sha1 = forge4.md.sha1.create();
        var macSalt = new forge4.util.ByteBuffer(
          forge4.random.getBytes(options.saltSize)
        );
        var count = options.count;
        var key = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge4.hmac.create();
        mac.start(sha1, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // mac DigestInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm = SHA-1
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.sha1).getBytes()
              ),
              // parameters = Null
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // digest
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              macValue.getBytes()
            )
          ]),
          // macSalt OCTET STRING
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            macSalt.getBytes()
          ),
          // iterations INTEGER (XXX: Only support count < 65536)
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(count).getBytes()
          )
        ]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (3)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(3).getBytes()
        ),
        // PKCS#7 ContentInfo
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // contentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            // OID for the content type is 'data'
            asn1.oidToDer(pki.oids.data).getBytes()
          ),
          // content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(safe).getBytes()
            )
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge4.pbe.generatePkcs12Key;
  }
});

// node_modules/node-forge/lib/pki.js
var require_pki = __commonJS({
  "node_modules/node-forge/lib/pki.js"(exports2, module2) {
    var forge4 = require_forge();
    require_asn1();
    require_oids();
    require_pbe();
    require_pem();
    require_pbkdf2();
    require_pkcs12();
    require_pss();
    require_rsa();
    require_util();
    require_x509();
    var asn1 = forge4.asn1;
    var pki = module2.exports = forge4.pki = forge4.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge4.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki2).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
  }
});

// node_modules/node-forge/lib/tls.js
var require_tls = __commonJS({
  "node_modules/node-forge/lib/tls.js"(exports2, module2) {
    var forge4 = require_forge();
    require_asn1();
    require_hmac();
    require_md5();
    require_pem();
    require_pki();
    require_random();
    require_sha1();
    require_util();
    var prf_TLS1 = function(secret, label, seed, length) {
      var rval = forge4.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge4.util.createBuffer();
      var hmac = forge4.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16);
      var sha1itr = Math.ceil(length / 20);
      hmac.start("MD5", s1);
      var md5bytes = forge4.util.createBuffer();
      ai.putBytes(seed);
      for (var i = 0; i < md5itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start("SHA1", s2);
      var sha1bytes = forge4.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i = 0; i < sha1itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge4.util.xorBytes(
        md5bytes.getBytes(),
        sha1bytes.getBytes(),
        length
      ));
      return rval;
    };
    var hmac_sha1 = function(key2, seqNum, record) {
      var hmac = forge4.hmac.create();
      hmac.start("SHA1", key2);
      var b = forge4.util.createBuffer();
      b.putInt32(seqNum[0]);
      b.putInt32(seqNum[1]);
      b.putByte(record.type);
      b.putByte(record.version.major);
      b.putByte(record.version.minor);
      b.putInt16(record.length);
      b.putBytes(record.fragment.bytes());
      hmac.update(b.getBytes());
      return hmac.digest().getBytes();
    };
    var deflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes3 = c.deflate(record.fragment.getBytes());
        record.fragment = forge4.util.createBuffer(bytes3);
        record.length = bytes3.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var inflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes3 = c.inflate(record.fragment.getBytes());
        record.fragment = forge4.util.createBuffer(bytes3);
        record.length = bytes3.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var readVector = function(b, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b.getByte();
          break;
        case 2:
          len = b.getInt16();
          break;
        case 3:
          len = b.getInt24();
          break;
        case 4:
          len = b.getInt32();
          break;
      }
      return forge4.util.createBuffer(b.getBytes(len));
    };
    var writeVector = function(b, lenBytes, v) {
      b.putInt(v.length(), lenBytes << 3);
      b.putBuffer(v);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls.SupportedVersions = [
      tls.Versions.TLS_1_1,
      tls.Versions.TLS_1_0
    ];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key2 in tls.CipherSuites) {
        var cs = tls.CipherSuites[key2];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c, record) {
      var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
      if (!ignore) {
        c.error(c, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c, record, length) {
      if (!c.handshaking && c.handshakes > 0) {
        tls.queue(c, tls.createAlert(c, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c);
      }
      c.process();
    };
    tls.parseHelloMessage = function(c, record, length) {
      var msg = null;
      var client = c.entity === tls.ConnectionEnd.client;
      if (length < 38) {
        c.error(c, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b = record.fragment;
        var remaining = b.length();
        msg = {
          version: {
            major: b.getByte(),
            minor: b.getByte()
          },
          random: forge4.util.createBuffer(b.getBytes(32)),
          session_id: readVector(b, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b.getBytes(2);
          msg.compression_method = b.getByte();
        } else {
          msg.cipher_suites = readVector(b, 2);
          msg.compression_methods = readVector(b, 1);
        }
        remaining = length - (remaining - b.length());
        if (remaining > 0) {
          var exts = readVector(b, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i = 0; i < msg.extensions.length; ++i) {
              var ext = msg.extensions[i];
              if (ext.type[0] === 0 && ext.type[1] === 0) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c.session.extensions.server_name.serverNameList.push(
                    readVector(snl, 2).getBytes()
                  );
                }
              }
            }
          }
        }
        if (c.session.version) {
          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
            return c.error(c, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge4.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c.session.cipherSuite === null) {
          return c.error(c, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge4.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c.session.compressionMethod = msg.compression_method;
        } else {
          c.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c, msg) {
      var client = c.entity === tls.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c.session.sp = {
        entity: c.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      if (msg.version.minor <= c.version.minor) {
        c.version.minor = msg.version.minor;
      } else {
        return c.error(c, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c.session.id) {
        c.expect = SCC;
        c.session.resuming = true;
        c.session.sp.server_random = msg.random.bytes();
      } else {
        c.expect = SCE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.session.id = sessionId;
      c.process();
    };
    tls.handleClientHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c.sessionCache) {
        session = c.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge4.random.getBytes(32);
      }
      c.session.id = sessionId;
      c.session.clientHelloVersion = msg.version;
      c.session.sp = {};
      if (session) {
        c.version = c.session.version = session.version;
        c.session.sp = session.sp;
      } else {
        var version10;
        for (var i = 1; i < tls.SupportedVersions.length; ++i) {
          version10 = tls.SupportedVersions[i];
          if (version10.minor <= msg.version.minor) {
            break;
          }
        }
        c.version = { major: version10.major, minor: version10.minor };
        c.session.version = c.version;
      }
      if (session !== null) {
        c.expect = CCC;
        c.session.resuming = true;
        c.session.sp.client_random = msg.random.bytes();
      } else {
        c.expect = c.verifyClient !== false ? CCE : CKE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.open = true;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      }));
      if (c.session.resuming) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      } else {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        }));
        if (!c.fail) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c)
          }));
          if (c.verifyClient !== false) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c)
            }));
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c)
          }));
        }
      }
      tls.flush(c);
      c.process();
    };
    tls.handleCertificate = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_list: readVector(b, 3)
      };
      var cert, asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn1 = forge4.asn1.fromDer(cert);
          cert = forge4.pki.certificateFromAsn1(asn1, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c.error(c, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if ((client || c.verifyClient === true) && certs.length === 0) {
        c.error(c, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c.session.serverCertificate = certs[0];
        } else {
          c.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c, certs)) {
          c.expect = client ? SKE : CKE;
        }
      }
      c.process();
    };
    tls.handleServerKeyExchange = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c.expect = SCR;
      c.process();
    };
    tls.handleClientKeyExchange = function(c, record, length) {
      if (length < 48) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b, 2).getBytes()
      };
      var privateKey = null;
      if (c.getPrivateKey) {
        try {
          privateKey = c.getPrivateKey(c, c.session.serverCertificate);
          privateKey = forge4.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c.error(c, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c.error(c, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version10 = c.session.clientHelloVersion;
        if (version10.major !== sp.pre_master_secret.charCodeAt(0) || version10.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge4.random.getBytes(48);
      }
      c.expect = CCC;
      if (c.session.clientCertificate !== null) {
        c.expect = CCV;
      }
      c.process();
    };
    tls.handleCertificateRequest = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_types: readVector(b, 1),
        certificate_authorities: readVector(b, 2)
      };
      c.session.certificateRequest = msg;
      c.expect = SHD;
      c.process();
    };
    tls.handleCertificateVerify = function(c, record, length) {
      if (length < 2) {
        return c.error(c, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var msg = {
        signature: readVector(b, 2).getBytes()
      };
      var verify2 = forge4.util.createBuffer();
      verify2.putBuffer(c.session.md5.digest());
      verify2.putBuffer(c.session.sha1.digest());
      verify2 = verify2.getBytes();
      try {
        var cert = c.session.clientCertificate;
        if (!cert.publicKey.verify(verify2, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
      } catch (ex) {
        return c.error(c, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c.expect = CCC;
      c.process();
    };
    tls.handleServerHelloDone = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c.serverCertificate === null) {
        var error = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c.verify(c, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge4.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error.alert.description = ret;
            }
          }
          return c.error(c, error);
        }
      }
      if (c.session.certificateRequest !== null) {
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        });
        tls.queue(c, record);
      }
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c)
      });
      tls.queue(c, record);
      c.expect = SER;
      var callback = function(c2, signature) {
        if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c2, signature)
          }));
        }
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.pending = tls.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
        c2.expect = SCC;
        tls.flush(c2);
        c2.process();
      };
      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
        return callback(c, null);
      }
      tls.getClientSignature(c, callback);
    };
    tls.handleChangeCipherSpec = function(c, record) {
      if (record.fragment.getByte() !== 1) {
        return c.error(c, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if (c.session.resuming && client || !c.session.resuming && !client) {
        c.state.pending = tls.createConnectionState(c);
      }
      c.state.current.read = c.state.pending.read;
      if (!c.session.resuming && client || c.session.resuming && !client) {
        c.state.pending = null;
      }
      c.expect = client ? SFI : CFI;
      c.process();
    };
    tls.handleFinished = function(c, record, length) {
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var vd = record.fragment.getBytes();
      b = forge4.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      if (b.getBytes() !== vd) {
        return c.error(c, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
      if (c.session.resuming && client || !c.session.resuming && !client) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.current.write = c.state.pending.write;
        c.state.pending = null;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      }
      c.expect = client ? SAD : CAD;
      c.handshaking = false;
      ++c.handshakes;
      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
      tls.flush(c);
      c.isConnected = true;
      c.connected(c);
      c.process();
    };
    tls.handleAlert = function(c, record) {
      var b = record.fragment;
      var alert = {
        level: b.getByte(),
        description: b.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c.close();
      }
      c.error(c, {
        message: msg,
        send: false,
        // origin is the opposite end
        origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c.process();
    };
    tls.handleHandshake = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length = b.getInt24();
      if (length > b.length()) {
        c.fragmented = record;
        record.fragment = forge4.util.createBuffer();
        b.read -= 4;
        return c.process();
      }
      c.fragmented = null;
      b.read -= 4;
      var bytes3 = b.bytes(length + 4);
      b.read += 4;
      if (type in hsTable[c.entity][c.expect]) {
        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
          c.handshaking = true;
          c.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge4.md.md5.create(),
            sha1: forge4.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c.session.md5.update(bytes3);
          c.session.sha1.update(bytes3);
        }
        hsTable[c.entity][c.expect][type](c, record, length);
      } else {
        tls.handleUnexpected(c, record);
      }
    };
    tls.handleApplicationData = function(c, record) {
      c.data.putBuffer(record.fragment);
      c.dataReady(c);
      c.process();
    };
    tls.handleHeartbeat = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length = b.getInt16();
      var payload = b.getBytes(length);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c.handshaking || length > payload.length) {
          return c.process();
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_response,
            payload
          )
        }));
        tls.flush(c);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c.expectedHeartbeatPayload) {
          return c.process();
        }
        if (c.heartbeatReceived) {
          c.heartbeatReceived(c, forge4.util.createBuffer(payload));
        }
      }
      c.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R2 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [
      //      CC,AL,HS,AD,HB
      /*SHE*/
      [__, R1, R2, __, R4],
      /*SCE*/
      [__, R1, R2, __, R4],
      /*SKE*/
      [__, R1, R2, __, R4],
      /*SCR*/
      [__, R1, R2, __, R4],
      /*SHD*/
      [__, R1, R2, __, R4],
      /*SCC*/
      [R0, R1, __, __, R4],
      /*SFI*/
      [__, R1, R2, __, R4],
      /*SAD*/
      [__, R1, R2, R3, R4],
      /*SER*/
      [__, R1, R2, __, R4]
    ];
    ctTable[tls.ConnectionEnd.server] = [
      //      CC,AL,HS,AD
      /*CHE*/
      [__, R1, R2, __, R4],
      /*CCE*/
      [__, R1, R2, __, R4],
      /*CKE*/
      [__, R1, R2, __, R4],
      /*CCV*/
      [__, R1, R2, __, R4],
      /*CCC*/
      [R0, R1, __, __, R4],
      /*CFI*/
      [__, R1, R2, __, R4],
      /*CAD*/
      [__, R1, R2, R3, R4],
      /*CER*/
      [__, R1, R2, __, R4]
    ];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H2 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [
      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
      /*SHE*/
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SCE*/
      [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
      /*SKE*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      /*SCR*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      /*SHD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      /*SCC*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SFI*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*SAD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SER*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [
      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
      /*CHE*/
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CCE*/
      [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
      /*CKE*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      /*CCV*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      /*CCC*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CFI*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*CAD*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CER*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls.generateKeys = function(c, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c.session.resuming) {
        sp.master_secret = prf(
          sp.pre_master_secret,
          "master secret",
          random,
          48
        ).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
      if (tls10) {
        length += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random, length);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var createMode = function() {
        var mode = {
          // two 32-bit numbers, first is most significant
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 4294967295) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c2, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c2.error(c2, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              // doesn't matter if decryption failed or MAC was
              // invalid, return the same error so as not to reveal
              // which one occurred
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c2, record, state.read)) {
          c2.error(c2, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c2.fail;
      };
      state.write.update = function(c2, record) {
        if (!state.write.compressFunction(c2, record, state.write)) {
          c2.error(c2, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c2.error(c2, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c2.fail;
      };
      if (c.session) {
        var sp = c.session.sp;
        c.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c.session.cipherSuite.initConnectionState(state, c, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d = /* @__PURE__ */ new Date();
      var utc = +d + d.getTimezoneOffset() * 6e4;
      var rval = forge4.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge4.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c.version.major,
          minor: c.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c, alert) {
      var b = forge4.util.createBuffer();
      b.putByte(alert.level);
      b.putByte(alert.description);
      return tls.createRecord(c, {
        type: tls.ContentType.alert,
        data: b
      });
    };
    tls.createClientHello = function(c) {
      c.session.clientHelloVersion = {
        major: c.version.major,
        minor: c.version.minor
      };
      var cipherSuites = forge4.util.createBuffer();
      for (var i = 0; i < c.cipherSuites.length; ++i) {
        var cs = c.cipherSuites[i];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge4.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge4.util.createBuffer();
      if (c.virtualHost) {
        var ext = forge4.util.createBuffer();
        ext.putByte(0);
        ext.putByte(0);
        var serverName = forge4.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge4.util.createBuffer(c.virtualHost));
        var snList = forge4.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + cSuites + // cipher suites vector
      1 + cMethods + // compression methods vector
      extLength;
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.client_random);
      writeVector(rval, 1, forge4.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c) {
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + // chosen cipher suite
      1;
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.server_random);
      writeVector(rval, 1, forge4.util.createBuffer(sessionId));
      rval.putByte(c.session.cipherSuite.id[0]);
      rval.putByte(c.session.cipherSuite.id[1]);
      rval.putByte(c.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var cert = null;
      if (c.getCertificate) {
        var hint;
        if (client) {
          hint = c.session.certificateRequest;
        } else {
          hint = c.session.extensions.server_name.serverNameList;
        }
        cert = c.getCertificate(c, hint);
      }
      var certList = forge4.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge4.util.isArray(cert)) {
            cert = [cert];
          }
          var asn1 = null;
          for (var i = 0; i < cert.length; ++i) {
            var msg = forge4.pem.decode(cert[i])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge4.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge4.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge4.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge4.pki.certificateFromAsn1(asn1);
          if (client) {
            c.session.clientCertificate = cert;
          } else {
            c.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c.error(c, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length = 3 + certList.length();
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c) {
      var b = forge4.util.createBuffer();
      b.putByte(c.session.clientHelloVersion.major);
      b.putByte(c.session.clientHelloVersion.minor);
      b.putBytes(forge4.random.getBytes(46));
      var sp = c.session.sp;
      sp.pre_master_secret = b.getBytes();
      var key2 = c.session.serverCertificate.publicKey;
      b = key2.encrypt(sp.pre_master_secret);
      var length = b.length + 2;
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length);
      rval.putInt16(b.length);
      rval.putBytes(b);
      return rval;
    };
    tls.createServerKeyExchange = function(c) {
      var length = 0;
      var rval = forge4.util.createBuffer();
      if (length > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length);
      }
      return rval;
    };
    tls.getClientSignature = function(c, callback) {
      var b = forge4.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      b = b.getBytes();
      c.getSignature = c.getSignature || function(c2, b2, callback2) {
        var privateKey = null;
        if (c2.getPrivateKey) {
          try {
            privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
            privateKey = forge4.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c2.error(c2, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c2.error(c2, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b2 = privateKey.sign(b2, null);
        }
        callback2(c2, b2);
      };
      c.getSignature(c, b, callback);
    };
    tls.createCertificateVerify = function(c, signature) {
      var length = signature.length + 2;
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c) {
      var certTypes = forge4.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge4.util.createBuffer();
      for (var key2 in c.caStore.certs) {
        var cert = c.caStore.certs[key2];
        var dn = forge4.pki.distinguishedNameToAsn1(cert.subject);
        var byteBuffer = forge4.asn1.toDer(dn);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c) {
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge4.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls.createFinished = function(c) {
      var b = forge4.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      var rval = forge4.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b.length());
      rval.putBuffer(b);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge4.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge4.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes3 = record.fragment.bytes();
        c.session.md5.update(bytes3);
        c.session.sha1.update(bytes3);
        bytes3 = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge4.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge4.util.createBuffer(data)
          }));
        }
      }
      for (var i = 0; i < records.length && !c.fail; ++i) {
        var rec = records[i];
        var s = c.state.current.write;
        if (s.update(c, rec)) {
          c.records.push(rec);
        }
      }
    };
    tls.flush = function(c) {
      for (var i = 0; i < c.records.length; ++i) {
        var record = c.records[i];
        c.tlsData.putByte(record.type);
        c.tlsData.putByte(record.version.major);
        c.tlsData.putByte(record.version.minor);
        c.tlsData.putInt16(record.fragment.length());
        c.tlsData.putBuffer(c.records[i].fragment);
      }
      c.records = [];
      return c.tlsDataReady(c);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge4.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge4.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge4.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge4.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge4.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge4.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge4.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge4.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge4.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge4.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge4.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge4.pki.certificateError.unknown_ca;
        default:
          return forge4.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c, chain) {
      try {
        var options = {};
        for (var key2 in c.verifyOptions) {
          options[key2] = c.verifyOptions[key2];
        }
        options.verify = function(vfd, depth, chain2) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c.verify(c, vfd, depth, chain2);
          if (ret !== true) {
            if (typeof ret === "object" && !forge4.util.isArray(ret)) {
              var error = new Error("The application rejected the certificate.");
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge4.pki.verifyCertificateChain(c.caStore, chain, options);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge4.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c.error(c, err);
      }
      return !c.fail;
    };
    tls.createSessionCache = function(cache, capacity) {
      var rval = null;
      if (cache && cache.getSession && cache.setSession && cache.order) {
        rval = cache;
      } else {
        rval = {};
        rval.cache = cache || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key2 in cache) {
          if (rval.order.length <= capacity) {
            rval.order.push(key2);
          } else {
            delete cache[key2];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key3 = null;
          if (sessionId) {
            key3 = forge4.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key3 = rval.order[0];
          }
          if (key3 !== null && key3 in rval.cache) {
            session = rval.cache[key3];
            delete rval.cache[key3];
            for (var i in rval.order) {
              if (rval.order[i] === key3) {
                rval.order.splice(i, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key3 = rval.order.shift();
            delete rval.cache[key3];
          }
          var key3 = forge4.util.bytesToHex(sessionId);
          rval.order.push(key3);
          rval.cache[key3] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge4.util.isArray(options.caStore)) {
          caStore = forge4.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge4.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key2 in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key2]);
        }
      }
      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c = {
        version: { major: tls.Version.major, minor: tls.Version.minor },
        entity,
        sessionId: options.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge4.util.createBuffer(),
        tlsData: forge4.util.createBuffer(),
        data: forge4.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c2, ex) {
          ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls.queue(c2, tls.createAlert(c2, ex.alert));
            tls.flush(c2);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c2.fail = true;
          }
          options.error(c2, ex);
          if (fatal) {
            c2.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c.reset = function(clearFail) {
        c.version = { major: tls.Version.major, minor: tls.Version.minor };
        c.record = null;
        c.session = null;
        c.peerCertificate = null;
        c.state = {
          pending: null,
          current: null
        };
        c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
        c.fragmented = null;
        c.records = [];
        c.open = false;
        c.handshakes = 0;
        c.handshaking = false;
        c.isConnected = false;
        c.fail = !(clearFail || typeof clearFail === "undefined");
        c.input.clear();
        c.tlsData.clear();
        c.data.clear();
        c.state.current = tls.createConnectionState(c);
      };
      c.reset();
      var _update = function(c2, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c2.entity][c2.expect];
        if (aligned in handlers) {
          handlers[aligned](c2, record);
        } else {
          tls.handleUnexpected(c2, record);
        }
      };
      var _readRecordHeader = function(c2) {
        var rval = 0;
        var b = c2.input;
        var len = b.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c2.record = {
            type: b.getByte(),
            version: {
              major: b.getByte(),
              minor: b.getByte()
            },
            length: b.getInt16(),
            fragment: forge4.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c2.record.version.major === c2.version.major;
          if (compatibleVersion && c2.session && c2.session.version) {
            compatibleVersion = c2.record.version.minor === c2.version.minor;
          }
          if (!compatibleVersion) {
            c2.error(c2, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c2) {
        var rval = 0;
        var b = c2.input;
        var len = b.length();
        if (len < c2.record.length) {
          rval = c2.record.length - len;
        } else {
          c2.record.fragment.putBytes(b.getBytes(c2.record.length));
          b.compact();
          var s = c2.state.current.read;
          if (s.update(c2, c2.record)) {
            if (c2.fragmented !== null) {
              if (c2.fragmented.type === c2.record.type) {
                c2.fragmented.fragment.putBuffer(c2.record.fragment);
                c2.record = c2.fragmented;
              } else {
                c2.error(c2, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c2.record.ready = true;
          }
        }
        return rval;
      };
      c.handshake = function(sessionId) {
        if (c.entity !== tls.ConnectionEnd.client) {
          c.error(c, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c.handshaking) {
          c.error(c, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c.fail && !c.open && c.handshakes === 0) {
            c.fail = false;
          }
          c.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c.sessionCache) {
              session = c.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c.sessionCache) {
            session = c.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge4.md.md5.create(),
            sha1: forge4.md.sha1.create()
          };
          if (session) {
            c.version = session.version;
            c.session.sp = session.sp;
          }
          c.session.sp.client_random = tls.createRandom().getBytes();
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c)
          }));
          tls.flush(c);
        }
      };
      c.process = function(data) {
        var rval = 0;
        if (data) {
          c.input.putBytes(data);
        }
        if (!c.fail) {
          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
            c.record = null;
          }
          if (c.record === null) {
            rval = _readRecordHeader(c);
          }
          if (!c.fail && c.record !== null && !c.record.ready) {
            rval = _readRecord(c);
          }
          if (!c.fail && c.record !== null && c.record.ready) {
            _update(c, c.record);
          }
        }
        return rval;
      };
      c.prepare = function(data) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.application_data,
          data: forge4.util.createBuffer(data)
        }));
        return tls.flush(c);
      };
      c.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge4.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c.expectedHeartbeatPayload = payload;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_request,
            payload,
            payloadLength
          )
        }));
        return tls.flush(c);
      };
      c.close = function(clearFail) {
        if (!c.fail && c.sessionCache && c.session) {
          var session = {
            id: c.session.id,
            version: c.session.version,
            sp: c.session.sp
          };
          session.sp.keys = null;
          c.sessionCache.setSession(session.id, session);
        }
        if (c.open) {
          c.open = false;
          c.input.clear();
          if (c.isConnected || c.handshaking) {
            c.isConnected = c.handshaking = false;
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c);
          }
          c.closed(c);
        }
        c.reset(clearFail);
      };
      return c;
    };
    module2.exports = forge4.tls = forge4.tls || {};
    for (key in tls) {
      if (typeof tls[key] !== "function") {
        forge4.tls[key] = tls[key];
      }
    }
    var key;
    forge4.tls.prf_tls1 = prf_TLS1;
    forge4.tls.hmac_sha1 = hmac_sha1;
    forge4.tls.createSessionCache = tls.createSessionCache;
    forge4.tls.createConnection = tls.createConnection;
  }
});

// node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS({
  "node_modules/node-forge/lib/aesCipherSuites.js"(exports2, module2) {
    var forge4 = require_forge();
    require_aes();
    require_tls();
    var tls = module2.exports = forge4.tls;
    tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    function initConnectionState(state, c, sp) {
      var client = c.entity === forge4.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge4.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge4.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = forge4.random.getBytesSync(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding2 = blockSize - input.length() % blockSize;
        input.fillWithByte(padding2 - 1, padding2);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
          rval = rval && output.at(i) == paddingLength;
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    function decrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s.macLength;
      var mac = forge4.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge4.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
      s.updateSequenceNumber();
      rval = compareMacs(s.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key, mac1, mac2) {
      var hmac = forge4.hmac.create();
      hmac.start("SHA1", key);
      hmac.update(mac1);
      mac1 = hmac.digest().getBytes();
      hmac.start(null, null);
      hmac.update(mac2);
      mac2 = hmac.digest().getBytes();
      return mac1 === mac2;
    }
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge4 = require_forge();
    require_md();
    require_util();
    var sha512 = module2.exports = forge4.sha512 = forge4.sha512 || {};
    forge4.md.sha512 = forge4.md.algorithms.sha512 = sha512;
    var sha384 = forge4.sha384 = forge4.sha512.sha384 = forge4.sha512.sha384 || {};
    sha384.create = function() {
      return sha512.create("SHA-384");
    };
    forge4.md.sha384 = forge4.md.algorithms.sha384 = sha384;
    forge4.sha512.sha256 = forge4.sha512.sha256 || {
      create: function() {
        return sha512.create("SHA-512/256");
      }
    };
    forge4.md["sha512/256"] = forge4.md.algorithms["sha512/256"] = forge4.sha512.sha256;
    forge4.sha512.sha224 = forge4.sha512.sha224 || {
      create: function() {
        return sha512.create("SHA-512/224");
      }
    };
    forge4.md["sha512/224"] = forge4.md.algorithms["sha512/224"] = forge4.sha512.sha224;
    sha512.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge4.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge4.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge4.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge4.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge4.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge4.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes3) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i, hi, lo, w2, w7, w15, w16;
      var len = bytes3.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w[i][0] = bytes3.getInt32() >>> 0;
          w[i][1] = bytes3.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w2 = w[i - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i - 7];
          w16 = w[i - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "node_modules/node-forge/lib/asn1-validator.js"(exports2) {
    var forge4 = require_forge();
    require_asn1();
    var asn1 = forge4.asn1;
    exports2.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports2.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
    var forge4 = require_forge();
    require_jsbn();
    require_random();
    require_sha512();
    require_util();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge4.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge4.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge4.pki = forge4.pki || {};
    module2.exports = forge4.pki.ed25519 = forge4.ed25519 = forge4.ed25519 || {};
    var ed25519 = forge4.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge4.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i = 0; i < 32; ++i) {
        sk[i] = seed[i];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge4.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge4.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge4.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge4.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge4.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge4.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge4.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i = 0; i < pk.length; ++i) {
        pk[i] = privateKey[32 + i];
      }
      return pk;
    };
    ed25519.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed25519.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i = 0; i < sig.length; ++i) {
        sig[i] = signedMsg[i];
      }
      return sig;
    };
    ed25519.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i;
      for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
        sm[i] = sig[i];
      }
      for (i = 0; i < msg.length; ++i) {
        sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
      }
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message.length());
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = message.at(i);
      }
      return buffer;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha512(msg, msgLen) {
      var md = forge4.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md.update(buffer.getBytes(msgLen), "binary");
      var hash2 = md.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash2, "binary");
      }
      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i = 0; i < 64; ++i) {
        out[i] = hash2.charCodeAt(i);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p = [gf(), gf(), gf(), gf()];
      var i;
      var d = sha512(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack2(pk, p);
      for (i = 0; i < 32; ++i) {
        sk[i + 32] = pk[i];
      }
      return 0;
    }
    function crypto_sign(sm, m, n, sk) {
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var d = sha512(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; ++i) {
        sm[64 + i] = m[i];
      }
      for (i = 0; i < 32; ++i) {
        sm[32 + i] = d[32 + i];
      }
      var r2 = sha512(sm.subarray(32), n + 32);
      reduce(r2);
      scalarbase(p, r2);
      pack2(sm, p);
      for (i = 32; i < 64; ++i) {
        sm[i] = sk[i];
      }
      var h = sha512(sm, n + 64);
      reduce(h);
      for (i = 32; i < 64; ++i) {
        x[i] = 0;
      }
      for (i = 0; i < 32; ++i) {
        x[i] = r2[i];
      }
      for (i = 0; i < 32; ++i) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new NativeBuffer(32);
      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) {
        return -1;
      }
      if (unpackneg(q, pk)) {
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m[i] = sm[i];
      }
      for (i = 0; i < 32; ++i) {
        m[i + 32] = pk[i];
      }
      var h = sha512(m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack2(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; ++i) {
          m[i] = 0;
        }
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m[i] = sm[i + 64];
      }
      mlen = n;
      return mlen;
    }
    function modL(r2, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; ++j) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; ++j) {
        x[j] -= carry * L[j];
      }
      for (i = 0; i < 32; ++i) {
        x[i + 1] += x[i] >> 8;
        r2[i] = x[i] & 255;
      }
    }
    function reduce(r2) {
      var x = new Float64Array(64);
      for (var i = 0; i < 64; ++i) {
        x[i] = r2[i];
        r2[i] = 0;
      }
      modL(r2, x);
    }
    function add(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f3 = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f3, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f3);
      M(p[1], h, g);
      M(p[2], g, f3);
      M(p[3], e, h);
    }
    function cswap(p, q, b) {
      for (var i = 0; i < 4; ++i) {
        sel25519(p[i], q[i], b);
      }
    }
    function pack2(r2, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; ++i) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; ++j) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; ++i) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function unpackneg(r2, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p);
      S(num, r2[1]);
      M(den, num, D);
      Z(num, num, r2[2]);
      A(den, r2[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r2[0], t, den);
      S(chk, r2[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        M(r2[0], r2[0], I);
      }
      S(chk, r2[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p[31] >> 7) {
        Z(r2[0], gf0, r2[0]);
      }
      M(r2[3], r2[0], r2[1]);
      return 0;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; ++i) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i[a];
      }
      for (a = 250; a >= 0; --a) {
        S(c, c);
        if (a !== 1) {
          M(c, c, i);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function neq25519(a, b) {
      var c = new NativeBuffer(32);
      var d = new NativeBuffer(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; ++i) {
        d |= x[xi + i] ^ y[yi + i];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    function par25519(a) {
      var d = new NativeBuffer(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function set25519(r2, a) {
      var i;
      for (i = 0; i < 16; i++) {
        r2[i] = a[i] | 0;
      }
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i[a];
      }
      for (a = 253; a >= 0; --a) {
        S(c, c);
        if (a !== 2 && a !== 4) {
          M(c, c, i);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; ++i) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t, c = ~(b - 1);
      for (var i = 0; i < 16; ++i) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function gf(init) {
      var i, r2 = new Float64Array(16);
      if (init) {
        for (i = 0; i < init.length; ++i) {
          r2[i] = init[i];
        }
      }
      return r2;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a[i] + b[i];
      }
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a[i] - b[i];
      }
    }
    function S(o, a) {
      M(o, a, a);
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
  }
});

// node_modules/node-forge/lib/kem.js
var require_kem = __commonJS({
  "node_modules/node-forge/lib/kem.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    require_random();
    require_jsbn();
    module2.exports = forge4.kem = forge4.kem || {};
    var BigInteger = forge4.jsbn.BigInteger;
    forge4.kem.rsa = {};
    forge4.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge4.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r2;
        do {
          r2 = new BigInteger(
            forge4.util.bytesToHex(prng.getBytesSync(byteLength)),
            16
          ).mod(publicKey.n);
        } while (r2.compareTo(BigInteger.ONE) <= 0);
        r2 = forge4.util.hexToBytes(r2.toString(16));
        var zeros2 = byteLength - r2.length;
        if (zeros2 > 0) {
          r2 = forge4.util.fillString(String.fromCharCode(0), zeros2) + r2;
        }
        var encapsulation = publicKey.encrypt(r2, "NONE");
        var key = kdf.generate(r2, keyLength);
        return { encapsulation, key };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r2 = privateKey.decrypt(encapsulation, "NONE");
        return kdf.generate(r2, keyLength);
      };
      return kem;
    };
    forge4.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge4.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x, length) {
        var key = new forge4.util.ByteBuffer();
        var k = Math.ceil(length / digestLength) + counterStart;
        var c = new forge4.util.ByteBuffer();
        for (var i = counterStart; i < k; ++i) {
          c.putInt32(i);
          md.start();
          md.update(x + c.getBytes());
          var hash2 = md.digest();
          key.putBytes(hash2.getBytes(digestLength));
        }
        key.truncate(key.length() - length);
        return key.getBytes();
      };
    }
  }
});

// node_modules/node-forge/lib/log.js
var require_log = __commonJS({
  "node_modules/node-forge/lib/log.js"(exports2, module2) {
    var forge4 = require_forge();
    require_util();
    module2.exports = forge4.log = forge4.log || {};
    forge4.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge4.log.LEVEL_LOCKED = 1 << 1;
    forge4.log.NO_LEVEL_CHECK = 1 << 2;
    forge4.log.INTERPOLATE = 1 << 3;
    for (i = 0; i < forge4.log.levels.length; ++i) {
      level = forge4.log.levels[i];
      sLevelInfo[level] = {
        index: i,
        name: level.toUpperCase()
      };
    }
    var level;
    var i;
    forge4.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i2 = 0; i2 < sLoggers.length; ++i2) {
        var logger16 = sLoggers[i2];
        if (logger16.flags & forge4.log.NO_LEVEL_CHECK) {
          logger16.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger16.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger16.f(logger16, message);
          }
        }
      }
    };
    forge4.log.prepareStandard = function(message) {
      if (!("standard" in message)) {
        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
        " [" + message.category + "] " + message.message;
      }
    };
    forge4.log.prepareFull = function(message) {
      if (!("full" in message)) {
        var args = [message.message];
        args = args.concat([]);
        message.full = forge4.util.format.apply(this, args);
      }
    };
    forge4.log.prepareStandardFull = function(message) {
      if (!("standardFull" in message)) {
        forge4.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i = 0; i < levels.length; ++i) {
        (function(level2) {
          forge4.log[level2] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: /* @__PURE__ */ new Date(),
              level: level2,
              category,
              message,
              "arguments": args
              /*standard*/
              /*full*/
              /*fullMessage*/
            };
            forge4.log.logMessage(msg);
          };
        })(levels[i]);
      }
    }
    var levels;
    var i;
    forge4.log.makeLogger = function(logFunction) {
      var logger16 = {
        flags: 0,
        f: logFunction
      };
      forge4.log.setLevel(logger16, "none");
      return logger16;
    };
    forge4.log.setLevel = function(logger16, level2) {
      var rval = false;
      if (logger16 && !(logger16.flags & forge4.log.LEVEL_LOCKED)) {
        for (var i2 = 0; i2 < forge4.log.levels.length; ++i2) {
          var aValidLevel = forge4.log.levels[i2];
          if (level2 == aValidLevel) {
            logger16.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge4.log.lock = function(logger16, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger16.flags |= forge4.log.LEVEL_LOCKED;
      } else {
        logger16.flags &= ~forge4.log.LEVEL_LOCKED;
      }
    };
    forge4.log.addLogger = function(logger16) {
      sLoggers.push(logger16);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f3 = function(logger16, message) {
          forge4.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message["arguments"].slice());
          handler.apply(console, args);
        };
        logger15 = forge4.log.makeLogger(f3);
      } else {
        f3 = function(logger16, message) {
          forge4.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger15 = forge4.log.makeLogger(f3);
      }
      forge4.log.setLevel(logger15, "debug");
      forge4.log.addLogger(logger15);
      sConsoleLogger = logger15;
    } else {
      console = {
        log: function() {
        }
      };
    }
    var logger15;
    var levelHandlers;
    var f3;
    if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
      query = new URL(window.location.href).searchParams;
      if (query.has("console.level")) {
        forge4.log.setLevel(
          sConsoleLogger,
          query.get("console.level").slice(-1)[0]
        );
      }
      if (query.has("console.lock")) {
        lock = query.get("console.lock").slice(-1)[0];
        if (lock == "true") {
          forge4.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge4.log.consoleLogger = sConsoleLogger;
  }
});

// node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS({
  "node_modules/node-forge/lib/md.all.js"(exports2, module2) {
    module2.exports = require_md();
    require_md5();
    require_sha1();
    require_sha256();
    require_sha512();
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    var forge4 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge4.asn1;
    var p7 = module2.exports = forge4.pkcs7 = forge4.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge4.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge4.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge4.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge4.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge4.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i = 0; i < certs.length; ++i) {
              msg.certificates.push(forge4.pki.certificateFromAsn1(certs[i]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge4.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        },
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge4.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge4.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge4.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge4.pki.oids.sha1:
            case forge4.pki.oids.sha256:
            case forge4.pki.oids.sha384:
            case forge4.pki.oids.sha512:
            case forge4.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest2 = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge4.pki.oids.contentType) {
                contentType = true;
                if (messageDigest2) {
                  break;
                }
                continue;
              }
              if (!messageDigest2 && attr.type === forge4.pki.oids.messageDigest) {
                messageDigest2 = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest2) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge4.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge4.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge4.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge4.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge4.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge4.md[forge4.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge4.md[forge4.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes3 = asn1.toDer(content);
        bytes3.getByte();
        asn1.getBerValueLength(bytes3);
        bytes3 = bytes3.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes3);
        }
        var signingTime = /* @__PURE__ */ new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge4.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge4.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge4.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes3 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes3);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge4.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge4.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge4.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge4.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r2 = msg.recipients[i];
            var rAttr = r2.issuer;
            if (r2.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r2;
            }
          }
          return null;
        },
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge4.pki.oids.rsaEncryption:
              case forge4.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge4.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge4.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge4.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge4.aes.createEncryptionCipher;
                break;
              case forge4.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge4.aes.createEncryptionCipher;
                break;
              case forge4.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge4.aes.createEncryptionCipher;
                break;
              case forge4.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge4.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge4.util.createBuffer(forge4.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge4.util.createBuffer(
              forge4.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge4.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge4.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge4.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge4.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge4.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge4.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge4.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge4.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge4.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge4.pki.oids.signingTime) {
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec2) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge4.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec2.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec2.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec2.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec2.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge4.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge4.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge4.util.createBuffer(capture.encParameter.value),
          content: forge4.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge4.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge4.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge4.pki.oids["aes128-CBC"]:
          case forge4.pki.oids["aes192-CBC"]:
          case forge4.pki.oids["aes256-CBC"]:
            ciph = forge4.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge4.pki.oids["desCBC"]:
          case forge4.pki.oids["des-EDE3-CBC"]:
            ciph = forge4.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS({
  "node_modules/node-forge/lib/ssh.js"(exports2, module2) {
    var forge4 = require_forge();
    require_aes();
    require_hmac();
    require_md5();
    require_sha1();
    require_util();
    var ssh = module2.exports = forge4.ssh = forge4.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment + "\r\n";
      var pubbuffer = forge4.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge4.util.encode64(pubbuffer.bytes(), 64);
      var length = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length + "\r\n";
      ppk += pub;
      var privbuffer = forge4.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge4.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding2 = _sha1(privbuffer.bytes());
        padding2.truncate(padding2.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding2);
        var aeskey = forge4.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge4.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge4.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge4.util.encode64(encrypted.bytes(), 64);
      }
      length = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge4.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge4.hmac.create();
      hmac.start("sha1", mackey);
      hmac.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment) {
      var type = "ssh-rsa";
      comment = comment || "";
      var buffer = forge4.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      return type + " " + forge4.util.encode64(buffer.bytes()) + " " + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge4.pki.privateKeyToPem(privateKey);
      }
      return forge4.pki.encryptRsaPrivateKey(
        privateKey,
        passphrase,
        { legacy: true, algorithm: "aes128" }
      );
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge4.md.md5.create();
      var type = "ssh-rsa";
      var buffer = forge4.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      md.start();
      md.update(buffer.getBytes());
      var digest3 = md.digest();
      if (options.encoding === "hex") {
        var hex = digest3.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest3.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest3;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes3 = forge4.util.hexToBytes(hexVal);
      buffer.putInt32(bytes3.length);
      buffer.putBytes(bytes3);
    }
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    function _sha1() {
      var sha = forge4.md.sha1.create();
      var num = arguments.length;
      for (var i = 0; i < num; ++i) {
        sha.update(arguments[i]);
      }
      return sha.digest();
    }
  }
});

// node_modules/node-forge/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-forge/lib/index.js"(exports2, module2) {
    module2.exports = require_forge();
    require_aes();
    require_aesCipherSuites();
    require_asn1();
    require_cipher();
    require_des();
    require_ed25519();
    require_hmac();
    require_kem();
    require_log();
    require_md_all();
    require_mgf1();
    require_pbkdf2();
    require_pem();
    require_pkcs1();
    require_pkcs12();
    require_pkcs7();
    require_pki();
    require_prime();
    require_prng();
    require_pss();
    require_random();
    require_rc2();
    require_ssh();
    require_tls();
    require_util();
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number, base, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN3;
      } else {
        exports3.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer5;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer5 = window.Buffer;
        } else {
          Buffer5 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN3.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN3.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r2 *= mul;
          if (c >= 49) {
            r2 += c - 49 + 10;
          } else if (c >= 17) {
            r2 += c - 17 + 10;
          } else {
            r2 += c;
          }
        }
        return r2;
      }
      BN3.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN3.prototype.clone = function clone() {
        var r2 = new BN3(null);
        this.copy(r2);
        return r2;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN3.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString(base, padding2) {
        base = base || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN3.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer5 !== "undefined");
        return this.toArrayLike(Buffer5, endian, length);
      };
      BN3.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w) {
          var t = w;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r2 += b;
          if (b !== 26)
            break;
        }
        return r2;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN3.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r2 = a * b;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r2 = a * b + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r2 = a * b;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t = new Array(N2);
        var l = BN3.prototype._countBits(N2) - 1;
        for (var i = 0; i < N2; i++) {
          t[i] = this.revBin(i, l, N2);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N2) {
        if (x === 0 || x === N2 - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i = 0; i < N2; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s = 1; s < N2; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N2; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N2 = Math.max(m, n) | 1;
        var odd = N2 & 1;
        var i = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i = 0; i < N2 / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N2 - i - 1];
          rws[N2 - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N2 - i - 1];
          iws[N2 - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i = 0; i < N2 / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N2) * 8192 + Math.round(ws[2 * i] / N2) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N2; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i = 0; i < N2; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N2 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x.words, x.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i = 0; i < N2; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN3.prototype.mul = function mul(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i;
        if (r2 !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r2;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN3.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN3.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r2 = a.cmp(b);
          if (r2 < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r2 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN3(1).iushln(m - i - 1));
          r2 = r2.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN3(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r2, msg) {
      if (l != r2)
        throw new Error(msg || "Assertion failed: " + l + " != " + r2);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex2;
    utils.encode = function encode8(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    var BN3 = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod2 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z = (ws >> 1) - mod2;
          else
            z = mod2;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes3) {
      return typeof bytes3 === "string" ? utils.toArray(bytes3, "hex") : bytes3;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes3) {
      return new BN3(bytes3, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports2, module2) {
    var r2;
    module2.exports = function rand(len) {
      if (!r2)
        r2 = new Rand(null);
      return r2.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate2(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto2.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto2;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var BN3 = require_bn();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN3(conf.p, 16);
      this.red = conf.prime ? BN3.red(conf.prime) : BN3.mont(this.p);
      this.zero = new BN3(0).toRed(this.red);
      this.one = new BN3(1).toRed(this.red);
      this.two = new BN3(2).toRed(this.red);
      this.n = conf.n && new BN3(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
      bytes3 = utils.toArray(bytes3, enc);
      var len = this.p.byteLength();
      if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
        if (bytes3[0] === 6)
          assert(bytes3[bytes3.length - 1] % 2 === 0);
        else if (bytes3[0] === 7)
          assert(bytes3[bytes3.length - 1] % 2 === 1);
        var res = this.point(
          bytes3.slice(1, 1 + len),
          bytes3.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
        return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode2(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode8(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r2 = this;
      for (var i = 0; i < k; i++)
        r2 = r2.dbl();
      return r2;
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN3 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN3(conf.a, 16).toRed(this.red);
      this.b = new BN3(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN3(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN3(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN3(vec.a, 16),
            b: new BN3(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN3.mont(num);
      var tinv = new BN3(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN3(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN3(1);
      var y1 = new BN3(0);
      var x2 = new BN3(0);
      var y2 = new BN3(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r2;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r2 = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r2.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r2.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r2;
        v = u;
        u = r2;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r2.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN3(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN3(x, 16);
        this.y = new BN3(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN3(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN3(0);
      } else {
        this.x = new BN3(x, 16);
        this.y = new BN3(y, 16);
        this.z = new BN3(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r2 = this;
        for (i = 0; i < pow; i++)
          r2 = r2.dbl();
        return r2;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f3 = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f3.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN3(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var BN3 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN3(conf.a, 16).toRed(this.red);
      this.b = new BN3(conf.b, 16).toRed(this.red);
      this.i4 = new BN3(4).toRed(this.red).redInvm();
      this.two = new BN3(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN3(x, 16);
        this.z = new BN3(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
      return this.point(utils.toArray(bytes3, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode2() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN3 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN3(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN3(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN3(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN3(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN3(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN3(x, 16);
        this.y = new BN3(y, 16);
        this.z = z ? new BN3(z, 16) : this.curve.one;
        this.t = t && new BN3(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f3 = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f3);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f3.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f3 = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f3.redSub(this.curve.two));
          ny = f3.redMul(e.redSub(d));
          nz = f3.redSqr().redSub(f3).redSub(f3);
        } else {
          h = this.z.redSqr();
          j = f3.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f3.redMul(e.redSub(d));
          nz = f3.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f3 = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f3);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f3.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f3 = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f3).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f3.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f3).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var curve = exports2;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex2;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r2 = al << 32 - num | ah >>> num;
      return r2 >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update3(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r2 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r2, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r2, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest3(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes3 = this._delta8;
      var k = bytes3 - (len + this.padLength) % bytes3;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports2.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports2.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports2.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports2.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f3 = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f3, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f3;
        f3 = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f3);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ ~xh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ ~xl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ xh & zh ^ yh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ xl & zl ^ yl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update3(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f3(j, B, C, D), msg[r2[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f3(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f3(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function Hmac(hash2, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash2, key, enc);
      this.Hash = hash2;
      this.blockSize = hash2.blockSize / 8;
      this.outSize = hash2.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update3(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest3(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports2) {
    var hash2 = exports2;
    hash2.utils = require_utils3();
    hash2.common = require_common();
    hash2.sha = require_sha();
    hash2.ripemd = require_ripemd();
    hash2.hmac = require_hmac2();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var curves = exports2;
    var hash2 = require_hash();
    var curve = require_curve();
    var utils = require_utils2();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var hash2 = require_hash();
    var utils = require_utils();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash2.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update3(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate2(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var BN3 = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    function KeyPair(ec2, options) {
      this.ec = ec2;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN3(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive3(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var BN3 = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN3(options.r, 16);
      this.s = new BN3(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r2 = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r2[0] === 0) {
        if (r2[1] & 128) {
          r2 = r2.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN3(r2);
      this.s = new BN3(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r2 = this.r.toArray();
      var s = this.s.toArray();
      if (r2[0] & 128)
        r2 = [0].concat(r2);
      if (s[0] & 128)
        s = [0].concat(s);
      r2 = rmPadding(r2);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r2.length);
      arr = arr.concat(r2);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var BN3 = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes3 = this.n.byteLength();
      var ns2 = this.n.sub(new BN3(2));
      for (; ; ) {
        var priv = new BN3(drbg.generate(bytes3));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN3(msg, 16));
      var bytes3 = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes3);
      var nonce = msg.toArray("be", bytes3);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN3(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN3(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r2 = kpX.umod(this.n);
        if (r2.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r2.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r2, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc) {
      msg = this._truncateToN(new BN3(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r2 = signature.r;
      var s = signature.s;
      if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r2).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r2) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r2);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN3(msg);
      var r2 = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
      else
        r2 = this.curve.pointFromX(r2, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r2, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash2 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash2.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash2() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix2() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var BN3 = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN3)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex2() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var hash2 = require_hash();
    var curves = require_curves();
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash2.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r2 = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r2);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r2.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash3 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash3.update(arguments[i]);
      return utils.intFromLE(hash3.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes3) {
      bytes3 = utils.parseBytes(bytes3);
      var lastIx = bytes3.length - 1;
      var normed = bytes3.slice(0, lastIx).concat(bytes3[lastIx] & ~128);
      var xIsOdd = (bytes3[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt2(bytes3) {
      return utils.intFromLE(bytes3);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var elliptic4 = exports2;
    elliptic4.version = require_package().version;
    elliptic4.utils = require_utils2();
    elliptic4.rand = require_brorand();
    elliptic4.curve = require_curve();
    elliptic4.curves = require_curves();
    elliptic4.ec = require_ec();
    elliptic4.eddsa = require_eddsa();
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number, base, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN3;
      } else {
        exports3.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer5;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer5 = window.Buffer;
        } else {
          Buffer5 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN3.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN3.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r2 *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r2 += b;
        }
        return r2;
      }
      BN3.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN3.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN3.prototype.clone = function clone() {
        var r2 = new BN3(null);
        this.copy(r2);
        return r2;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN3.prototype.inspect = inspect;
        }
      } else {
        BN3.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString(base, padding2) {
        base = base || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer5) {
        BN3.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer5, endian, length);
        };
      }
      BN3.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w) {
          var t = w;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r2 += b;
          if (b !== 26)
            break;
        }
        return r2;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN3.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r2 = a * b;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r2 = a * b + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r2 = a * b;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t = new Array(N2);
        var l = BN3.prototype._countBits(N2) - 1;
        for (var i = 0; i < N2; i++) {
          t[i] = this.revBin(i, l, N2);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N2) {
        if (x === 0 || x === N2 - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i = 0; i < N2; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s = 1; s < N2; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N2; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N2 = Math.max(m, n) | 1;
        var odd = N2 & 1;
        var i = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i = 0; i < N2 / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N2 - i - 1];
          rws[N2 - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N2 - i - 1];
          iws[N2 - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i = 0; i < N2 / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N2) * 8192 + Math.round(ws[2 * i] / N2) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N2; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i = 0; i < N2; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N2 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x.words, x.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i = 0; i < N2; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN3.prototype.mul = function mul(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i;
        if (r2 !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r2;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN3.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN3.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN3.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r2 = a.cmp(b);
          if (r2 < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r2 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN3(1).iushln(m - i - 1));
          r2 = r2.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN3(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS({
  "node_modules/spark-md5/spark-md5.js"(exports2, module2) {
    (function(factory) {
      if (typeof exports2 === "object") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        var glob;
        try {
          glob = window;
        } catch (e) {
          glob = self;
        }
        glob.SparkMD5 = factory();
      }
    })(function(undefined2) {
      "use strict";
      var add32 = function(a, b) {
        return a + b & 4294967295;
      }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32(a << s | a >>> 32 - s, b);
      }
      function md5cycle(x, k) {
        var a = x[0], b = x[1], c = x[2], d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      }
      function md5blk(s) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
      }
      function md51(s) {
        var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a) {
        var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }
        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= a[i] << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n) {
        var s = "", j;
        for (j = 0; j < 4; j += 1) {
          s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
        }
        return s;
      }
      function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
          x[i] = rhex(x[i]);
        }
        return x.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
        add32 = function(x, y) {
          var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
      }
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length, 0);
            }
            return Math.min(val, length);
          }
          ArrayBuffer.prototype.slice = function(from, to) {
            var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
            if (to !== undefined2) {
              end = clamp(to, length);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
          str = unescape(encodeURIComponent(str));
        }
        return str;
      }
      function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;
        for (i = 0; i < length; i += 1) {
          arr[i] = str.charCodeAt(i);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes3 = [], length = hex2.length, x;
        for (x = 0; x < length - 1; x += 2) {
          bytes3.push(parseInt(hex2.substr(x, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes3);
      }
      function SparkMD52() {
        this.reset();
      }
      SparkMD52.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this;
      };
      SparkMD52.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length, i;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }
        this._buff = this._buff.substring(i - 64);
        return this;
      };
      SparkMD52.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD52.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD52.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD52.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD52.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD52.prototype._finish = function(tail, length) {
        var i = length, tmp, lo, hi;
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(this._hash, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
      };
      SparkMD52.hash = function(str, raw) {
        return SparkMD52.hashBinary(toUtf8(str), raw);
      };
      SparkMD52.hashBinary = function(content, raw) {
        var hash2 = md51(content), ret = hex(hash2);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD52.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD52.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;
        this._length += arr.byteLength;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }
        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD52.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff[i] << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD52.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD52.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD52.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD52.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD52.prototype.setState.call(this, state);
      };
      SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
      SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
      SparkMD52.ArrayBuffer.hash = function(arr, raw) {
        var hash2 = md51_array(new Uint8Array(arr)), ret = hex(hash2);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD52;
    });
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS3 = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING3 = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT3 = [0, 8, 16, 24];
      var RC3 = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak3(bits2, padding2, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak3(bits2, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding2, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding2) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding2, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak3(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      };
      var createShakeMethod = function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak3(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      };
      var createCshakeMethod = function(bits2, padding2) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak3(bits2, padding2, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      };
      var createKmacMethod = function(bits2, padding2) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING3, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak3(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak3.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT3[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT3[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT3[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT3[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT3[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT3[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT3[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT3[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT3[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT3[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT3[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f3(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak3.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes3 = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes3.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes3.push(n);
        } else {
          bytes3.unshift(n);
        }
        this.update(bytes3);
        return bytes3.length;
      };
      Keccak3.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes3 = 0, length = str.length;
        if (notString) {
          bytes3 = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes3 += 1;
            } else if (code < 2048) {
              bytes3 += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes3 += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes3 += 4;
            }
          }
        }
        bytes3 += this.encode(bytes3 * 8);
        this.update(str);
        return bytes3;
      };
      Keccak3.prototype.bytepad = function(strs, w) {
        var bytes3 = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes3 += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes3 % w;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak3.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f3(s);
      };
      Keccak3.prototype.toString = Keccak3.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS3[block >> 4 & 15] + HEX_CHARS3[block & 15] + HEX_CHARS3[block >> 12 & 15] + HEX_CHARS3[block >> 8 & 15] + HEX_CHARS3[block >> 20 & 15] + HEX_CHARS3[block >> 16 & 15] + HEX_CHARS3[block >> 28 & 15] + HEX_CHARS3[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f3(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS3[block >> 4 & 15] + HEX_CHARS3[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS3[block >> 12 & 15] + HEX_CHARS3[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS3[block >> 20 & 15] + HEX_CHARS3[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak3.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes3 = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes3);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f3(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes3);
        }
        return buffer;
      };
      Keccak3.prototype.buffer = Keccak3.prototype.arrayBuffer;
      Keccak3.prototype.digest = Keccak3.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f3(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak3.call(this, bits2, padding2, outputBits);
      }
      Kmac.prototype = new Keccak3();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak3.prototype.finalize.call(this);
      };
      var f3 = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC3[n];
          s[1] ^= RC3[n + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f3, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f3 === "object" && f3 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f3;
        var objects = new Array(len);
        objects[0] = ss(f3);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f3 !== "string") {
        return f3;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f3;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f3 && f3.length || 0;
      for (var i = 0; i < flen; ) {
        if (f3.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f3.charCodeAt(i + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f3;
      else if (lastPos < flen) {
        str += f3.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/pino/browser.js"(exports2, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    module2.exports = pino2;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function levelToValue(level, logger15) {
      return level === "silent" ? Infinity : logger15.levels.values[level];
    }
    var baseLogFunctionSymbol = Symbol("pino.logFuncs");
    var hierarchySymbol = Symbol("pino.hierarchy");
    var logFallbackMap = {
      error: "log",
      fatal: "error",
      warn: "error",
      info: "log",
      debug: "log",
      trace: "log"
    };
    function appendChildLogger(parentLogger, childLogger) {
      const newEntry = {
        logger: childLogger,
        parent: parentLogger[hierarchySymbol]
      };
      childLogger[hierarchySymbol] = newEntry;
    }
    function setupBaseLogFunctions(logger15, levels, proto42) {
      const logFunctions = {};
      levels.forEach((level) => {
        logFunctions[level] = proto42[level] ? proto42[level] : _console[level] || _console[logFallbackMap[level] || "log"] || noop;
      });
      logger15[baseLogFunctionSymbol] = logFunctions;
    }
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k) {
          return k !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino2(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto42 = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto42 === "function") {
        levels.forEach(function(level2) {
          proto42[level2] = proto42;
        });
      }
      if (opts.enabled === false || opts.browser.disabled)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger15 = Object.create(proto42);
      if (!logger15.log)
        logger15.log = noop;
      setupBaseLogFunctions(logger15, levels, proto42);
      appendChildLogger({}, logger15);
      Object.defineProperty(logger15, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger15, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        formatters: opts.browser.formatters,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger15.levels = getLevels(opts);
      logger15.level = level;
      logger15.setMaxListeners = logger15.getMaxListeners = logger15.emit = logger15.addListener = logger15.on = logger15.prependListener = logger15.once = logger15.prependOnceListener = logger15.removeListener = logger15.removeAllListeners = logger15.listeners = logger15.listenerCount = logger15.eventNames = logger15.write = logger15.flush = noop;
      logger15.serializers = serializers;
      logger15._serialize = serialize;
      logger15._stdErrSerialize = stdErrSerialize;
      logger15.child = child;
      if (transmit2)
        logger15._logEvent = createLogEventShape();
      function getLevelVal() {
        return levelToValue(this.level, this);
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(this, setOpts, logger15, "error");
        set(this, setOpts, logger15, "fatal");
        set(this, setOpts, logger15, "warn");
        set(this, setOpts, logger15, "info");
        set(this, setOpts, logger15, "debug");
        set(this, setOpts, logger15, "trace");
        customLevels.forEach((level3) => {
          set(this, setOpts, logger15, level3);
        });
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.bindings = bindings;
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        const newLogger = new Child(this);
        appendChildLogger(this, newLogger);
        newLogger.level = this.level;
        return newLogger;
      }
      return logger15;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino2.levels.values, customLevels);
      const labels = Object.assign({}, pino2.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino2.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino2.stdSerializers = stdSerializers;
    pino2.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function getBindingChain(logger15) {
      const bindings = [];
      if (logger15.bindings) {
        bindings.push(logger15.bindings);
      }
      let hierarchy = logger15[hierarchySymbol];
      while (hierarchy.parent) {
        hierarchy = hierarchy.parent;
        if (hierarchy.logger.bindings) {
          bindings.push(hierarchy.logger.bindings);
        }
      }
      return bindings.reverse();
    }
    function set(self2, opts, rootLogger, level) {
      self2[level] = levelToValue(self2.level, rootLogger) > levelToValue(level, rootLogger) ? noop : rootLogger[baseLogFunctionSymbol][level];
      if (!opts.transmit && self2[level] === noop) {
        return;
      }
      self2[level] = createWrap(self2, opts, rootLogger, level);
      const bindings = getBindingChain(self2);
      if (bindings.length === 0) {
        return;
      }
      self2[level] = prependBindingsInArguments(bindings, self2[level]);
    }
    function prependBindingsInArguments(bindings, logFunc) {
      return function() {
        return logFunc.apply(this, [...bindings, ...arguments]);
      };
    }
    function createWrap(self2, opts, rootLogger, level) {
      return /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto42 = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i = 0; i < args.length; i++)
            args[i] = arguments[i];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject || opts.formatters) {
            write.call(proto42, asObject(this, level, args, ts, opts.formatters));
          } else
            write.apply(proto42, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || self2._level;
            const transmitValue = rootLogger.levels.values[transmitLevel];
            const methodValue = rootLogger.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: rootLogger.levels.values[opts.transmit.level || self2._level],
              send: opts.transmit.send,
              val: levelToValue(self2._level, rootLogger)
            }, args);
          }
        };
      }(self2[baseLogFunctionSymbol][level]);
    }
    function asObject(logger15, level, args, ts, formatters = {}) {
      const {
        level: levelFormatter = () => logger15.levels.values[level],
        log: logObjectFormatter = (obj) => obj
      } = formatters;
      if (logger15._serialize)
        applySerializers(args, logger15._serialize, logger15.serializers, logger15._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const logObject = {};
      if (ts) {
        logObject.time = ts;
      }
      logObject.level = levelFormatter(level, logger15.levels.values[level]);
      let lvl = (logger15._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(logObject, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        logObject.msg = msg;
      const formattedLogObject = logObjectFormatter(logObject);
      return formattedLogObject;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i in args) {
        if (stdErrSerialize && args[i] instanceof Error) {
          args[i] = pino2.stdSerializers.err(args[i]);
        } else if (typeof args[i] === "object" && !Array.isArray(args[i])) {
          for (const k in args[i]) {
            if (serialize && serialize.indexOf(k) > -1 && k in serializers) {
              args[i][k] = serializers[k](args[i][k]);
            }
          }
        }
      }
    }
    function transmit(logger15, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger15._logEvent.bindings;
      applySerializers(
        args,
        logger15._serialize || Object.keys(logger15.serializers),
        logger15.serializers,
        logger15._stdErrSerialize === void 0 ? true : logger15._stdErrSerialize
      );
      logger15._logEvent.ts = ts;
      logger15._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger15._logEvent.level.label = methodLevel;
      logger15._logEvent.level.value = methodValue;
      send(methodLevel, logger15._logEvent, val);
      logger15._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a) {
      return a;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o) {
        return typeof o !== "undefined" && o;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
    module2.exports.default = pino2;
    module2.exports.pino = pino2;
  }
});

// node_modules/@hashgraph/sdk/src/EntityIdHelper.js
var EntityIdHelper_exports = {};
__export(EntityIdHelper_exports, {
  _checksum: () => _checksum,
  _parseAddress: () => _parseAddress,
  aliasToEvmAddress: () => aliasToEvmAddress,
  aliasToPublicKey: () => aliasToPublicKey,
  compare: () => compare2,
  constructor: () => constructor,
  fromSolidityAddress: () => fromSolidityAddress,
  fromString: () => fromString,
  fromStringSplitter: () => fromStringSplitter,
  publicKeyToAlias: () => publicKeyToAlias,
  toSolidityAddress: () => toSolidityAddress,
  toStringWithChecksum: () => toStringWithChecksum,
  validateChecksum: () => validateChecksum
});
var import_long2 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/encoding/hex.browser.js
var byteToHex = [];
for (let n = 0; n <= 255; n += 1) {
  byteToHex.push(n.toString(16).padStart(2, "0"));
}
function encode(data) {
  let string = "";
  for (const byte of data) {
    string += byteToHex[byte];
  }
  return string;
}
function decode(text) {
  const str = text.startsWith("0x") ? text.substring(2) : text;
  const result = str.match(/.{1,2}/gu);
  return new Uint8Array(
    (result == null ? [] : result).map((byte) => parseInt(byte, 16))
  );
}

// node_modules/@hashgraph/sdk/src/BadEntityIdError.js
var BadEntityIdError = class extends Error {
  /**
   * @param {Long} shard
   * @param {Long} realm
   * @param {Long} num
   * @param {string} presentChecksum
   * @param {string} expectedChecksum
   */
  constructor(shard, realm, num, presentChecksum, expectedChecksum) {
    super(
      `Entity ID ${shard.toString()}.${realm.toString()}.${num.toString()}-${presentChecksum} was incorrect.`
    );
    this.name = "BadEntityIdException";
    this.shard = shard;
    this.realm = realm;
    this.num = num;
    this.presentChecksum = presentChecksum;
    this.expectedChecksum = expectedChecksum;
  }
};

// node_modules/@hashgraph/sdk/src/util.js
var import_long = __toESM(require_long(), 1);
var REQUIRE_NON_NULL_ERROR = "This value cannot be null | undefined.";
var REQUIRE_STRING_OR_UINT8ARRAY_ERROR = "This value must be a string or Uint8Array.";
var REQUIRE_ARRAY_ERROR = "The provided variable must be an Array.";
var FUNCTION_CONVERT_TO_BIGNUMBER_ERROR = "This value must be a String, Number, or BigNumber to be converted.";
var FUNCTION_CONVERT_TO_NUMBER_ERROR = "This value must be a String, Number, or BigNumber to be converted.";
var FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR = "Unable to parse given variable. Returns NaN.";
function isNonNull(variable) {
  return variable != null;
}
function isUint8Array(variable) {
  return isNonNull(variable) && variable instanceof Uint8Array;
}
function isNumber(variable) {
  return isNonNull(variable) && (typeof variable == "number" || variable instanceof Number);
}
function isBigNumber(variable) {
  return isNonNull(variable) && variable instanceof bignumber_default;
}
function isLong(variable) {
  return isNonNull(variable) && variable instanceof import_long.default;
}
function isString(variable) {
  return isNonNull(variable) && typeof variable == "string";
}
function isStringOrUint8Array(variable) {
  return isNonNull(variable) && (isString(variable) || isUint8Array(variable));
}
function isLongZeroAddress(address) {
  for (let i = 0; i < 12; i++) {
    if (address[i] != 0) {
      return false;
    }
  }
  return true;
}
function requireNotNegative(variable) {
  if (variable.isNegative()) {
    throw new Error("negative value not allowed");
  }
  return variable;
}
function requireNonNull(variable) {
  if (!isNonNull(variable)) {
    throw new Error(REQUIRE_NON_NULL_ERROR);
  } else {
    return variable;
  }
}
function requireStringOrUint8Array(variable) {
  if (isStringOrUint8Array(requireNonNull(variable))) {
    return (
      /** @type {string | Uint8Array} */
      variable
    );
  } else {
    throw new Error(REQUIRE_STRING_OR_UINT8ARRAY_ERROR);
  }
}
function convertToBigNumber(variable) {
  requireNonNull(variable);
  if (isBigNumber(variable) || isString(variable) || isNumber(variable) || isLong(variable)) {
    return new bignumber_default(variable);
  }
  throw new Error(FUNCTION_CONVERT_TO_BIGNUMBER_ERROR);
}
function convertToBigNumberArray(variable) {
  if (variable instanceof Array) {
    return (
      /** @type {Array<BigNumber>} */
      variable.map(convertToBigNumber)
    );
  } else {
    throw new Error(REQUIRE_ARRAY_ERROR);
  }
}
function convertToNumber(variable) {
  requireNonNull(variable);
  if (isBigNumber(variable) || isString(variable) || isNumber(variable) || isLong(variable)) {
    const num = parseInt(variable);
    if (isNaN(num)) {
      throw new Error(FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR);
    } else {
      return num;
    }
  } else {
    throw new Error(FUNCTION_CONVERT_TO_NUMBER_ERROR);
  }
}
function safeView(arr, offset = 0, length = arr.byteLength) {
  if (!(Number.isInteger(offset) && offset >= 0))
    throw new Error("Invalid offset!");
  if (!(Number.isInteger(length) && length >= 0))
    throw new Error("Invalid length!");
  return new DataView(
    arr.buffer,
    arr.byteOffset + offset,
    Math.min(length, arr.byteLength - offset)
  );
}
function compare(a, b, ignore = /* @__PURE__ */ new Set()) {
  if (typeof a === "object" && typeof b === "object") {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      if (aKeys[i] !== bKeys[i]) {
        return false;
      }
      if (ignore.has(aKeys[i])) {
        continue;
      }
      if (!compare(a[aKeys[i]], b[bKeys[i]], ignore)) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "number" && typeof b === "number") {
    return a === b;
  } else if (typeof a === "string" && typeof b === "string") {
    return a === b;
  } else if (typeof a === "boolean" && typeof b === "boolean") {
    return a === b;
  } else {
    return false;
  }
}
function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
}
function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.byteLength !== array2.byteLength) {
    return false;
  }
  const view1 = new DataView(
    array1.buffer,
    array1.byteOffset,
    array1.byteLength
  );
  const view2 = new DataView(
    array2.buffer,
    array2.byteOffset,
    array2.byteLength
  );
  let i = array1.byteLength;
  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }
  return true;
}

// node_modules/rfc4648/lib/rfc4648.js
function parse(string, encoding, opts) {
  var _opts$out;
  if (opts === void 0) {
    opts = {};
  }
  if (!encoding.codes) {
    encoding.codes = {};
    for (var i = 0; i < encoding.chars.length; ++i) {
      encoding.codes[encoding.chars[i]] = i;
    }
  }
  if (!opts.loose && string.length * encoding.bits & 7) {
    throw new SyntaxError("Invalid padding");
  }
  var end = string.length;
  while (string[end - 1] === "=") {
    --end;
    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
      throw new SyntaxError("Invalid padding");
    }
  }
  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0);
  var bits = 0;
  var buffer = 0;
  var written = 0;
  for (var _i = 0; _i < end; ++_i) {
    var value = encoding.codes[string[_i]];
    if (value === void 0) {
      throw new SyntaxError("Invalid character " + string[_i]);
    }
    buffer = buffer << encoding.bits | value;
    bits += encoding.bits;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= encoding.bits || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function stringify(data, encoding, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var _opts = opts, _opts$pad = _opts.pad, pad = _opts$pad === void 0 ? true : _opts$pad;
  var mask = (1 << encoding.bits) - 1;
  var out = "";
  var bits = 0;
  var buffer = 0;
  for (var i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | 255 & data[i];
    bits += 8;
    while (bits > encoding.bits) {
      bits -= encoding.bits;
      out += encoding.chars[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += encoding.chars[mask & buffer << encoding.bits - bits];
  }
  if (pad) {
    while (out.length * encoding.bits & 7) {
      out += "=";
    }
  }
  return out;
}
var base32Encoding = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bits: 5
};
var base32 = {
  parse: function parse$1(string, opts) {
    if (opts === void 0) {
      opts = {};
    }
    return parse(opts.loose ? string.toUpperCase().replace(/0/g, "O").replace(/1/g, "L").replace(/8/g, "B") : string, base32Encoding, opts);
  },
  stringify: function stringify$1(data, opts) {
    return stringify(data, base32Encoding, opts);
  }
};

// node_modules/@hashgraph/sdk/src/base32.js
var decodeOpts = { loose: true };
var encodeOpts = { pad: false };
var decode2 = (str) => str && base32.parse(str, decodeOpts);
var encode2 = (data) => data && base32.stringify(data, encodeOpts);
var base32_default = {
  decode: decode2,
  encode: encode2
};

// node_modules/@hashgraph/sdk/src/EntityIdHelper.js
var HashgraphProto = __toESM(require_lib(), 1);

// node_modules/@hashgraph/cryptography/src/Key.js
var Key = class {
};

// node_modules/@hashgraph/cryptography/src/BadKeyError.js
var BadKeyError = class extends Error {
  /**
   * @param {Error | string} messageOrCause
   */
  constructor(messageOrCause) {
    super(
      messageOrCause instanceof Error ? messageOrCause.message : messageOrCause
    );
    this.name = "BadKeyError";
    if (messageOrCause instanceof Error) {
      this.cause = messageOrCause;
      this.stack = messageOrCause.stack;
    }
  }
};

// node_modules/@hashgraph/cryptography/src/Ed25519PublicKey.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/@hashgraph/cryptography/src/util/array.js
function arrayEqual2(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.byteLength !== array2.byteLength) {
    return false;
  }
  const view1 = new DataView(
    array1.buffer,
    array1.byteOffset,
    array1.byteLength
  );
  const view2 = new DataView(
    array2.buffer,
    array2.byteOffset,
    array2.byteLength
  );
  let i = array1.byteLength;
  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }
  return true;
}
function arrayStartsWith(array, arrayPrefix) {
  if (array.byteLength < arrayPrefix.byteLength) {
    return false;
  }
  let i = arrayPrefix.byteLength;
  while (i--) {
    if (array[i] !== arrayPrefix[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@hashgraph/cryptography/src/encoding/hex.browser.js
var byteToHex2 = [];
for (let n = 0; n <= 255; n += 1) {
  byteToHex2.push(n.toString(16).padStart(2, "0"));
}
function encode3(data) {
  let string = "";
  for (const byte of data) {
    string += byteToHex2[byte];
  }
  return string;
}
function decode3(text) {
  const str = text.startsWith("0x") ? text.substring(2) : text;
  const result = str.match(/.{1,2}/gu);
  return new Uint8Array(
    (result == null ? [] : result).map((byte) => parseInt(byte, 16))
  );
}
function hexZeroPadded(value, length) {
  const HexCharacters2 = "0123456789abcdef";
  let result = "0x";
  for (let i = 0; i < value.length; i++) {
    let v = value[i];
    result += HexCharacters2[(v & 240) >> 4] + HexCharacters2[v & 15];
  }
  if (result.length > 2 * length + 2) {
    console.log("result out of range", "result");
  }
  while (result.length < 2 * length + 2) {
    result = "0x0" + result.substring(2);
  }
  return result.substring(2);
}

// node_modules/@hashgraph/cryptography/src/Ed25519PublicKey.js
var import_node_forge = __toESM(require_lib2(), 1);
var derPrefix = "302a300506032b6570032100";
var derPrefixBytes = decode3(derPrefix);
var Ed25519PublicKey = class _Ed25519PublicKey extends Key {
  /**
   * @internal
   * @hideconstructor
   * @param {Uint8Array} keyData
   */
  constructor(keyData) {
    super();
    this._keyData = keyData;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "ED25519";
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ed25519PublicKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 32:
        return _Ed25519PublicKey.fromBytesRaw(data);
      case 44:
        return _Ed25519PublicKey.fromBytesDer(data);
      default:
        throw new BadKeyError(
          `invalid public key length: ${data.length} bytes`
        );
    }
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ed25519PublicKey}
   */
  static fromBytesDer(data) {
    const asn = import_node_forge.default.asn1.fromDer(new import_node_forge.default.util.ByteStringBuffer(data));
    let publicKey;
    try {
      publicKey = import_node_forge.default.pki.ed25519.publicKeyFromAsn1(asn);
    } catch (error) {
      const message = (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        error != null && /** @type {Error} */
        error.message != null ? (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          /** @type {Error} */
          error.message
        ) : ""
      );
      throw new BadKeyError(
        `cannot decode ED25519 public key data from DER format: ${message}`
      );
    }
    return new _Ed25519PublicKey(publicKey);
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ed25519PublicKey}
   */
  static fromBytesRaw(data) {
    if (data.length != 32) {
      throw new BadKeyError(
        `invalid public key length: ${data.length} bytes`
      );
    }
    return new _Ed25519PublicKey(data);
  }
  /**
   * Parse a public key from a string of hexadecimal digits.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   * @param {string} text
   * @returns {Ed25519PublicKey}
   */
  static fromString(text) {
    return _Ed25519PublicKey.fromBytes(decode3(text));
  }
  /**
   * Verify a signature on a message with this public key.
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  verify(message, signature) {
    return import_tweetnacl.default.sign.detached.verify(message, signature, this._keyData);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(derPrefixBytes.length + 32);
    bytes3.set(derPrefixBytes, 0);
    bytes3.set(this._keyData.subarray(0, 32), derPrefixBytes.length);
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._keyData.slice();
  }
  /**
   * @param {Ed25519PublicKey} other
   * @returns {boolean}
   */
  equals(other) {
    return arrayEqual2(this._keyData, other._keyData);
  }
};

// node_modules/@hashgraph/cryptography/src/Ed25519PrivateKey.js
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);

// node_modules/@hashgraph/cryptography/src/primitive/random.js
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
function bytes(count) {
  return import_tweetnacl2.default.randomBytes(count);
}
function bytesAsync(count) {
  return Promise.resolve(import_tweetnacl2.default.randomBytes(count));
}

// node_modules/@hashgraph/cryptography/src/encoding/utf8.browser.js
function decode4(data) {
  return new TextDecoder().decode(data);
}
function encode4(text) {
  return new TextEncoder().encode(text);
}

// node_modules/@hashgraph/cryptography/src/primitive/hmac.browser.js
var HashAlgorithm = {
  Sha256: "SHA-256",
  Sha384: "SHA-384",
  Sha512: "SHA-512"
};
async function hash(algorithm, secretKey, data) {
  const key = typeof secretKey === "string" ? encode4(secretKey) : secretKey;
  const value = typeof data === "string" ? encode4(data) : data;
  try {
    const key_ = await window.crypto.subtle.importKey(
      "raw",
      key,
      {
        name: "HMAC",
        hash: algorithm
      },
      false,
      ["sign"]
    );
    return new Uint8Array(
      await window.crypto.subtle.sign("HMAC", key_, value)
    );
  } catch {
    throw new Error("Fallback if SubtleCrypto fails is not implemented");
  }
}

// node_modules/@hashgraph/cryptography/src/primitive/bip32.browser.js
var import_elliptic = __toESM(require_elliptic(), 1);
var import_bn = __toESM(require_bn2(), 1);
var secp256k1 = new import_elliptic.default.ec("secp256k1");
var N = new import_bn.default(
  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  "hex"
);
var HARDENED_BIT = 2147483648;
async function derive(parentKey, chainCode, index) {
  const isHardened = isHardenedIndex(index);
  const data = new Uint8Array(37);
  const publicKey = decode3(
    secp256k1.keyFromPrivate(parentKey).getPublic(true, "hex")
  );
  if (isHardened) {
    data[0] = 0;
    data.set(parentKey, 1);
  } else {
    data.set(publicKey, 0);
  }
  new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(
    33,
    index,
    false
  );
  const I = await hash(HashAlgorithm.Sha512, chainCode, data);
  const IL = I.subarray(0, 32);
  const IR = I.subarray(32);
  try {
    const ki = secp256k1.keyFromPrivate(parentKey).getPrivate().add(secp256k1.keyFromPrivate(IL).getPrivate()).mod(N);
    const hexZeroPadded2 = hexZeroPadded(
      Uint8Array.from(ki.toArray()),
      32
    );
    if (ki.eqn(0)) {
      return derive(parentKey, chainCode, index + 1);
    }
    return {
      keyData: decode3(hexZeroPadded2),
      chainCode: IR
    };
  } catch {
    return derive(parentKey, chainCode, index + 1);
  }
}
async function fromSeed(seed) {
  if (seed.length < 16)
    throw new TypeError("Seed should be at least 128 bits");
  if (seed.length > 64)
    throw new TypeError("Seed should be at most 512 bits");
  const I = await hash(HashAlgorithm.Sha512, "Bitcoin seed", seed);
  const IL = I.subarray(0, 32);
  const IR = I.subarray(32);
  return { keyData: IL, chainCode: IR };
}
function toHardenedIndex(index) {
  return index | HARDENED_BIT;
}
function isHardenedIndex(index) {
  return (index & HARDENED_BIT) !== 0;
}

// node_modules/@hashgraph/cryptography/src/primitive/slip10.js
async function derive2(parentKey, chainCode, index) {
  if (isHardenedIndex(index)) {
    throw new Error("the index should not be pre-hardened");
  }
  const input = new Uint8Array(37);
  input[0] = 0;
  input.set(parentKey, 1);
  new DataView(input.buffer, input.byteOffset, input.byteLength).setUint32(
    33,
    index,
    false
  );
  input[33] |= 128;
  const digest3 = await hash(HashAlgorithm.Sha512, chainCode, input);
  return { keyData: digest3.subarray(0, 32), chainCode: digest3.subarray(32) };
}
async function fromSeed2(seed) {
  const digest3 = await hash(
    HashAlgorithm.Sha512,
    "ed25519 seed",
    seed
  );
  return { keyData: digest3.subarray(0, 32), chainCode: digest3.subarray(32) };
}

// node_modules/@hashgraph/cryptography/src/Ed25519PrivateKey.js
var import_node_forge2 = __toESM(require_lib2(), 1);
var derPrefix2 = "302e020100300506032b657004220420";
var derPrefixBytes2 = decode3(derPrefix2);
var Ed25519PrivateKey = class _Ed25519PrivateKey {
  /**
   * @hideconstructor
   * @internal
   * @param {nacl.SignKeyPair | Uint8Array} keyPair
   * @param {Uint8Array=} chainCode
   */
  constructor(keyPair, chainCode) {
    this._keyPair = keyPair instanceof Uint8Array ? import_tweetnacl3.default.sign.keyPair.fromSeed(keyPair) : keyPair;
    this._chainCode = chainCode != null ? chainCode : null;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "ED25519";
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Ed25519PrivateKey}
   */
  static generate() {
    const entropy = bytes(64);
    return new _Ed25519PrivateKey(
      import_tweetnacl3.default.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
      entropy.subarray(32)
    );
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Promise<Ed25519PrivateKey>}
   */
  static async generateAsync() {
    const entropy = await bytesAsync(64);
    return new _Ed25519PrivateKey(
      import_tweetnacl3.default.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
      entropy.subarray(32)
    );
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {Ed25519PrivateKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 48:
        return _Ed25519PrivateKey.fromBytesDer(data);
      case 32:
      case 64:
        return _Ed25519PrivateKey.fromBytesRaw(data);
      default:
        throw new BadKeyError(
          `invalid private key length: ${data.length} bytes`
        );
    }
  }
  /**
   * Construct a private key from bytes with DER header.
   * @param {Uint8Array} data
   * @returns {Ed25519PrivateKey}
   */
  static fromBytesDer(data) {
    const asn = import_node_forge2.default.asn1.fromDer(new import_node_forge2.default.util.ByteStringBuffer(data));
    let privateKey;
    try {
      privateKey = import_node_forge2.default.pki.ed25519.privateKeyFromAsn1(asn).privateKeyBytes;
    } catch (error) {
      const message = (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        error != null && /** @type {Error} */
        error.message != null ? (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          /** @type {Error} */
          error.message
        ) : ""
      );
      throw new BadKeyError(
        `cannot decode ED25519 private key data from DER format: ${message}`
      );
    }
    const keyPair = import_tweetnacl3.default.sign.keyPair.fromSeed(privateKey);
    return new _Ed25519PrivateKey(keyPair);
  }
  /**
   * Construct a private key from bytes without DER header.
   * @param {Uint8Array} data
   * @returns {Ed25519PrivateKey}
   */
  static fromBytesRaw(data) {
    switch (data.length) {
      case 32:
        return new _Ed25519PrivateKey(import_tweetnacl3.default.sign.keyPair.fromSeed(data));
      case 64:
        return new _Ed25519PrivateKey(
          import_tweetnacl3.default.sign.keyPair.fromSecretKey(data)
        );
      default:
    }
    throw new BadKeyError(
      `invalid private key length: ${data.length} bytes`
    );
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {Ed25519PrivateKey}
   */
  static fromString(text) {
    return _Ed25519PrivateKey.fromBytes(decode3(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {Ed25519PrivateKey}
   */
  static fromStringDer(text) {
    return _Ed25519PrivateKey.fromBytesDer(decode3(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {Ed25519PrivateKey}
   */
  static fromStringRaw(text) {
    return _Ed25519PrivateKey.fromBytesRaw(decode3(text));
  }
  /**
   * Construct a ED25519 private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<Ed25519PrivateKey>}
   */
  static async fromSeed(seed) {
    const { keyData, chainCode } = await fromSeed2(seed);
    return new _Ed25519PrivateKey(keyData, chainCode);
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   * @returns {Ed25519PublicKey}
   */
  get publicKey() {
    return new Ed25519PublicKey(this._keyPair.publicKey);
  }
  /**
   * Sign a message with this private key.
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */
  sign(bytes3) {
    return import_tweetnacl3.default.sign.detached(bytes3, this._keyPair.secretKey);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(derPrefixBytes2.length + 32);
    bytes3.set(derPrefixBytes2, 0);
    bytes3.set(
      this._keyPair.secretKey.subarray(0, 32),
      derPrefixBytes2.length
    );
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._keyPair.secretKey.slice(0, 32);
  }
};

// node_modules/@hashgraph/cryptography/src/primitive/keccak.js
var HEX_CHARS = "0123456789abcdef".split("");
var KECCAK_PADDING = [1, 256, 65536, 16777216];
var SHIFT = [0, 8, 16, 24];
var RC = [
  1,
  0,
  32898,
  0,
  32906,
  2147483648,
  2147516416,
  2147483648,
  32907,
  0,
  2147483649,
  0,
  2147516545,
  2147483648,
  32777,
  2147483648,
  138,
  0,
  136,
  0,
  2147516425,
  0,
  2147483658,
  0,
  2147516555,
  0,
  139,
  2147483648,
  32905,
  2147483648,
  32771,
  2147483648,
  32770,
  2147483648,
  128,
  2147483648,
  32778,
  0,
  2147483658,
  2147483648,
  2147516545,
  2147483648,
  32896,
  2147483648,
  2147483649,
  0,
  2147516424,
  2147483648
];
var Keccak = (bits) => ({
  blocks: [],
  reset: true,
  block: 0,
  start: 0,
  blockCount: 1600 - (bits << 1) >> 5,
  outputBlocks: bits >> 5,
  // @ts-ignore
  s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
});
var update = (state, message) => {
  var length = message.length, blocks = state.blocks, byteCount = state.blockCount << 2, blockCount = state.blockCount, outputBlocks = state.outputBlocks, s = state.s, index = 0, i, code;
  while (index < length) {
    if (state.reset) {
      state.reset = false;
      blocks[0] = state.block;
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    if (typeof message !== "string") {
      for (i = state.start; index < length && i < byteCount; ++index) {
        blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
      }
    } else {
      for (i = state.start; index < length && i < byteCount; ++index) {
        code = message.charCodeAt(index);
        if (code < 128) {
          blocks[i >> 2] |= code << SHIFT[i++ & 3];
        } else if (code < 2048) {
          blocks[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else if (code < 55296 || code >= 57344) {
          blocks[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else {
          code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
          blocks[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        }
      }
    }
    state.lastByteIndex = i;
    if (i >= byteCount) {
      state.start = i - byteCount;
      state.block = blocks[blockCount];
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
      state.reset = true;
    } else {
      state.start = i;
    }
  }
  i = state.lastByteIndex;
  blocks[i >> 2] |= KECCAK_PADDING[i & 3];
  if (state.lastByteIndex === byteCount) {
    blocks[0] = blocks[blockCount];
    for (i = 1; i < blockCount + 1; ++i) {
      blocks[i] = 0;
    }
  }
  blocks[blockCount - 1] |= 2147483648;
  for (i = 0; i < blockCount; ++i) {
    s[i] ^= blocks[i];
  }
  f(s);
  var hex = "";
  var block;
  var j = 0;
  i = 0;
  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      block = s[i];
      hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
    }
    if (j % blockCount === 0) {
      f(s);
      i = 0;
    }
  }
  return "0x" + hex;
};
var f = (s) => {
  var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
  for (n = 0; n < 48; n += 2) {
    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    h = c8 ^ (c2 << 1 | c3 >>> 31);
    l = c9 ^ (c3 << 1 | c2 >>> 31);
    s[0] ^= h;
    s[1] ^= l;
    s[10] ^= h;
    s[11] ^= l;
    s[20] ^= h;
    s[21] ^= l;
    s[30] ^= h;
    s[31] ^= l;
    s[40] ^= h;
    s[41] ^= l;
    h = c0 ^ (c4 << 1 | c5 >>> 31);
    l = c1 ^ (c5 << 1 | c4 >>> 31);
    s[2] ^= h;
    s[3] ^= l;
    s[12] ^= h;
    s[13] ^= l;
    s[22] ^= h;
    s[23] ^= l;
    s[32] ^= h;
    s[33] ^= l;
    s[42] ^= h;
    s[43] ^= l;
    h = c2 ^ (c6 << 1 | c7 >>> 31);
    l = c3 ^ (c7 << 1 | c6 >>> 31);
    s[4] ^= h;
    s[5] ^= l;
    s[14] ^= h;
    s[15] ^= l;
    s[24] ^= h;
    s[25] ^= l;
    s[34] ^= h;
    s[35] ^= l;
    s[44] ^= h;
    s[45] ^= l;
    h = c4 ^ (c8 << 1 | c9 >>> 31);
    l = c5 ^ (c9 << 1 | c8 >>> 31);
    s[6] ^= h;
    s[7] ^= l;
    s[16] ^= h;
    s[17] ^= l;
    s[26] ^= h;
    s[27] ^= l;
    s[36] ^= h;
    s[37] ^= l;
    s[46] ^= h;
    s[47] ^= l;
    h = c6 ^ (c0 << 1 | c1 >>> 31);
    l = c7 ^ (c1 << 1 | c0 >>> 31);
    s[8] ^= h;
    s[9] ^= l;
    s[18] ^= h;
    s[19] ^= l;
    s[28] ^= h;
    s[29] ^= l;
    s[38] ^= h;
    s[39] ^= l;
    s[48] ^= h;
    s[49] ^= l;
    b0 = s[0];
    b1 = s[1];
    b32 = s[11] << 4 | s[10] >>> 28;
    b33 = s[10] << 4 | s[11] >>> 28;
    b14 = s[20] << 3 | s[21] >>> 29;
    b15 = s[21] << 3 | s[20] >>> 29;
    b46 = s[31] << 9 | s[30] >>> 23;
    b47 = s[30] << 9 | s[31] >>> 23;
    b28 = s[40] << 18 | s[41] >>> 14;
    b29 = s[41] << 18 | s[40] >>> 14;
    b20 = s[2] << 1 | s[3] >>> 31;
    b21 = s[3] << 1 | s[2] >>> 31;
    b2 = s[13] << 12 | s[12] >>> 20;
    b3 = s[12] << 12 | s[13] >>> 20;
    b34 = s[22] << 10 | s[23] >>> 22;
    b35 = s[23] << 10 | s[22] >>> 22;
    b16 = s[33] << 13 | s[32] >>> 19;
    b17 = s[32] << 13 | s[33] >>> 19;
    b48 = s[42] << 2 | s[43] >>> 30;
    b49 = s[43] << 2 | s[42] >>> 30;
    b40 = s[5] << 30 | s[4] >>> 2;
    b41 = s[4] << 30 | s[5] >>> 2;
    b22 = s[14] << 6 | s[15] >>> 26;
    b23 = s[15] << 6 | s[14] >>> 26;
    b4 = s[25] << 11 | s[24] >>> 21;
    b5 = s[24] << 11 | s[25] >>> 21;
    b36 = s[34] << 15 | s[35] >>> 17;
    b37 = s[35] << 15 | s[34] >>> 17;
    b18 = s[45] << 29 | s[44] >>> 3;
    b19 = s[44] << 29 | s[45] >>> 3;
    b10 = s[6] << 28 | s[7] >>> 4;
    b11 = s[7] << 28 | s[6] >>> 4;
    b42 = s[17] << 23 | s[16] >>> 9;
    b43 = s[16] << 23 | s[17] >>> 9;
    b24 = s[26] << 25 | s[27] >>> 7;
    b25 = s[27] << 25 | s[26] >>> 7;
    b6 = s[36] << 21 | s[37] >>> 11;
    b7 = s[37] << 21 | s[36] >>> 11;
    b38 = s[47] << 24 | s[46] >>> 8;
    b39 = s[46] << 24 | s[47] >>> 8;
    b30 = s[8] << 27 | s[9] >>> 5;
    b31 = s[9] << 27 | s[8] >>> 5;
    b12 = s[18] << 20 | s[19] >>> 12;
    b13 = s[19] << 20 | s[18] >>> 12;
    b44 = s[29] << 7 | s[28] >>> 25;
    b45 = s[28] << 7 | s[29] >>> 25;
    b26 = s[38] << 8 | s[39] >>> 24;
    b27 = s[39] << 8 | s[38] >>> 24;
    b8 = s[48] << 14 | s[49] >>> 18;
    b9 = s[49] << 14 | s[48] >>> 18;
    s[0] = b0 ^ ~b2 & b4;
    s[1] = b1 ^ ~b3 & b5;
    s[10] = b10 ^ ~b12 & b14;
    s[11] = b11 ^ ~b13 & b15;
    s[20] = b20 ^ ~b22 & b24;
    s[21] = b21 ^ ~b23 & b25;
    s[30] = b30 ^ ~b32 & b34;
    s[31] = b31 ^ ~b33 & b35;
    s[40] = b40 ^ ~b42 & b44;
    s[41] = b41 ^ ~b43 & b45;
    s[2] = b2 ^ ~b4 & b6;
    s[3] = b3 ^ ~b5 & b7;
    s[12] = b12 ^ ~b14 & b16;
    s[13] = b13 ^ ~b15 & b17;
    s[22] = b22 ^ ~b24 & b26;
    s[23] = b23 ^ ~b25 & b27;
    s[32] = b32 ^ ~b34 & b36;
    s[33] = b33 ^ ~b35 & b37;
    s[42] = b42 ^ ~b44 & b46;
    s[43] = b43 ^ ~b45 & b47;
    s[4] = b4 ^ ~b6 & b8;
    s[5] = b5 ^ ~b7 & b9;
    s[14] = b14 ^ ~b16 & b18;
    s[15] = b15 ^ ~b17 & b19;
    s[24] = b24 ^ ~b26 & b28;
    s[25] = b25 ^ ~b27 & b29;
    s[34] = b34 ^ ~b36 & b38;
    s[35] = b35 ^ ~b37 & b39;
    s[44] = b44 ^ ~b46 & b48;
    s[45] = b45 ^ ~b47 & b49;
    s[6] = b6 ^ ~b8 & b0;
    s[7] = b7 ^ ~b9 & b1;
    s[16] = b16 ^ ~b18 & b10;
    s[17] = b17 ^ ~b19 & b11;
    s[26] = b26 ^ ~b28 & b20;
    s[27] = b27 ^ ~b29 & b21;
    s[36] = b36 ^ ~b38 & b30;
    s[37] = b37 ^ ~b39 & b31;
    s[46] = b46 ^ ~b48 & b40;
    s[47] = b47 ^ ~b49 & b41;
    s[8] = b8 ^ ~b0 & b2;
    s[9] = b9 ^ ~b1 & b3;
    s[18] = b18 ^ ~b10 & b12;
    s[19] = b19 ^ ~b11 & b13;
    s[28] = b28 ^ ~b20 & b22;
    s[29] = b29 ^ ~b21 & b23;
    s[38] = b38 ^ ~b30 & b32;
    s[39] = b39 ^ ~b31 & b33;
    s[48] = b48 ^ ~b40 & b42;
    s[49] = b49 ^ ~b41 & b43;
    s[0] ^= RC[n];
    s[1] ^= RC[n + 1];
  }
};
var keccak = (bits) => (str) => {
  var msg;
  if (str.slice(0, 2) === "0x") {
    msg = [];
    for (var i = 2, l = str.length; i < l; i += 2)
      msg.push(parseInt(str.slice(i, i + 2), 16));
  } else {
    msg = str;
  }
  return update(Keccak(bits), msg);
};
var keccak256 = keccak(256);

// node_modules/@hashgraph/cryptography/src/primitive/ecdsa.js
var import_elliptic2 = __toESM(require_elliptic(), 1);
var secp256k12 = new import_elliptic2.default.ec("secp256k1");
function generate() {
  const keypair = secp256k12.genKeyPair();
  return {
    privateKey: decode3(keypair.getPrivate("hex")),
    publicKey: decode3(keypair.getPublic(true, "hex"))
  };
}
async function generateAsync() {
  return Promise.resolve(generate());
}
function fromBytes(data) {
  const keypair = secp256k12.keyFromPrivate(data);
  return {
    privateKey: decode3(keypair.getPrivate("hex")),
    publicKey: decode3(keypair.getPublic(true, "hex"))
  };
}
function getFullPublicKey(data) {
  const keypair = secp256k12.keyFromPublic(data);
  return decode3(keypair.getPublic(false, "hex"));
}
function sign(keydata, message) {
  const msg = encode3(message);
  const data = decode3(keccak256(`0x${msg}`));
  const keypair = secp256k12.keyFromPrivate(keydata);
  const signature = keypair.sign(data);
  const r2 = signature.r.toArray("be", 32);
  const s = signature.s.toArray("be", 32);
  const result = new Uint8Array(64);
  result.set(r2, 0);
  result.set(s, 32);
  return result;
}
function verify(keydata, message, signature) {
  const msg = encode3(message);
  const data = decode3(keccak256(`0x${msg}`));
  const keypair = secp256k12.keyFromPublic(keydata);
  return keypair.verify(data, {
    r: signature.subarray(0, 32),
    s: signature.subarray(32, 64)
  });
}

// node_modules/@hashgraph/cryptography/src/EcdsaPublicKey.js
var import_elliptic3 = __toESM(require_elliptic(), 1);
var ec = new import_elliptic3.default.ec("secp256k1");
var legacyDerPrefix = "302d300706052b8104000a032200";
var legacyDerPrefixBytes = decode3(legacyDerPrefix);
var derPrefix3 = "3036301006072a8648ce3d020106052b8104000a032200";
var derPrefixBytes3 = decode3(derPrefix3);
var EcdsaPublicKey = class _EcdsaPublicKey extends Key {
  /**
   * @internal
   * @hideconstructor
   * @param {Uint8Array} keyData
   */
  constructor(keyData) {
    super();
    this._keyData = keyData;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "secp256k1";
  }
  /**
   * @param {Uint8Array} data
   * @returns {EcdsaPublicKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 33:
        return _EcdsaPublicKey.fromBytesRaw(data);
      default:
        return _EcdsaPublicKey.fromBytesDer(data);
    }
  }
  /**
   * @param {Uint8Array} data
   * @returns {EcdsaPublicKey}
   */
  static fromBytesDer(data) {
    let ecdsaPublicKeyBytes = new Uint8Array();
    switch (data.length) {
      case 47:
        ecdsaPublicKeyBytes = data.subarray(
          legacyDerPrefixBytes.length
        );
        break;
      case 56:
        ecdsaPublicKeyBytes = data.subarray(
          derPrefixBytes3.length,
          derPrefixBytes3.length + 33
        );
        break;
      default:
        const keyPair = ec.keyFromPublic(
          data.subarray(derPrefixBytes3.length),
          "der"
        );
        const pk = keyPair.getPublic();
        const compressedPublicKeyBytes = pk.encodeCompressed("hex");
        ecdsaPublicKeyBytes = decode3(compressedPublicKeyBytes);
        break;
    }
    if (ecdsaPublicKeyBytes.length == 0) {
      throw new BadKeyError(
        `cannot decode ECDSA private key data from DER format`
      );
    }
    return new _EcdsaPublicKey(ecdsaPublicKeyBytes);
  }
  /**
   * @param {Uint8Array} data
   * @returns {EcdsaPublicKey}
   */
  static fromBytesRaw(data) {
    if (data.length != 33) {
      throw new BadKeyError(
        `invalid public key length: ${data.length} bytes`
      );
    }
    return new _EcdsaPublicKey(data);
  }
  /**
   * Parse a public key from a string of hexadecimal digits.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   * @param {string} text
   * @returns {EcdsaPublicKey}
   */
  static fromString(text) {
    return _EcdsaPublicKey.fromBytes(decode3(text));
  }
  /**
   * Verify a signature on a message with this public key.
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  verify(message, signature) {
    return verify(this._keyData, message, signature);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(
      legacyDerPrefixBytes.length + this._keyData.length
    );
    bytes3.set(legacyDerPrefixBytes, 0);
    bytes3.set(this._keyData, legacyDerPrefixBytes.length);
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return new Uint8Array(this._keyData.subarray());
  }
  /**
   * @returns {string}
   */
  toEthereumAddress() {
    const hash2 = decode3(
      keccak256(
        `0x${encode3(
          getFullPublicKey(this.toBytesRaw()).subarray(1)
        )}`
      )
    );
    return encode3(hash2.subarray(12));
  }
  /**
   * @param {EcdsaPublicKey} other
   * @returns {boolean}
   */
  equals(other) {
    return arrayEqual2(this._keyData, other._keyData);
  }
};

// node_modules/@hashgraph/cryptography/src/EcdsaPrivateKey.js
var derPrefix4 = "3030020100300706052b8104000a04220420";
var derPrefixBytes4 = decode3(derPrefix4);
var derPrefix22 = "30540201010420";
var derPrefixBytes22 = decode3(derPrefix22);
var EcdsaPrivateKey = class _EcdsaPrivateKey {
  /**
   * @hideconstructor
   * @internal
   * @param {KeyPair} keyPair
   * @param {(Uint8Array)=} chainCode
   */
  constructor(keyPair, chainCode) {
    this._keyPair = keyPair;
    this._chainCode = chainCode != null ? chainCode : null;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "secp256k1";
  }
  /**
   * Generate a random ECDSA private key.
   * @returns {EcdsaPrivateKey}
   */
  static generate() {
    return new _EcdsaPrivateKey(generate());
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Promise<EcdsaPrivateKey>}
   */
  static async generateAsync() {
    return new _EcdsaPrivateKey(await generateAsync());
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {EcdsaPrivateKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 32:
        return _EcdsaPrivateKey.fromBytesRaw(data);
      default:
        return _EcdsaPrivateKey.fromBytesDer(data);
    }
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {EcdsaPrivateKey}
   */
  static fromBytesDer(data) {
    let ecdsaPrivateKeyBytes = new Uint8Array();
    if (arrayStartsWith(data, derPrefixBytes4)) {
      ecdsaPrivateKeyBytes = data.subarray(derPrefixBytes4.length);
    } else {
      ecdsaPrivateKeyBytes = data.subarray(
        derPrefixBytes22.length,
        derPrefixBytes22.length + 32
      );
    }
    return new _EcdsaPrivateKey(fromBytes(ecdsaPrivateKeyBytes));
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {EcdsaPrivateKey}
   */
  static fromBytesRaw(data) {
    return new _EcdsaPrivateKey(fromBytes(data));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {EcdsaPrivateKey}
   */
  static fromString(text) {
    return _EcdsaPrivateKey.fromBytes(decode3(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {EcdsaPrivateKey}
   */
  static fromStringDer(text) {
    return _EcdsaPrivateKey.fromBytesDer(decode3(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {EcdsaPrivateKey}
   */
  static fromStringRaw(text) {
    return _EcdsaPrivateKey.fromBytesRaw(decode3(text));
  }
  /**
   * Construct a ECDSA private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<EcdsaPrivateKey>}
   */
  static async fromSeed(seed) {
    const { keyData, chainCode } = await fromSeed(seed);
    return new _EcdsaPrivateKey(fromBytes(keyData), chainCode);
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   * @returns {EcdsaPublicKey}
   */
  get publicKey() {
    return new EcdsaPublicKey(this._keyPair.publicKey);
  }
  /**
   * Sign a message with this private key.
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */
  sign(bytes3) {
    return sign(this._keyPair.privateKey, bytes3);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(derPrefixBytes4.length + 32);
    bytes3.set(derPrefixBytes4, 0);
    bytes3.set(
      this._keyPair.privateKey.subarray(0, 32),
      derPrefixBytes4.length
    );
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    const bytes3 = new Uint8Array(32);
    bytes3.set(this._keyPair.privateKey.slice(0, 32), 0);
    return bytes3;
  }
};

// node_modules/@hashgraph/cryptography/src/PublicKey.js
var PublicKey = class _PublicKey extends Key {
  /**
   * @internal
   * @hideconstructor
   * @param {Ed25519PublicKey | EcdsaPublicKey} key
   */
  constructor(key) {
    super();
    this._key = key;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return this._key._type;
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytes(data) {
    let message;
    try {
      return new _PublicKey(Ed25519PublicKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    try {
      return new _PublicKey(EcdsaPublicKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    throw new BadKeyError(
      `public key cannot be decoded from bytes: ${message}`
    );
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytesED25519(data) {
    return new _PublicKey(Ed25519PublicKey.fromBytes(data));
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytesECDSA(data) {
    return new _PublicKey(EcdsaPublicKey.fromBytes(data));
  }
  /**
   * Parse a public key from a string of hexadecimal digits.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromString(text) {
    return _PublicKey.fromBytes(decode3(text));
  }
  /**
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromStringED25519(text) {
    return _PublicKey.fromBytesED25519(decode3(text));
  }
  /**
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromStringECDSA(text) {
    return _PublicKey.fromBytesECDSA(decode3(text));
  }
  /**
   * Verify a signature on a message with this public key.
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  verify(message, signature) {
    return this._key.verify(message, signature);
  }
  /**
   * @deprecated - use `@hashgraph/sdk`.PublicKey instead
   * @param {Transaction} transaction
   * @returns {boolean}
   */
  verifyTransaction(transaction) {
    console.log("Deprecated: use `@hashgraph/sdk`.PublicKey instead");
    transaction._requireFrozen();
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    for (const signedTransaction of transaction._signedTransactions) {
      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        let found = false;
        for (const sigPair of signedTransaction.sigMap.sigPair) {
          const pubKeyPrefix = (
            /** @type {Uint8Array} */
            sigPair.pubKeyPrefix
          );
          if (arrayEqual2(pubKeyPrefix, this.toBytesRaw())) {
            found = true;
            const bodyBytes = (
              /** @type {Uint8Array} */
              signedTransaction.bodyBytes
            );
            const signature = sigPair.ed25519 != null ? sigPair.ed25519 : (
              /** @type {Uint8Array} */
              sigPair.ECDSASecp256k1
            );
            if (!this.verify(bodyBytes, signature)) {
              return false;
            }
          }
        }
        if (!found) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    if (this._key instanceof Ed25519PublicKey) {
      return this.toBytesRaw();
    } else {
      return this.toBytesDer();
    }
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    return this._key.toBytesDer();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.toStringDer();
  }
  /**
   * @returns {string}
   */
  toStringDer() {
    return encode3(this.toBytesDer());
  }
  /**
   * @returns {string}
   */
  toStringRaw() {
    return encode3(this.toBytesRaw());
  }
  /**
   * @returns {string}
   */
  toEthereumAddress() {
    if (this._key instanceof EcdsaPublicKey) {
      return this._key.toEthereumAddress();
    } else {
      throw new Error("unsupported operation on Ed25519PublicKey");
    }
  }
  /**
   * @param {PublicKey} other
   * @returns {boolean}
   */
  equals(other) {
    if (this._key instanceof Ed25519PublicKey && other._key instanceof Ed25519PublicKey) {
      return this._key.equals(other._key);
    } else if (this._key instanceof EcdsaPublicKey && other._key instanceof EcdsaPublicKey) {
      return this._key.equals(other._key);
    } else {
      return false;
    }
  }
};

// node_modules/@hashgraph/cryptography/src/primitive/aes.browser.js
var import_spark_md5 = __toESM(require_spark_md5(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var CipherAlgorithm = {
  Aes128Ctr: "AES-128-CTR",
  Aes128Cbc: "AES-128-CBC"
};
async function createCipheriv(algorithm, key, iv, data) {
  let algorithm_;
  switch (algorithm.toUpperCase()) {
    case CipherAlgorithm.Aes128Ctr:
      algorithm_ = {
        name: "AES-CTR",
        counter: iv,
        length: 128
      };
      break;
    case CipherAlgorithm.Aes128Cbc:
      algorithm_ = {
        name: "AES-CBC",
        iv
      };
      break;
    default:
      throw new Error(
        "(BUG) non-exhaustive switch statement for CipherAlgorithm"
      );
  }
  const key_ = await window.crypto.subtle.importKey(
    "raw",
    key,
    algorithm_.name,
    false,
    ["encrypt"]
  );
  return new Uint8Array(
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
    /** @type {ArrayBuffer} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    await window.crypto.subtle.encrypt(algorithm_, key_, data)
  );
}
async function createDecipheriv(algorithm, key, iv, data) {
  let algorithm_;
  switch (algorithm.toUpperCase()) {
    case CipherAlgorithm.Aes128Ctr:
      algorithm_ = {
        name: "AES-CTR",
        counter: iv,
        length: 128
      };
      break;
    case CipherAlgorithm.Aes128Cbc:
      algorithm_ = {
        name: "AES-CBC",
        iv
      };
      break;
    default:
      throw new Error(
        "(BUG) non-exhaustive switch statement for CipherAlgorithm"
      );
  }
  const key_ = await window.crypto.subtle.importKey(
    "raw",
    key,
    algorithm_.name,
    false,
    ["decrypt"]
  );
  let decrypted;
  try {
    decrypted = await window.crypto.subtle.decrypt(algorithm_, key_, data);
  } catch (error) {
    const message = (
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : ""
    );
    throw new Error(`Unable to decrypt: ${message}`);
  }
  return new Uint8Array(
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
    /** @type {ArrayBuffer} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    decrypted
  );
}
async function messageDigest(passphrase, iv) {
  const pass = encode4(passphrase);
  const sliced = decode3(iv).slice(0, 8);
  const result = import_spark_md5.default.ArrayBuffer.hash(
    import_buffer.Buffer.concat([import_buffer.Buffer.from(pass), import_buffer.Buffer.from(sliced)])
  );
  return Promise.resolve(decode3(result));
}

// node_modules/@hashgraph/cryptography/src/primitive/pbkdf2.browser.js
async function deriveKey(algorithm, password, salt, iterations, length) {
  const pass = typeof password === "string" ? (
    // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
    // should be fine if only valid ASCII characters are used in the password
    encode4(password)
  ) : password;
  const nacl5 = typeof salt === "string" ? encode4(salt) : salt;
  try {
    const key = await window.crypto.subtle.importKey(
      "raw",
      pass,
      {
        name: "PBKDF2",
        hash: algorithm
      },
      false,
      ["deriveBits"]
    );
    return new Uint8Array(
      await window.crypto.subtle.deriveBits(
        {
          name: "PBKDF2",
          hash: algorithm,
          salt: nacl5,
          iterations
        },
        key,
        length << 3
      )
    );
  } catch {
    throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
  }
}

// node_modules/@hashgraph/cryptography/src/primitive/keystore.js
var HMAC_SHA256 = "hmac-sha256";
async function createKeystore(privateKey, passphrase) {
  const dkLen = 32;
  const c = 262144;
  const saltLen = 32;
  const salt = await bytesAsync(saltLen);
  const key = await deriveKey(
    HashAlgorithm.Sha256,
    passphrase,
    salt,
    c,
    dkLen
  );
  const iv = await bytesAsync(16);
  const cipherText = await createCipheriv(
    CipherAlgorithm.Aes128Ctr,
    key.slice(0, 16),
    iv,
    privateKey
  );
  const mac = await hash(
    HashAlgorithm.Sha384,
    key.slice(16),
    cipherText
  );
  const keystore = {
    version: 1,
    crypto: {
      ciphertext: encode3(cipherText),
      cipherparams: { iv: encode3(iv) },
      cipher: CipherAlgorithm.Aes128Ctr,
      kdf: "pbkdf2",
      kdfparams: {
        dkLen,
        salt: encode3(salt),
        c,
        prf: HMAC_SHA256
      },
      mac: encode3(mac)
    }
  };
  return encode4(JSON.stringify(keystore));
}
async function loadKeystore(keystoreBytes, passphrase) {
  const keystore = JSON.parse(decode4(keystoreBytes));
  if (keystore.version !== 1) {
    throw new BadKeyError(
      `unsupported keystore version: ${keystore.version}`
    );
  }
  const {
    ciphertext,
    cipherparams: { iv },
    cipher,
    kdf,
    kdfparams: { dkLen, salt, c, prf },
    mac
  } = keystore.crypto;
  if (kdf !== "pbkdf2") {
    throw new BadKeyError(`unsupported key derivation function:" + ${kdf}`);
  }
  if (prf !== HMAC_SHA256) {
    throw new BadKeyError(
      `unsupported key derivation hash function: ${prf}`
    );
  }
  const saltBytes = decode3(salt);
  const ivBytes = decode3(iv);
  const cipherBytes = decode3(ciphertext);
  const key = await deriveKey(
    HashAlgorithm.Sha256,
    passphrase,
    saltBytes,
    c,
    dkLen
  );
  const macHex = decode3(mac);
  const verifyHmac = await hash(
    HashAlgorithm.Sha384,
    key.slice(16),
    cipherBytes
  );
  if (!macHex.every((b, i) => b === verifyHmac[i])) {
    throw new BadKeyError("HMAC mismatch; passphrase is incorrect");
  }
  return createDecipheriv(
    cipher,
    key.slice(0, 16),
    ivBytes,
    cipherBytes
  );
}

// node_modules/@hashgraph/cryptography/src/encoding/der.js
function decode5(data) {
  return decodeIncremental(data)[0];
}
function decodeIncremental(bytes3) {
  const [len, rem] = decodeLength(bytes3.subarray(1));
  const data = rem.subarray(0, len);
  const tail = rem.subarray(len);
  switch (bytes3[0]) {
    case 2:
      return [{ int: decodeInt(data) }, tail];
    case 4:
      return [{ bytes: data }, tail];
    case 5:
      return [{}, tail];
    case 6:
      return [{ ident: decodeObjectIdent(data) }, tail];
    case 48:
      return [{ seq: decodeSeq(data) }, tail];
    default:
      throw new Error(`unsupported DER type tag: ${bytes3[0]}`);
  }
}
function decodeSeq(seqBytes) {
  let data = seqBytes;
  const seq = [];
  while (data.length !== 0) {
    const [decoded, remaining] = decodeIncremental(data);
    seq.push(decoded);
    data = remaining;
  }
  return seq;
}
function decodeObjectIdent(idBytes) {
  const id2 = [
    // first octet is 40 * value1 + value2
    Math.floor(idBytes[0] / 40),
    idBytes[0] % 40
  ];
  let val = 0;
  for (const byte of idBytes.subarray(1)) {
    val *= 128;
    if (byte < 128) {
      val += byte;
      id2.push(val);
      val = 0;
    } else {
      val += byte & 127;
    }
  }
  return id2.join(".");
}
function decodeLength(lenBytes) {
  if (lenBytes[0] < 128) {
    return [lenBytes[0], lenBytes.subarray(1)];
  }
  const numBytes = lenBytes[0] - 128;
  const intBytes = lenBytes.subarray(1, numBytes + 1);
  const rem = lenBytes.subarray(numBytes + 1);
  return [decodeInt(intBytes), rem];
}
function decodeInt(intBytes) {
  const len = intBytes.length;
  if (len === 1) {
    return intBytes[0];
  }
  let view = new DataView(
    intBytes.buffer,
    intBytes.byteOffset,
    intBytes.byteLength
  );
  if (len === 2)
    return view.getUint16(0, false);
  if (len === 3) {
    const data = Uint8Array.of(0, ...intBytes);
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  if (len > 4) {
    throw new Error(`unsupported DER integer length of ${len} bytes`);
  }
  return view.getUint32(0, false);
}

// node_modules/@hashgraph/cryptography/src/primitive/pkcs.js
var AlgorithmIdentifier = class {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 1 && "ident" in asn.seq[0]) {
      this.algIdent = asn.seq[0].ident;
      this.parameters = asn.seq[1];
    } else {
      throw new Error(
        `error parsing AlgorithmIdentifier from ${JSON.stringify(asn)}`
      );
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this);
  }
};
var PBES2Params = class {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2) {
      this.kdf = new AlgorithmIdentifier(asn.seq[0]);
      this.encScheme = new AlgorithmIdentifier(asn.seq[1]);
    } else {
      throw new Error(
        `error parsing PBES2Params from ${JSON.stringify(asn)}`
      );
    }
  }
};
var PBKDF2Params = class {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 2 && "bytes" in asn.seq[0] && "int" in asn.seq[1]) {
      this.salt = asn.seq[0].bytes;
      this.iterCount = asn.seq[1]["int"];
      if (asn.seq.length > 2) {
        if ("seq" in asn.seq[2]) {
          this.prf = new AlgorithmIdentifier(asn.seq[2]);
          return;
        } else if ("int" in asn.seq[2]) {
          this.keyLength = asn.seq[2]["int"];
        }
        if (asn.seq.length === 4) {
          this.prf = new AlgorithmIdentifier(asn.seq[3]);
        }
        return;
      }
    }
    throw new Error(
      `error parsing PBKDF2Params from ${JSON.stringify(asn)}`
    );
  }
};
var PrivateKeyInfo = class _PrivateKeyInfo {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 3) {
      if ("int" in asn.seq[0] && asn.seq[0]["int"] === 0) {
        this.version = 0;
      } else {
        throw new Error(
          `expected version = 0, got ${JSON.stringify(asn.seq[0])}`
        );
      }
      this.algId = new AlgorithmIdentifier(asn.seq[1]);
      if ("bytes" in asn.seq[2]) {
        this.privateKey = asn.seq[2].bytes;
      } else {
        throw new Error(
          `expected octet string as 3rd element, got ${JSON.stringify(
            asn.seq[2]
          )}`
        );
      }
      return;
    }
    throw new Error(
      `error parsing PrivateKeyInfo from ${JSON.stringify(asn)}`
    );
  }
  /**
   * @param {Uint8Array} encoded
   * @returns {PrivateKeyInfo}
   */
  static parse(encoded) {
    return new _PrivateKeyInfo(decode5(encoded));
  }
};
var EncryptedPrivateKeyInfo = class _EncryptedPrivateKeyInfo {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2 && "bytes" in asn.seq[1]) {
      this.algId = new AlgorithmIdentifier(asn.seq[0]);
      this.data = asn.seq[1].bytes;
      return;
    }
    throw new Error(
      `error parsing EncryptedPrivateKeyInfo from ${JSON.stringify(asn)}`
    );
  }
  /**
   * @param {Uint8Array} encoded
   * @returns {EncryptedPrivateKeyInfo}
   */
  static parse(encoded) {
    return new _EncryptedPrivateKeyInfo(decode5(encoded));
  }
  /**
   * @param {string} passphrase
   * @returns {Promise<PrivateKeyInfo>}
   */
  async decrypt(passphrase) {
    if (this.algId.algIdent !== "1.2.840.113549.1.5.13" || !this.algId.parameters) {
      throw new Error(
        `unsupported key encryption algorithm: ${this.algId.toString()}`
      );
    }
    const pbes2Params = new PBES2Params(this.algId.parameters);
    if (pbes2Params.kdf.algIdent !== "1.2.840.113549.1.5.12" || !pbes2Params.kdf.parameters) {
      throw new Error(
        `unsupported key derivation function: ${pbes2Params.kdf.toString()}`
      );
    }
    const pbkdf2Params = new PBKDF2Params(pbes2Params.kdf.parameters);
    if (!pbkdf2Params.prf) {
      throw new Error("unsupported PRF HMAC-SHA-1");
    } else if (pbkdf2Params.prf.algIdent !== "1.2.840.113549.2.9") {
      throw new Error(`unsupported PRF ${pbkdf2Params.prf.toString()}`);
    }
    if (pbes2Params.encScheme.algIdent !== "2.16.840.1.101.3.4.1.2") {
      throw new Error(
        `unsupported encryption scheme: ${pbes2Params.encScheme.toString()}`
      );
    }
    if (!pbes2Params.encScheme.parameters || !("bytes" in pbes2Params.encScheme.parameters)) {
      throw new Error(
        `expected IV as bytes for AES-128-CBC, got: ${JSON.stringify(pbes2Params.encScheme.parameters)}`
      );
    }
    const keyLen = pbkdf2Params.keyLength || 16;
    const iv = pbes2Params.encScheme.parameters.bytes;
    const key = await deriveKey(
      HashAlgorithm.Sha256,
      passphrase,
      pbkdf2Params.salt,
      pbkdf2Params.iterCount,
      keyLen
    );
    const decrypted = await createDecipheriv(
      CipherAlgorithm.Aes128Cbc,
      key,
      iv,
      this.data
    );
    return PrivateKeyInfo.parse(decrypted);
  }
};

// node_modules/@hashgraph/cryptography/src/encoding/base64.browser.js
var import_buffer2 = __toESM(require_buffer(), 1);
function decode6(text) {
  return Uint8Array.from(import_buffer2.Buffer.from(text, "base64"));
}

// node_modules/pvtsutils/build/index.es.js
var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
var BufferSourceConverter = class _BufferSourceConverter {
  static isArrayBuffer(data) {
    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  }
  static toArrayBuffer(data) {
    if (this.isArrayBuffer(data)) {
      return data;
    }
    if (data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
  }
  static toUint8Array(data) {
    return this.toView(data, Uint8Array);
  }
  static toView(data, type) {
    if (data.constructor === type) {
      return data;
    }
    if (this.isArrayBuffer(data)) {
      return new type(data);
    }
    if (this.isArrayBufferView(data)) {
      return new type(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  }
  static isBufferSource(data) {
    return this.isArrayBufferView(data) || this.isArrayBuffer(data);
  }
  static isArrayBufferView(data) {
    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
  }
  static isEqual(a, b) {
    const aView = _BufferSourceConverter.toUint8Array(a);
    const bView = _BufferSourceConverter.toUint8Array(b);
    if (aView.length !== bView.byteLength) {
      return false;
    }
    for (let i = 0; i < aView.length; i++) {
      if (aView[i] !== bView[i]) {
        return false;
      }
    }
    return true;
  }
  static concat(...args) {
    let buffers;
    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
      buffers = args[0];
    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
      buffers = args[0];
    } else {
      if (args[args.length - 1] instanceof Function) {
        buffers = args.slice(0, args.length - 1);
      } else {
        buffers = args;
      }
    }
    let size = 0;
    for (const buffer of buffers) {
      size += buffer.byteLength;
    }
    const res = new Uint8Array(size);
    let offset = 0;
    for (const buffer of buffers) {
      const view = this.toUint8Array(buffer);
      res.set(view, offset);
      offset += view.length;
    }
    if (args[args.length - 1] instanceof Function) {
      return this.toView(res, args[args.length - 1]);
    }
    return res.buffer;
  }
};
var STRING_TYPE = "string";
var HEX_REGEX = /^[0-9a-f]+$/i;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
var Utf8Converter = class {
  static fromString(text) {
    const s = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s.length);
    for (let i = 0; i < s.length; i++) {
      uintArray[i] = s.charCodeAt(i);
    }
    return uintArray.buffer;
  }
  static toString(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let encodedString = "";
    for (let i = 0; i < buf.length; i++) {
      encodedString += String.fromCharCode(buf[i]);
    }
    const decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
  }
};
var Utf16Converter = class {
  static toString(buffer, littleEndian = false) {
    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
    const dataView = new DataView(arrayBuffer);
    let res = "";
    for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
      const code = dataView.getUint16(i, littleEndian);
      res += String.fromCharCode(code);
    }
    return res;
  }
  static fromString(text, littleEndian = false) {
    const res = new ArrayBuffer(text.length * 2);
    const dataView = new DataView(res);
    for (let i = 0; i < text.length; i++) {
      dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
    }
    return res;
  }
};
var Convert = class _Convert {
  static isHex(data) {
    return typeof data === STRING_TYPE && HEX_REGEX.test(data);
  }
  static isBase64(data) {
    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
  }
  static isBase64Url(data) {
    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
  }
  static ToString(buffer, enc = "utf8") {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.ToUtf8String(buf);
      case "binary":
        return this.ToBinary(buf);
      case "hex":
        return this.ToHex(buf);
      case "base64":
        return this.ToBase64(buf);
      case "base64url":
        return this.ToBase64Url(buf);
      case "utf16le":
        return Utf16Converter.toString(buf, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buf);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static FromString(str, enc = "utf8") {
    if (!str) {
      return new ArrayBuffer(0);
    }
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.FromUtf8String(str);
      case "binary":
        return this.FromBinary(str);
      case "hex":
        return this.FromHex(str);
      case "base64":
        return this.FromBase64(str);
      case "base64url":
        return this.FromBase64Url(str);
      case "utf16le":
        return Utf16Converter.fromString(str, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(str);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static ToBase64(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    if (typeof btoa !== "undefined") {
      const binary = this.ToString(buf, "binary");
      return btoa(binary);
    } else {
      return Buffer.from(buf).toString("base64");
    }
  }
  static FromBase64(base64) {
    const formatted = this.formatString(base64);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64(formatted)) {
      throw new TypeError("Argument 'base64Text' is not Base64 encoded");
    }
    if (typeof atob !== "undefined") {
      return this.FromBinary(atob(formatted));
    } else {
      return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
    }
  }
  static FromBase64Url(base64url) {
    const formatted = this.formatString(base64url);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64Url(formatted)) {
      throw new TypeError("Argument 'base64url' is not Base64Url encoded");
    }
    return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  }
  static ToBase64Url(data) {
    return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  static FromUtf8String(text, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.FromBinary(text);
      case "utf8":
        return Utf8Converter.fromString(text);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(text);
      case "utf16le":
      case "usc2":
        return Utf16Converter.fromString(text, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static ToUtf8String(buffer, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.ToBinary(buffer);
      case "utf8":
        return Utf8Converter.toString(buffer);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buffer);
      case "utf16le":
      case "usc2":
        return Utf16Converter.toString(buffer, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static FromBinary(text) {
    const stringLength = text.length;
    const resultView = new Uint8Array(stringLength);
    for (let i = 0; i < stringLength; i++) {
      resultView[i] = text.charCodeAt(i);
    }
    return resultView.buffer;
  }
  static ToBinary(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let res = "";
    for (let i = 0; i < buf.length; i++) {
      res += String.fromCharCode(buf[i]);
    }
    return res;
  }
  static ToHex(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let result = "";
    const len = buf.length;
    for (let i = 0; i < len; i++) {
      const byte = buf[i];
      if (byte < 16) {
        result += "0";
      }
      result += byte.toString(16);
    }
    return result;
  }
  static FromHex(hexString) {
    let formatted = this.formatString(hexString);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isHex(formatted)) {
      throw new TypeError("Argument 'hexString' is not HEX encoded");
    }
    if (formatted.length % 2) {
      formatted = `0${formatted}`;
    }
    const res = new Uint8Array(formatted.length / 2);
    for (let i = 0; i < formatted.length; i = i + 2) {
      const c = formatted.slice(i, i + 2);
      res[i / 2] = parseInt(c, 16);
    }
    return res.buffer;
  }
  static ToUtf16String(buffer, littleEndian = false) {
    return Utf16Converter.toString(buffer, littleEndian);
  }
  static FromUtf16String(text, littleEndian = false) {
    return Utf16Converter.fromString(text, littleEndian);
  }
  static Base64Padding(base64) {
    const padCount = 4 - base64.length % 4;
    if (padCount < 4) {
      for (let i = 0; i < padCount; i++) {
        base64 += "=";
      }
    }
    return base64;
  }
  static formatString(data) {
    return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
  }
};
Convert.DEFAULT_UTF8_ENCODING = "utf8";

// node_modules/pvutils/build/utils.es.js
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i = inputBuffer.length - 1; i >= 0; i--) {
    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
  }
  return result;
}
function utilToBase(value, base, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base);
  for (let i = 1; i < 8; i++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i);
        result = i;
      } else {
        if (internalReserved < i) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j = i - 1; j >= 0; j--) {
        const basis = Math.pow(2, j * base);
        retView[result - j - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf[0] === 255 && buf[1] & 128;
    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i = 0; i < this.valueHex.byteLength; i++) {
    bigIntView[i] = 0;
  }
  bigIntView[0] = buf[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j = 0; j < this.valueHex.byteLength; j++) {
    smallIntView[j] = buf[j];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i = 1; i < 8; i++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k = 0; k < tempBuf.byteLength; k++) {
          retView[k + 1] = tempView[k];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i = 0; i < view1.length; i++) {
    if (view1[i] !== view2[i]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding2 = new Array(dif);
  for (let i = 0; i < dif; i++) {
    padding2[i] = "0";
  }
  const paddingString = padding2.join("");
  return paddingString.concat(str);
}
var log2 = Math.log(2);

// node_modules/asn1js/build/index.es.js
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0; i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0; i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}
var ViewWriter = class {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat(this.items);
  }
};
var powers2 = [new Uint8Array([1])];
var digitsString = "0123456789";
var EMPTY_STRING = "";
var EMPTY_BUFFER = new ArrayBuffer(0);
var EMPTY_VIEW = new Uint8Array(0);
var END_OF_CONTENT_NAME = "EndOfContent";
var OCTET_STRING_NAME = "OCTET STRING";
var BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
  var _a2;
  return _a2 = class Some extends BaseClass {
    constructor(...args) {
      var _a3;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_a3 = params.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a2.NAME = "hexBlock", _a2;
}
var LocalBaseBlock = class {
  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
};
LocalBaseBlock.NAME = "baseBlock";
var ValueBlock = class extends LocalBaseBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(sizeOnly, writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
};
ValueBlock.NAME = "valueBlock";
var LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ idBlock = {} } = {}) {
    var _a2, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== void 0 ? _a2 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0; i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0; i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0; i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0; i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
};
LocalIdentificationBlock.NAME = "identificationBlock";
var LocalLengthBlock = class extends LocalBaseBlock {
  constructor({ lenBlock = {} } = {}) {
    var _a2, _b, _c;
    super();
    this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== void 0 ? _a2 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0; i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
};
LocalLengthBlock.NAME = "lengthBlock";
var typeStore = {};
var BaseBlock = class extends LocalBaseBlock {
  constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock(parameters);
    this.lenBlock = new LocalLengthBlock(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    if (!writer) {
      prepareIndefiniteForm(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
};
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!baseBlock.lenBlock.isIndefiniteForm;
}
var BaseStringBlock = class extends BaseBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
};
BaseStringBlock.NAME = "BaseStringBlock";
var LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
};
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;
var Primitive = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock);
    this.idBlock.isConstructed = false;
  }
};
_a$w = Primitive;
(() => {
  typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType();
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock();
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}
var LocalConstructedValueBlock = class extends ValueBlock {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    for (let i = 0; i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
};
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;
var Constructed = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
  }
};
_a$v = Constructed;
(() => {
  typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";
var LocalEndOfContentValueBlock = class extends ValueBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    return inputOffset;
  }
  toBER(sizeOnly) {
    return EMPTY_BUFFER;
  }
};
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;
var EndOfContent = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
};
_a$u = EndOfContent;
(() => {
  typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;
var Null = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, ValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
};
_a$t = Null;
(() => {
  typeStore.Null = _a$t;
})();
Null.NAME = "NULL";
var LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;
var Boolean2 = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
};
_a$s = Boolean2;
(() => {
  typeStore.Boolean = _a$s;
})();
Boolean2.NAME = "BOOLEAN";
var LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0; i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
};
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;
var OctetString = class _OctetString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch (e) {
      }
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    }
    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueHexView)}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _OctetString) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
};
_a$r = OctetString;
(() => {
  typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;
var LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch (e) {
      }
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
};
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;
var BitString = class extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
    }
  }
};
_a$q = BitString;
(() => {
  typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max; i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power2(n) {
  if (n >= powers2.length) {
    for (let p = powers2.length; p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers2[p - 1].slice(0);
      for (let i = digits.length - 1; i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers2.push(digits);
    }
  }
  return powers2[n];
}
function viewSub(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}
var LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== void 0) {
      this.valueDec = value;
    }
  }
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0; i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub(power2(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd(digits, power2(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0; i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString.charAt(0);
    return result;
  }
};
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o;
var Integer = class _Integer extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter();
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _Integer({
      valueHex: writer.final()
    });
    return res;
  }
  convertToDER() {
    const integer = new _Integer({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _Integer({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
};
_a$o = Integer;
(() => {
  typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;
var Enumerated = class extends Integer {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
};
_a$n = Enumerated;
(() => {
  typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";
var LocalSidValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes3 = new Uint8Array(bits.length / 7);
    for (let i = 0; i < bytes3.length; i++) {
      bytes3[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes3.length ? 128 : 0);
    }
    this.fromBER(bytes3.buffer, 0, bytes3.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0; i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
};
LocalSidValueBlock.NAME = "sidBlock";
var LocalObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock();
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
};
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;
var ObjectIdentifier = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$m = ObjectIdentifier;
(() => {
  typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
var LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0; i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
};
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
var LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock();
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
};
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;
var RelativeObjectIdentifier = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$l = RelativeObjectIdentifier;
(() => {
  typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;
var Sequence = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
};
_a$k = Sequence;
(() => {
  typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;
var Set2 = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
};
_a$j = Set2;
(() => {
  typeStore.Set = _a$j;
})();
Set2.NAME = "SET";
var LocalStringValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalStringValueBlock.NAME = "StringValueBlock";
var LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
};
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
var LocalSimpleStringBlock = class extends BaseStringBlock {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0; i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
};
LocalSimpleStringBlock.NAME = "SIMPLE STRING";
var LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
};
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;
var Utf8String = class extends LocalUtf8StringValueBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
};
_a$i = Utf8String;
(() => {
  typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";
var LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
};
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;
var BmpString = class extends LocalBmpStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
};
_a$h = BmpString;
(() => {
  typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";
var LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0; i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0; i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1; j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
};
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;
var UniversalString = class extends LocalUniversalStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
};
_a$g = UniversalString;
(() => {
  typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;
var NumericString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
};
_a$f = NumericString;
(() => {
  typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;
var PrintableString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
};
_a$e = PrintableString;
(() => {
  typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;
var TeletexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
};
_a$d = TeletexString;
(() => {
  typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;
var VideotexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
};
_a$c = VideotexString;
(() => {
  typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;
var IA5String = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
};
_a$b = IA5String;
(() => {
  typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;
var GraphicString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
};
_a$a = GraphicString;
(() => {
  typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;
var VisibleString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
};
_a$9 = VisibleString;
(() => {
  typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;
var GeneralString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
};
_a$8 = GeneralString;
(() => {
  typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;
var CharacterString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
};
_a$7 = CharacterString;
(() => {
  typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;
var UTCTime = class extends VisibleString {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0; i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2e3 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
};
_a$6 = UTCTime;
(() => {
  typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;
var GeneralizedTime = class extends UTCTime {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1e3 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1; j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
};
_a$5 = GeneralizedTime;
(() => {
  typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;
var DATE = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
};
_a$4 = DATE;
(() => {
  typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;
var TimeOfDay = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
};
_a$3 = TimeOfDay;
(() => {
  typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;
var DateTime = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
};
_a$2 = DateTime;
(() => {
  typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;
var Duration = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
};
_a$1 = Duration;
(() => {
  typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;
var TIME = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
};
_a = TIME;
(() => {
  typeStore.TIME = _a;
})();
TIME.NAME = "TIME";

// node_modules/@hashgraph/cryptography/src/encoding/pem.js
var import_node_forge3 = __toESM(require_lib2(), 1);
var import_buffer3 = __toESM(require_buffer(), 1);
var ID_ED25519 = "1.3.101.112";
async function readPemED25519(pem, passphrase) {
  const pemKeyData = pem.replace(
    /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
    ""
  );
  const key = decode6(pemKeyData);
  if (passphrase) {
    let encrypted;
    try {
      encrypted = EncryptedPrivateKeyInfo.parse(key);
    } catch (error) {
      const message = (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        error != null && /** @type {Error} */
        error.message != null ? (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          /** @type {Error} */
          error.message
        ) : ""
      );
      throw new BadKeyError(
        `failed to parse encrypted private key: ${message}`
      );
    }
    const decrypted = await encrypted.decrypt(passphrase);
    let privateKey = null;
    if (decrypted.algId.algIdent === ID_ED25519) {
      privateKey = Ed25519PrivateKey;
    } else {
      throw new BadKeyError(
        `unknown private key algorithm ${decrypted.algId.toString()}`
      );
    }
    const keyData = decode5(decrypted.privateKey);
    if (!("bytes" in keyData)) {
      throw new BadKeyError(
        `expected ASN bytes, got ${JSON.stringify(keyData)}`
      );
    }
    return privateKey.fromBytes(keyData.bytes);
  }
  return key.subarray(16);
}
async function readPemECDSA(pem, passphrase) {
  const pemKeyData = pem.replace(
    /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
    ""
  );
  const key = decode6(pemKeyData);
  if (passphrase) {
    const decodedPem = import_node_forge3.default.pem.decode(pem)[0];
    const ivString = decodedPem.dekInfo.parameters;
    const iv = decode3(ivString);
    const pemLines = pem.split("\n");
    const key2 = await messageDigest(passphrase, ivString);
    const dataToDecrypt = import_buffer3.Buffer.from(
      pemLines.slice(4, pemLines.length - 1).join(""),
      "base64"
    );
    const keyDerBytes = await createDecipheriv(
      CipherAlgorithm.Aes128Cbc,
      key2,
      iv,
      dataToDecrypt
    );
    return EcdsaPrivateKey.fromBytesDer(keyDerBytes);
  } else {
    const asnData = fromBER(key);
    const parsedKey = asnData.result;
    return parsedKey.valueBlock.value[1].valueBlock.valueHexView;
  }
}
async function read(pem, passphrase) {
  const isEcdsa = pem.includes("BEGIN EC PRIVATE KEY") ? true : false;
  if (isEcdsa) {
    return readPemECDSA(pem, passphrase);
  } else {
    return readPemED25519(pem, passphrase);
  }
}

// node_modules/@hashgraph/cryptography/src/util/derive.js
function legacy(seed, index) {
  const password = new Uint8Array(seed.length + 8);
  password.set(seed, 0);
  const view = new DataView(
    password.buffer,
    password.byteOffset,
    password.byteLength
  );
  if (index === 1099511627775) {
    view.setInt32(seed.length + 0, 255);
    view.setInt32(seed.length + 4, -1);
  } else {
    view.setInt32(seed.length + 0, index < 0 ? -1 : 0);
    view.setInt32(seed.length + 4, index);
  }
  const salt = Uint8Array.from([255]);
  return deriveKey(
    HashAlgorithm.Sha512,
    password,
    salt,
    2048,
    32
  );
}

// node_modules/@hashgraph/cryptography/src/Cache.js
var CACHE = {
  /** @type {((key: Ed25519PrivateKey | EcdsaPrivateKey) => PrivateKey) | null} */
  privateKeyConstructor: null,
  /** @type {((bytes: Uint8Array) => PrivateKey) | null} */
  privateKeyFromBytes: null,
  /** @type {((words: string) => Mnemonic) | null} */
  mnemonicFromString: null
};
var Cache_default = CACHE;

// node_modules/@hashgraph/cryptography/src/PrivateKey.js
var PrivateKey = class _PrivateKey extends Key {
  /**
   * @hideconstructor
   * @internal
   * @param {Ed25519PrivateKey | EcdsaPrivateKey} key
   */
  constructor(key) {
    super();
    this._key = key;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return this._key._type;
  }
  /**
   * @returns {Uint8Array | null}
   */
  get _chainCode() {
    return this._key._chainCode;
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {PrivateKey}
   */
  static generateED25519() {
    return new _PrivateKey(Ed25519PrivateKey.generate());
  }
  /**
   * Generate a random EDSA private key.
   * @returns {PrivateKey}
   */
  static generateECDSA() {
    return new _PrivateKey(EcdsaPrivateKey.generate());
  }
  /**
   * Depredated - Use `generateED25519()` instead
   * Generate a random Ed25519 private key.
   * @returns {PrivateKey}
   */
  static generate() {
    return _PrivateKey.generateED25519();
  }
  /**
   * Depredated - Use `generateED25519Async()` instead
   * Generate a random Ed25519 private key.
   * @returns {Promise<PrivateKey>}
   */
  static async generateAsync() {
    return _PrivateKey.generateED25519Async();
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Promise<PrivateKey>}
   */
  static async generateED25519Async() {
    return new _PrivateKey(await Ed25519PrivateKey.generateAsync());
  }
  /**
   * Generate a random ECDSA private key.
   * @returns {Promise<PrivateKey>}
   */
  static async generateECDSAAsync() {
    return new _PrivateKey(await EcdsaPrivateKey.generateAsync());
  }
  /**
   * Construct a private key from bytes. Requires DER header.
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytes(data) {
    let message;
    if (data.length == 32) {
      console.warn(
        "WARNING: Consider using fromStringECDSA() or fromStringED2551() on a HEX-encoded string and fromStringDer() on a HEX-encoded string with DER prefix instead."
      );
    }
    try {
      return new _PrivateKey(Ed25519PrivateKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    try {
      return new _PrivateKey(EcdsaPrivateKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    throw new BadKeyError(
      `private key cannot be decoded from bytes: ${message}`
    );
  }
  /**
   * Construct a ECDSA private key from bytes.
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytesECDSA(data) {
    return new _PrivateKey(EcdsaPrivateKey.fromBytes(data));
  }
  /**
   * Construct a ED25519 private key from bytes.
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytesED25519(data) {
    return new _PrivateKey(Ed25519PrivateKey.fromBytes(data));
  }
  /**
   * Construct a private key from a hex-encoded string. Requires DER header.
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromString(text) {
    return _PrivateKey.fromBytes(decode3(text));
  }
  /**
   * Construct a ECDSA private key from a hex-encoded string.
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromStringECDSA(text) {
    return _PrivateKey.fromBytesECDSA(decode3(text));
  }
  /**
   * Construct a Ed25519 private key from a hex-encoded string.
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromStringED25519(text) {
    return _PrivateKey.fromBytesED25519(decode3(text));
  }
  /**
   * Construct a Ed25519 private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<PrivateKey>}
   */
  static async fromSeedED25519(seed) {
    const ed25519Key = await Ed25519PrivateKey.fromSeed(seed);
    return new _PrivateKey(ed25519Key);
  }
  /**
   * Construct a ECDSA private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<PrivateKey>}
   */
  static async fromSeedECDSAsecp256k1(seed) {
    const ecdsaKey = await EcdsaPrivateKey.fromSeed(seed);
    return new _PrivateKey(ecdsaKey);
  }
  /**
   * @deprecated - Use `Mnemonic.from[Words|String]().toStandard[Ed25519|ECDSAsecp256k1]PrivateKey()` instead
   *
   * Recover a private key from a mnemonic phrase (and optionally a password).
   * @param {Mnemonic | string} mnemonic
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  static async fromMnemonic(mnemonic, passphrase = "") {
    if (Cache_default.mnemonicFromString == null) {
      throw new Error("Mnemonic not found in cache");
    }
    return (typeof mnemonic === "string" ? Cache_default.mnemonicFromString(mnemonic) : mnemonic).toEd25519PrivateKey(passphrase);
  }
  /**
   * Recover a private key from a keystore, previously created by `.toKeystore()`.
   *
   * This key will _not_ support child key derivation.
   * @param {Uint8Array} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.
   */
  static async fromKeystore(data, passphrase = "") {
    return _PrivateKey.fromBytes(await loadKeystore(data, passphrase));
  }
  /**
   * Recover a private key from a pem string; the private key may be encrypted.
   *
   * This method assumes the .pem file has been converted to a string already.
   *
   * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
   * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
   * section and decodes that as a DER-encoded  private key.
   * @param {string} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  static async fromPem(data, passphrase = "") {
    const pem = await read(data, passphrase);
    if (pem instanceof Ed25519PrivateKey || pem instanceof EcdsaPrivateKey) {
      return new _PrivateKey(pem);
    }
    const isEcdsa = data.includes("BEGIN EC PRIVATE KEY") ? true : false;
    if (isEcdsa) {
      return new _PrivateKey(EcdsaPrivateKey.fromBytes(pem));
    } else {
      return new _PrivateKey(Ed25519PrivateKey.fromBytes(pem));
    }
  }
  /**
   * Derive a new private key at the given wallet index.
   *
   * Only currently supported for keys created with from mnemonics; other keys will throw
   * an error.
   *
   * You can check if a key supports derivation with `.supportsDerivation()`
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */
  async derive(index) {
    if (this._key._chainCode == null) {
      throw new Error("this private key does not support key derivation");
    }
    if (this._key instanceof Ed25519PrivateKey) {
      const { keyData, chainCode } = await derive2(
        this.toBytesRaw(),
        this._key._chainCode,
        index
      );
      return new _PrivateKey(new Ed25519PrivateKey(keyData, chainCode));
    } else {
      const { keyData, chainCode } = await derive(
        this.toBytesRaw(),
        this._key._chainCode,
        index
      );
      return new _PrivateKey(
        new EcdsaPrivateKey(fromBytes(keyData), chainCode)
      );
    }
  }
  /**
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */
  async legacyDerive(index) {
    const keyBytes = await legacy(
      this.toBytesRaw().subarray(0, 32),
      index
    );
    const constructor2 = (
      /** @type {any} */
      this._key.constructor
    );
    return new _PrivateKey(new constructor2(keyBytes));
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   * @returns {PublicKey}
   */
  get publicKey() {
    return new PublicKey(this._key.publicKey);
  }
  /**
   * Sign a message with this private key.
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */
  sign(bytes3) {
    return this._key.sign(bytes3);
  }
  /**
   * @param {Transaction} transaction
   * @returns {Uint8Array}
   */
  signTransaction(transaction) {
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    if (transaction._signedTransactions.length != 1) {
      throw new Error(
        "`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set"
      );
    }
    const tx = (
      /** @type {ProtoSignedTransaction} */
      transaction._signedTransactions[0]
    );
    const publicKeyHex = encode3(this.publicKey.toBytesRaw());
    if (tx.sigMap == null) {
      tx.sigMap = {};
    }
    if (tx.sigMap.sigPair == null) {
      tx.sigMap.sigPair = [];
    }
    for (const sigPair of tx.sigMap.sigPair) {
      if (sigPair.pubKeyPrefix != null && encode3(sigPair.pubKeyPrefix) === publicKeyHex) {
        switch (this._type) {
          case "ED25519":
            return (
              /** @type {Uint8Array} */
              sigPair.ed25519
            );
          case "secp256k1":
            return (
              /** @type {Uint8Array} */
              sigPair.ECDSASecp256k1
            );
        }
      }
    }
    const siganture = this.sign(
      tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array()
    );
    const protoSignature = {
      pubKeyPrefix: this.publicKey.toBytesRaw()
    };
    switch (this._type) {
      case "ED25519":
        protoSignature.ed25519 = siganture;
        break;
      case "secp256k1":
        protoSignature.ECDSASecp256k1 = siganture;
        break;
    }
    tx.sigMap.sigPair.push(protoSignature);
    transaction._signerPublicKeys.add(publicKeyHex);
    return siganture;
  }
  /**
   * Check if `derive` can be called on this private key.
   *
   * This is only the case if the key was created from a mnemonic.
   * @returns {boolean}
   */
  isDerivable() {
    return this._key._chainCode != null;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    if (this._key instanceof Ed25519PrivateKey) {
      return this.toBytesRaw();
    } else {
      return this.toBytesDer();
    }
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    return this._key.toBytesDer();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.toStringDer();
  }
  /**
   * @returns {string}
   */
  toStringDer() {
    return encode3(this.toBytesDer());
  }
  /**
   * @returns {string}
   */
  toStringRaw() {
    return encode3(this.toBytesRaw());
  }
  /**
   * Create a keystore with a given passphrase.
   *
   * The key can be recovered later with `fromKeystore()`.
   *
   * Note that this will not retain the ancillary data used for
   * deriving child keys, thus `.derive()` on the restored key will
   * throw even if this instance supports derivation.
   * @param {string} [passphrase]
   * @returns {Promise<Uint8Array>}
   */
  toKeystore(passphrase = "") {
    return createKeystore(this.toBytesRaw(), passphrase);
  }
};
Cache_default.privateKeyConstructor = (key) => new PrivateKey(key);
Cache_default.privateKeyFromBytes = (bytes3) => PrivateKey.fromBytes(bytes3);

// node_modules/@hashgraph/cryptography/src/BadMnemonicReason.js
var BadMnemonicReason = Object.freeze({
  /**
   * The mnemonic did not have a supported number of words (12 or 24 for regular and 22 for legacy).
   */
  BadLength: "BadLength",
  /**
   * The mnemonic contained words which were not found in the word list.
   */
  UnknownWords: "UnknownWords",
  /**
   * The checksum encoded in the mnemonic did not match the checksum we just calculated for
   * that mnemonic.
   *
   * 24-word mnemonics have an 8-bit checksum that is appended to the 32 bytes of source entropy
   * after being calculated from it, before being encoded into words.
   *
   * This could happen if two or more of the words were entered out of the original order or
   * replaced with another from the standard word list (as this is only returned if all the words
   * exist in the word list).
   */
  ChecksumMismatch: "ChecksumMismatch"
});
var BadMnemonicReason_default = BadMnemonicReason;

// node_modules/@hashgraph/cryptography/src/BadMnemonicError.js
var BadMnemonicError = class _BadMnemonicError extends Error {
  /**
   * @param {Mnemonic} mnemonic
   * @param {string} reason
   * @param {number[]} unknownWordIndices
   * @hideconstructor
   */
  constructor(mnemonic, reason, unknownWordIndices) {
    let reasonMessage;
    switch (reason) {
      case BadMnemonicReason_default.BadLength:
        reasonMessage = "mnemonic is of an unexpected number of words";
        break;
      case BadMnemonicReason_default.ChecksumMismatch:
        reasonMessage = "checksum byte in mnemonic did not match the rest of the mnemonic";
        break;
      case BadMnemonicReason_default.UnknownWords:
        reasonMessage = "mnemonic contained words that are not in the standard word list";
        break;
      default:
        throw new Error(
          `unexpected value ${reason.toString()} for 'reason'`
        );
    }
    super(`invalid mnemonic: ${reasonMessage}`);
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, _BadMnemonicError);
    }
    this.name = "BadMnemonicError";
    this.reason = reason;
    this.mnemonic = mnemonic;
    this.unknownWordIndices = unknownWordIndices;
  }
};

// node_modules/@hashgraph/cryptography/src/words/legacy.js
var legacy_default = [
  "aback",
  "abbey",
  "abbot",
  "abide",
  "ablaze",
  "able",
  "aboard",
  "abode",
  "abort",
  "abound",
  "about",
  "above",
  "abroad",
  "abrupt",
  "absent",
  "absorb",
  "absurd",
  "abuse",
  "accent",
  "accept",
  "access",
  "accord",
  "accuse",
  "ace",
  "ache",
  "aching",
  "acid",
  "acidic",
  "acorn",
  "acre",
  "across",
  "act",
  "action",
  "active",
  "actor",
  "actual",
  "acute",
  "adam",
  "adapt",
  "add",
  "added",
  "addict",
  "adept",
  "adhere",
  "adjust",
  "admire",
  "admit",
  "adobe",
  "adopt",
  "adrift",
  "adult",
  "adverb",
  "advice",
  "aerial",
  "afar",
  "affair",
  "affect",
  "afford",
  "afghan",
  "afield",
  "afloat",
  "afraid",
  "afresh",
  "after",
  "again",
  "age",
  "agency",
  "agenda",
  "agent",
  "aghast",
  "agile",
  "ago",
  "agony",
  "agree",
  "agreed",
  "ahead",
  "aid",
  "aide",
  "aim",
  "air",
  "airman",
  "airy",
  "akin",
  "alarm",
  "alaska",
  "albeit",
  "album",
  "ale",
  "alert",
  "alibi",
  "alice",
  "alien",
  "alight",
  "align",
  "alike",
  "alive",
  "alkali",
  "all",
  "alley",
  "allied",
  "allow",
  "alloy",
  "ally",
  "almond",
  "almost",
  "aloft",
  "alone",
  "along",
  "aloof",
  "aloud",
  "alpha",
  "alpine",
  "also",
  "altar",
  "alter",
  "always",
  "amaze",
  "amazon",
  "amber",
  "ambush",
  "amen",
  "amend",
  "amid",
  "amidst",
  "amiss",
  "among",
  "amount",
  "ample",
  "amuse",
  "anchor",
  "and",
  "andrew",
  "anew",
  "angel",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "annoy",
  "annual",
  "answer",
  "anthem",
  "any",
  "anyhow",
  "anyway",
  "apart",
  "apathy",
  "apex",
  "apiece",
  "appeal",
  "appear",
  "apple",
  "apply",
  "april",
  "apron",
  "arab",
  "arcade",
  "arcane",
  "arch",
  "arctic",
  "ardent",
  "are",
  "area",
  "argue",
  "arid",
  "arise",
  "ark",
  "arm",
  "armful",
  "army",
  "aroma",
  "around",
  "arouse",
  "array",
  "arrest",
  "arrive",
  "arrow",
  "arson",
  "art",
  "artery",
  "artful",
  "artist",
  "ascent",
  "ash",
  "ashen",
  "ashore",
  "aside",
  "ask",
  "asleep",
  "aspect",
  "assay",
  "assent",
  "assert",
  "assess",
  "asset",
  "assign",
  "assist",
  "assume",
  "assure",
  "asthma",
  "astute",
  "asylum",
  "ate",
  "athens",
  "atlas",
  "atom",
  "atomic",
  "attach",
  "attack",
  "attain",
  "attend",
  "attic",
  "auburn",
  "audio",
  "audit",
  "august",
  "aunt",
  "auntie",
  "aura",
  "austin",
  "author",
  "auto",
  "autumn",
  "avail",
  "avenge",
  "avenue",
  "avert",
  "avid",
  "avoid",
  "await",
  "awake",
  "awaken",
  "award",
  "aware",
  "awash",
  "away",
  "awful",
  "awhile",
  "axe",
  "axes",
  "axiom",
  "axis",
  "axle",
  "aye",
  "babe",
  "baby",
  "bach",
  "back",
  "backup",
  "bacon",
  "bad",
  "badge",
  "badly",
  "bag",
  "baggy",
  "bail",
  "bait",
  "bake",
  "baker",
  "bakery",
  "bald",
  "ball",
  "ballad",
  "ballet",
  "ballot",
  "baltic",
  "bamboo",
  "ban",
  "banal",
  "banana",
  "band",
  "bang",
  "bank",
  "bar",
  "barber",
  "bare",
  "barely",
  "barge",
  "bark",
  "barley",
  "barn",
  "baron",
  "barrel",
  "barren",
  "basalt",
  "base",
  "basic",
  "basil",
  "basin",
  "basis",
  "basket",
  "bass",
  "bat",
  "batch",
  "bath",
  "baton",
  "battle",
  "bay",
  "beach",
  "beacon",
  "beak",
  "beam",
  "bean",
  "bear",
  "beard",
  "beast",
  "beat",
  "beauty",
  "become",
  "bed",
  "beech",
  "beef",
  "beefy",
  "beep",
  "beer",
  "beet",
  "beetle",
  "before",
  "beg",
  "beggar",
  "begin",
  "behalf",
  "behave",
  "behind",
  "beige",
  "being",
  "belief",
  "bell",
  "belly",
  "belong",
  "below",
  "belt",
  "bench",
  "bend",
  "benign",
  "bent",
  "berlin",
  "berry",
  "berth",
  "beset",
  "beside",
  "best",
  "bestow",
  "bet",
  "beta",
  "betray",
  "better",
  "beware",
  "beyond",
  "bias",
  "biceps",
  "bicker",
  "bid",
  "big",
  "bigger",
  "bike",
  "bile",
  "bill",
  "bin",
  "binary",
  "bind",
  "biopsy",
  "birch",
  "bird",
  "birdie",
  "birth",
  "bishop",
  "bit",
  "bitch",
  "bite",
  "bitter",
  "black",
  "blade",
  "blame",
  "bland",
  "blast",
  "blaze",
  "bleak",
  "blend",
  "bless",
  "blew",
  "blind",
  "blink",
  "blip",
  "bliss",
  "blitz",
  "block",
  "blond",
  "blood",
  "bloody",
  "bloom",
  "blot",
  "blouse",
  "blow",
  "blue",
  "bluff",
  "blunt",
  "blur",
  "blush",
  "boar",
  "board",
  "boast",
  "boat",
  "bob",
  "bodily",
  "body",
  "bogus",
  "boil",
  "bold",
  "bolt",
  "bomb",
  "bombay",
  "bond",
  "bone",
  "bonn",
  "bonnet",
  "bonus",
  "bony",
  "book",
  "boom",
  "boost",
  "boot",
  "booth",
  "booze",
  "border",
  "bore",
  "borrow",
  "bosom",
  "boss",
  "boston",
  "both",
  "bother",
  "bottle",
  "bottom",
  "bought",
  "bounce",
  "bound",
  "bounty",
  "bout",
  "bovine",
  "bow",
  "bowel",
  "bowl",
  "box",
  "boy",
  "boyish",
  "brace",
  "brain",
  "brainy",
  "brake",
  "bran",
  "branch",
  "brand",
  "brandy",
  "brass",
  "brave",
  "bravo",
  "brazil",
  "breach",
  "bread",
  "break",
  "breast",
  "breath",
  "bred",
  "breed",
  "breeze",
  "brew",
  "bribe",
  "brick",
  "bride",
  "bridge",
  "brief",
  "bright",
  "brim",
  "brine",
  "bring",
  "brink",
  "brisk",
  "broad",
  "broke",
  "broken",
  "bronze",
  "brook",
  "broom",
  "brown",
  "bruise",
  "brush",
  "brutal",
  "brute",
  "bubble",
  "buck",
  "bucket",
  "buckle",
  "budget",
  "buffet",
  "buggy",
  "build",
  "bulb",
  "bulge",
  "bulk",
  "bulky",
  "bull",
  "bullet",
  "bully",
  "bump",
  "bumpy",
  "bunch",
  "bundle",
  "bunk",
  "bunny",
  "burden",
  "bureau",
  "burial",
  "buried",
  "burly",
  "burn",
  "burnt",
  "burrow",
  "burst",
  "bury",
  "bus",
  "bush",
  "bust",
  "bustle",
  "busy",
  "but",
  "butler",
  "butt",
  "butter",
  "button",
  "buy",
  "buyer",
  "buzz",
  "bye",
  "byte",
  "cab",
  "cabin",
  "cable",
  "cache",
  "cactus",
  "caesar",
  "cage",
  "cairo",
  "cajun",
  "cajole",
  "cake",
  "calf",
  "call",
  "caller",
  "calm",
  "calmly",
  "came",
  "camel",
  "camera",
  "camp",
  "campus",
  "can",
  "canada",
  "canal",
  "canary",
  "cancel",
  "cancer",
  "candid",
  "candle",
  "candy",
  "cane",
  "canine",
  "canoe",
  "canopy",
  "canvas",
  "canyon",
  "cap",
  "cape",
  "car",
  "carbon",
  "card",
  "care",
  "career",
  "caress",
  "cargo",
  "carl",
  "carnal",
  "carol",
  "carp",
  "carpet",
  "carrot",
  "carry",
  "cart",
  "cartel",
  "case",
  "cash",
  "cask",
  "cast",
  "castle",
  "casual",
  "cat",
  "catch",
  "cater",
  "cattle",
  "caught",
  "causal",
  "cause",
  "cave",
  "cease",
  "celery",
  "cell",
  "cellar",
  "celtic",
  "cement",
  "censor",
  "census",
  "cent",
  "cereal",
  "chain",
  "chair",
  "chalk",
  "chalky",
  "champ",
  "chance",
  "change",
  "chant",
  "chaos",
  "chap",
  "chapel",
  "charge",
  "charm",
  "chart",
  "chase",
  "chat",
  "cheap",
  "cheat",
  "check",
  "cheek",
  "cheeky",
  "cheer",
  "cheery",
  "cheese",
  "chef",
  "cheque",
  "cherry",
  "chess",
  "chest",
  "chew",
  "chic",
  "chick",
  "chief",
  "child",
  "chile",
  "chill",
  "chilly",
  "chin",
  "china",
  "chip",
  "choice",
  "choir",
  "choose",
  "chop",
  "choppy",
  "chord",
  "chorus",
  "chose",
  "chosen",
  "chris",
  "chrome",
  "chunk",
  "chunky",
  "church",
  "cider",
  "cigar",
  "cinema",
  "circa",
  "circle",
  "circus",
  "cite",
  "city",
  "civic",
  "civil",
  "clad",
  "claim",
  "clammy",
  "clan",
  "clap",
  "clash",
  "clasp",
  "class",
  "clause",
  "claw",
  "clay",
  "clean",
  "clear",
  "clergy",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climax",
  "climb",
  "clinch",
  "cling",
  "clinic",
  "clip",
  "cloak",
  "clock",
  "clone",
  "close",
  "closer",
  "closet",
  "cloth",
  "cloud",
  "cloudy",
  "clout",
  "clown",
  "club",
  "clue",
  "clumsy",
  "clung",
  "clutch",
  "coach",
  "coal",
  "coarse",
  "coast",
  "coat",
  "coax",
  "cobalt",
  "cobra",
  "coca",
  "cock",
  "cocoa",
  "code",
  "coffee",
  "coffin",
  "cohort",
  "coil",
  "coin",
  "coke",
  "cold",
  "collar",
  "colon",
  "colony",
  "colt",
  "column",
  "comb",
  "combat",
  "come",
  "comedy",
  "comic",
  "commit",
  "common",
  "compel",
  "comply",
  "concur",
  "cone",
  "confer",
  "congo",
  "consul",
  "convex",
  "convey",
  "convoy",
  "cook",
  "cool",
  "cope",
  "copper",
  "copy",
  "coral",
  "cord",
  "core",
  "cork",
  "corn",
  "corner",
  "corps",
  "corpse",
  "corpus",
  "cortex",
  "cosmic",
  "cosmos",
  "cost",
  "costly",
  "cotton",
  "couch",
  "cough",
  "could",
  "count",
  "county",
  "coup",
  "couple",
  "coupon",
  "course",
  "court",
  "cousin",
  "cove",
  "cover",
  "covert",
  "cow",
  "coward",
  "cowboy",
  "cozy",
  "crab",
  "crack",
  "cradle",
  "craft",
  "crafty",
  "crag",
  "crane",
  "crash",
  "crate",
  "crater",
  "crawl",
  "crazy",
  "creak",
  "cream",
  "creamy",
  "create",
  "credit",
  "creed",
  "creek",
  "creep",
  "creepy",
  "crept",
  "crest",
  "crew",
  "cried",
  "crime",
  "crisis",
  "crisp",
  "critic",
  "crook",
  "crop",
  "cross",
  "crow",
  "crowd",
  "crown",
  "crude",
  "cruel",
  "cruise",
  "crunch",
  "crush",
  "crust",
  "crux",
  "cry",
  "crypt",
  "cuba",
  "cube",
  "cubic",
  "cuckoo",
  "cuff",
  "cult",
  "cup",
  "curb",
  "cure",
  "curfew",
  "curl",
  "curry",
  "curse",
  "cursor",
  "curve",
  "cuss",
  "custom",
  "cut",
  "cute",
  "cycle",
  "cyclic",
  "cynic",
  "czech",
  "dad",
  "daddy",
  "dagger",
  "daily",
  "dairy",
  "daisy",
  "dale",
  "dam",
  "damage",
  "damp",
  "dampen",
  "dance",
  "danger",
  "danish",
  "dare",
  "dark",
  "darken",
  "darn",
  "dart",
  "dash",
  "data",
  "date",
  "david",
  "dawn",
  "day",
  "dead",
  "deadly",
  "deaf",
  "deal",
  "dealer",
  "dean",
  "dear",
  "death",
  "debate",
  "debit",
  "debris",
  "debt",
  "debtor",
  "decade",
  "decay",
  "decent",
  "decide",
  "deck",
  "decor",
  "decree",
  "deduce",
  "deed",
  "deep",
  "deeply",
  "deer",
  "defeat",
  "defect",
  "defend",
  "defer",
  "define",
  "defy",
  "degree",
  "deity",
  "delay",
  "delete",
  "delhi",
  "delta",
  "demand",
  "demise",
  "demo",
  "demure",
  "denial",
  "denote",
  "dense",
  "dental",
  "deny",
  "depart",
  "depend",
  "depict",
  "deploy",
  "depot",
  "depth",
  "deputy",
  "derive",
  "desert",
  "design",
  "desire",
  "desist",
  "desk",
  "detail",
  "detect",
  "deter",
  "detest",
  "detour",
  "device",
  "devise",
  "devoid",
  "devote",
  "devour",
  "dial",
  "diana",
  "diary",
  "dice",
  "dictum",
  "did",
  "die",
  "diesel",
  "diet",
  "differ",
  "dig",
  "digest",
  "digit",
  "dine",
  "dinghy",
  "dinner",
  "diode",
  "dip",
  "dire",
  "direct",
  "dirt",
  "dirty",
  "disc",
  "disco",
  "dish",
  "disk",
  "dismal",
  "dispel",
  "ditch",
  "dive",
  "divert",
  "divide",
  "divine",
  "dizzy",
  "docile",
  "dock",
  "doctor",
  "dog",
  "dogma",
  "dole",
  "doll",
  "dollar",
  "dolly",
  "domain",
  "dome",
  "domino",
  "donate",
  "done",
  "donkey",
  "donor",
  "doom",
  "door",
  "dorsal",
  "dose",
  "dot",
  "double",
  "doubt",
  "dough",
  "dour",
  "dove",
  "down",
  "dozen",
  "draft",
  "drag",
  "dragon",
  "drain",
  "drama",
  "drank",
  "draw",
  "drawer",
  "dread",
  "dream",
  "dreary",
  "dress",
  "drew",
  "dried",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "driver",
  "drop",
  "drove",
  "drown",
  "drug",
  "drum",
  "drunk",
  "dry",
  "dual",
  "duck",
  "duct",
  "due",
  "duel",
  "duet",
  "duke",
  "dull",
  "duly",
  "dumb",
  "dummy",
  "dump",
  "dune",
  "dung",
  "duress",
  "during",
  "dusk",
  "dust",
  "dusty",
  "dutch",
  "duty",
  "dwarf",
  "dwell",
  "dyer",
  "dying",
  "dynamo",
  "each",
  "eager",
  "eagle",
  "ear",
  "earl",
  "early",
  "earn",
  "earth",
  "ease",
  "easel",
  "easily",
  "east",
  "easter",
  "easy",
  "eat",
  "eaten",
  "eater",
  "echo",
  "eddy",
  "eden",
  "edge",
  "edible",
  "edict",
  "edit",
  "editor",
  "eel",
  "eerie",
  "eerily",
  "effect",
  "effort",
  "egg",
  "ego",
  "eight",
  "eighth",
  "eighty",
  "either",
  "elbow",
  "elder",
  "eldest",
  "elect",
  "eleven",
  "elicit",
  "elite",
  "else",
  "elude",
  "elves",
  "embark",
  "emblem",
  "embryo",
  "emerge",
  "emit",
  "empire",
  "employ",
  "empty",
  "enable",
  "enamel",
  "end",
  "endure",
  "enemy",
  "energy",
  "engage",
  "engine",
  "enjoy",
  "enlist",
  "enough",
  "ensure",
  "entail",
  "enter",
  "entire",
  "entry",
  "envoy",
  "envy",
  "enzyme",
  "epic",
  "epoch",
  "equal",
  "equate",
  "equip",
  "equity",
  "era",
  "erect",
  "eric",
  "erode",
  "erotic",
  "errant",
  "error",
  "escape",
  "escort",
  "essay",
  "essex",
  "estate",
  "esteem",
  "ethic",
  "ethnic",
  "europe",
  "evade",
  "eve",
  "even",
  "event",
  "ever",
  "every",
  "evict",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "exam",
  "exceed",
  "excel",
  "except",
  "excess",
  "excise",
  "excite",
  "excuse",
  "exempt",
  "exert",
  "exile",
  "exist",
  "exit",
  "exodus",
  "exotic",
  "expand",
  "expect",
  "expert",
  "expire",
  "export",
  "expose",
  "extend",
  "extra",
  "eye",
  "eyed",
  "fabric",
  "face",
  "facial",
  "fact",
  "factor",
  "fade",
  "fail",
  "faint",
  "fair",
  "fairly",
  "fairy",
  "faith",
  "fake",
  "falcon",
  "fall",
  "false",
  "falter",
  "fame",
  "family",
  "famine",
  "famous",
  "fan",
  "fancy",
  "far",
  "farce",
  "fare",
  "farm",
  "farmer",
  "fast",
  "fasten",
  "faster",
  "fat",
  "fatal",
  "fate",
  "father",
  "fatty",
  "fault",
  "faulty",
  "fauna",
  "fear",
  "feast",
  "feat",
  "fed",
  "fee",
  "feeble",
  "feed",
  "feel",
  "feet",
  "fell",
  "fellow",
  "felt",
  "female",
  "fence",
  "fend",
  "ferry",
  "fetal",
  "fetch",
  "feudal",
  "fever",
  "few",
  "fewer",
  "fiasco",
  "fiddle",
  "field",
  "fiend",
  "fierce",
  "fiery",
  "fifth",
  "fifty",
  "fig",
  "fight",
  "figure",
  "file",
  "fill",
  "filled",
  "filler",
  "film",
  "filter",
  "filth",
  "filthy",
  "final",
  "finale",
  "find",
  "fine",
  "finery",
  "finger",
  "finish",
  "finite",
  "fire",
  "firm",
  "firmly",
  "first",
  "fiscal",
  "fish",
  "fisher",
  "fist",
  "fit",
  "fitful",
  "five",
  "fix",
  "flag",
  "flair",
  "flak",
  "flame",
  "flank",
  "flap",
  "flare",
  "flash",
  "flask",
  "flat",
  "flavor",
  "flaw",
  "fled",
  "flee",
  "fleece",
  "fleet",
  "flesh",
  "fleshy",
  "flew",
  "flick",
  "flight",
  "flimsy",
  "flint",
  "flirt",
  "float",
  "flock",
  "flood",
  "floor",
  "floppy",
  "flora",
  "floral",
  "flour",
  "flow",
  "flower",
  "fluent",
  "fluffy",
  "fluid",
  "flung",
  "flurry",
  "flush",
  "flute",
  "flux",
  "fly",
  "flyer",
  "foal",
  "foam",
  "focal",
  "focus",
  "fog",
  "foil",
  "fold",
  "folk",
  "follow",
  "folly",
  "fond",
  "fondly",
  "font",
  "food",
  "fool",
  "foot",
  "for",
  "forbid",
  "force",
  "ford",
  "forest",
  "forge",
  "forget",
  "fork",
  "form",
  "formal",
  "format",
  "former",
  "fort",
  "forth",
  "forty",
  "forum",
  "fossil",
  "foster",
  "foul",
  "found",
  "four",
  "fourth",
  "fox",
  "foyer",
  "frail",
  "frame",
  "franc",
  "france",
  "frank",
  "fraud",
  "fred",
  "free",
  "freed",
  "freely",
  "freeze",
  "french",
  "frenzy",
  "fresh",
  "friar",
  "friday",
  "fridge",
  "fried",
  "friend",
  "fright",
  "fringe",
  "frock",
  "frog",
  "from",
  "front",
  "frost",
  "frosty",
  "frown",
  "frozen",
  "frugal",
  "fruit",
  "fry",
  "fudge",
  "fuel",
  "full",
  "fully",
  "fumes",
  "fun",
  "fund",
  "funny",
  "fur",
  "furry",
  "fury",
  "fuse",
  "fusion",
  "fuss",
  "fussy",
  "futile",
  "future",
  "fuzzy",
  "gadget",
  "gain",
  "gala",
  "galaxy",
  "gale",
  "gall",
  "galley",
  "gallon",
  "gallop",
  "gamble",
  "game",
  "gamma",
  "gandhi",
  "gang",
  "gap",
  "garage",
  "garden",
  "garlic",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaunt",
  "gave",
  "gaze",
  "gear",
  "geese",
  "gem",
  "gemini",
  "gender",
  "gene",
  "geneva",
  "genial",
  "genius",
  "genre",
  "gentle",
  "gently",
  "gentry",
  "genus",
  "george",
  "germ",
  "get",
  "ghetto",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "gill",
  "gilt",
  "ginger",
  "girl",
  "give",
  "given",
  "glad",
  "glade",
  "glance",
  "gland",
  "glare",
  "glass",
  "glassy",
  "gleam",
  "glee",
  "glide",
  "global",
  "globe",
  "gloom",
  "gloomy",
  "gloria",
  "glory",
  "gloss",
  "glossy",
  "glove",
  "glow",
  "glue",
  "gnat",
  "gnu",
  "goal",
  "goat",
  "gold",
  "golden",
  "golf",
  "gone",
  "gong",
  "goo",
  "good",
  "goose",
  "gore",
  "gorge",
  "gory",
  "gosh",
  "gospel",
  "gossip",
  "got",
  "gothic",
  "govern",
  "gown",
  "grab",
  "grace",
  "grade",
  "grail",
  "grain",
  "grand",
  "grant",
  "grape",
  "graph",
  "grasp",
  "grass",
  "grassy",
  "grate",
  "grave",
  "gravel",
  "gravy",
  "grease",
  "greasy",
  "great",
  "greece",
  "greed",
  "greedy",
  "greek",
  "green",
  "greet",
  "grew",
  "grey",
  "grid",
  "grief",
  "grill",
  "grim",
  "grin",
  "grind",
  "grip",
  "grit",
  "gritty",
  "groan",
  "groin",
  "groom",
  "groove",
  "gross",
  "ground",
  "group",
  "grove",
  "grow",
  "grown",
  "growth",
  "grudge",
  "grunt",
  "guard",
  "guess",
  "guest",
  "guide",
  "guild",
  "guilt",
  "guilty",
  "guise",
  "guitar",
  "gulf",
  "gully",
  "gun",
  "gunman",
  "guru",
  "gut",
  "guy",
  "gypsy",
  "habit",
  "hack",
  "had",
  "hail",
  "hair",
  "hairy",
  "haiti",
  "hale",
  "half",
  "hall",
  "halt",
  "hamlet",
  "hammer",
  "hand",
  "handle",
  "handy",
  "hang",
  "hangar",
  "hanoi",
  "happen",
  "happy",
  "harass",
  "harbor",
  "hard",
  "harder",
  "hardly",
  "hare",
  "harem",
  "harm",
  "harp",
  "harry",
  "harsh",
  "has",
  "hash",
  "hassle",
  "haste",
  "hasten",
  "hasty",
  "hat",
  "hatch",
  "hate",
  "haul",
  "haunt",
  "havana",
  "have",
  "haven",
  "havoc",
  "hawaii",
  "hawk",
  "hay",
  "hazard",
  "haze",
  "hazel",
  "hazy",
  "head",
  "heal",
  "health",
  "heap",
  "hear",
  "heard",
  "heart",
  "hearth",
  "hearty",
  "heat",
  "heater",
  "heaven",
  "heavy",
  "hebrew",
  "heck",
  "hectic",
  "hedge",
  "heel",
  "hefty",
  "height",
  "heir",
  "held",
  "helium",
  "helix",
  "hell",
  "hello",
  "helm",
  "helmet",
  "help",
  "hemp",
  "hence",
  "henry",
  "her",
  "herald",
  "herb",
  "herd",
  "here",
  "hereby",
  "hermes",
  "hernia",
  "hero",
  "heroic",
  "heroin",
  "hey",
  "heyday",
  "hick",
  "hidden",
  "hide",
  "high",
  "higher",
  "highly",
  "hill",
  "him",
  "hind",
  "hinder",
  "hint",
  "hippie",
  "hire",
  "his",
  "hiss",
  "hit",
  "hive",
  "hoard",
  "hoarse",
  "hobby",
  "hockey",
  "hold",
  "holder",
  "hole",
  "hollow",
  "holly",
  "holy",
  "home",
  "honest",
  "honey",
  "hood",
  "hook",
  "hope",
  "horn",
  "horrid",
  "horror",
  "horse",
  "hose",
  "host",
  "hot",
  "hotel",
  "hound",
  "hour",
  "house",
  "hover",
  "how",
  "huge",
  "hull",
  "human",
  "humane",
  "humble",
  "humid",
  "hung",
  "hunger",
  "hungry",
  "hunt",
  "hurdle",
  "hurl",
  "hurry",
  "hurt",
  "hush",
  "hut",
  "hybrid",
  "hymn",
  "hyphen",
  "ice",
  "icing",
  "icon",
  "idaho",
  "idea",
  "ideal",
  "idiom",
  "idiot",
  "idle",
  "idly",
  "idol",
  "ignite",
  "ignore",
  "ill",
  "image",
  "immune",
  "impact",
  "imply",
  "import",
  "impose",
  "inca",
  "incest",
  "inch",
  "income",
  "incur",
  "indeed",
  "index",
  "india",
  "indian",
  "indoor",
  "induce",
  "inept",
  "inert",
  "infant",
  "infect",
  "infer",
  "influx",
  "inform",
  "inject",
  "injure",
  "injury",
  "ink",
  "inlaid",
  "inland",
  "inlet",
  "inmate",
  "inn",
  "innate",
  "inner",
  "input",
  "insane",
  "insect",
  "insert",
  "inset",
  "inside",
  "insist",
  "insult",
  "insure",
  "intact",
  "intake",
  "intend",
  "inter",
  "into",
  "invade",
  "invent",
  "invest",
  "invite",
  "invoke",
  "inward",
  "iowa",
  "iran",
  "iraq",
  "irish",
  "iron",
  "ironic",
  "irony",
  "isaac",
  "isabel",
  "island",
  "isle",
  "israel",
  "issue",
  "italy",
  "itch",
  "item",
  "itself",
  "ivan",
  "ivory",
  "jack",
  "jacket",
  "jacob",
  "jade",
  "jaguar",
  "jail",
  "james",
  "jane",
  "japan",
  "jargon",
  "java",
  "jaw",
  "jazz",
  "jeep",
  "jelly",
  "jerky",
  "jest",
  "jet",
  "jewel",
  "jewish",
  "jim",
  "job",
  "jock",
  "jockey",
  "joe",
  "john",
  "join",
  "joint",
  "joke",
  "jolly",
  "jolt",
  "jordan",
  "joseph",
  "joy",
  "joyful",
  "joyous",
  "judge",
  "judy",
  "juice",
  "juicy",
  "july",
  "jumble",
  "jumbo",
  "jump",
  "june",
  "jungle",
  "junior",
  "junk",
  "junta",
  "jury",
  "just",
  "kansas",
  "karate",
  "karl",
  "keel",
  "keen",
  "keep",
  "keeper",
  "kenya",
  "kept",
  "kernel",
  "kettle",
  "key",
  "khaki",
  "kick",
  "kid",
  "kidnap",
  "kidney",
  "kill",
  "killer",
  "kin",
  "kind",
  "kindly",
  "king",
  "kiss",
  "kite",
  "kitten",
  "knack",
  "knee",
  "kneel",
  "knew",
  "knife",
  "knight",
  "knit",
  "knob",
  "knock",
  "knot",
  "know",
  "known",
  "koran",
  "korea",
  "kuwait",
  "label",
  "lace",
  "lack",
  "lad",
  "ladder",
  "laden",
  "lady",
  "lagoon",
  "laity",
  "lake",
  "lamb",
  "lame",
  "lamp",
  "lance",
  "land",
  "lane",
  "lap",
  "lapse",
  "large",
  "larval",
  "laser",
  "last",
  "latch",
  "late",
  "lately",
  "latent",
  "later",
  "latest",
  "latin",
  "latter",
  "laugh",
  "launch",
  "lava",
  "lavish",
  "law",
  "lawful",
  "lawn",
  "lawyer",
  "lay",
  "layer",
  "layman",
  "lazy",
  "lead",
  "leader",
  "leaf",
  "leafy",
  "league",
  "leak",
  "leaky",
  "lean",
  "leap",
  "learn",
  "lease",
  "leash",
  "least",
  "leave",
  "led",
  "ledge",
  "left",
  "leg",
  "legacy",
  "legal",
  "legend",
  "legion",
  "lemon",
  "lend",
  "length",
  "lens",
  "lent",
  "leo",
  "leper",
  "lesion",
  "less",
  "lessen",
  "lesser",
  "lesson",
  "lest",
  "let",
  "lethal",
  "letter",
  "level",
  "lever",
  "levy",
  "lewis",
  "liable",
  "liar",
  "libel",
  "libya",
  "lice",
  "lick",
  "lid",
  "lie",
  "lied",
  "lier",
  "life",
  "lift",
  "light",
  "like",
  "likely",
  "limb",
  "lime",
  "limit",
  "limp",
  "line",
  "linear",
  "linen",
  "linger",
  "link",
  "lint",
  "lion",
  "lip",
  "liquid",
  "liquor",
  "list",
  "listen",
  "lit",
  "live",
  "lively",
  "liver",
  "liz",
  "lizard",
  "load",
  "loaf",
  "loan",
  "lobby",
  "lobe",
  "local",
  "locate",
  "lock",
  "locus",
  "lodge",
  "loft",
  "lofty",
  "log",
  "logic",
  "logo",
  "london",
  "lone",
  "lonely",
  "long",
  "longer",
  "look",
  "loop",
  "loose",
  "loosen",
  "loot",
  "lord",
  "lorry",
  "lose",
  "loss",
  "lost",
  "lot",
  "lotion",
  "lotus",
  "loud",
  "loudly",
  "lounge",
  "lousy",
  "love",
  "lovely",
  "lover",
  "low",
  "lower",
  "lowest",
  "loyal",
  "lucid",
  "luck",
  "lucky",
  "lucy",
  "lull",
  "lump",
  "lumpy",
  "lunacy",
  "lunar",
  "lunch",
  "lung",
  "lure",
  "lurid",
  "lush",
  "lust",
  "lute",
  "luther",
  "luxury",
  "lying",
  "lymph",
  "lynch",
  "lyric",
  "macho",
  "macro",
  "mad",
  "madam",
  "made",
  "mafia",
  "magic",
  "magma",
  "magnet",
  "magnum",
  "magpie",
  "maid",
  "maiden",
  "mail",
  "main",
  "mainly",
  "major",
  "make",
  "maker",
  "male",
  "malice",
  "mall",
  "malt",
  "mammal",
  "manage",
  "mane",
  "mania",
  "manic",
  "manner",
  "manor",
  "mantle",
  "manual",
  "manure",
  "many",
  "map",
  "maple",
  "marble",
  "march",
  "mare",
  "margin",
  "maria",
  "marina",
  "mark",
  "market",
  "marry",
  "mars",
  "marsh",
  "martin",
  "martyr",
  "mary",
  "mask",
  "mason",
  "mass",
  "mast",
  "master",
  "mat",
  "match",
  "mate",
  "matrix",
  "matter",
  "mature",
  "maxim",
  "may",
  "maybe",
  "mayor",
  "maze",
  "mead",
  "meadow",
  "meal",
  "mean",
  "meant",
  "meat",
  "medal",
  "media",
  "median",
  "medic",
  "medium",
  "meet",
  "mellow",
  "melody",
  "melon",
  "melt",
  "member",
  "memo",
  "memory",
  "menace",
  "mend",
  "mental",
  "mentor",
  "menu",
  "mercy",
  "mere",
  "merely",
  "merge",
  "merger",
  "merit",
  "merry",
  "mesh",
  "mess",
  "messy",
  "met",
  "metal",
  "meter",
  "method",
  "methyl",
  "metric",
  "metro",
  "mexico",
  "miami",
  "mickey",
  "mid",
  "midday",
  "middle",
  "midst",
  "midway",
  "might",
  "mighty",
  "mild",
  "mildew",
  "mile",
  "milk",
  "milky",
  "mill",
  "mimic",
  "mince",
  "mind",
  "mine",
  "mini",
  "mink",
  "minor",
  "mint",
  "minus",
  "minute",
  "mire",
  "mirror",
  "mirth",
  "misery",
  "miss",
  "mist",
  "misty",
  "mite",
  "mix",
  "moan",
  "moat",
  "mob",
  "mobile",
  "mock",
  "mode",
  "model",
  "modem",
  "modern",
  "modest",
  "modify",
  "module",
  "moist",
  "molar",
  "mold",
  "mole",
  "molten",
  "moment",
  "monday",
  "money",
  "monk",
  "monkey",
  "month",
  "mood",
  "moody",
  "moon",
  "moor",
  "moral",
  "morale",
  "morbid",
  "more",
  "morgue",
  "mortal",
  "mortar",
  "mosaic",
  "moscow",
  "moses",
  "mosque",
  "moss",
  "most",
  "mostly",
  "moth",
  "mother",
  "motion",
  "motive",
  "motor",
  "mount",
  "mourn",
  "mouse",
  "mouth",
  "move",
  "movie",
  "mrs",
  "much",
  "muck",
  "mucus",
  "mud",
  "muddle",
  "muddy",
  "mule",
  "mummy",
  "munich",
  "murder",
  "murky",
  "murmur",
  "muscle",
  "museum",
  "music",
  "mussel",
  "must",
  "mutant",
  "mute",
  "mutiny",
  "mutter",
  "mutton",
  "mutual",
  "muzzle",
  "myopic",
  "myriad",
  "myself",
  "mystic",
  "myth",
  "nadir",
  "nail",
  "naked",
  "name",
  "namely",
  "nape",
  "napkin",
  "naples",
  "narrow",
  "nasal",
  "nasty",
  "nathan",
  "nation",
  "native",
  "nature",
  "nausea",
  "naval",
  "nave",
  "navy",
  "near",
  "nearer",
  "nearly",
  "neat",
  "neatly",
  "neck",
  "need",
  "needle",
  "needy",
  "negate",
  "neon",
  "nepal",
  "nephew",
  "nerve",
  "nest",
  "net",
  "neural",
  "never",
  "newly",
  "next",
  "nice",
  "nicely",
  "niche",
  "nickel",
  "niece",
  "night",
  "nile",
  "nimble",
  "nine",
  "ninety",
  "ninth",
  "nobel",
  "noble",
  "nobody",
  "node",
  "noise",
  "noisy",
  "none",
  "noon",
  "nor",
  "norm",
  "normal",
  "north",
  "norway",
  "nose",
  "nosy",
  "not",
  "note",
  "notice",
  "notify",
  "notion",
  "noun",
  "novel",
  "novice",
  "now",
  "nozzle",
  "null",
  "numb",
  "number",
  "nurse",
  "nut",
  "nylon",
  "nymph",
  "oak",
  "oar",
  "oasis",
  "oath",
  "obese",
  "obey",
  "object",
  "oblige",
  "oboe",
  "obtain",
  "obtuse",
  "occult",
  "occupy",
  "occur",
  "ocean",
  "octave",
  "odd",
  "off",
  "offend",
  "offer",
  "office",
  "offset",
  "often",
  "ohio",
  "oil",
  "oily",
  "okay",
  "old",
  "older",
  "oldest",
  "olive",
  "omega",
  "omen",
  "omit",
  "once",
  "one",
  "onion",
  "only",
  "onset",
  "onto",
  "onus",
  "onward",
  "opaque",
  "open",
  "openly",
  "opera",
  "opium",
  "oppose",
  "optic",
  "option",
  "oracle",
  "oral",
  "orange",
  "orbit",
  "orchid",
  "ordeal",
  "order",
  "organ",
  "orgasm",
  "orient",
  "origin",
  "ornate",
  "orphan",
  "oscar",
  "other",
  "otter",
  "ought",
  "ounce",
  "our",
  "out",
  "outer",
  "output",
  "outset",
  "oval",
  "oven",
  "over",
  "overt",
  "owe",
  "owing",
  "owl",
  "own",
  "owner",
  "oxford",
  "oxide",
  "oxygen",
  "oyster",
  "ozone",
  "pace",
  "pack",
  "packet",
  "pact",
  "pad",
  "paddle",
  "paddy",
  "pagan",
  "page",
  "paid",
  "pain",
  "paint",
  "pair",
  "palace",
  "pale",
  "palm",
  "pan",
  "panama",
  "panel",
  "panic",
  "papa",
  "papal",
  "paper",
  "parade",
  "parcel",
  "pardon",
  "parent",
  "paris",
  "parish",
  "park",
  "parody",
  "parrot",
  "part",
  "partly",
  "party",
  "pascal",
  "pass",
  "past",
  "paste",
  "pastel",
  "pastor",
  "pastry",
  "pat",
  "patch",
  "patent",
  "path",
  "patio",
  "patrol",
  "patron",
  "paul",
  "pause",
  "pave",
  "paw",
  "pawn",
  "pay",
  "peace",
  "peach",
  "peak",
  "pear",
  "pearl",
  "pedal",
  "peel",
  "peer",
  "peking",
  "pelvic",
  "pelvis",
  "pen",
  "penal",
  "pence",
  "pencil",
  "penny",
  "people",
  "pepper",
  "per",
  "perch",
  "peril",
  "period",
  "perish",
  "permit",
  "person",
  "peru",
  "pest",
  "pet",
  "peter",
  "petite",
  "petrol",
  "petty",
  "phase",
  "philip",
  "phone",
  "photo",
  "phrase",
  "piano",
  "pick",
  "picket",
  "picnic",
  "pie",
  "piece",
  "pier",
  "pierce",
  "piety",
  "pig",
  "pigeon",
  "piggy",
  "pike",
  "pile",
  "pill",
  "pillar",
  "pillow",
  "pilot",
  "pin",
  "pinch",
  "pine",
  "pink",
  "pint",
  "pious",
  "pipe",
  "pirate",
  "piss",
  "pistol",
  "piston",
  "pit",
  "pitch",
  "pity",
  "pivot",
  "pixel",
  "pizza",
  "place",
  "placid",
  "plague",
  "plain",
  "plan",
  "plane",
  "planet",
  "plank",
  "plant",
  "plasma",
  "plate",
  "play",
  "player",
  "plea",
  "plead",
  "please",
  "pledge",
  "plenty",
  "plight",
  "plot",
  "plough",
  "ploy",
  "plug",
  "plum",
  "plump",
  "plunge",
  "plural",
  "plus",
  "plush",
  "pocket",
  "poem",
  "poet",
  "poetic",
  "poetry",
  "point",
  "poison",
  "poland",
  "polar",
  "pole",
  "police",
  "policy",
  "polish",
  "polite",
  "poll",
  "pollen",
  "polo",
  "pond",
  "ponder",
  "pony",
  "pool",
  "poor",
  "poorly",
  "pop",
  "poppy",
  "pore",
  "pork",
  "port",
  "portal",
  "pose",
  "posh",
  "post",
  "postal",
  "pot",
  "potato",
  "potent",
  "pouch",
  "pound",
  "pour",
  "powder",
  "power",
  "praise",
  "pray",
  "prayer",
  "preach",
  "prefer",
  "prefix",
  "press",
  "pretty",
  "price",
  "pride",
  "priest",
  "primal",
  "prime",
  "prince",
  "print",
  "prior",
  "prism",
  "prison",
  "privy",
  "prize",
  "probe",
  "profit",
  "prompt",
  "prone",
  "proof",
  "propel",
  "proper",
  "prose",
  "proton",
  "proud",
  "prove",
  "proven",
  "proxy",
  "prune",
  "pry",
  "psalm",
  "pseudo",
  "psyche",
  "pub",
  "public",
  "puff",
  "pull",
  "pulp",
  "pulpit",
  "pulsar",
  "pulse",
  "pump",
  "punch",
  "punish",
  "punk",
  "pupil",
  "puppet",
  "puppy",
  "pure",
  "purely",
  "purge",
  "purify",
  "purple",
  "purse",
  "pursue",
  "push",
  "pushy",
  "put",
  "putt",
  "puzzle",
  "quaint",
  "quake",
  "quarry",
  "quart",
  "quartz",
  "quebec",
  "queen",
  "queer",
  "query",
  "quest",
  "queue",
  "quick",
  "quid",
  "quiet",
  "quilt",
  "quirk",
  "quit",
  "quite",
  "quiver",
  "quiz",
  "quota",
  "quote",
  "rabbit",
  "race",
  "racial",
  "racism",
  "rack",
  "racket",
  "radar",
  "radio",
  "radish",
  "radius",
  "raffle",
  "raft",
  "rage",
  "raid",
  "rail",
  "rain",
  "rainy",
  "raise",
  "rake",
  "rally",
  "ramp",
  "random",
  "range",
  "rank",
  "ransom",
  "rape",
  "rapid",
  "rare",
  "rarely",
  "rarity",
  "rash",
  "rat",
  "rate",
  "rather",
  "ratify",
  "ratio",
  "rattle",
  "rave",
  "raven",
  "raw",
  "ray",
  "razor",
  "reach",
  "react",
  "read",
  "reader",
  "ready",
  "real",
  "really",
  "realm",
  "reap",
  "rear",
  "reason",
  "rebel",
  "recall",
  "recent",
  "recess",
  "recipe",
  "reckon",
  "record",
  "recoup",
  "rector",
  "red",
  "redeem",
  "redo",
  "reduce",
  "reed",
  "reef",
  "reek",
  "refer",
  "reform",
  "refuge",
  "refuse",
  "regal",
  "regard",
  "regent",
  "regime",
  "region",
  "regret",
  "reign",
  "reject",
  "relate",
  "relax",
  "relay",
  "relic",
  "relief",
  "relish",
  "rely",
  "remain",
  "remark",
  "remedy",
  "remind",
  "remit",
  "remote",
  "remove",
  "renal",
  "render",
  "rent",
  "rental",
  "repair",
  "repeal",
  "repeat",
  "repent",
  "reply",
  "report",
  "rescue",
  "resent",
  "reside",
  "resign",
  "resin",
  "resist",
  "resort",
  "rest",
  "result",
  "resume",
  "retail",
  "retain",
  "retina",
  "retire",
  "return",
  "reveal",
  "review",
  "revise",
  "revive",
  "revolt",
  "reward",
  "rex",
  "rhine",
  "rhino",
  "rhyme",
  "rhythm",
  "ribbon",
  "rice",
  "rich",
  "rick",
  "rid",
  "ride",
  "rider",
  "ridge",
  "rife",
  "rifle",
  "rift",
  "right",
  "rigid",
  "rile",
  "rim",
  "ring",
  "rinse",
  "riot",
  "ripe",
  "ripen",
  "ripple",
  "rise",
  "risk",
  "risky",
  "rite",
  "ritual",
  "ritz",
  "rival",
  "river",
  "road",
  "roar",
  "roast",
  "rob",
  "robe",
  "robert",
  "robin",
  "robot",
  "robust",
  "rock",
  "rocket",
  "rocky",
  "rod",
  "rode",
  "rodent",
  "rogue",
  "role",
  "roll",
  "roman",
  "rome",
  "roof",
  "room",
  "root",
  "rope",
  "rose",
  "rosy",
  "rot",
  "rotate",
  "rotor",
  "rotten",
  "rouge",
  "rough",
  "round",
  "route",
  "rover",
  "row",
  "royal",
  "rub",
  "rubber",
  "rubble",
  "ruby",
  "rudder",
  "rude",
  "rug",
  "rugby",
  "ruin",
  "rule",
  "ruler",
  "rumble",
  "rump",
  "run",
  "rune",
  "rung",
  "runway",
  "rural",
  "rush",
  "russia",
  "rust",
  "rustic",
  "rusty",
  "sack",
  "sacred",
  "sad",
  "saddle",
  "sadism",
  "sadly",
  "safari",
  "safe",
  "safely",
  "safer",
  "safety",
  "saga",
  "sage",
  "sahara",
  "said",
  "sail",
  "sailor",
  "saint",
  "sake",
  "salad",
  "salary",
  "sale",
  "saline",
  "saliva",
  "salmon",
  "saloon",
  "salt",
  "salty",
  "salute",
  "sam",
  "same",
  "sample",
  "sand",
  "sandy",
  "sane",
  "sash",
  "satin",
  "satire",
  "saturn",
  "sauce",
  "saucer",
  "saudi",
  "sauna",
  "savage",
  "save",
  "saw",
  "say",
  "scale",
  "scalp",
  "scan",
  "scant",
  "scar",
  "scarce",
  "scare",
  "scarf",
  "scary",
  "scene",
  "scenic",
  "scent",
  "school",
  "scold",
  "scope",
  "score",
  "scorn",
  "scotch",
  "scott",
  "scout",
  "scrap",
  "scrape",
  "scream",
  "screen",
  "screw",
  "script",
  "scroll",
  "scrub",
  "scum",
  "sea",
  "seal",
  "seam",
  "seaman",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "sect",
  "sector",
  "secure",
  "see",
  "seed",
  "seeing",
  "seek",
  "seem",
  "seize",
  "seldom",
  "select",
  "self",
  "sell",
  "seller",
  "semi",
  "senate",
  "send",
  "senile",
  "senior",
  "sense",
  "sensor",
  "sent",
  "sentry",
  "seoul",
  "sequel",
  "serene",
  "serial",
  "series",
  "sermon",
  "serum",
  "serve",
  "server",
  "set",
  "settle",
  "seven",
  "severe",
  "sew",
  "sewage",
  "shabby",
  "shade",
  "shadow",
  "shady",
  "shaft",
  "shaggy",
  "shah",
  "shake",
  "shaky",
  "shall",
  "sham",
  "shame",
  "shape",
  "share",
  "shark",
  "sharp",
  "shawl",
  "she",
  "shear",
  "sheen",
  "sheep",
  "sheer",
  "sheet",
  "shelf",
  "shell",
  "sherry",
  "shield",
  "shift",
  "shine",
  "shiny",
  "ship",
  "shire",
  "shirk",
  "shirt",
  "shiver",
  "shock",
  "shoe",
  "shook",
  "shoot",
  "shop",
  "shore",
  "short",
  "shot",
  "should",
  "shout",
  "show",
  "shower",
  "shrank",
  "shrewd",
  "shrill",
  "shrimp",
  "shrine",
  "shrink",
  "shrub",
  "shrug",
  "shut",
  "shy",
  "shyly",
  "sick",
  "side",
  "siege",
  "sigh",
  "sight",
  "sigma",
  "sign",
  "signal",
  "silent",
  "silk",
  "silken",
  "silky",
  "sill",
  "silly",
  "silo",
  "silver",
  "simple",
  "simply",
  "since",
  "sinful",
  "sing",
  "singer",
  "single",
  "sink",
  "sir",
  "sire",
  "siren",
  "sister",
  "sit",
  "site",
  "sitter",
  "six",
  "sixth",
  "sixty",
  "size",
  "sketch",
  "skill",
  "skin",
  "skinny",
  "skip",
  "skirt",
  "skull",
  "sky",
  "slab",
  "slack",
  "slain",
  "slam",
  "slang",
  "slap",
  "slat",
  "slate",
  "slave",
  "sleek",
  "sleep",
  "sleepy",
  "sleeve",
  "slice",
  "slick",
  "slid",
  "slide",
  "slight",
  "slim",
  "slimy",
  "sling",
  "slip",
  "slit",
  "slogan",
  "slope",
  "sloppy",
  "slot",
  "slow",
  "slowly",
  "slug",
  "slum",
  "slump",
  "smack",
  "small",
  "smart",
  "smash",
  "smear",
  "smell",
  "smelly",
  "smelt",
  "smile",
  "smite",
  "smoke",
  "smoky",
  "smooth",
  "smug",
  "snack",
  "snail",
  "snake",
  "snap",
  "snatch",
  "sneak",
  "snow",
  "snowy",
  "snug",
  "soak",
  "soap",
  "sober",
  "soccer",
  "social",
  "sock",
  "socket",
  "socks",
  "soda",
  "sodden",
  "sodium",
  "sofa",
  "soft",
  "soften",
  "softly",
  "soggy",
  "soil",
  "solar",
  "sold",
  "sole",
  "solely",
  "solemn",
  "solid",
  "solo",
  "solve",
  "some",
  "son",
  "sonar",
  "sonata",
  "song",
  "sonic",
  "sony",
  "soon",
  "sooner",
  "soot",
  "soothe",
  "sordid",
  "sore",
  "sorrow",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "sour",
  "source",
  "soviet",
  "sow",
  "space",
  "spade",
  "spain",
  "span",
  "spare",
  "spark",
  "sparse",
  "spasm",
  "spat",
  "spate",
  "speak",
  "spear",
  "speech",
  "speed",
  "speedy",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spicy",
  "spider",
  "spiky",
  "spill",
  "spin",
  "spinal",
  "spine",
  "spiral",
  "spirit",
  "spit",
  "spite",
  "splash",
  "split",
  "spoil",
  "spoke",
  "sponge",
  "spoon",
  "sport",
  "spot",
  "spouse",
  "spray",
  "spread",
  "spree",
  "spring",
  "sprint",
  "spur",
  "squad",
  "square",
  "squash",
  "squat",
  "squid",
  "stab",
  "stable",
  "stack",
  "staff",
  "stage",
  "stain",
  "stair",
  "stairs",
  "stake",
  "stale",
  "stall",
  "stamp",
  "stance",
  "stand",
  "staple",
  "star",
  "starch",
  "stare",
  "stark",
  "start",
  "starve",
  "state",
  "static",
  "statue",
  "status",
  "stay",
  "stead",
  "steady",
  "steak",
  "steal",
  "steam",
  "steel",
  "steep",
  "steer",
  "stem",
  "stench",
  "step",
  "stereo",
  "stern",
  "stew",
  "stick",
  "sticky",
  "stiff",
  "stifle",
  "stigma",
  "still",
  "sting",
  "stint",
  "stir",
  "stitch",
  "stock",
  "stocky",
  "stone",
  "stony",
  "stool",
  "stop",
  "store",
  "storm",
  "stormy",
  "story",
  "stout",
  "stove",
  "stow",
  "strain",
  "strait",
  "strand",
  "strap",
  "strata",
  "straw",
  "stray",
  "streak",
  "stream",
  "street",
  "stress",
  "strict",
  "stride",
  "strife",
  "strike",
  "string",
  "strip",
  "stripe",
  "strive",
  "stroke",
  "stroll",
  "strong",
  "stud",
  "studio",
  "study",
  "stuff",
  "stuffy",
  "stunt",
  "stupid",
  "sturdy",
  "style",
  "submit",
  "subtle",
  "subtly",
  "suburb",
  "such",
  "sudden",
  "sue",
  "suez",
  "suffer",
  "sugar",
  "suit",
  "suite",
  "suitor",
  "sullen",
  "sultan",
  "sum",
  "summer",
  "summit",
  "summon",
  "sun",
  "sunday",
  "sunny",
  "sunset",
  "super",
  "superb",
  "supper",
  "supple",
  "supply",
  "sure",
  "surely",
  "surf",
  "surge",
  "survey",
  "suture",
  "swamp",
  "swan",
  "swap",
  "swarm",
  "sway",
  "swear",
  "sweat",
  "sweaty",
  "sweden",
  "sweep",
  "sweet",
  "swell",
  "swift",
  "swim",
  "swine",
  "swing",
  "swirl",
  "swiss",
  "switch",
  "sword",
  "swore",
  "sydney",
  "symbol",
  "synod",
  "syntax",
  "syria",
  "syrup",
  "system",
  "table",
  "tablet",
  "taboo",
  "tacit",
  "tackle",
  "tact",
  "tactic",
  "tail",
  "tailor",
  "taiwan",
  "take",
  "tale",
  "talent",
  "talk",
  "tall",
  "tally",
  "tame",
  "tampa",
  "tan",
  "tandem",
  "tangle",
  "tank",
  "tap",
  "tape",
  "target",
  "tariff",
  "tarp",
  "tart",
  "tarzan",
  "task",
  "taste",
  "tasty",
  "tattoo",
  "taurus",
  "taut",
  "tavern",
  "tax",
  "taxi",
  "tea",
  "teach",
  "teak",
  "team",
  "tear",
  "tease",
  "tech",
  "teeth",
  "tell",
  "temper",
  "temple",
  "tempo",
  "tempt",
  "ten",
  "tenant",
  "tend",
  "tender",
  "tendon",
  "tennis",
  "tenor",
  "tense",
  "tent",
  "tenth",
  "tenure",
  "teresa",
  "term",
  "terror",
  "terse",
  "test",
  "texas",
  "text",
  "thank",
  "thaw",
  "them",
  "theme",
  "thence",
  "theory",
  "there",
  "these",
  "thesis",
  "they",
  "thick",
  "thief",
  "thigh",
  "thin",
  "thing",
  "think",
  "third",
  "thirst",
  "thirty",
  "this",
  "thomas",
  "thorn",
  "those",
  "though",
  "thread",
  "threat",
  "three",
  "thrill",
  "thrive",
  "throat",
  "throne",
  "throng",
  "throw",
  "thrust",
  "thud",
  "thug",
  "thumb",
  "thus",
  "thyme",
  "tibet",
  "tick",
  "ticket",
  "tidal",
  "tide",
  "tidy",
  "tie",
  "tier",
  "tiger",
  "tight",
  "tile",
  "till",
  "tilt",
  "timber",
  "time",
  "timid",
  "tin",
  "tiny",
  "tip",
  "tire",
  "tissue",
  "title",
  "toad",
  "toast",
  "today",
  "toe",
  "toilet",
  "token",
  "tokyo",
  "told",
  "toll",
  "tom",
  "tomato",
  "tomb",
  "tonal",
  "tone",
  "tongue",
  "tonic",
  "too",
  "took",
  "tool",
  "tooth",
  "top",
  "topaz",
  "topic",
  "torch",
  "torque",
  "torso",
  "tort",
  "toss",
  "total",
  "touch",
  "tough",
  "tour",
  "toward",
  "towel",
  "tower",
  "town",
  "toxic",
  "toxin",
  "toy",
  "trace",
  "track",
  "tract",
  "trade",
  "tragic",
  "trail",
  "train",
  "trait",
  "tram",
  "trance",
  "trap",
  "trauma",
  "travel",
  "tray",
  "tread",
  "treat",
  "treaty",
  "treble",
  "tree",
  "trek",
  "tremor",
  "trench",
  "trend",
  "trendy",
  "trial",
  "tribal",
  "tribe",
  "trick",
  "tricky",
  "tried",
  "trifle",
  "trim",
  "trio",
  "trip",
  "triple",
  "troop",
  "trophy",
  "trot",
  "trough",
  "trout",
  "truce",
  "truck",
  "true",
  "truly",
  "trunk",
  "trust",
  "truth",
  "try",
  "tube",
  "tumble",
  "tuna",
  "tundra",
  "tune",
  "tunic",
  "tunnel",
  "turban",
  "turf",
  "turk",
  "turkey",
  "turn",
  "turtle",
  "tutor",
  "tweed",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "tycoon",
  "tying",
  "type",
  "tyrant",
  "ugly",
  "ulcer",
  "ultra",
  "umpire",
  "unable",
  "uncle",
  "under",
  "uneasy",
  "unfair",
  "unify",
  "union",
  "unique",
  "unit",
  "unite",
  "unity",
  "unlike",
  "unrest",
  "unruly",
  "until",
  "update",
  "upheld",
  "uphill",
  "uphold",
  "upon",
  "upper",
  "uproar",
  "upset",
  "upshot",
  "uptake",
  "upturn",
  "upward",
  "urban",
  "urge",
  "urgent",
  "urging",
  "urine",
  "usable",
  "usage",
  "use",
  "useful",
  "user",
  "usual",
  "utmost",
  "utter",
  "vacant",
  "vacuum",
  "vague",
  "vain",
  "valet",
  "valid",
  "valley",
  "value",
  "valve",
  "van",
  "vanish",
  "vanity",
  "vary",
  "vase",
  "vast",
  "vat",
  "vault",
  "vector",
  "veil",
  "vein",
  "velvet",
  "vendor",
  "veneer",
  "venice",
  "venom",
  "vent",
  "venue",
  "venus",
  "verb",
  "verbal",
  "verge",
  "verify",
  "verity",
  "verse",
  "versus",
  "very",
  "vessel",
  "vest",
  "vet",
  "veto",
  "via",
  "viable",
  "vicar",
  "vice",
  "victim",
  "victor",
  "video",
  "vienna",
  "view",
  "vigil",
  "viking",
  "vile",
  "villa",
  "vine",
  "vinyl",
  "viola",
  "violet",
  "violin",
  "viral",
  "virgo",
  "virtue",
  "virus",
  "visa",
  "vision",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "vodka",
  "vogue",
  "voice",
  "void",
  "volley",
  "volume",
  "vote",
  "vowel",
  "voyage",
  "vulgar",
  "wade",
  "wage",
  "waist",
  "wait",
  "waiter",
  "wake",
  "walk",
  "walker",
  "wall",
  "wallet",
  "walnut",
  "wander",
  "want",
  "war",
  "warden",
  "warm",
  "warmth",
  "warn",
  "warp",
  "warsaw",
  "wary",
  "was",
  "wash",
  "wasp",
  "waste",
  "watch",
  "water",
  "watery",
  "wave",
  "wax",
  "way",
  "weak",
  "weaken",
  "wealth",
  "weapon",
  "wear",
  "weary",
  "weave",
  "wedge",
  "wee",
  "weed",
  "week",
  "weekly",
  "weep",
  "weigh",
  "weight",
  "weird",
  "well",
  "were",
  "west",
  "wet",
  "whale",
  "wharf",
  "what",
  "wheat",
  "wheel",
  "when",
  "whence",
  "where",
  "which",
  "whiff",
  "while",
  "whim",
  "whip",
  "whisky",
  "white",
  "who",
  "whole",
  "wholly",
  "whom",
  "whose",
  "why",
  "wicked",
  "wide",
  "widely",
  "widen",
  "wider",
  "widow",
  "width",
  "wife",
  "wig",
  "wild",
  "wildly",
  "will",
  "willow",
  "wily",
  "win",
  "wind",
  "window",
  "windy",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wipe",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "wit",
  "witch",
  "with",
  "within",
  "witty",
  "wizard",
  "woke",
  "wolf",
  "wolves",
  "woman",
  "womb",
  "won",
  "wonder",
  "wood",
  "wooden",
  "woods",
  "woody",
  "wool",
  "word",
  "work",
  "worker",
  "world",
  "worm",
  "worry",
  "worse",
  "worst",
  "worth",
  "worthy",
  "would",
  "wound",
  "wrap",
  "wrath",
  "wreath",
  "wreck",
  "wring",
  "wrist",
  "writ",
  "write",
  "writer",
  "wrong",
  "xerox",
  "yacht",
  "yale",
  "yard",
  "yarn",
  "yeah",
  "year",
  "yeard",
  "yeast",
  "yellow",
  "yet",
  "yield",
  "yogurt",
  "yolk",
  "you",
  "young",
  "your",
  "youth",
  "zaire",
  "zeal",
  "zebra",
  "zenith",
  "zero",
  "zeus",
  "zigzag",
  "zinc",
  "zombie",
  "zone"
];

// node_modules/@hashgraph/cryptography/src/words/bip39.js
var bip39_default = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// node_modules/@hashgraph/cryptography/src/Mnemonic.js
var import_tweetnacl4 = __toESM(require_nacl_fast(), 1);

// node_modules/@hashgraph/cryptography/src/primitive/sha256.browser.js
async function digest(data) {
  return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
}

// node_modules/@hashgraph/cryptography/src/primitive/bip39.js
async function toSeed(words, passphrase) {
  const input = words.join(" ");
  const salt = `mnemonic${passphrase}`.normalize("NFKD");
  return deriveKey(HashAlgorithm.Sha512, input, salt, 2048, 64);
}

// node_modules/@hashgraph/cryptography/src/util/entropy.js
function legacy1(words, wordlist) {
  const indicies = words.map((word) => wordlist.indexOf(word.toLowerCase()));
  const data = convertRadix(indicies, wordlist.length, 256, 33);
  const checksum = data[data.length - 1];
  const result = new Uint8Array(data.length - 1);
  for (let i = 0; i < data.length - 1; i += 1) {
    result[i] = data[i] ^ checksum;
  }
  return [result, checksum];
}
async function legacy2(words, wordlist) {
  const concatBitsLen = words.length * 11;
  const concatBits = [];
  concatBits.fill(false, 0, concatBitsLen);
  for (const [wordIndex, word] of words.entries()) {
    const index = wordlist.indexOf(word.toLowerCase());
    if (index < 0) {
      throw new Error(`Word not found in wordlist: ${word}`);
    }
    for (let i = 0; i < 11; i += 1) {
      concatBits[wordIndex * 11 + i] = (index & 1 << 10 - i) !== 0;
    }
  }
  const checksumBitsLen = concatBitsLen / 33;
  const entropyBitsLen = concatBitsLen - checksumBitsLen;
  const entropy = new Uint8Array(entropyBitsLen / 8);
  for (let i = 0; i < entropy.length; i += 1) {
    for (let j = 0; j < 8; j += 1) {
      if (concatBits[i * 8 + j]) {
        entropy[i] |= 1 << 7 - j;
      }
    }
  }
  const hash2 = await digest(entropy);
  const hashBits = bytesToBits(hash2);
  for (let i = 0; i < checksumBitsLen; i += 1) {
    if (concatBits[entropyBitsLen + i] !== hashBits[i]) {
      throw new Error("Checksum mismatch");
    }
  }
  return entropy;
}
function crc8(data) {
  let crc = 255;
  for (let i = 0; i < data.length - 1; i += 1) {
    crc ^= data[i];
    for (let j = 0; j < 8; j += 1) {
      crc = crc >>> 1 ^ ((crc & 1) === 0 ? 0 : 178);
    }
  }
  return crc ^ 255;
}
function convertRadix(nums, fromRadix, toRadix, toLength) {
  let num = new bignumber_default(0);
  for (const element of nums) {
    num = num.times(fromRadix);
    num = num.plus(element);
  }
  const result = new Uint8Array(toLength);
  for (let i = toLength - 1; i >= 0; i -= 1) {
    const tem = num.dividedToIntegerBy(toRadix);
    const rem = num.modulo(toRadix);
    num = tem;
    result[i] = rem.toNumber();
  }
  return result;
}
function bytesToBits(data) {
  const bits = [];
  bits.fill(false, 0, data.length * 8);
  for (let i = 0; i < data.length; i += 1) {
    for (let j = 0; j < 8; j += 1) {
      bits[i * 8 + j] = (data[i] & 1 << 7 - j) !== 0;
    }
  }
  return bits;
}

// node_modules/@hashgraph/cryptography/src/Mnemonic.js
var ED25519_SEED_TEXT = "ed25519 seed";
var ECDSA_SEED_TEXT = "Bitcoin seed";
var HARDENED = 2147483648;
var HEDERA_PATH = [44, 3030, 0, 0];
var SLIP44_ECDSA_HEDERA_PATH = [
  44 | HARDENED,
  3030 | HARDENED,
  0 | HARDENED,
  0
];
var SLIP44_ECDSA_ETH_PATH = [
  44 | HARDENED,
  60 | HARDENED,
  0 | HARDENED,
  0,
  0
];
var Mnemonic = class _Mnemonic {
  /**
   * @param {object} props
   * @param {string[]} props.words
   * @throws {BadMnemonicError}
   * @hideconstructor
   * @private
   */
  constructor({ words }) {
    this.words = words;
  }
  /**
   * Returns a new random 24-word mnemonic from the BIP-39
   * standard English word list.
   * @returns {Promise<Mnemonic>}
   */
  static generate() {
    return _Mnemonic._generate(24);
  }
  /**
   * Returns a new random 12-word mnemonic from the BIP-39
   * standard English word list.
   * @returns {Promise<Mnemonic>}
   */
  static generate12() {
    return _Mnemonic._generate(12);
  }
  /**
   * @param {number} length
   * @returns {Promise<Mnemonic>}
   */
  static async _generate(length) {
    let neededEntropy;
    if (length === 12)
      neededEntropy = 16;
    else if (length === 24)
      neededEntropy = 32;
    else {
      throw new Error(
        `unsupported phrase length ${length}, only 12 or 24 are supported`
      );
    }
    const seed = await bytesAsync(neededEntropy);
    const entropyBits = bytesToBinary(Array.from(seed));
    const checksumBits = await deriveChecksumBits(seed);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = (chunks != null ? chunks : []).map(
      (binary) => bip39_default[binaryToByte(binary)]
    );
    return new _Mnemonic({ words });
  }
  /**
   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
   *
   * An exception of BadMnemonicError will be thrown if the mnemonic
   * contains unknown words or fails the checksum. An invalid mnemonic
   * can still be used to create private keys, the exception will
   * contain the failing mnemonic in case you wish to ignore the
   * validation error and continue.
   * @param {string[]} words
   * @throws {BadMnemonicError}
   * @returns {Promise<Mnemonic>}
   */
  static fromWords(words) {
    return new _Mnemonic({
      words
    })._validate();
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover a private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  toPrivateKey(passphrase = "") {
    return this.toEd25519PrivateKey(passphrase);
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover an Ed25519 private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number[]} [path]
   * @returns {Promise<PrivateKey>}
   */
  async toEd25519PrivateKey(passphrase = "", path = HEDERA_PATH) {
    let { keyData, chainCode } = await this._toKeyData(
      passphrase,
      ED25519_SEED_TEXT
    );
    for (const index of path) {
      ({ keyData, chainCode } = await derive2(
        keyData,
        chainCode,
        index
      ));
    }
    const keyPair = import_tweetnacl4.default.sign.keyPair.fromSeed(keyData);
    if (Cache_default.privateKeyConstructor == null) {
      throw new Error("PrivateKey not found in cache");
    }
    return Cache_default.privateKeyConstructor(
      new Ed25519PrivateKey(keyPair, chainCode)
    );
  }
  /**
   * Recover an Ed25519 private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number} [index]
   * @returns {Promise<PrivateKey>}
   */
  async toStandardEd25519PrivateKey(passphrase = "", index) {
    const seed = await _Mnemonic.toSeed(this.words, passphrase);
    let derivedKey = await PrivateKey.fromSeedED25519(seed);
    index = index == null ? 0 : index;
    for (const currentIndex of [44, 3030, 0, 0, index]) {
      derivedKey = await derivedKey.derive(currentIndex);
    }
    return derivedKey;
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover an ECDSA private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number[]} [path]
   * @returns {Promise<PrivateKey>}
   */
  async toEcdsaPrivateKey(passphrase = "", path = HEDERA_PATH) {
    let { keyData, chainCode } = await this._toKeyData(
      passphrase,
      ECDSA_SEED_TEXT
    );
    for (const index of path) {
      ({ keyData, chainCode } = await derive(
        keyData,
        chainCode,
        index
      ));
    }
    if (Cache_default.privateKeyConstructor == null) {
      throw new Error("PrivateKey not found in cache");
    }
    return Cache_default.privateKeyConstructor(
      new EcdsaPrivateKey(fromBytes(keyData), chainCode)
    );
  }
  /**
   * Recover an ECDSA private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number} [index]
   * @returns {Promise<PrivateKey>}
   */
  async toStandardECDSAsecp256k1PrivateKey(passphrase = "", index) {
    const seed = await _Mnemonic.toSeed(this.words, passphrase);
    let derivedKey = await PrivateKey.fromSeedECDSAsecp256k1(seed);
    index = index == null ? 0 : index;
    for (const currentIndex of [
      toHardenedIndex(44),
      toHardenedIndex(3030),
      toHardenedIndex(0),
      0,
      index
    ]) {
      derivedKey = await derivedKey.derive(currentIndex);
    }
    return derivedKey;
  }
  /**
   * @param {string[]} words
   * @param {string} passphrase
   * @returns {Promise<Uint8Array>}
   */
  static async toSeed(words, passphrase) {
    return await toSeed(words, passphrase);
  }
  /**
   * @param {string} passphrase
   * @param {string} seedText
   * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>} seedText
   */
  async _toKeyData(passphrase, seedText) {
    const seed = await toSeed(this.words, passphrase);
    const digest3 = await hash(
      HashAlgorithm.Sha512,
      seedText,
      seed
    );
    return {
      keyData: digest3.subarray(0, 32),
      chainCode: digest3.subarray(32)
    };
  }
  /**
   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
   * @param {string} mnemonic
   * @returns {Promise<Mnemonic>}
   */
  static async fromString(mnemonic) {
    return _Mnemonic.fromWords(mnemonic.split(/\s|,/));
  }
  /**
   * @returns {Promise<Mnemonic>}
   * @private
   */
  async _validate() {
    if (this.words.length === 22) {
      const unknownWordIndices = this.words.reduce(
        (unknowns, word, index) => legacy_default.includes(word.toLowerCase()) ? unknowns : [...unknowns, index],
        []
      );
      if (unknownWordIndices.length > 0) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.UnknownWords,
          unknownWordIndices
        );
      }
      const [seed, checksum] = legacy1(this.words, legacy_default);
      const newChecksum = crc8(seed);
      if (checksum !== newChecksum) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.ChecksumMismatch,
          []
        );
      }
    } else {
      if (!(this.words.length === 12 || this.words.length === 24)) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.BadLength,
          []
        );
      }
      const unknownWordIndices = this.words.reduce(
        (unknowns, word, index) => bip39_default.includes(word) ? unknowns : [...unknowns, index],
        []
      );
      if (unknownWordIndices.length > 0) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.UnknownWords,
          unknownWordIndices
        );
      }
      const bits = this.words.map((word) => {
        return bip39_default.indexOf(word).toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);
      const entropyBytes = (
        /** @type {RegExpMatchArray} */
        entropyBitsRegex.map(binaryToByte)
      );
      const newChecksum = await deriveChecksumBits(
        Uint8Array.from(entropyBytes)
      );
      if (newChecksum !== checksumBits) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.ChecksumMismatch,
          []
        );
      }
    }
    return this;
  }
  /**
   * @returns {Promise<PrivateKey>}
   */
  async toLegacyPrivateKey() {
    let seed;
    if (this.words.length === 22) {
      [seed] = legacy1(this.words, legacy_default);
    } else {
      seed = await legacy2(this.words, bip39_default);
    }
    if (Cache_default.privateKeyFromBytes == null) {
      throw new Error("PrivateKey not found in cache");
    }
    return Cache_default.privateKeyFromBytes(seed);
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.words.join(" ");
  }
};
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes3) {
  return bytes3.map((x) => x.toString(2).padStart(8, "0")).join("");
}
async function deriveChecksumBits(entropyBuffer) {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash2 = await digest(entropyBuffer);
  return bytesToBinary(Array.from(hash2)).slice(0, CS);
}

// node_modules/@hashgraph/sdk/src/array.js
function arrayEqual3(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.byteLength !== array2.byteLength) {
    return false;
  }
  const view1 = new DataView(
    array1.buffer,
    array1.byteOffset,
    array1.byteLength
  );
  const view2 = new DataView(
    array2.buffer,
    array2.byteOffset,
    array2.byteLength
  );
  let i = array1.byteLength;
  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }
  return true;
}

// node_modules/@hashgraph/sdk/src/Cache.js
var Cache = class {
  constructor() {
    this._timeDrift = 0;
    this._contractId = null;
    this._keyList = null;
    this._thresholdKey = null;
    this._publicKeyED25519 = null;
    this._publicKeyECDSA = null;
    this._privateKeyConstructor = null;
    this._mnemonicFromString = null;
    this._accountIdConstructor = null;
    this._delegateContractId = null;
    this._evmAddress = null;
    this._ethereumTransactionDataLegacyFromBytes = null;
    this._ethereumTransactionDataEip1559FromBytes = null;
    this._ethereumTransactionDataEip2930FromBytes = null;
    this._transactionReceiptQueryConstructor = null;
    this._transactionRecordQueryConstructor = null;
  }
  /**
   * @param {number} timeDrift
   */
  setTimeDrift(timeDrift) {
    this._timeDrift = timeDrift;
  }
  /**
   * @returns {number}
   */
  get timeDrift() {
    if (this._timeDrift == null) {
      throw new Error("Cache.timeDrift was used before it was set");
    }
    return this._timeDrift;
  }
  /**
   * @param {FromProtobufKeyFuncT<HashgraphProto.proto.IContractID, ContractId>} contractId
   */
  setContractId(contractId) {
    this._contractId = contractId;
  }
  /**
   * @returns {FromProtobufKeyFuncT<HashgraphProto.proto.IContractID, ContractId>}
   */
  get contractId() {
    if (this._contractId == null) {
      throw new Error("Cache.contractId was used before it was set");
    }
    return this._contractId;
  }
  /**
   * @param {FromProtobufKeyFuncT<HashgraphProto.proto.IKeyList, KeyList>} keyList
   */
  setKeyList(keyList) {
    this._keyList = keyList;
  }
  /**
   * @returns {FromProtobufKeyFuncT<HashgraphProto.proto.IKeyList, KeyList>}
   */
  get keyList() {
    if (this._keyList == null) {
      throw new Error("Cache.keyList was used before it was set");
    }
    return this._keyList;
  }
  /**
   * @param {FromProtobufKeyFuncT<HashgraphProto.proto.IThresholdKey, KeyList>} thresholdKey
   */
  setThresholdKey(thresholdKey) {
    this._thresholdKey = thresholdKey;
  }
  /**
   * @returns {FromProtobufKeyFuncT<HashgraphProto.proto.IThresholdKey, KeyList>}
   */
  get thresholdKey() {
    if (this._thresholdKey == null) {
      throw new Error("Cache.thresholdKey was used before it was set");
    }
    return this._thresholdKey;
  }
  /**
   * @param {FromProtobufKeyFuncT<Uint8Array, PublicKey>} publicKeyED25519
   */
  setPublicKeyED25519(publicKeyED25519) {
    this._publicKeyED25519 = publicKeyED25519;
  }
  /**
   * @returns {FromProtobufKeyFuncT<Uint8Array, PublicKey>}
   */
  get publicKeyED25519() {
    if (this._publicKeyED25519 == null) {
      throw new Error(
        "Cache.publicKeyED25519 was used before it was set"
      );
    }
    return this._publicKeyED25519;
  }
  /**
   * @param {FromProtobufKeyFuncT<Uint8Array, PublicKey>} publicKeyECDSA
   */
  setPublicKeyECDSA(publicKeyECDSA) {
    this._publicKeyECDSA = publicKeyECDSA;
  }
  /**
   * @returns {FromProtobufKeyFuncT<Uint8Array, PublicKey>}
   */
  get publicKeyECDSA() {
    if (this._publicKeyECDSA == null) {
      throw new Error("Cache.publicKeyECDSA was used before it was set");
    }
    return this._publicKeyECDSA;
  }
  /**
   * @param {((key: cryptography.PrivateKey) => PrivateKey)} privateKeyConstructor
   */
  setPrivateKeyConstructor(privateKeyConstructor) {
    this._privateKeyConstructor = privateKeyConstructor;
  }
  /**
   * @returns {((key: cryptography.PrivateKey) => PrivateKey)}
   */
  get privateKeyConstructor() {
    if (this._privateKeyConstructor == null) {
      throw new Error(
        "Cache.privateKeyConstructor was used before it was set"
      );
    }
    return this._privateKeyConstructor;
  }
  /**
   * @param {((key: cryptography.Mnemonic) => Mnemonic)} mnemonicFromString
   */
  setMnemonicFromString(mnemonicFromString) {
    this._mnemonicFromString = mnemonicFromString;
  }
  /**
   * @returns {((key: cryptography.PrivateKey) => PrivateKey)}
   */
  get mnemonicFromString() {
    if (this._mnemonicFromString == null) {
      throw new Error(
        "Cache.mnemonicFromString was used before it was set"
      );
    }
    return this.mnemonicFromString;
  }
  /**
   * @param {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId)} accountIdConstructor
   */
  setAccountIdConstructor(accountIdConstructor) {
    this._accountIdConstructor = accountIdConstructor;
  }
  /**
   * @returns {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId)}
   */
  get accountIdConstructor() {
    if (this._accountIdConstructor == null) {
      throw new Error(
        "Cache.accountIdConstructor was used before it was set"
      );
    }
    return this._accountIdConstructor;
  }
  /**
   * @param {FromProtobufKeyFuncT<HashgraphProto.proto.IContractID, ContractId>} delegateContractId
   */
  setDelegateContractId(delegateContractId) {
    this._delegateContractId = delegateContractId;
  }
  /**
   * @returns {FromProtobufKeyFuncT<HashgraphProto.proto.IContractID, ContractId>}
   */
  get delegateContractId() {
    if (this._delegateContractId == null) {
      throw new Error(
        "Cache.delegateContractId was used before it was set"
      );
    }
    return this._delegateContractId;
  }
  /**
   * @param {FromProtobufKeyFuncT<Uint8Array, EvmAddress>} evmAddress
   */
  setEvmAddress(evmAddress) {
    this._evmAddress = evmAddress;
  }
  /**
   * @returns {FromProtobufKeyFuncT<Uint8Array, EvmAddress>}
   */
  get evmAddress() {
    if (this._evmAddress == null) {
      throw new Error("Cache.evmAddress was used before it was set");
    }
    return this._evmAddress;
  }
  /**
   * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataLegacyFromBytes
   */
  setEthereumTransactionDataLegacyFromBytes(ethereumTransactionDataLegacyFromBytes) {
    this._ethereumTransactionDataLegacyFromBytes = ethereumTransactionDataLegacyFromBytes;
  }
  /**
   * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
   */
  get ethereumTransactionDataLegacyFromBytes() {
    if (this._ethereumTransactionDataLegacyFromBytes == null) {
      throw new Error(
        "Cache.ethereumTransactionDataLegacyFromBytes was used before it was set"
      );
    }
    return this._ethereumTransactionDataLegacyFromBytes;
  }
  /**
   * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataEip1559FromBytes
   */
  setEthereumTransactionDataEip1559FromBytes(ethereumTransactionDataEip1559FromBytes) {
    this._ethereumTransactionDataEip1559FromBytes = ethereumTransactionDataEip1559FromBytes;
  }
  /**
   * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
   */
  get ethereumTransactionDataEip1559FromBytes() {
    if (this._ethereumTransactionDataEip1559FromBytes == null) {
      throw new Error(
        "Cache.ethereumTransactionDataEip1559FromBytes was used before it was set"
      );
    }
    return this._ethereumTransactionDataEip1559FromBytes;
  }
  /**
   * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataEip2930FromBytes
   */
  setEthereumTransactionDataEip2930FromBytes(ethereumTransactionDataEip2930FromBytes) {
    this._ethereumTransactionDataEip2930FromBytes = ethereumTransactionDataEip2930FromBytes;
  }
  /**
   * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
   */
  get ethereumTransactionDataEip2930FromBytes() {
    if (this._ethereumTransactionDataEip2930FromBytes == null) {
      throw new Error(
        "Cache.ethereumTransactionDataEip2930FromBytes was used before it was set"
      );
    }
    return this._ethereumTransactionDataEip2930FromBytes;
  }
  /**
   * @param {(() => TransactionReceiptQuery)} transactionReceiptQueryConstructor
   */
  setTransactionReceiptQueryConstructor(transactionReceiptQueryConstructor) {
    this._transactionReceiptQueryConstructor = transactionReceiptQueryConstructor;
  }
  /**
   * @returns {(() => TransactionReceiptQuery)}
   */
  get transactionReceiptQueryConstructor() {
    if (this._transactionReceiptQueryConstructor == null) {
      throw new Error(
        "Cache.transactionReceiptQueryConstructor was used before it was set"
      );
    }
    return this._transactionReceiptQueryConstructor;
  }
  /**
   * @param {(() => TransactionRecordQuery)} transactionRecordQueryConstructor
   */
  setTransactionRecordQueryConstructor(transactionRecordQueryConstructor) {
    this._transactionRecordQueryConstructor = transactionRecordQueryConstructor;
  }
  /**
   * @returns {(() => TransactionRecordQuery)}
   */
  get transactionRecordQueryConstructor() {
    if (this._transactionRecordQueryConstructor == null) {
      throw new Error(
        "Cache.transactionRecordQueryConstructor was used before it was set"
      );
    }
    return this._transactionRecordQueryConstructor;
  }
  /**
   * @param {() => AddressBookQuery} addressBookQueryConstructor
   */
  setAddressBookQueryConstructor(addressBookQueryConstructor) {
    this._addressBookQueryConstructor = addressBookQueryConstructor;
  }
  /**
   * @returns {() => AddressBookQuery}
   */
  get addressBookQueryConstructor() {
    if (this._addressBookQueryConstructor == null) {
      throw new Error(
        "Cache.addressBookQueryConstructor was used before it was set"
      );
    }
    return this._addressBookQueryConstructor;
  }
};
var CACHE2 = new Cache();
var Cache_default2 = CACHE2;

// node_modules/@hashgraph/sdk/src/Key.js
var Key2 = class {
  /**
   * @internal
   * @abstract
   * @returns {HashgraphProto.proto.IKey}
   */
  // eslint-disable-next-line jsdoc/require-returns-check
  _toProtobufKey() {
    throw new Error("not implemented");
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IKey} key
   * @returns {Key}
   */
  static _fromProtobufKey(key) {
    if (key.contractID != null) {
      return Cache_default2.contractId(key.contractID);
    }
    if (key.delegatableContractId != null) {
      return Cache_default2.delegateContractId(key.delegatableContractId);
    }
    if (key.ed25519 != null && key.ed25519.byteLength > 0) {
      return Cache_default2.publicKeyED25519(key.ed25519);
    }
    if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
      return Cache_default2.publicKeyECDSA(key.ECDSASecp256k1);
    }
    if (key.thresholdKey != null && key.thresholdKey.threshold != null) {
      return Cache_default2.thresholdKey(key.thresholdKey);
    }
    if (key.keyList != null) {
      return Cache_default2.keyList(key.keyList);
    }
    return null;
  }
};

// node_modules/@hashgraph/sdk/src/PublicKey.js
var PublicKey2 = class _PublicKey extends Key2 {
  /**
   * @internal
   * @hideconstructor
   * @param {cryptography.PublicKey} key
   */
  constructor(key) {
    super();
    this._key = key;
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytes(data) {
    return new _PublicKey(PublicKey.fromBytes(data));
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytesED25519(data) {
    return new _PublicKey(PublicKey.fromBytesED25519(data));
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytesECDSA(data) {
    return new _PublicKey(PublicKey.fromBytesECDSA(data));
  }
  /**
   * Parse a public key from a string of hexadecimal digits.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   *
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromString(text) {
    return new _PublicKey(PublicKey.fromString(text));
  }
  /**
   * Parse an ECDSA public key from a string of hexadecimal digits.
   *
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromStringECDSA(text) {
    return new _PublicKey(PublicKey.fromStringECDSA(text));
  }
  /**
   * Parse an ED25519 public key from a string of hexadecimal digits.
   *
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromStringED25519(text) {
    return new _PublicKey(PublicKey.fromStringED25519(text));
  }
  /**
   * Verify a signature on a message with this public key.
   *
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  verify(message, signature) {
    return this._key.verify(message, signature);
  }
  /**
   * @param {Transaction} transaction
   * @returns {boolean}
   */
  verifyTransaction(transaction) {
    transaction._requireFrozen();
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    for (const signedTransaction of transaction._signedTransactions.list) {
      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        let found = false;
        for (const sigPair of signedTransaction.sigMap.sigPair) {
          const pubKeyPrefix = (
            /** @type {Uint8Array} */
            sigPair.pubKeyPrefix
          );
          if (arrayEqual3(pubKeyPrefix, this.toBytesRaw())) {
            found = true;
            const bodyBytes = (
              /** @type {Uint8Array} */
              signedTransaction.bodyBytes
            );
            let signature = null;
            if (sigPair.ed25519 != null) {
              signature = sigPair.ed25519;
            } else if (sigPair.ECDSASecp256k1 != null) {
              signature = sigPair.ECDSASecp256k1;
            }
            if (signature == null) {
              continue;
            }
            if (!this.verify(bodyBytes, signature)) {
              return false;
            }
          }
        }
        if (!found) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return this._key.toBytes();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    return this._key.toBytesDer();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  /**
   * @deprecated Use `toEvmAddress()` instead.
   * @returns {string}
   */
  toEthereumAddress() {
    return this._key.toEthereumAddress();
  }
  /**
   * @returns {string}
   */
  toEvmAddress() {
    return this._key.toEthereumAddress();
  }
  /**
   * @returns {string}
   */
  toString() {
    return this._key.toString();
  }
  /**
   * @returns {string}
   */
  toStringDer() {
    return this._key.toStringDer();
  }
  /**
   * @returns {string}
   */
  toStringRaw() {
    return this._key.toStringRaw();
  }
  /**
   * @param {PublicKey} other
   * @returns {boolean}
   */
  equals(other) {
    return this._key.equals(other._key);
  }
  /**
   * @returns {HashgraphProto.proto.IKey}
   */
  _toProtobufKey() {
    switch (this._key._type) {
      case "ED25519":
        return {
          ed25519: this._key.toBytesRaw()
        };
      case "secp256k1":
        return {
          ECDSASecp256k1: this._key.toBytesRaw()
        };
      default:
        throw new Error(`unrecognized key type ${this._key._type}`);
    }
  }
  /**
   * @param {Uint8Array} signature
   * @returns {HashgraphProto.proto.ISignaturePair}
   */
  _toProtobufSignature(signature) {
    switch (this._key._type) {
      case "ED25519":
        return {
          pubKeyPrefix: this._key.toBytesRaw(),
          ed25519: signature
        };
      case "secp256k1":
        return {
          pubKeyPrefix: this._key.toBytesRaw(),
          ECDSASecp256k1: signature
        };
      default:
        throw new Error(`unrecognized key type ${this._key._type}`);
    }
  }
  /**
   * @param {Long | number} shard
   * @param {Long | number} realm
   * @returns {AccountId}
   */
  toAccountId(shard, realm) {
    return Cache_default2.accountIdConstructor(shard, realm, this);
  }
};
Cache_default2.setPublicKeyED25519((key) => PublicKey2.fromBytesED25519(key));
Cache_default2.setPublicKeyECDSA((key) => PublicKey2.fromBytesECDSA(key));

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version = "logger/5.7.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel3) {
  LogLevel3["DEBUG"] = "DEBUG";
  LogLevel3["INFO"] = "INFO";
  LogLevel3["WARNING"] = "WARNING";
  LogLevel3["ERROR"] = "ERROR";
  LogLevel3["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class _Logger {
  constructor(version10) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version10,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(_Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(_Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(_Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = _Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key) => {
      const value = params[key];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 15];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new _Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      _Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version10) {
    return new _Logger(version10);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2 = "bytes/5.7.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat2(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@hashgraph/sdk/src/EntityIdHelper.js
var regex = /"^(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))(?:-([a-z]{5}))?$/;
var ENTITY_ID_REGEX = /^(\d+)(?:\.(\d+)\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;
function constructor(props, realmOrNull, numOrNull) {
  if (realmOrNull == null && numOrNull != null || realmOrNull != null && numOrNull == null) {
    throw new Error("invalid entity ID");
  }
  const [shard, realm, num] = typeof props === "number" || import_long2.default.isLong(props) ? [
    numOrNull != null ? import_long2.default.fromValue(
      /** @type {Long | number} */
      props
    ) : import_long2.default.ZERO,
    realmOrNull != null ? import_long2.default.fromValue(realmOrNull) : import_long2.default.ZERO,
    numOrNull != null ? import_long2.default.fromValue(numOrNull) : import_long2.default.fromValue(
      /** @type {Long | number} */
      props
    )
  ] : [
    props.shard != null ? import_long2.default.fromValue(props.shard) : import_long2.default.ZERO,
    props.realm != null ? import_long2.default.fromValue(props.realm) : import_long2.default.ZERO,
    import_long2.default.fromValue(props.num)
  ];
  if (shard.isNegative() || realm.isNegative() || num.isNegative()) {
    throw new Error("negative numbers are not allowed in IDs");
  }
  return {
    shard,
    realm,
    num
  };
}
function compare2(a, b) {
  let comparison = a[0].compare(b[0]);
  if (comparison != 0) {
    return comparison;
  }
  comparison = a[1].compare(b[1]);
  if (comparison != 0) {
    return comparison;
  }
  return a[2].compare(b[2]);
}
function fromStringSplitter(text) {
  const match = ENTITY_ID_REGEX.exec(text);
  if (match == null) {
    throw new Error(`failed to parse entity id: ${text}`);
  }
  if (match[2] == null && match[3] == null) {
    return {
      shard: "0",
      realm: "0",
      numOrHex: match[1],
      checksum: match[4]
    };
  } else {
    return {
      shard: match[1],
      realm: match[2],
      numOrHex: match[3],
      checksum: match[4]
    };
  }
}
function fromString(text) {
  const result = fromStringSplitter(text);
  if (Number.isNaN(result.shard) || Number.isNaN(result.realm) || Number.isNaN(result.numOrHex)) {
    throw new Error("invalid format for entity ID");
  }
  return {
    shard: result.shard != null ? import_long2.default.fromString(result.shard) : import_long2.default.ZERO,
    realm: result.realm != null ? import_long2.default.fromString(result.realm) : import_long2.default.ZERO,
    num: import_long2.default.fromString(result.numOrHex),
    checksum: result.checksum
  };
}
function fromSolidityAddress(address) {
  const addr = address.startsWith("0x") ? decode(address.slice(2)) : decode(address);
  if (addr.length !== 20) {
    throw new Error(`Invalid hex encoded solidity address length:
                expected length 40, got length ${address.length}`);
  }
  const shard = import_long2.default.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);
  const realm = import_long2.default.fromBytesBE(Array.from(addr.slice(4, 12)));
  const num = import_long2.default.fromBytesBE(Array.from(addr.slice(12, 20)));
  return [shard, realm, num];
}
function toSolidityAddress(address) {
  const buffer = new Uint8Array(20);
  const view = safeView(buffer);
  const [shard, realm, num] = address;
  view.setUint32(0, convertToNumber(shard));
  view.setUint32(8, convertToNumber(realm));
  view.setUint32(16, convertToNumber(num));
  return encode(buffer);
}
function _parseAddress(ledgerId, addr) {
  let match = regex.exec(addr);
  if (match === null) {
    let result = { status: 0 };
    return result;
  }
  let a = [
    import_long2.default.fromString(match[1]),
    import_long2.default.fromString(match[2]),
    import_long2.default.fromString(match[3])
  ];
  let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;
  let c = _checksum(ledgerId, ad);
  let s = match[4] === void 0 ? 2 : c == match[4] ? 3 : 1;
  return {
    status: s,
    num1: a[0],
    num2: a[1],
    num3: a[2],
    givenChecksum: match[4],
    correctChecksum: c,
    noChecksumFormat: ad,
    withChecksumFormat: `${ad}-${c}`
  };
}
function _checksum(ledgerId, addr) {
  let answer = "";
  let d = [];
  let s0 = 0;
  let s1 = 0;
  let s = 0;
  let sh = 0;
  let c = 0;
  const p3 = 26 * 26 * 26;
  const p5 = 26 * 26 * 26 * 26 * 26;
  const ascii_a = "a".charCodeAt(0);
  const m = 1000003;
  const w = 31;
  let h = new Uint8Array(ledgerId.length + 6);
  h.set(ledgerId, 0);
  h.set([0, 0, 0, 0, 0, 0], ledgerId.length);
  for (let i = 0; i < addr.length; i++) {
    d.push(addr[i] === "." ? 10 : parseInt(addr[i], 10));
  }
  for (let i = 0; i < d.length; i++) {
    s = (w * s + d[i]) % p3;
    if (i % 2 === 0) {
      s0 = (s0 + d[i]) % 11;
    } else {
      s1 = (s1 + d[i]) % 11;
    }
  }
  for (let i = 0; i < h.length; i++) {
    sh = (w * sh + h[i]) % p5;
  }
  c = (((addr.length % 5 * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;
  c = c * m % p5;
  for (let i = 0; i < 5; i++) {
    answer = String.fromCharCode(ascii_a + c % 26) + answer;
    c /= 26;
  }
  return answer;
}
function validateChecksum(shard, realm, num, checksum, client) {
  if (client._network._ledgerId == null || checksum == null) {
    return;
  }
  const expectedChecksum = _checksum(
    client._network._ledgerId._ledgerId,
    `${shard.toString()}.${realm.toString()}.${num.toString()}`
  );
  if (checksum != expectedChecksum) {
    throw new BadEntityIdError(
      shard,
      realm,
      num,
      checksum,
      expectedChecksum
    );
  }
}
function toStringWithChecksum(string, client) {
  if (client == null) {
    throw new Error("client cannot be null");
  }
  if (client._network._ledgerId == null) {
    throw new Error(
      "cannot calculate checksum with a client that does not contain a recognzied ledger ID"
    );
  }
  const checksum = _checksum(client._network._ledgerId._ledgerId, string);
  return `${string}-${checksum}`;
}
function appendBuffer(buffer1, buffer2) {
  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp;
}
function toHexString(bytes3) {
  var s = "0x";
  bytes3.forEach(function(byte) {
    s += ("0" + (byte & 255).toString(16)).slice(-2);
  });
  return s;
}
function aliasToPublicKey(alias) {
  const bytes3 = base32_default.decode(alias);
  if (!bytes3) {
    return null;
  }
  let key;
  try {
    key = HashgraphProto.proto.Key.decode(bytes3);
  } catch (e) {
    throw new Error(
      "The alias is created with hollow account. Please use aliasToEvmAddress!"
    );
  }
  if (key.ed25519 != null && key.ed25519.byteLength > 0) {
    return PublicKey2.fromBytes(key.ed25519);
  }
  if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
    return PublicKey2.fromBytes(key.ECDSASecp256k1);
  }
  return null;
}
function aliasToEvmAddress(alias) {
  const bytes3 = base32_default.decode(alias);
  if (!bytes3) {
    return null;
  }
  try {
    HashgraphProto.proto.Key.decode(bytes3);
    throw new Error(
      "The alias is created with ed25519 or ECDSASecp256k1 account. Please use aliasToPublicKey!"
    );
  } catch (e) {
    return toHexString(bytes3);
  }
}
function publicKeyToAlias(publicKey) {
  if (typeof publicKey === "string" && (publicKey.startsWith("0x") && publicKey.length == 42 || publicKey.length == 40)) {
    if (!publicKey.startsWith("0x")) {
      publicKey = `0x${publicKey}`;
    }
    const bytes3 = arrayify(publicKey);
    if (!bytes3) {
      return null;
    }
    return base32_default.encode(bytes3);
  }
  const publicKeyRaw = typeof publicKey === "string" ? PublicKey2.fromString(publicKey) : publicKey;
  let publicKeyHex = publicKeyRaw.toStringRaw();
  let leadingHex = "";
  if (publicKeyRaw._key._type === "secp256k1") {
    leadingHex = "0x3A21";
  }
  if (publicKeyRaw._key._type === "ED25519") {
    leadingHex = "0x1220";
  }
  if (!publicKeyHex.startsWith("0x")) {
    publicKeyHex = `0x${publicKeyHex}`;
  }
  const leadingBytes = arrayify(leadingHex);
  const publicKeyBytes = arrayify(publicKeyHex);
  const publicKeyInBytes = appendBuffer(leadingBytes, publicKeyBytes);
  const alias = base32_default.encode(publicKeyInBytes);
  return alias;
}

// node_modules/@hashgraph/sdk/src/Mnemonic.js
var Mnemonic2 = class _Mnemonic {
  /**
   * @param {cryptography.Mnemonic} mnemonic
   * @hideconstructor
   * @private
   */
  constructor(mnemonic) {
    this._mnemonic = mnemonic;
  }
  /**
   * Returns a new random 24-word mnemonic from the BIP-39
   * standard English word list.
   *
   * @returns {Promise<Mnemonic>}
   */
  static async generate() {
    return new _Mnemonic(await Mnemonic._generate(24));
  }
  /**
   * Returns a new random 12-word mnemonic from the BIP-39
   * standard English word list.
   *
   * @returns {Promise<Mnemonic>}
   */
  static async generate12() {
    return new _Mnemonic(await Mnemonic._generate(12));
  }
  /**
   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
   *
   * An exception of BadMnemonicError will be thrown if the mnemonic
   * contains unknown words or fails the checksum. An invalid mnemonic
   * can still be used to create private keys, the exception will
   * contain the failing mnemonic in case you wish to ignore the
   * validation error and continue.
   *
   * @param {string[]} words
   * @throws {cryptography.BadMnemonicError}
   * @returns {Promise<Mnemonic>}
   */
  static async fromWords(words) {
    return new _Mnemonic(await Mnemonic.fromWords(words));
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover a private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  async toPrivateKey(passphrase = "") {
    return Cache_default2.privateKeyConstructor(
      // eslint-disable-next-line deprecation/deprecation
      await this._mnemonic.toPrivateKey(passphrase)
    );
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover an Ed25519 private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number[]} [path]
   * @returns {Promise<PrivateKey>}
   */
  async toEd25519PrivateKey(passphrase = "", path) {
    return Cache_default2.privateKeyConstructor(
      // eslint-disable-next-line deprecation/deprecation
      await this._mnemonic.toEd25519PrivateKey(passphrase, path)
    );
  }
  /**
   * Recover an Ed25519 private key from this mnemonic phrase, with an
   * optional passphrase.
   *
   * @param {string} [passphrase]
   * @param {number} [index]
   * @returns {Promise<PrivateKey>}
   */
  async toStandardEd25519PrivateKey(passphrase = "", index) {
    return Cache_default2.privateKeyConstructor(
      await this._mnemonic.toStandardEd25519PrivateKey(passphrase, index)
    );
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover an ECDSA private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number[]} [path]
   * @returns {Promise<PrivateKey>}
   */
  async toEcdsaPrivateKey(passphrase = "", path) {
    return Cache_default2.privateKeyConstructor(
      // eslint-disable-next-line deprecation/deprecation
      await this._mnemonic.toEcdsaPrivateKey(passphrase, path)
    );
  }
  /**
   * Recover an ECDSA private key from this mnemonic phrase, with an
   * optional passphrase.
   *
   * @param {string} [passphrase]
   * @param {number} [index]
   * @returns {Promise<PrivateKey>}
   */
  async toStandardECDSAsecp256k1PrivateKey(passphrase = "", index) {
    return Cache_default2.privateKeyConstructor(
      await this._mnemonic.toStandardECDSAsecp256k1PrivateKey(
        passphrase,
        index
      )
    );
  }
  /**
   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
   *
   * @param {string} mnemonic
   * @returns {Promise<Mnemonic>}
   */
  static async fromString(mnemonic) {
    return new _Mnemonic(await Mnemonic.fromString(mnemonic));
  }
  /**
   * @returns {Promise<PrivateKey>}
   */
  async toLegacyPrivateKey() {
    return Cache_default2.privateKeyConstructor(
      await this._mnemonic.toLegacyPrivateKey()
    );
  }
  /**
   * @param {string} passphrase
   * @returns {Promise<Uint8Array>}
   */
  async toSeed(passphrase) {
    return await Mnemonic.toSeed(
      this._mnemonic.words,
      passphrase
    );
  }
  /**
   * @returns {string}
   */
  toString() {
    return this._mnemonic.toString();
  }
};

// node_modules/@hashgraph/sdk/src/PrivateKey.js
var PrivateKey2 = class _PrivateKey extends Key2 {
  /**
   * @internal
   * @hideconstructor
   * @param {cryptography.PrivateKey} key
   */
  constructor(key) {
    super();
    this._key = key;
  }
  /**
   * Generate a random Ed25519 private key.
   *
   * @returns {PrivateKey}
   */
  static generateED25519() {
    return new _PrivateKey(PrivateKey.generateED25519());
  }
  /**
   * Generate a random EDSA private key.
   *
   * @returns {PrivateKey}
   */
  static generateECDSA() {
    return new _PrivateKey(PrivateKey.generateECDSA());
  }
  /**
   * Depredated - Use `generateED25519()` instead
   * Generate a random Ed25519 private key.
   *
   * @returns {PrivateKey}
   */
  static generate() {
    return _PrivateKey.generateED25519();
  }
  /**
   * Depredated - Use `generateED25519Async()` instead
   * Generate a random Ed25519 private key.
   *
   * @returns {Promise<PrivateKey>}
   */
  static async generateAsync() {
    return new _PrivateKey(await PrivateKey.generateAsync());
  }
  /**
   * Generate a random Ed25519 private key.
   *
   * @returns {Promise<PrivateKey>}
   */
  static async generateED25519Async() {
    return new _PrivateKey(
      await PrivateKey.generateED25519Async()
    );
  }
  /**
   * Generate a random ECDSA private key.
   *
   * @returns {Promise<PrivateKey>}
   */
  static async generateECDSAAsync() {
    return new _PrivateKey(
      await PrivateKey.generateECDSAAsync()
    );
  }
  /**
   * Construct a private key from bytes. Requires DER header.
   *
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytes(data) {
    return new _PrivateKey(PrivateKey.fromBytes(data));
  }
  /**
   * Construct a ECDSA private key from bytes.
   *
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytesECDSA(data) {
    return new _PrivateKey(PrivateKey.fromBytesECDSA(data));
  }
  /**
   * Construct a ED25519 private key from bytes.
   *
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytesED25519(data) {
    return new _PrivateKey(PrivateKey.fromBytesED25519(data));
  }
  /**
   * @deprecated - Use fromStringECDSA() or fromStringED2551() on a HEX-encoded string
   * and fromStringDer() on a HEX-encoded string with DER prefix instead.
   * Construct a private key from a hex-encoded string. Requires DER header.
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromString(text) {
    return new _PrivateKey(PrivateKey.fromString(text));
  }
  /**
   * Construct a private key from a HEX-encoded string with a der prefix
   *
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromStringDer(text) {
    return new _PrivateKey(PrivateKey.fromString(text));
  }
  /**
   * Construct a ECDSA private key from a hex-encoded string.
   *
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromStringECDSA(text) {
    return new _PrivateKey(PrivateKey.fromStringECDSA(text));
  }
  /**
   * Construct a Ed25519 private key from a hex-encoded string.
   *
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromStringED25519(text) {
    return new _PrivateKey(PrivateKey.fromStringED25519(text));
  }
  /**
   * Construct a Ed25519 private key from a Uint8Array seed.
   *
   * @param {Uint8Array} seed
   * @returns {Promise<PrivateKey>}
   */
  static async fromSeedED25519(seed) {
    return new _PrivateKey(
      await PrivateKey.fromSeedED25519(seed)
    );
  }
  /**
   * Construct a Ed25519 private key from a Uint8Array seed.
   *
   * @param {Uint8Array} seed
   * @returns {Promise<PrivateKey>}
   */
  static async fromSeedECDSAsecp256k1(seed) {
    return new _PrivateKey(
      await PrivateKey.fromSeedECDSAsecp256k1(seed)
    );
  }
  /**
   * @deprecated - Use `Mnemonic.from[Words|String]().to[Ed25519|Ecdsa]PrivateKey()` instead
   *
   * Recover a private key from a mnemonic phrase (and optionally a password).
   * @param {Mnemonic | cryptography.Mnemonic | string} mnemonic
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  static async fromMnemonic(mnemonic, passphrase = "") {
    if (mnemonic instanceof Mnemonic2) {
      return new _PrivateKey(
        // eslint-disable-next-line deprecation/deprecation
        await PrivateKey.fromMnemonic(
          mnemonic._mnemonic,
          passphrase
        )
      );
    }
    return new _PrivateKey(
      // eslint-disable-next-line deprecation/deprecation
      await PrivateKey.fromMnemonic(mnemonic, passphrase)
    );
  }
  /**
   * Recover a private key from a keystore, previously created by `.toKeystore()`.
   *
   * This key will _not_ support child key derivation.
   *
   * @param {Uint8Array} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   * @throws {cryptography.BadKeyError} If the passphrase is incorrect or the hash fails to validate.
   */
  static async fromKeystore(data, passphrase = "") {
    return new _PrivateKey(
      await PrivateKey.fromKeystore(data, passphrase)
    );
  }
  /**
   * Recover a private key from a pem string; the private key may be encrypted.
   *
   * This method assumes the .pem file has been converted to a string already.
   *
   * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
   * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
   * section and decodes that as a DER-encoded  private key.
   *
   * @param {string} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  static async fromPem(data, passphrase = "") {
    return new _PrivateKey(
      await PrivateKey.fromPem(data, passphrase)
    );
  }
  /**
   * Derive a new private key at the given wallet index.
   *
   * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
   * an error.
   *
   * You can check if a key supports derivation with `.supportsDerivation()`
   *
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */
  async derive(index) {
    return new _PrivateKey(await this._key.derive(index));
  }
  /**
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */
  async legacyDerive(index) {
    return new _PrivateKey(await this._key.legacyDerive(index));
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   *
   * @returns {PublicKey}
   */
  get publicKey() {
    return new PublicKey2(this._key.publicKey);
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   *
   * @returns {?Uint8Array}
   */
  get chainCode() {
    return this._key._chainCode;
  }
  /**
   * Sign a message with this private key.
   *
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */
  sign(bytes3) {
    return this._key.sign(bytes3);
  }
  /**
   * @param {Transaction} transaction
   * @returns {Uint8Array}
   */
  signTransaction(transaction) {
    const tx = transaction._signedTransactions.get(0);
    const signature = tx.bodyBytes != null ? this.sign(tx.bodyBytes) : new Uint8Array();
    transaction.addSignature(this.publicKey, signature);
    return signature;
  }
  /**
   * Check if `derive` can be called on this private key.
   *
   * This is only the case if the key was created from a mnemonic.
   *
   * @returns {boolean}
   */
  isDerivable() {
    return this._key.isDerivable();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return this._key.toBytes();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    return this._key.toBytesDer();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  /**
   * @returns {string}
   */
  toString() {
    return this._key.toStringDer();
  }
  /**
   * @returns {string}
   */
  toStringDer() {
    return this._key.toStringDer();
  }
  /**
   * @returns {string}
   */
  toStringRaw() {
    return this._key.toStringRaw();
  }
  /**
   * Create a keystore with a given passphrase.
   *
   * The key can be recovered later with `fromKeystore()`.
   *
   * Note that this will not retain the ancillary data used for
   * deriving child keys, thus `.derive()` on the restored key will
   * throw even if this instance supports derivation.
   *
   * @param {string} [passphrase]
   * @returns {Promise<Uint8Array>}
   */
  toKeystore(passphrase = "") {
    return this._key.toKeystore(passphrase);
  }
  /**
   * @returns {HashgraphProto.proto.IKey}
   */
  _toProtobufKey() {
    return this.publicKey._toProtobufKey();
  }
  /**
   * @param {Long | number} shard
   * @param {Long | number} realm
   * @returns {AccountId}
   */
  toAccountId(shard, realm) {
    return this.publicKey.toAccountId(shard, realm);
  }
  /**
   * @returns {string}
   */
  get type() {
    return this._key._type;
  }
};
Cache_default2.setPrivateKeyConstructor((key) => new PrivateKey2(key));

// node_modules/@hashgraph/sdk/src/KeyList.js
var KeyList2 = class _KeyList extends Key2 {
  /**
   * @param {?Key[]} [keys]
   * @param {?number} [threshold]
   */
  constructor(keys, threshold) {
    super();
    if (keys == null)
      this._keys = [];
    else if (keys instanceof Key2)
      this._keys = [keys];
    else
      this._keys = keys;
    this._threshold = threshold == null ? null : threshold;
  }
  /**
   * @param {Key[]} keys
   * @returns {KeyList}
   */
  static of(...keys) {
    return new _KeyList(keys, null);
  }
  /**
   * @template T
   * @param {ArrayLike<Key>} arrayLike
   * @param {((key: Key) => Key)} [mapFn]
   * @param {T} [thisArg]
   * @returns {KeyList}
   */
  static from(arrayLike, mapFn, thisArg) {
    if (mapFn == null) {
      return new _KeyList(Array.from(arrayLike));
    }
    return new _KeyList(Array.from(arrayLike, mapFn, thisArg));
  }
  /**
   * @returns {?number}
   */
  get threshold() {
    return this._threshold;
  }
  /**
   * @param {number} threshold
   * @returns {this}
   */
  setThreshold(threshold) {
    this._threshold = threshold;
    return this;
  }
  /**
   * @param {Key[]} keys
   * @returns {number}
   */
  push(...keys) {
    return this._keys.push(...keys);
  }
  /**
   * @param {number} start
   * @param {number} deleteCount
   * @param {Key[]} items
   * @returns {KeyList}
   */
  splice(start, deleteCount, ...items) {
    return new _KeyList(
      this._keys.splice(start, deleteCount, ...items),
      this.threshold
    );
  }
  /**
   * @param {number=} start
   * @param {number=} end
   * @returns {KeyList}
   */
  slice(start, end) {
    return new _KeyList(this._keys.slice(start, end), this.threshold);
  }
  /**
   * @returns {Iterator<Key>}
   */
  [Symbol.iterator]() {
    return this._keys[Symbol.iterator]();
  }
  /**
   * @returns {Key[]}
   */
  toArray() {
    return this._keys.slice();
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify({
      threshold: this._threshold,
      keys: this._keys.toString()
    });
  }
  /**
   * @returns {HashgraphProto.proto.IKey}
   */
  _toProtobufKey() {
    const keys = this._keys.map((key) => key._toProtobufKey());
    if (this.threshold == null) {
      return { keyList: { keys } };
    } else {
      return {
        thresholdKey: {
          threshold: this.threshold,
          keys: { keys }
        }
      };
    }
  }
  /**
   * @param {HashgraphProto.proto.IKeyList} key
   * @returns {KeyList}
   */
  static __fromProtobufKeyList(key) {
    const keys = (key.keys != null ? key.keys : []).map(
      (key2) => Key2._fromProtobufKey(key2)
    );
    return new _KeyList(keys);
  }
  /**
   * @param {HashgraphProto.proto.IThresholdKey} key
   * @returns {KeyList}
   */
  static __fromProtobufThresoldKey(key) {
    const list = _KeyList.__fromProtobufKeyList(
      key.keys != null ? key.keys : {}
    );
    list.setThreshold(key.threshold != null ? key.threshold : 0);
    return list;
  }
};
Cache_default2.setKeyList((key) => KeyList2.__fromProtobufKeyList(key));
Cache_default2.setThresholdKey((key) => KeyList2.__fromProtobufThresoldKey(key));

// node_modules/@hashgraph/sdk/src/long.js
function valueToLong(value) {
  if (bignumber_default.isBigNumber(value)) {
    return value;
  } else {
    return new bignumber_default(value.toString());
  }
}

// node_modules/@hashgraph/sdk/src/HbarUnit.js
var HbarUnit = class _HbarUnit {
  /**
   * @internal
   * @param {string} name
   * @param {string} symbol
   * @param {BigNumber} tinybar
   */
  constructor(name, symbol, tinybar) {
    this._name = name;
    this._symbol = symbol;
    this._tinybar = tinybar;
    Object.freeze(this);
  }
  /**
   * @param {string} unit
   * @returns {HbarUnit}
   */
  static fromString(unit) {
    switch (unit) {
      case _HbarUnit.Hbar._symbol:
        return _HbarUnit.Hbar;
      case _HbarUnit.Tinybar._symbol:
        return _HbarUnit.Tinybar;
      case _HbarUnit.Microbar._symbol:
        return _HbarUnit.Microbar;
      case _HbarUnit.Millibar._symbol:
        return _HbarUnit.Millibar;
      case _HbarUnit.Kilobar._symbol:
        return _HbarUnit.Kilobar;
      case _HbarUnit.Megabar._symbol:
        return _HbarUnit.Megabar;
      case _HbarUnit.Gigabar._symbol:
        return _HbarUnit.Gigabar;
      default:
        throw new Error("Unknown unit.");
    }
  }
};
HbarUnit.Tinybar = new HbarUnit("tinybar", "t", new bignumber_default(1));
HbarUnit.Microbar = new HbarUnit("microbar", "", new bignumber_default(100));
HbarUnit.Millibar = new HbarUnit("millibar", "m", new bignumber_default(1e5));
HbarUnit.Hbar = new HbarUnit("hbar", "", new bignumber_default("100000000"));
HbarUnit.Kilobar = new HbarUnit(
  "kilobar",
  "k",
  new bignumber_default(1e3).multipliedBy(new bignumber_default("100000000"))
);
HbarUnit.Megabar = new HbarUnit(
  "megabar",
  "M",
  new bignumber_default(1e6).multipliedBy(new bignumber_default("100000000"))
);
HbarUnit.Gigabar = new HbarUnit(
  "gigabar",
  "G",
  new bignumber_default("1000000000").multipliedBy(new bignumber_default("100000000"))
);

// node_modules/@hashgraph/sdk/src/Hbar.js
var import_long4 = __toESM(require_long(), 1);
var Hbar = class _Hbar {
  /**
   * @param {number | string | Long | LongObject | BigNumber} amount
   * @param {HbarUnit=} unit
   */
  constructor(amount, unit = HbarUnit.Hbar) {
    if (unit === HbarUnit.Tinybar) {
      this._valueInTinybar = valueToLong(amount);
    } else {
      let bigAmount;
      if (import_long4.default.isLong(amount)) {
        bigAmount = new bignumber_default(amount.toString(10));
      } else if (bignumber_default.isBigNumber(amount) || typeof amount === "string" || typeof amount === "number") {
        bigAmount = new bignumber_default(amount);
      } else {
        bigAmount = new bignumber_default(0);
      }
      this._valueInTinybar = bigAmount.multipliedBy(unit._tinybar);
    }
    if (!this._valueInTinybar.isInteger()) {
      throw new Error("Hbar in tinybars contains decimals");
    }
  }
  /**
   * @param {number | Long | BigNumber} amount
   * @param {HbarUnit} unit
   * @returns {Hbar}
   */
  static from(amount, unit) {
    return new _Hbar(amount, unit);
  }
  /**
   * @param {number | Long | string | BigNumber} amount
   * @returns {Hbar}
   */
  static fromTinybars(amount) {
    if (typeof amount === "string") {
      return this.fromString(amount, HbarUnit.Tinybar);
    }
    return new _Hbar(amount, HbarUnit.Tinybar);
  }
  /**
   * @param {string} str
   * @param {HbarUnit=} unit
   * @returns {Hbar}
   */
  static fromString(str, unit = HbarUnit.Hbar) {
    const pattern = /^((?:\+|-)?\d+(?:\.\d+)?)(?: (t||m||k|M|G))?$/;
    if (pattern.test(str)) {
      let [amount, symbol] = str.split(" ");
      if (symbol != null) {
        unit = HbarUnit.fromString(symbol);
      }
      return new _Hbar(new bignumber_default(amount), unit);
    } else {
      throw new Error("invalid argument provided");
    }
  }
  /**
   * @param {HbarUnit} unit
   * @returns {BigNumber}
   */
  to(unit) {
    return this._valueInTinybar.dividedBy(unit._tinybar);
  }
  /**
   * @returns {BigNumber}
   */
  toBigNumber() {
    return this.to(HbarUnit.Hbar);
  }
  /**
   * @returns {Long}
   */
  toTinybars() {
    return import_long4.default.fromValue(this._valueInTinybar.toFixed());
  }
  /**
   * @returns {Hbar}
   */
  negated() {
    return _Hbar.fromTinybars(this._valueInTinybar.negated());
  }
  /**
   * @returns {boolean}
   */
  isNegative() {
    return this._valueInTinybar.isNegative();
  }
  /**
   * @param {HbarUnit=} unit
   * @returns {string}
   */
  toString(unit) {
    if (unit != null) {
      return `${this._valueInTinybar.dividedBy(unit._tinybar).toString()} ${unit._symbol}`;
    }
    if (this._valueInTinybar.isLessThan(1e4) && this._valueInTinybar.isGreaterThan(-1e4)) {
      return `${this._valueInTinybar.toFixed()} ${HbarUnit.Tinybar._symbol}`;
    }
    return `${this.to(HbarUnit.Hbar).toString()} ${HbarUnit.Hbar._symbol}`;
  }
};

// node_modules/@hashgraph/sdk/src/StatusError.js
var StatusError = class _StatusError extends Error {
  /**
   * @param {object} props
   * @param {Status} props.status
   * @param {TransactionId} props.transactionId
   * @param {string} message
   */
  constructor(props, message) {
    super(message);
    this.name = "StatusError";
    this.status = props.status;
    this.transactionId = props.transactionId;
    this.message = message;
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, _StatusError);
    }
  }
  /**
   * @returns {StatusErrorJSON}
   */
  toJSON() {
    return {
      name: this.name,
      status: this.status.toString(),
      transactionId: this.transactionId.toString(),
      message: this.message
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @returns {StatusErrorJSON}
   */
  valueOf() {
    return this.toJSON();
  }
};

// node_modules/@hashgraph/sdk/src/ReceiptStatusError.js
var ReceiptStatusError = class extends StatusError {
  /**
   * @param {object} props
   * @param {TransactionReceipt} props.transactionReceipt
   * @param {Status} props.status
   * @param {TransactionId} props.transactionId
   */
  constructor(props) {
    super(
      props,
      `receipt for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`
    );
    this.transactionReceipt = props.transactionReceipt;
  }
};

// node_modules/@hashgraph/sdk/src/Status.js
var Status = class _Status {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _Status.Ok:
        return "OK";
      case _Status.InvalidTransaction:
        return "INVALID_TRANSACTION";
      case _Status.PayerAccountNotFound:
        return "PAYER_ACCOUNT_NOT_FOUND";
      case _Status.InvalidNodeAccount:
        return "INVALID_NODE_ACCOUNT";
      case _Status.TransactionExpired:
        return "TRANSACTION_EXPIRED";
      case _Status.InvalidTransactionStart:
        return "INVALID_TRANSACTION_START";
      case _Status.InvalidTransactionDuration:
        return "INVALID_TRANSACTION_DURATION";
      case _Status.InvalidSignature:
        return "INVALID_SIGNATURE";
      case _Status.MemoTooLong:
        return "MEMO_TOO_LONG";
      case _Status.InsufficientTxFee:
        return "INSUFFICIENT_TX_FEE";
      case _Status.InsufficientPayerBalance:
        return "INSUFFICIENT_PAYER_BALANCE";
      case _Status.DuplicateTransaction:
        return "DUPLICATE_TRANSACTION";
      case _Status.Busy:
        return "BUSY";
      case _Status.NotSupported:
        return "NOT_SUPPORTED";
      case _Status.InvalidFileId:
        return "INVALID_FILE_ID";
      case _Status.InvalidAccountId:
        return "INVALID_ACCOUNT_ID";
      case _Status.InvalidContractId:
        return "INVALID_CONTRACT_ID";
      case _Status.InvalidTransactionId:
        return "INVALID_TRANSACTION_ID";
      case _Status.ReceiptNotFound:
        return "RECEIPT_NOT_FOUND";
      case _Status.RecordNotFound:
        return "RECORD_NOT_FOUND";
      case _Status.InvalidSolidityId:
        return "INVALID_SOLIDITY_ID";
      case _Status.Unknown:
        return "UNKNOWN";
      case _Status.Success:
        return "SUCCESS";
      case _Status.FailInvalid:
        return "FAIL_INVALID";
      case _Status.FailFee:
        return "FAIL_FEE";
      case _Status.FailBalance:
        return "FAIL_BALANCE";
      case _Status.KeyRequired:
        return "KEY_REQUIRED";
      case _Status.BadEncoding:
        return "BAD_ENCODING";
      case _Status.InsufficientAccountBalance:
        return "INSUFFICIENT_ACCOUNT_BALANCE";
      case _Status.InvalidSolidityAddress:
        return "INVALID_SOLIDITY_ADDRESS";
      case _Status.InsufficientGas:
        return "INSUFFICIENT_GAS";
      case _Status.ContractSizeLimitExceeded:
        return "CONTRACT_SIZE_LIMIT_EXCEEDED";
      case _Status.LocalCallModificationException:
        return "LOCAL_CALL_MODIFICATION_EXCEPTION";
      case _Status.ContractRevertExecuted:
        return "CONTRACT_REVERT_EXECUTED";
      case _Status.ContractExecutionException:
        return "CONTRACT_EXECUTION_EXCEPTION";
      case _Status.InvalidReceivingNodeAccount:
        return "INVALID_RECEIVING_NODE_ACCOUNT";
      case _Status.MissingQueryHeader:
        return "MISSING_QUERY_HEADER";
      case _Status.AccountUpdateFailed:
        return "ACCOUNT_UPDATE_FAILED";
      case _Status.InvalidKeyEncoding:
        return "INVALID_KEY_ENCODING";
      case _Status.NullSolidityAddress:
        return "NULL_SOLIDITY_ADDRESS";
      case _Status.ContractUpdateFailed:
        return "CONTRACT_UPDATE_FAILED";
      case _Status.InvalidQueryHeader:
        return "INVALID_QUERY_HEADER";
      case _Status.InvalidFeeSubmitted:
        return "INVALID_FEE_SUBMITTED";
      case _Status.InvalidPayerSignature:
        return "INVALID_PAYER_SIGNATURE";
      case _Status.KeyNotProvided:
        return "KEY_NOT_PROVIDED";
      case _Status.InvalidExpirationTime:
        return "INVALID_EXPIRATION_TIME";
      case _Status.NoWaclKey:
        return "NO_WACL_KEY";
      case _Status.FileContentEmpty:
        return "FILE_CONTENT_EMPTY";
      case _Status.InvalidAccountAmounts:
        return "INVALID_ACCOUNT_AMOUNTS";
      case _Status.EmptyTransactionBody:
        return "EMPTY_TRANSACTION_BODY";
      case _Status.InvalidTransactionBody:
        return "INVALID_TRANSACTION_BODY";
      case _Status.InvalidSignatureTypeMismatchingKey:
        return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY";
      case _Status.InvalidSignatureCountMismatchingKey:
        return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY";
      case _Status.EmptyLiveHashBody:
        return "EMPTY_LIVE_HASH_BODY";
      case _Status.EmptyLiveHash:
        return "EMPTY_LIVE_HASH";
      case _Status.EmptyLiveHashKeys:
        return "EMPTY_LIVE_HASH_KEYS";
      case _Status.InvalidLiveHashSize:
        return "INVALID_LIVE_HASH_SIZE";
      case _Status.EmptyQueryBody:
        return "EMPTY_QUERY_BODY";
      case _Status.EmptyLiveHashQuery:
        return "EMPTY_LIVE_HASH_QUERY";
      case _Status.LiveHashNotFound:
        return "LIVE_HASH_NOT_FOUND";
      case _Status.AccountIdDoesNotExist:
        return "ACCOUNT_ID_DOES_NOT_EXIST";
      case _Status.LiveHashAlreadyExists:
        return "LIVE_HASH_ALREADY_EXISTS";
      case _Status.InvalidFileWacl:
        return "INVALID_FILE_WACL";
      case _Status.SerializationFailed:
        return "SERIALIZATION_FAILED";
      case _Status.TransactionOversize:
        return "TRANSACTION_OVERSIZE";
      case _Status.TransactionTooManyLayers:
        return "TRANSACTION_TOO_MANY_LAYERS";
      case _Status.ContractDeleted:
        return "CONTRACT_DELETED";
      case _Status.PlatformNotActive:
        return "PLATFORM_NOT_ACTIVE";
      case _Status.KeyPrefixMismatch:
        return "KEY_PREFIX_MISMATCH";
      case _Status.PlatformTransactionNotCreated:
        return "PLATFORM_TRANSACTION_NOT_CREATED";
      case _Status.InvalidRenewalPeriod:
        return "INVALID_RENEWAL_PERIOD";
      case _Status.InvalidPayerAccountId:
        return "INVALID_PAYER_ACCOUNT_ID";
      case _Status.AccountDeleted:
        return "ACCOUNT_DELETED";
      case _Status.FileDeleted:
        return "FILE_DELETED";
      case _Status.AccountRepeatedInAccountAmounts:
        return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS";
      case _Status.SettingNegativeAccountBalance:
        return "SETTING_NEGATIVE_ACCOUNT_BALANCE";
      case _Status.ObtainerRequired:
        return "OBTAINER_REQUIRED";
      case _Status.ObtainerSameContractId:
        return "OBTAINER_SAME_CONTRACT_ID";
      case _Status.ObtainerDoesNotExist:
        return "OBTAINER_DOES_NOT_EXIST";
      case _Status.ModifyingImmutableContract:
        return "MODIFYING_IMMUTABLE_CONTRACT";
      case _Status.FileSystemException:
        return "FILE_SYSTEM_EXCEPTION";
      case _Status.AutorenewDurationNotInRange:
        return "AUTORENEW_DURATION_NOT_IN_RANGE";
      case _Status.ErrorDecodingBytestring:
        return "ERROR_DECODING_BYTESTRING";
      case _Status.ContractFileEmpty:
        return "CONTRACT_FILE_EMPTY";
      case _Status.ContractBytecodeEmpty:
        return "CONTRACT_BYTECODE_EMPTY";
      case _Status.InvalidInitialBalance:
        return "INVALID_INITIAL_BALANCE";
      case _Status.InvalidReceiveRecordThreshold:
        return "INVALID_RECEIVE_RECORD_THRESHOLD";
      case _Status.InvalidSendRecordThreshold:
        return "INVALID_SEND_RECORD_THRESHOLD";
      case _Status.AccountIsNotGenesisAccount:
        return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT";
      case _Status.PayerAccountUnauthorized:
        return "PAYER_ACCOUNT_UNAUTHORIZED";
      case _Status.InvalidFreezeTransactionBody:
        return "INVALID_FREEZE_TRANSACTION_BODY";
      case _Status.FreezeTransactionBodyNotFound:
        return "FREEZE_TRANSACTION_BODY_NOT_FOUND";
      case _Status.TransferListSizeLimitExceeded:
        return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
      case _Status.ResultSizeLimitExceeded:
        return "RESULT_SIZE_LIMIT_EXCEEDED";
      case _Status.NotSpecialAccount:
        return "NOT_SPECIAL_ACCOUNT";
      case _Status.ContractNegativeGas:
        return "CONTRACT_NEGATIVE_GAS";
      case _Status.ContractNegativeValue:
        return "CONTRACT_NEGATIVE_VALUE";
      case _Status.InvalidFeeFile:
        return "INVALID_FEE_FILE";
      case _Status.InvalidExchangeRateFile:
        return "INVALID_EXCHANGE_RATE_FILE";
      case _Status.InsufficientLocalCallGas:
        return "INSUFFICIENT_LOCAL_CALL_GAS";
      case _Status.EntityNotAllowedToDelete:
        return "ENTITY_NOT_ALLOWED_TO_DELETE";
      case _Status.AuthorizationFailed:
        return "AUTHORIZATION_FAILED";
      case _Status.FileUploadedProtoInvalid:
        return "FILE_UPLOADED_PROTO_INVALID";
      case _Status.FileUploadedProtoNotSavedToDisk:
        return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK";
      case _Status.FeeScheduleFilePartUploaded:
        return "FEE_SCHEDULE_FILE_PART_UPLOADED";
      case _Status.ExchangeRateChangeLimitExceeded:
        return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED";
      case _Status.MaxContractStorageExceeded:
        return "MAX_CONTRACT_STORAGE_EXCEEDED";
      case _Status.TransferAccountSameAsDeleteAccount:
        return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT";
      case _Status.TotalLedgerBalanceInvalid:
        return "TOTAL_LEDGER_BALANCE_INVALID";
      case _Status.ExpirationReductionNotAllowed:
        return "EXPIRATION_REDUCTION_NOT_ALLOWED";
      case _Status.MaxGasLimitExceeded:
        return "MAX_GAS_LIMIT_EXCEEDED";
      case _Status.MaxFileSizeExceeded:
        return "MAX_FILE_SIZE_EXCEEDED";
      case _Status.ReceiverSigRequired:
        return "RECEIVER_SIG_REQUIRED";
      case _Status.InvalidTopicId:
        return "INVALID_TOPIC_ID";
      case _Status.InvalidAdminKey:
        return "INVALID_ADMIN_KEY";
      case _Status.InvalidSubmitKey:
        return "INVALID_SUBMIT_KEY";
      case _Status.Unauthorized:
        return "UNAUTHORIZED";
      case _Status.InvalidTopicMessage:
        return "INVALID_TOPIC_MESSAGE";
      case _Status.InvalidAutorenewAccount:
        return "INVALID_AUTORENEW_ACCOUNT";
      case _Status.AutorenewAccountNotAllowed:
        return "AUTORENEW_ACCOUNT_NOT_ALLOWED";
      case _Status.TopicExpired:
        return "TOPIC_EXPIRED";
      case _Status.InvalidChunkNumber:
        return "INVALID_CHUNK_NUMBER";
      case _Status.InvalidChunkTransactionId:
        return "INVALID_CHUNK_TRANSACTION_ID";
      case _Status.AccountFrozenForToken:
        return "ACCOUNT_FROZEN_FOR_TOKEN";
      case _Status.TokensPerAccountLimitExceeded:
        return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED";
      case _Status.InvalidTokenId:
        return "INVALID_TOKEN_ID";
      case _Status.InvalidTokenDecimals:
        return "INVALID_TOKEN_DECIMALS";
      case _Status.InvalidTokenInitialSupply:
        return "INVALID_TOKEN_INITIAL_SUPPLY";
      case _Status.InvalidTreasuryAccountForToken:
        return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN";
      case _Status.InvalidTokenSymbol:
        return "INVALID_TOKEN_SYMBOL";
      case _Status.TokenHasNoFreezeKey:
        return "TOKEN_HAS_NO_FREEZE_KEY";
      case _Status.TransfersNotZeroSumForToken:
        return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN";
      case _Status.MissingTokenSymbol:
        return "MISSING_TOKEN_SYMBOL";
      case _Status.TokenSymbolTooLong:
        return "TOKEN_SYMBOL_TOO_LONG";
      case _Status.AccountKycNotGrantedForToken:
        return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN";
      case _Status.TokenHasNoKycKey:
        return "TOKEN_HAS_NO_KYC_KEY";
      case _Status.InsufficientTokenBalance:
        return "INSUFFICIENT_TOKEN_BALANCE";
      case _Status.TokenWasDeleted:
        return "TOKEN_WAS_DELETED";
      case _Status.TokenHasNoSupplyKey:
        return "TOKEN_HAS_NO_SUPPLY_KEY";
      case _Status.TokenHasNoWipeKey:
        return "TOKEN_HAS_NO_WIPE_KEY";
      case _Status.InvalidTokenMintAmount:
        return "INVALID_TOKEN_MINT_AMOUNT";
      case _Status.InvalidTokenBurnAmount:
        return "INVALID_TOKEN_BURN_AMOUNT";
      case _Status.TokenNotAssociatedToAccount:
        return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT";
      case _Status.CannotWipeTokenTreasuryAccount:
        return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT";
      case _Status.InvalidKycKey:
        return "INVALID_KYC_KEY";
      case _Status.InvalidWipeKey:
        return "INVALID_WIPE_KEY";
      case _Status.InvalidFreezeKey:
        return "INVALID_FREEZE_KEY";
      case _Status.InvalidSupplyKey:
        return "INVALID_SUPPLY_KEY";
      case _Status.MissingTokenName:
        return "MISSING_TOKEN_NAME";
      case _Status.TokenNameTooLong:
        return "TOKEN_NAME_TOO_LONG";
      case _Status.InvalidWipingAmount:
        return "INVALID_WIPING_AMOUNT";
      case _Status.TokenIsImmutable:
        return "TOKEN_IS_IMMUTABLE";
      case _Status.TokenAlreadyAssociatedToAccount:
        return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT";
      case _Status.TransactionRequiresZeroTokenBalances:
        return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES";
      case _Status.AccountIsTreasury:
        return "ACCOUNT_IS_TREASURY";
      case _Status.TokenIdRepeatedInTokenList:
        return "TOKEN_ID_REPEATED_IN_TOKEN_LIST";
      case _Status.TokenTransferListSizeLimitExceeded:
        return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
      case _Status.EmptyTokenTransferBody:
        return "EMPTY_TOKEN_TRANSFER_BODY";
      case _Status.EmptyTokenTransferAccountAmounts:
        return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS";
      case _Status.InvalidScheduleId:
        return "INVALID_SCHEDULE_ID";
      case _Status.ScheduleIsImmutable:
        return "SCHEDULE_IS_IMMUTABLE";
      case _Status.InvalidSchedulePayerId:
        return "INVALID_SCHEDULE_PAYER_ID";
      case _Status.InvalidScheduleAccountId:
        return "INVALID_SCHEDULE_ACCOUNT_ID";
      case _Status.NoNewValidSignatures:
        return "NO_NEW_VALID_SIGNATURES";
      case _Status.UnresolvableRequiredSigners:
        return "UNRESOLVABLE_REQUIRED_SIGNERS";
      case _Status.ScheduledTransactionNotInWhitelist:
        return "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST";
      case _Status.SomeSignaturesWereInvalid:
        return "SOME_SIGNATURES_WERE_INVALID";
      case _Status.TransactionIdFieldNotAllowed:
        return "TRANSACTION_ID_FIELD_NOT_ALLOWED";
      case _Status.IdenticalScheduleAlreadyCreated:
        return "IDENTICAL_SCHEDULE_ALREADY_CREATED";
      case _Status.InvalidZeroByteInString:
        return "INVALID_ZERO_BYTE_IN_STRING";
      case _Status.ScheduleAlreadyDeleted:
        return "SCHEDULE_ALREADY_DELETED";
      case _Status.ScheduleAlreadyExecuted:
        return "SCHEDULE_ALREADY_EXECUTED";
      case _Status.MessageSizeTooLarge:
        return "MESSAGE_SIZE_TOO_LARGE";
      case _Status.OperationRepeatedInBucketGroups:
        return "OPERATION_REPEATED_IN_BUCKET_GROUPS";
      case _Status.BucketCapacityOverflow:
        return "BUCKET_CAPACITY_OVERFLOW";
      case _Status.NodeCapacityNotSufficientForOperation:
        return "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION";
      case _Status.BucketHasNoThrottleGroups:
        return "BUCKET_HAS_NO_THROTTLE_GROUPS";
      case _Status.ThrottleGroupHasZeroOpsPerSec:
        return "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC";
      case _Status.SuccessButMissingExpectedOperation:
        return "SUCCESS_BUT_MISSING_EXPECTED_OPERATION";
      case _Status.UnparseableThrottleDefinitions:
        return "UNPARSEABLE_THROTTLE_DEFINITIONS";
      case _Status.InvalidThrottleDefinitions:
        return "INVALID_THROTTLE_DEFINITIONS";
      case _Status.AccountExpiredAndPendingRemoval:
        return "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL";
      case _Status.InvalidTokenMaxSupply:
        return "INVALID_TOKEN_MAX_SUPPLY";
      case _Status.InvalidTokenNftSerialNumber:
        return "INVALID_TOKEN_NFT_SERIAL_NUMBER";
      case _Status.InvalidNftId:
        return "INVALID_NFT_ID";
      case _Status.MetadataTooLong:
        return "METADATA_TOO_LONG";
      case _Status.BatchSizeLimitExceeded:
        return "BATCH_SIZE_LIMIT_EXCEEDED";
      case _Status.InvalidQueryRange:
        return "INVALID_QUERY_RANGE";
      case _Status.FractionDividesByZero:
        return "FRACTION_DIVIDES_BY_ZERO";
      case _Status.InsufficientPayerBalanceForCustomFee:
        return "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE";
      case _Status.CustomFeesListTooLong:
        return "CUSTOM_FEES_LIST_TOO_LONG";
      case _Status.InvalidCustomFeeCollector:
        return "INVALID_CUSTOM_FEE_COLLECTOR";
      case _Status.InvalidTokenIdInCustomFees:
        return "INVALID_TOKEN_ID_IN_CUSTOM_FEES";
      case _Status.TokenNotAssociatedToFeeCollector:
        return "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR";
      case _Status.TokenMaxSupplyReached:
        return "TOKEN_MAX_SUPPLY_REACHED";
      case _Status.SenderDoesNotOwnNftSerialNo:
        return "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO";
      case _Status.CustomFeeNotFullySpecified:
        return "CUSTOM_FEE_NOT_FULLY_SPECIFIED";
      case _Status.CustomFeeMustBePositive:
        return "CUSTOM_FEE_MUST_BE_POSITIVE";
      case _Status.TokenHasNoFeeScheduleKey:
        return "TOKEN_HAS_NO_FEE_SCHEDULE_KEY";
      case _Status.CustomFeeOutsideNumericRange:
        return "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE";
      case _Status.RoyaltyFractionCannotExceedOne:
        return "ROYALTY_FRACTION_CANNOT_EXCEED_ONE";
      case _Status.FractionalFeeMaxAmountLessThanMinAmount:
        return "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT";
      case _Status.CustomScheduleAlreadyHasNoFees:
        return "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES";
      case _Status.CustomFeeDenominationMustBeFungibleCommon:
        return "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON";
      case _Status.CustomFractionalFeeOnlyAllowedForFungibleCommon:
        return "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
      case _Status.InvalidCustomFeeScheduleKey:
        return "INVALID_CUSTOM_FEE_SCHEDULE_KEY";
      case _Status.InvalidTokenMintMetadata:
        return "INVALID_TOKEN_MINT_METADATA";
      case _Status.InvalidTokenBurnMetadata:
        return "INVALID_TOKEN_BURN_METADATA";
      case _Status.CurrentTreasuryStillOwnsNfts:
        return "CURRENT_TREASURY_STILL_OWNS_NFTS";
      case _Status.AccountStillOwnsNfts:
        return "ACCOUNT_STILL_OWNS_NFTS";
      case _Status.TreasuryMustOwnBurnedNft:
        return "TREASURY_MUST_OWN_BURNED_NFT";
      case _Status.AccountDoesNotOwnWipedNft:
        return "ACCOUNT_DOES_NOT_OWN_WIPED_NFT";
      case _Status.AccountAmountTransfersOnlyAllowedForFungibleCommon:
        return "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
      case _Status.MaxNftsInPriceRegimeHaveBeenMinted:
        return "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED";
      case _Status.PayerAccountDeleted:
        return "PAYER_ACCOUNT_DELETED";
      case _Status.CustomFeeChargingExceededMaxRecursionDepth:
        return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH";
      case _Status.CustomFeeChargingExceededMaxAccountAmounts:
        return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS";
      case _Status.InsufficientSenderAccountBalanceForCustomFee:
        return "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE";
      case _Status.SerialNumberLimitReached:
        return "SERIAL_NUMBER_LIMIT_REACHED";
      case _Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique:
        return "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
      case _Status.NoRemainingAutomaticAssociations:
        return "NO_REMAINING_AUTOMATIC_ASSOCIATIONS";
      case _Status.ExistingAutomaticAssociationsExceedGivenLimit:
        return "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT";
      case _Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit:
        return "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT";
      case _Status.TokenIsPaused:
        return "TOKEN_IS_PAUSED";
      case _Status.TokenHasNoPauseKey:
        return "TOKEN_HAS_NO_PAUSE_KEY";
      case _Status.InvalidPauseKey:
        return "INVALID_PAUSE_KEY";
      case _Status.FreezeUpdateFileDoesNotExist:
        return "FREEZE_UPDATE_FILE_DOES_NOT_EXIST";
      case _Status.FreezeUpdateFileHashDoesNotMatch:
        return "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH";
      case _Status.NoUpgradeHasBeenPrepared:
        return "NO_UPGRADE_HAS_BEEN_PREPARED";
      case _Status.NoFreezeIsScheduled:
        return "NO_FREEZE_IS_SCHEDULED";
      case _Status.UpdateFileHashChangedSincePrepareUpgrade:
        return "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE";
      case _Status.FreezeStartTimeMustBeFuture:
        return "FREEZE_START_TIME_MUST_BE_FUTURE";
      case _Status.PreparedUpdateFileIsImmutable:
        return "PREPARED_UPDATE_FILE_IS_IMMUTABLE";
      case _Status.FreezeAlreadyScheduled:
        return "FREEZE_ALREADY_SCHEDULED";
      case _Status.FreezeUpgradeInProgress:
        return "FREEZE_UPGRADE_IN_PROGRESS";
      case _Status.UpdateFileIdDoesNotMatchPrepared:
        return "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED";
      case _Status.UpdateFileHashDoesNotMatchPrepared:
        return "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED";
      case _Status.ConsensusGasExhausted:
        return "CONSENSUS_GAS_EXHAUSTED";
      case _Status.RevertedSuccess:
        return "REVERTED_SUCCESS";
      case _Status.MaxStorageInPriceRegimeHasBeenUsed:
        return "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED";
      case _Status.InvalidAliasKey:
        return "INVALID_ALIAS_KEY";
      case _Status.UnexpectedTokenDecimals:
        return "UNEXPECTED_TOKEN_DECIMALS";
      case _Status.InvalidProxyAccountId:
        return "INVALID_PROXY_ACCOUNT_ID";
      case _Status.InvalidTransferAccountId:
        return "INVALID_TRANSFER_ACCOUNT_ID";
      case _Status.InvalidFeeCollectorAccountId:
        return "INVALID_FEE_COLLECTOR_ACCOUNT_ID";
      case _Status.AliasIsImmutable:
        return "ALIAS_IS_IMMUTABLE";
      case _Status.SpenderAccountSameAsOwner:
        return "SPENDER_ACCOUNT_SAME_AS_OWNER";
      case _Status.AmountExceedsTokenMaxSupply:
        return "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY";
      case _Status.NegativeAllowanceAmount:
        return "NEGATIVE_ALLOWANCE_AMOUNT";
      case _Status.CannotApproveForAllFungibleCommon:
        return "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON";
      case _Status.SpenderDoesNotHaveAllowance:
        return "SPENDER_DOES_NOT_HAVE_ALLOWANCE";
      case _Status.AmountExceedsAllowance:
        return "AMOUNT_EXCEEDS_ALLOWANCE";
      case _Status.MaxAllowancesExceeded:
        return "MAX_ALLOWANCES_EXCEEDED";
      case _Status.EmptyAllowances:
        return "EMPTY_ALLOWANCES";
      case _Status.SpenderAccountRepeatedInAllowances:
        return "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES";
      case _Status.RepeatedSerialNumsInNftAllowances:
        return "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES";
      case _Status.FungibleTokenInNftAllowances:
        return "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES";
      case _Status.NftInFungibleTokenAllowances:
        return "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES";
      case _Status.InvalidAllowanceOwnerId:
        return "INVALID_ALLOWANCE_OWNER_ID";
      case _Status.InvalidAllowanceSpenderId:
        return "INVALID_ALLOWANCE_SPENDER_ID";
      case _Status.RepeatedAllowancesToDelete:
        return "REPEATED_ALLOWANCES_TO_DELETE";
      case _Status.InvalidDelegatingSpender:
        return "INVALID_DELEGATING_SPENDER";
      case _Status.DelegatingSpenderCannotGrantApproveForAll:
        return "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL";
      case _Status.DelegatingSpenderDoesNotHaveApproveForAll:
        return "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL";
      case _Status.ScheduleExpirationTimeTooFarInFuture:
        return "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE";
      case _Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime:
        return "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME";
      case _Status.ScheduleFutureThrottleExceeded:
        return "SCHEDULE_FUTURE_THROTTLE_EXCEEDED";
      case _Status.ScheduleFutureGasLimitExceeded:
        return "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED";
      case _Status.InvalidEthereumTransaction:
        return "INVALID_ETHEREUM_TRANSACTION";
      case _Status.WrongChainId:
        return "WRONG_CHAIN_ID";
      case _Status.WrongNonce:
        return "WRONG_NONCE";
      case _Status.AccessListUnsupported:
        return "ACCESS_LIST_UNSUPPORTED";
      case _Status.SchedulePendingExpiration:
        return "SCHEDULE_PENDING_EXPIRATION";
      case _Status.ContractIsTokenTreasury:
        return "CONTRACT_IS_TOKEN_TREASURY";
      case _Status.ContractHasNonZeroTokenBalances:
        return "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES";
      case _Status.ContractExpiredAndPendingRemoval:
        return "CONTRACT_EXPIRED_AND_PENDING_REMOVAL";
      case _Status.ContractHasNoAutoRenewAccount:
        return "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT";
      case _Status.PermanentRemovalRequiresSystemInitiation:
        return "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION";
      case _Status.ProxyAccountIdFieldIsDeprecated:
        return "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED";
      case _Status.SelfStakingIsNotAllowed:
        return "SELF_STAKING_IS_NOT_ALLOWED";
      case _Status.InvalidStakingId:
        return "INVALID_STAKING_ID";
      case _Status.StakingNotEnabled:
        return "STAKING_NOT_ENABLED";
      case _Status.InvalidPrngRange:
        return "INVALID_PRNG_RANGE";
      case _Status.MaxEntitiesInPriceRegimeHaveBeenCreated:
        return "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED";
      case _Status.InvalidFullPrefixSignatureForPrecompile:
        return "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE";
      case _Status.InsufficientBalancesForStorageRent:
        return "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT";
      case _Status.MaxChildRecordsExceeded:
        return "MAX_CHILD_RECORDS_EXCEEDED";
      case _Status.InsufficientBalancesForRenewalFees:
        return "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES";
      case _Status.TransactionHasUnknownFields:
        return "TRANSACTION_HAS_UNKNOWN_FIELDS";
      case _Status.AccountIsImmutable:
        return "ACCOUNT_IS_IMMUTABLE";
      case _Status.AliasAlreadyAssigned:
        return "ALIAS_ALREADY_ASSIGNED";
      case _Status.InvalidMetadataKey:
        return "INVALID_METADATA_KEY";
      case _Status.TokenHasNoMetadataKey:
        return "TOKEN_HAS_NO_METADATA_KEY";
      case _Status.MissingTokenMetadata:
        return "MISSING_TOKEN_METADATA";
      case _Status.MissingSerialNumbers:
        return "MISSING_SERIAL_NUMBERS";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @internal
   * @param {number} code
   * @returns {Status}
   */
  static _fromCode(code) {
    switch (code) {
      case 0:
        return _Status.Ok;
      case 1:
        return _Status.InvalidTransaction;
      case 2:
        return _Status.PayerAccountNotFound;
      case 3:
        return _Status.InvalidNodeAccount;
      case 4:
        return _Status.TransactionExpired;
      case 5:
        return _Status.InvalidTransactionStart;
      case 6:
        return _Status.InvalidTransactionDuration;
      case 7:
        return _Status.InvalidSignature;
      case 8:
        return _Status.MemoTooLong;
      case 9:
        return _Status.InsufficientTxFee;
      case 10:
        return _Status.InsufficientPayerBalance;
      case 11:
        return _Status.DuplicateTransaction;
      case 12:
        return _Status.Busy;
      case 13:
        return _Status.NotSupported;
      case 14:
        return _Status.InvalidFileId;
      case 15:
        return _Status.InvalidAccountId;
      case 16:
        return _Status.InvalidContractId;
      case 17:
        return _Status.InvalidTransactionId;
      case 18:
        return _Status.ReceiptNotFound;
      case 19:
        return _Status.RecordNotFound;
      case 20:
        return _Status.InvalidSolidityId;
      case 21:
        return _Status.Unknown;
      case 22:
        return _Status.Success;
      case 23:
        return _Status.FailInvalid;
      case 24:
        return _Status.FailFee;
      case 25:
        return _Status.FailBalance;
      case 26:
        return _Status.KeyRequired;
      case 27:
        return _Status.BadEncoding;
      case 28:
        return _Status.InsufficientAccountBalance;
      case 29:
        return _Status.InvalidSolidityAddress;
      case 30:
        return _Status.InsufficientGas;
      case 31:
        return _Status.ContractSizeLimitExceeded;
      case 32:
        return _Status.LocalCallModificationException;
      case 33:
        return _Status.ContractRevertExecuted;
      case 34:
        return _Status.ContractExecutionException;
      case 35:
        return _Status.InvalidReceivingNodeAccount;
      case 36:
        return _Status.MissingQueryHeader;
      case 37:
        return _Status.AccountUpdateFailed;
      case 38:
        return _Status.InvalidKeyEncoding;
      case 39:
        return _Status.NullSolidityAddress;
      case 40:
        return _Status.ContractUpdateFailed;
      case 41:
        return _Status.InvalidQueryHeader;
      case 42:
        return _Status.InvalidFeeSubmitted;
      case 43:
        return _Status.InvalidPayerSignature;
      case 44:
        return _Status.KeyNotProvided;
      case 45:
        return _Status.InvalidExpirationTime;
      case 46:
        return _Status.NoWaclKey;
      case 47:
        return _Status.FileContentEmpty;
      case 48:
        return _Status.InvalidAccountAmounts;
      case 49:
        return _Status.EmptyTransactionBody;
      case 50:
        return _Status.InvalidTransactionBody;
      case 51:
        return _Status.InvalidSignatureTypeMismatchingKey;
      case 52:
        return _Status.InvalidSignatureCountMismatchingKey;
      case 53:
        return _Status.EmptyLiveHashBody;
      case 54:
        return _Status.EmptyLiveHash;
      case 55:
        return _Status.EmptyLiveHashKeys;
      case 56:
        return _Status.InvalidLiveHashSize;
      case 57:
        return _Status.EmptyQueryBody;
      case 58:
        return _Status.EmptyLiveHashQuery;
      case 59:
        return _Status.LiveHashNotFound;
      case 60:
        return _Status.AccountIdDoesNotExist;
      case 61:
        return _Status.LiveHashAlreadyExists;
      case 62:
        return _Status.InvalidFileWacl;
      case 63:
        return _Status.SerializationFailed;
      case 64:
        return _Status.TransactionOversize;
      case 65:
        return _Status.TransactionTooManyLayers;
      case 66:
        return _Status.ContractDeleted;
      case 67:
        return _Status.PlatformNotActive;
      case 68:
        return _Status.KeyPrefixMismatch;
      case 69:
        return _Status.PlatformTransactionNotCreated;
      case 70:
        return _Status.InvalidRenewalPeriod;
      case 71:
        return _Status.InvalidPayerAccountId;
      case 72:
        return _Status.AccountDeleted;
      case 73:
        return _Status.FileDeleted;
      case 74:
        return _Status.AccountRepeatedInAccountAmounts;
      case 75:
        return _Status.SettingNegativeAccountBalance;
      case 76:
        return _Status.ObtainerRequired;
      case 77:
        return _Status.ObtainerSameContractId;
      case 78:
        return _Status.ObtainerDoesNotExist;
      case 79:
        return _Status.ModifyingImmutableContract;
      case 80:
        return _Status.FileSystemException;
      case 81:
        return _Status.AutorenewDurationNotInRange;
      case 82:
        return _Status.ErrorDecodingBytestring;
      case 83:
        return _Status.ContractFileEmpty;
      case 84:
        return _Status.ContractBytecodeEmpty;
      case 85:
        return _Status.InvalidInitialBalance;
      case 86:
        return _Status.InvalidReceiveRecordThreshold;
      case 87:
        return _Status.InvalidSendRecordThreshold;
      case 88:
        return _Status.AccountIsNotGenesisAccount;
      case 89:
        return _Status.PayerAccountUnauthorized;
      case 90:
        return _Status.InvalidFreezeTransactionBody;
      case 91:
        return _Status.FreezeTransactionBodyNotFound;
      case 92:
        return _Status.TransferListSizeLimitExceeded;
      case 93:
        return _Status.ResultSizeLimitExceeded;
      case 94:
        return _Status.NotSpecialAccount;
      case 95:
        return _Status.ContractNegativeGas;
      case 96:
        return _Status.ContractNegativeValue;
      case 97:
        return _Status.InvalidFeeFile;
      case 98:
        return _Status.InvalidExchangeRateFile;
      case 99:
        return _Status.InsufficientLocalCallGas;
      case 100:
        return _Status.EntityNotAllowedToDelete;
      case 101:
        return _Status.AuthorizationFailed;
      case 102:
        return _Status.FileUploadedProtoInvalid;
      case 103:
        return _Status.FileUploadedProtoNotSavedToDisk;
      case 104:
        return _Status.FeeScheduleFilePartUploaded;
      case 105:
        return _Status.ExchangeRateChangeLimitExceeded;
      case 106:
        return _Status.MaxContractStorageExceeded;
      case 107:
        return _Status.TransferAccountSameAsDeleteAccount;
      case 108:
        return _Status.TotalLedgerBalanceInvalid;
      case 110:
        return _Status.ExpirationReductionNotAllowed;
      case 111:
        return _Status.MaxGasLimitExceeded;
      case 112:
        return _Status.MaxFileSizeExceeded;
      case 113:
        return _Status.ReceiverSigRequired;
      case 150:
        return _Status.InvalidTopicId;
      case 155:
        return _Status.InvalidAdminKey;
      case 156:
        return _Status.InvalidSubmitKey;
      case 157:
        return _Status.Unauthorized;
      case 158:
        return _Status.InvalidTopicMessage;
      case 159:
        return _Status.InvalidAutorenewAccount;
      case 160:
        return _Status.AutorenewAccountNotAllowed;
      case 162:
        return _Status.TopicExpired;
      case 163:
        return _Status.InvalidChunkNumber;
      case 164:
        return _Status.InvalidChunkTransactionId;
      case 165:
        return _Status.AccountFrozenForToken;
      case 166:
        return _Status.TokensPerAccountLimitExceeded;
      case 167:
        return _Status.InvalidTokenId;
      case 168:
        return _Status.InvalidTokenDecimals;
      case 169:
        return _Status.InvalidTokenInitialSupply;
      case 170:
        return _Status.InvalidTreasuryAccountForToken;
      case 171:
        return _Status.InvalidTokenSymbol;
      case 172:
        return _Status.TokenHasNoFreezeKey;
      case 173:
        return _Status.TransfersNotZeroSumForToken;
      case 174:
        return _Status.MissingTokenSymbol;
      case 175:
        return _Status.TokenSymbolTooLong;
      case 176:
        return _Status.AccountKycNotGrantedForToken;
      case 177:
        return _Status.TokenHasNoKycKey;
      case 178:
        return _Status.InsufficientTokenBalance;
      case 179:
        return _Status.TokenWasDeleted;
      case 180:
        return _Status.TokenHasNoSupplyKey;
      case 181:
        return _Status.TokenHasNoWipeKey;
      case 182:
        return _Status.InvalidTokenMintAmount;
      case 183:
        return _Status.InvalidTokenBurnAmount;
      case 184:
        return _Status.TokenNotAssociatedToAccount;
      case 185:
        return _Status.CannotWipeTokenTreasuryAccount;
      case 186:
        return _Status.InvalidKycKey;
      case 187:
        return _Status.InvalidWipeKey;
      case 188:
        return _Status.InvalidFreezeKey;
      case 189:
        return _Status.InvalidSupplyKey;
      case 190:
        return _Status.MissingTokenName;
      case 191:
        return _Status.TokenNameTooLong;
      case 192:
        return _Status.InvalidWipingAmount;
      case 193:
        return _Status.TokenIsImmutable;
      case 194:
        return _Status.TokenAlreadyAssociatedToAccount;
      case 195:
        return _Status.TransactionRequiresZeroTokenBalances;
      case 196:
        return _Status.AccountIsTreasury;
      case 197:
        return _Status.TokenIdRepeatedInTokenList;
      case 198:
        return _Status.TokenTransferListSizeLimitExceeded;
      case 199:
        return _Status.EmptyTokenTransferBody;
      case 200:
        return _Status.EmptyTokenTransferAccountAmounts;
      case 201:
        return _Status.InvalidScheduleId;
      case 202:
        return _Status.ScheduleIsImmutable;
      case 203:
        return _Status.InvalidSchedulePayerId;
      case 204:
        return _Status.InvalidScheduleAccountId;
      case 205:
        return _Status.NoNewValidSignatures;
      case 206:
        return _Status.UnresolvableRequiredSigners;
      case 207:
        return _Status.ScheduledTransactionNotInWhitelist;
      case 208:
        return _Status.SomeSignaturesWereInvalid;
      case 209:
        return _Status.TransactionIdFieldNotAllowed;
      case 210:
        return _Status.IdenticalScheduleAlreadyCreated;
      case 211:
        return _Status.InvalidZeroByteInString;
      case 212:
        return _Status.ScheduleAlreadyDeleted;
      case 213:
        return _Status.ScheduleAlreadyExecuted;
      case 214:
        return _Status.MessageSizeTooLarge;
      case 215:
        return _Status.OperationRepeatedInBucketGroups;
      case 216:
        return _Status.BucketCapacityOverflow;
      case 217:
        return _Status.NodeCapacityNotSufficientForOperation;
      case 218:
        return _Status.BucketHasNoThrottleGroups;
      case 219:
        return _Status.ThrottleGroupHasZeroOpsPerSec;
      case 220:
        return _Status.SuccessButMissingExpectedOperation;
      case 221:
        return _Status.UnparseableThrottleDefinitions;
      case 222:
        return _Status.InvalidThrottleDefinitions;
      case 223:
        return _Status.AccountExpiredAndPendingRemoval;
      case 224:
        return _Status.InvalidTokenMaxSupply;
      case 225:
        return _Status.InvalidTokenNftSerialNumber;
      case 226:
        return _Status.InvalidNftId;
      case 227:
        return _Status.MetadataTooLong;
      case 228:
        return _Status.BatchSizeLimitExceeded;
      case 229:
        return _Status.InvalidQueryRange;
      case 230:
        return _Status.FractionDividesByZero;
      case 231:
        return _Status.InsufficientPayerBalanceForCustomFee;
      case 232:
        return _Status.CustomFeesListTooLong;
      case 233:
        return _Status.InvalidCustomFeeCollector;
      case 234:
        return _Status.InvalidTokenIdInCustomFees;
      case 235:
        return _Status.TokenNotAssociatedToFeeCollector;
      case 236:
        return _Status.TokenMaxSupplyReached;
      case 237:
        return _Status.SenderDoesNotOwnNftSerialNo;
      case 238:
        return _Status.CustomFeeNotFullySpecified;
      case 239:
        return _Status.CustomFeeMustBePositive;
      case 240:
        return _Status.TokenHasNoFeeScheduleKey;
      case 241:
        return _Status.CustomFeeOutsideNumericRange;
      case 242:
        return _Status.RoyaltyFractionCannotExceedOne;
      case 243:
        return _Status.FractionalFeeMaxAmountLessThanMinAmount;
      case 244:
        return _Status.CustomScheduleAlreadyHasNoFees;
      case 245:
        return _Status.CustomFeeDenominationMustBeFungibleCommon;
      case 246:
        return _Status.CustomFractionalFeeOnlyAllowedForFungibleCommon;
      case 247:
        return _Status.InvalidCustomFeeScheduleKey;
      case 248:
        return _Status.InvalidTokenMintMetadata;
      case 249:
        return _Status.InvalidTokenBurnMetadata;
      case 250:
        return _Status.CurrentTreasuryStillOwnsNfts;
      case 251:
        return _Status.AccountStillOwnsNfts;
      case 252:
        return _Status.TreasuryMustOwnBurnedNft;
      case 253:
        return _Status.AccountDoesNotOwnWipedNft;
      case 254:
        return _Status.AccountAmountTransfersOnlyAllowedForFungibleCommon;
      case 255:
        return _Status.MaxNftsInPriceRegimeHaveBeenMinted;
      case 256:
        return _Status.PayerAccountDeleted;
      case 257:
        return _Status.CustomFeeChargingExceededMaxRecursionDepth;
      case 258:
        return _Status.CustomFeeChargingExceededMaxAccountAmounts;
      case 259:
        return _Status.InsufficientSenderAccountBalanceForCustomFee;
      case 260:
        return _Status.SerialNumberLimitReached;
      case 261:
        return _Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique;
      case 262:
        return _Status.NoRemainingAutomaticAssociations;
      case 263:
        return _Status.ExistingAutomaticAssociationsExceedGivenLimit;
      case 264:
        return _Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit;
      case 265:
        return _Status.TokenIsPaused;
      case 266:
        return _Status.TokenHasNoPauseKey;
      case 267:
        return _Status.InvalidPauseKey;
      case 268:
        return _Status.FreezeUpdateFileDoesNotExist;
      case 269:
        return _Status.FreezeUpdateFileHashDoesNotMatch;
      case 270:
        return _Status.NoUpgradeHasBeenPrepared;
      case 271:
        return _Status.NoFreezeIsScheduled;
      case 272:
        return _Status.UpdateFileHashChangedSincePrepareUpgrade;
      case 273:
        return _Status.FreezeStartTimeMustBeFuture;
      case 274:
        return _Status.PreparedUpdateFileIsImmutable;
      case 275:
        return _Status.FreezeAlreadyScheduled;
      case 276:
        return _Status.FreezeUpgradeInProgress;
      case 277:
        return _Status.UpdateFileIdDoesNotMatchPrepared;
      case 278:
        return _Status.UpdateFileHashDoesNotMatchPrepared;
      case 279:
        return _Status.ConsensusGasExhausted;
      case 280:
        return _Status.RevertedSuccess;
      case 281:
        return _Status.MaxStorageInPriceRegimeHasBeenUsed;
      case 282:
        return _Status.InvalidAliasKey;
      case 283:
        return _Status.UnexpectedTokenDecimals;
      case 284:
        return _Status.InvalidProxyAccountId;
      case 285:
        return _Status.InvalidTransferAccountId;
      case 286:
        return _Status.InvalidFeeCollectorAccountId;
      case 287:
        return _Status.AliasIsImmutable;
      case 288:
        return _Status.SpenderAccountSameAsOwner;
      case 289:
        return _Status.AmountExceedsTokenMaxSupply;
      case 290:
        return _Status.NegativeAllowanceAmount;
      case 291:
        return _Status.CannotApproveForAllFungibleCommon;
      case 292:
        return _Status.SpenderDoesNotHaveAllowance;
      case 293:
        return _Status.AmountExceedsAllowance;
      case 294:
        return _Status.MaxAllowancesExceeded;
      case 295:
        return _Status.EmptyAllowances;
      case 296:
        return _Status.SpenderAccountRepeatedInAllowances;
      case 297:
        return _Status.RepeatedSerialNumsInNftAllowances;
      case 298:
        return _Status.FungibleTokenInNftAllowances;
      case 299:
        return _Status.NftInFungibleTokenAllowances;
      case 300:
        return _Status.InvalidAllowanceOwnerId;
      case 301:
        return _Status.InvalidAllowanceSpenderId;
      case 302:
        return _Status.RepeatedAllowancesToDelete;
      case 303:
        return _Status.InvalidDelegatingSpender;
      case 304:
        return _Status.DelegatingSpenderCannotGrantApproveForAll;
      case 305:
        return _Status.DelegatingSpenderDoesNotHaveApproveForAll;
      case 306:
        return _Status.ScheduleExpirationTimeTooFarInFuture;
      case 307:
        return _Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime;
      case 308:
        return _Status.ScheduleFutureThrottleExceeded;
      case 309:
        return _Status.ScheduleFutureGasLimitExceeded;
      case 310:
        return _Status.InvalidEthereumTransaction;
      case 311:
        return _Status.WrongChainId;
      case 312:
        return _Status.WrongNonce;
      case 313:
        return _Status.AccessListUnsupported;
      case 314:
        return _Status.SchedulePendingExpiration;
      case 315:
        return _Status.ContractIsTokenTreasury;
      case 316:
        return _Status.ContractHasNonZeroTokenBalances;
      case 317:
        return _Status.ContractExpiredAndPendingRemoval;
      case 318:
        return _Status.ContractHasNoAutoRenewAccount;
      case 319:
        return _Status.PermanentRemovalRequiresSystemInitiation;
      case 320:
        return _Status.ProxyAccountIdFieldIsDeprecated;
      case 321:
        return _Status.SelfStakingIsNotAllowed;
      case 322:
        return _Status.InvalidStakingId;
      case 323:
        return _Status.StakingNotEnabled;
      case 324:
        return _Status.InvalidPrngRange;
      case 325:
        return _Status.MaxEntitiesInPriceRegimeHaveBeenCreated;
      case 326:
        return _Status.InvalidFullPrefixSignatureForPrecompile;
      case 327:
        return _Status.InsufficientBalancesForStorageRent;
      case 328:
        return _Status.MaxChildRecordsExceeded;
      case 329:
        return _Status.InsufficientBalancesForRenewalFees;
      case 330:
        return _Status.TransactionHasUnknownFields;
      case 331:
        return _Status.AccountIsImmutable;
      case 332:
        return _Status.AliasAlreadyAssigned;
      case 333:
        return _Status.InvalidMetadataKey;
      case 334:
        return _Status.TokenHasNoMetadataKey;
      case 335:
        return _Status.MissingTokenMetadata;
      case 336:
        return _Status.MissingSerialNumbers;
      default:
        throw new Error(
          `(BUG) Status.fromCode() does not handle code: ${code}`
        );
    }
  }
  /**
   * @returns {HashgraphProto.proto.ResponseCodeEnum}
   */
  valueOf() {
    return this._code;
  }
};
Status.Ok = new Status(0);
Status.InvalidTransaction = new Status(1);
Status.PayerAccountNotFound = new Status(2);
Status.InvalidNodeAccount = new Status(3);
Status.TransactionExpired = new Status(4);
Status.InvalidTransactionStart = new Status(5);
Status.InvalidTransactionDuration = new Status(6);
Status.InvalidSignature = new Status(7);
Status.MemoTooLong = new Status(8);
Status.InsufficientTxFee = new Status(9);
Status.InsufficientPayerBalance = new Status(10);
Status.DuplicateTransaction = new Status(11);
Status.Busy = new Status(12);
Status.NotSupported = new Status(13);
Status.InvalidFileId = new Status(14);
Status.InvalidAccountId = new Status(15);
Status.InvalidContractId = new Status(16);
Status.InvalidTransactionId = new Status(17);
Status.ReceiptNotFound = new Status(18);
Status.RecordNotFound = new Status(19);
Status.InvalidSolidityId = new Status(20);
Status.Unknown = new Status(21);
Status.Success = new Status(22);
Status.FailInvalid = new Status(23);
Status.FailFee = new Status(24);
Status.FailBalance = new Status(25);
Status.KeyRequired = new Status(26);
Status.BadEncoding = new Status(27);
Status.InsufficientAccountBalance = new Status(28);
Status.InvalidSolidityAddress = new Status(29);
Status.InsufficientGas = new Status(30);
Status.ContractSizeLimitExceeded = new Status(31);
Status.LocalCallModificationException = new Status(32);
Status.ContractRevertExecuted = new Status(33);
Status.ContractExecutionException = new Status(34);
Status.InvalidReceivingNodeAccount = new Status(35);
Status.MissingQueryHeader = new Status(36);
Status.AccountUpdateFailed = new Status(37);
Status.InvalidKeyEncoding = new Status(38);
Status.NullSolidityAddress = new Status(39);
Status.ContractUpdateFailed = new Status(40);
Status.InvalidQueryHeader = new Status(41);
Status.InvalidFeeSubmitted = new Status(42);
Status.InvalidPayerSignature = new Status(43);
Status.KeyNotProvided = new Status(44);
Status.InvalidExpirationTime = new Status(45);
Status.NoWaclKey = new Status(46);
Status.FileContentEmpty = new Status(47);
Status.InvalidAccountAmounts = new Status(48);
Status.EmptyTransactionBody = new Status(49);
Status.InvalidTransactionBody = new Status(50);
Status.InvalidSignatureTypeMismatchingKey = new Status(51);
Status.InvalidSignatureCountMismatchingKey = new Status(52);
Status.EmptyLiveHashBody = new Status(53);
Status.EmptyLiveHash = new Status(54);
Status.EmptyLiveHashKeys = new Status(55);
Status.InvalidLiveHashSize = new Status(56);
Status.EmptyQueryBody = new Status(57);
Status.EmptyLiveHashQuery = new Status(58);
Status.LiveHashNotFound = new Status(59);
Status.AccountIdDoesNotExist = new Status(60);
Status.LiveHashAlreadyExists = new Status(61);
Status.InvalidFileWacl = new Status(62);
Status.SerializationFailed = new Status(63);
Status.TransactionOversize = new Status(64);
Status.TransactionTooManyLayers = new Status(65);
Status.ContractDeleted = new Status(66);
Status.PlatformNotActive = new Status(67);
Status.KeyPrefixMismatch = new Status(68);
Status.PlatformTransactionNotCreated = new Status(69);
Status.InvalidRenewalPeriod = new Status(70);
Status.InvalidPayerAccountId = new Status(71);
Status.AccountDeleted = new Status(72);
Status.FileDeleted = new Status(73);
Status.AccountRepeatedInAccountAmounts = new Status(74);
Status.SettingNegativeAccountBalance = new Status(75);
Status.ObtainerRequired = new Status(76);
Status.ObtainerSameContractId = new Status(77);
Status.ObtainerDoesNotExist = new Status(78);
Status.ModifyingImmutableContract = new Status(79);
Status.FileSystemException = new Status(80);
Status.AutorenewDurationNotInRange = new Status(81);
Status.ErrorDecodingBytestring = new Status(82);
Status.ContractFileEmpty = new Status(83);
Status.ContractBytecodeEmpty = new Status(84);
Status.InvalidInitialBalance = new Status(85);
Status.InvalidReceiveRecordThreshold = new Status(86);
Status.InvalidSendRecordThreshold = new Status(87);
Status.AccountIsNotGenesisAccount = new Status(88);
Status.PayerAccountUnauthorized = new Status(89);
Status.InvalidFreezeTransactionBody = new Status(90);
Status.FreezeTransactionBodyNotFound = new Status(91);
Status.TransferListSizeLimitExceeded = new Status(92);
Status.ResultSizeLimitExceeded = new Status(93);
Status.NotSpecialAccount = new Status(94);
Status.ContractNegativeGas = new Status(95);
Status.ContractNegativeValue = new Status(96);
Status.InvalidFeeFile = new Status(97);
Status.InvalidExchangeRateFile = new Status(98);
Status.InsufficientLocalCallGas = new Status(99);
Status.EntityNotAllowedToDelete = new Status(100);
Status.AuthorizationFailed = new Status(101);
Status.FileUploadedProtoInvalid = new Status(102);
Status.FileUploadedProtoNotSavedToDisk = new Status(103);
Status.FeeScheduleFilePartUploaded = new Status(104);
Status.ExchangeRateChangeLimitExceeded = new Status(105);
Status.MaxContractStorageExceeded = new Status(106);
Status.TransferAccountSameAsDeleteAccount = new Status(107);
Status.TotalLedgerBalanceInvalid = new Status(108);
Status.ExpirationReductionNotAllowed = new Status(110);
Status.MaxGasLimitExceeded = new Status(111);
Status.MaxFileSizeExceeded = new Status(112);
Status.ReceiverSigRequired = new Status(113);
Status.InvalidTopicId = new Status(150);
Status.InvalidAdminKey = new Status(155);
Status.InvalidSubmitKey = new Status(156);
Status.Unauthorized = new Status(157);
Status.InvalidTopicMessage = new Status(158);
Status.InvalidAutorenewAccount = new Status(159);
Status.AutorenewAccountNotAllowed = new Status(160);
Status.TopicExpired = new Status(162);
Status.InvalidChunkNumber = new Status(163);
Status.InvalidChunkTransactionId = new Status(164);
Status.AccountFrozenForToken = new Status(165);
Status.TokensPerAccountLimitExceeded = new Status(166);
Status.InvalidTokenId = new Status(167);
Status.InvalidTokenDecimals = new Status(168);
Status.InvalidTokenInitialSupply = new Status(169);
Status.InvalidTreasuryAccountForToken = new Status(170);
Status.InvalidTokenSymbol = new Status(171);
Status.TokenHasNoFreezeKey = new Status(172);
Status.TransfersNotZeroSumForToken = new Status(173);
Status.MissingTokenSymbol = new Status(174);
Status.TokenSymbolTooLong = new Status(175);
Status.AccountKycNotGrantedForToken = new Status(176);
Status.TokenHasNoKycKey = new Status(177);
Status.InsufficientTokenBalance = new Status(178);
Status.TokenWasDeleted = new Status(179);
Status.TokenHasNoSupplyKey = new Status(180);
Status.TokenHasNoWipeKey = new Status(181);
Status.InvalidTokenMintAmount = new Status(182);
Status.InvalidTokenBurnAmount = new Status(183);
Status.TokenNotAssociatedToAccount = new Status(184);
Status.CannotWipeTokenTreasuryAccount = new Status(185);
Status.InvalidKycKey = new Status(186);
Status.InvalidWipeKey = new Status(187);
Status.InvalidFreezeKey = new Status(188);
Status.InvalidSupplyKey = new Status(189);
Status.MissingTokenName = new Status(190);
Status.TokenNameTooLong = new Status(191);
Status.InvalidWipingAmount = new Status(192);
Status.TokenIsImmutable = new Status(193);
Status.TokenAlreadyAssociatedToAccount = new Status(194);
Status.TransactionRequiresZeroTokenBalances = new Status(195);
Status.AccountIsTreasury = new Status(196);
Status.TokenIdRepeatedInTokenList = new Status(197);
Status.TokenTransferListSizeLimitExceeded = new Status(198);
Status.EmptyTokenTransferBody = new Status(199);
Status.EmptyTokenTransferAccountAmounts = new Status(200);
Status.InvalidScheduleId = new Status(201);
Status.ScheduleIsImmutable = new Status(202);
Status.InvalidSchedulePayerId = new Status(203);
Status.InvalidScheduleAccountId = new Status(204);
Status.NoNewValidSignatures = new Status(205);
Status.UnresolvableRequiredSigners = new Status(206);
Status.ScheduledTransactionNotInWhitelist = new Status(207);
Status.SomeSignaturesWereInvalid = new Status(208);
Status.TransactionIdFieldNotAllowed = new Status(209);
Status.IdenticalScheduleAlreadyCreated = new Status(210);
Status.InvalidZeroByteInString = new Status(211);
Status.ScheduleAlreadyDeleted = new Status(212);
Status.ScheduleAlreadyExecuted = new Status(213);
Status.MessageSizeTooLarge = new Status(214);
Status.OperationRepeatedInBucketGroups = new Status(215);
Status.BucketCapacityOverflow = new Status(216);
Status.NodeCapacityNotSufficientForOperation = new Status(217);
Status.BucketHasNoThrottleGroups = new Status(218);
Status.ThrottleGroupHasZeroOpsPerSec = new Status(219);
Status.SuccessButMissingExpectedOperation = new Status(220);
Status.UnparseableThrottleDefinitions = new Status(221);
Status.InvalidThrottleDefinitions = new Status(222);
Status.AccountExpiredAndPendingRemoval = new Status(223);
Status.InvalidTokenMaxSupply = new Status(224);
Status.InvalidTokenNftSerialNumber = new Status(225);
Status.InvalidNftId = new Status(226);
Status.MetadataTooLong = new Status(227);
Status.BatchSizeLimitExceeded = new Status(228);
Status.InvalidQueryRange = new Status(229);
Status.FractionDividesByZero = new Status(230);
Status.InsufficientPayerBalanceForCustomFee = new Status(231);
Status.CustomFeesListTooLong = new Status(232);
Status.InvalidCustomFeeCollector = new Status(233);
Status.InvalidTokenIdInCustomFees = new Status(234);
Status.TokenNotAssociatedToFeeCollector = new Status(235);
Status.TokenMaxSupplyReached = new Status(236);
Status.SenderDoesNotOwnNftSerialNo = new Status(237);
Status.CustomFeeNotFullySpecified = new Status(238);
Status.CustomFeeMustBePositive = new Status(239);
Status.TokenHasNoFeeScheduleKey = new Status(240);
Status.CustomFeeOutsideNumericRange = new Status(241);
Status.RoyaltyFractionCannotExceedOne = new Status(242);
Status.FractionalFeeMaxAmountLessThanMinAmount = new Status(243);
Status.CustomScheduleAlreadyHasNoFees = new Status(244);
Status.CustomFeeDenominationMustBeFungibleCommon = new Status(245);
Status.CustomFractionalFeeOnlyAllowedForFungibleCommon = new Status(246);
Status.InvalidCustomFeeScheduleKey = new Status(247);
Status.InvalidTokenMintMetadata = new Status(248);
Status.InvalidTokenBurnMetadata = new Status(249);
Status.CurrentTreasuryStillOwnsNfts = new Status(250);
Status.AccountStillOwnsNfts = new Status(251);
Status.TreasuryMustOwnBurnedNft = new Status(252);
Status.AccountDoesNotOwnWipedNft = new Status(253);
Status.AccountAmountTransfersOnlyAllowedForFungibleCommon = new Status(254);
Status.MaxNftsInPriceRegimeHaveBeenMinted = new Status(255);
Status.PayerAccountDeleted = new Status(256);
Status.CustomFeeChargingExceededMaxRecursionDepth = new Status(257);
Status.CustomFeeChargingExceededMaxAccountAmounts = new Status(258);
Status.InsufficientSenderAccountBalanceForCustomFee = new Status(259);
Status.SerialNumberLimitReached = new Status(260);
Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique = new Status(261);
Status.NoRemainingAutomaticAssociations = new Status(262);
Status.ExistingAutomaticAssociationsExceedGivenLimit = new Status(263);
Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit = new Status(
  264
);
Status.TokenIsPaused = new Status(265);
Status.TokenHasNoPauseKey = new Status(266);
Status.InvalidPauseKey = new Status(267);
Status.FreezeUpdateFileDoesNotExist = new Status(268);
Status.FreezeUpdateFileHashDoesNotMatch = new Status(269);
Status.NoUpgradeHasBeenPrepared = new Status(270);
Status.NoFreezeIsScheduled = new Status(271);
Status.UpdateFileHashChangedSincePrepareUpgrade = new Status(272);
Status.FreezeStartTimeMustBeFuture = new Status(273);
Status.PreparedUpdateFileIsImmutable = new Status(274);
Status.FreezeAlreadyScheduled = new Status(275);
Status.FreezeUpgradeInProgress = new Status(276);
Status.UpdateFileIdDoesNotMatchPrepared = new Status(277);
Status.UpdateFileHashDoesNotMatchPrepared = new Status(278);
Status.ConsensusGasExhausted = new Status(279);
Status.RevertedSuccess = new Status(280);
Status.MaxStorageInPriceRegimeHasBeenUsed = new Status(281);
Status.InvalidAliasKey = new Status(282);
Status.UnexpectedTokenDecimals = new Status(283);
Status.InvalidProxyAccountId = new Status(284);
Status.InvalidTransferAccountId = new Status(285);
Status.InvalidFeeCollectorAccountId = new Status(286);
Status.AliasIsImmutable = new Status(287);
Status.SpenderAccountSameAsOwner = new Status(288);
Status.AmountExceedsTokenMaxSupply = new Status(289);
Status.NegativeAllowanceAmount = new Status(290);
Status.CannotApproveForAllFungibleCommon = new Status(291);
Status.SpenderDoesNotHaveAllowance = new Status(292);
Status.AmountExceedsAllowance = new Status(293);
Status.MaxAllowancesExceeded = new Status(294);
Status.EmptyAllowances = new Status(295);
Status.SpenderAccountRepeatedInAllowances = new Status(296);
Status.RepeatedSerialNumsInNftAllowances = new Status(297);
Status.FungibleTokenInNftAllowances = new Status(298);
Status.NftInFungibleTokenAllowances = new Status(299);
Status.InvalidAllowanceOwnerId = new Status(300);
Status.InvalidAllowanceSpenderId = new Status(301);
Status.RepeatedAllowancesToDelete = new Status(302);
Status.InvalidDelegatingSpender = new Status(303);
Status.DelegatingSpenderCannotGrantApproveForAll = new Status(304);
Status.DelegatingSpenderDoesNotHaveApproveForAll = new Status(305);
Status.ScheduleExpirationTimeTooFarInFuture = new Status(306);
Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime = new Status(307);
Status.ScheduleFutureThrottleExceeded = new Status(308);
Status.ScheduleFutureGasLimitExceeded = new Status(309);
Status.InvalidEthereumTransaction = new Status(310);
Status.WrongChainId = new Status(311);
Status.WrongNonce = new Status(312);
Status.AccessListUnsupported = new Status(313);
Status.SchedulePendingExpiration = new Status(314);
Status.ContractIsTokenTreasury = new Status(315);
Status.ContractHasNonZeroTokenBalances = new Status(316);
Status.ContractExpiredAndPendingRemoval = new Status(317);
Status.ContractHasNoAutoRenewAccount = new Status(318);
Status.PermanentRemovalRequiresSystemInitiation = new Status(319);
Status.ProxyAccountIdFieldIsDeprecated = new Status(320);
Status.SelfStakingIsNotAllowed = new Status(321);
Status.InvalidStakingId = new Status(322);
Status.StakingNotEnabled = new Status(323);
Status.InvalidPrngRange = new Status(324);
Status.MaxEntitiesInPriceRegimeHaveBeenCreated = new Status(325);
Status.InvalidFullPrefixSignatureForPrecompile = new Status(326);
Status.InsufficientBalancesForStorageRent = new Status(327);
Status.MaxChildRecordsExceeded = new Status(328);
Status.InsufficientBalancesForRenewalFees = new Status(329);
Status.TransactionHasUnknownFields = new Status(330);
Status.AccountIsImmutable = new Status(331);
Status.AliasAlreadyAssigned = new Status(332);
Status.InvalidMetadataKey = new Status(333);
Status.TokenHasNoMetadataKey = new Status(334);
Status.MissingTokenMetadata = new Status(335);
Status.MissingSerialNumbers = new Status(336);

// node_modules/@hashgraph/sdk/src/account/AccountId.js
var import_long5 = __toESM(require_long(), 1);
var HashgraphProto2 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/EvmAddress.js
var EvmAddress = class _EvmAddress extends Key2 {
  /**
   * @internal
   * @param {Uint8Array} bytes
   */
  constructor(bytes3) {
    super();
    this._bytes = bytes3;
  }
  /**
   * @param {string} text
   * @returns {EvmAddress}
   */
  static fromString(text) {
    return new _EvmAddress(decode(text));
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {EvmAddress}
   */
  static fromBytes(bytes3) {
    return new _EvmAddress(bytes3);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return this._bytes;
  }
  /**
   * @returns {string}
   */
  toString() {
    return encode(this._bytes);
  }
  /**
   * @param {EvmAddress} other
   * @returns {boolean}
   */
  equals(other) {
    return arrayEqual(this._bytes, other._bytes);
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountId.js
var AccountId = class _AccountId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   * @param {(PublicKey)=} aliasKey
   * @param {(EvmAddress)=} evmAddress
   */
  constructor(props, realm, num, aliasKey, evmAddress) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this.aliasKey = aliasKey != null ? aliasKey : null;
    this.evmAddress = evmAddress != null ? evmAddress : null;
    this._checksum = null;
  }
  /**
   * @description Accepts the following formats as string:
   *      - as stand alone nubmers
   *      - as shard.realm.num
   *      - as shard.realm.hex (wo 0x prefix)
   *      - hex (w/wo 0x prefix)
   * @param {string} text
   * @returns {AccountId}
   */
  static fromString(text) {
    let shard = import_long5.default.ZERO;
    let realm = import_long5.default.ZERO;
    let num = import_long5.default.ZERO;
    let aliasKey = void 0;
    let evmAddress = void 0;
    if (text.startsWith("0x") && text.length == 42 || text.length == 40) {
      evmAddress = EvmAddress.fromString(text);
    } else {
      const result = fromStringSplitter(text);
      if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
        throw new Error("invalid format for entity ID");
      }
      if (result.shard != null)
        shard = import_long5.default.fromString(result.shard);
      if (result.realm != null)
        realm = import_long5.default.fromString(result.realm);
      if (result.numOrHex.length < 20) {
        num = import_long5.default.fromString(result.numOrHex);
      } else if (result.numOrHex.length == 40) {
        evmAddress = EvmAddress.fromString(result.numOrHex);
      } else {
        aliasKey = PublicKey2.fromString(result.numOrHex);
      }
    }
    return new _AccountId(shard, realm, num, aliasKey, evmAddress);
  }
  /**
   * @description This handles both long-zero format and evm address format addresses.
   * If an actual evm address is passed, please use `AccountId.populateAccountNum(client)` method
   * to get the actual `num` value, since there is no cryptographic relation to the evm address
   * and cannot be populated directly
   * @param {Long | number} shard
   * @param {Long | number} realm
   * @param {EvmAddress | string} evmAddress
   * @returns {AccountId}
   */
  static fromEvmAddress(shard, realm, evmAddress) {
    const evmAddressObj = typeof evmAddress === "string" ? EvmAddress.fromString(evmAddress) : evmAddress;
    if (isLongZeroAddress(evmAddressObj.toBytes())) {
      return this.fromSolidityAddress(evmAddressObj.toString());
    } else {
      return new _AccountId(shard, realm, 0, void 0, evmAddressObj);
    }
  }
  /**
   * @deprecated - Use `fromEvmAddress` instead
   * @summary Accepts an evm address only as `EvmAddress` type
   * @param {EvmAddress} evmAddress
   * @returns {AccountId}
   */
  static fromEvmPublicAddress(evmAddress) {
    return new _AccountId(0, 0, 0, void 0, evmAddress);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IAccountID} id
   * @returns {AccountId}
   */
  static _fromProtobuf(id2) {
    let aliasKey = void 0;
    let evmAddress = void 0;
    if (id2.alias != null) {
      if (id2.alias.length === 20) {
        evmAddress = EvmAddress.fromBytes(id2.alias);
      } else {
        aliasKey = Key2._fromProtobufKey(
          HashgraphProto2.proto.Key.decode(id2.alias)
        );
      }
    }
    if (!(aliasKey instanceof PublicKey2)) {
      aliasKey = void 0;
    }
    return new _AccountId(
      id2.shardNum != null ? id2.shardNum : 0,
      id2.realmNum != null ? id2.realmNum : 0,
      id2.accountNum != null ? id2.accountNum : 0,
      aliasKey,
      evmAddress
    );
  }
  /**
   * @returns {string | null}
   */
  get checksum() {
    return this._checksum;
  }
  /**
   * @returns {?EvmAddress}
   */
  getEvmAddress() {
    return this.evmAddress;
  }
  /**
   * @description Gets the actual `num` field of the `AccountId` from the Mirror Node.
   * Should be used after generating `AccountId.fromEvmAddress()` because it sets the `num` field to `0`
   * automatically since there is no connection between the `num` and the `evmAddress`
   * @param {Client} client
   * @returns {Promise<AccountId>}
   */
  async populateAccountNum(client) {
    if (this.evmAddress === null) {
      throw new Error("field `evmAddress` should not be null");
    }
    const mirrorUrl = client.mirrorNetwork[0].slice(
      0,
      client.mirrorNetwork[0].indexOf(":")
    );
    await new Promise((resolve) => {
      setTimeout(resolve, 3e3);
    });
    const url = `https://${mirrorUrl}/api/v1/accounts/${this.evmAddress.toString()}`;
    const mirrorAccountId = (await axios_default.get(url)).data.account;
    this.num = import_long5.default.fromString(
      mirrorAccountId.slice(mirrorAccountId.lastIndexOf(".") + 1)
    );
    return this;
  }
  /**
   * @description Populates `evmAddress` field of the `AccountId` extracted from the Mirror Node.
   * @param {Client} client
   * @returns {Promise<AccountId>}
   */
  async populateAccountEvmAddress(client) {
    if (this.num === null) {
      throw new Error("field `num` should not be null");
    }
    const mirrorUrl = client.mirrorNetwork[0].slice(
      0,
      client.mirrorNetwork[0].indexOf(":")
    );
    await new Promise((resolve) => {
      setTimeout(resolve, 3e3);
    });
    const url = `https://${mirrorUrl}/api/v1/accounts/${this.num.toString()}`;
    const mirrorAccountId = (await axios_default.get(url)).data.evm_address;
    this.evmAddress = EvmAddress.fromString(mirrorAccountId);
    return this;
  }
  /**
   * @deprecated - Use `validateChecksum` instead
   * @param {Client} client
   */
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  /**
   * @param {Client} client
   */
  validateChecksum(client) {
    if (this.aliasKey != null) {
      throw new Error(
        "cannot calculate checksum with an account ID that has a aliasKey"
      );
    }
    validateChecksum(
      this.shard,
      this.realm,
      this.num,
      this._checksum,
      client
    );
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AccountId}
   */
  static fromBytes(bytes3) {
    return _AccountId._fromProtobuf(
      HashgraphProto2.proto.AccountID.decode(bytes3)
    );
  }
  /**
   * @deprecated - Use `fromEvmAddress` instead
   * @param {string} address
   * @returns {AccountId}
   */
  static fromSolidityAddress(address) {
    if (isLongZeroAddress(decode(address))) {
      return new _AccountId(...fromSolidityAddress(address));
    } else {
      return this.fromEvmAddress(0, 0, address);
    }
  }
  /**
   * @returns {string}
   */
  toSolidityAddress() {
    if (this.evmAddress != null) {
      return this.evmAddress.toString();
    } else if (this.aliasKey != null && this.aliasKey._key._type == "secp256k1") {
      return this.aliasKey.toEvmAddress();
    } else {
      return toSolidityAddress([
        this.shard,
        this.realm,
        this.num
      ]);
    }
  }
  //TODO remove the comments after we get to HIP-631
  /**
   * @internal
   * @returns {HashgraphProto.proto.IAccountID}
   */
  _toProtobuf() {
    let alias = null;
    if (this.aliasKey != null) {
      alias = HashgraphProto2.proto.Key.encode(
        this.aliasKey._toProtobufKey()
      ).finish();
    } else if (this.evmAddress != null) {
      alias = this.evmAddress._bytes;
    }
    return {
      alias,
      accountNum: this.aliasKey != null ? null : this.num,
      shardNum: this.shard,
      realmNum: this.realm
      //evmAddress,
    };
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto2.proto.AccountID.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {string}
   */
  toString() {
    let account = this.num.toString();
    if (this.aliasKey != null) {
      account = this.aliasKey.toString();
    } else if (this.evmAddress != null) {
      account = this.evmAddress.toString();
    }
    return `${this.shard.toString()}.${this.realm.toString()}.${account}`;
  }
  /**
   * @param {Client} client
   * @returns {string}
   */
  toStringWithChecksum(client) {
    if (this.aliasKey != null) {
      throw new Error(
        "cannot calculate checksum with an account ID that has a aliasKey"
      );
    }
    return toStringWithChecksum(this.toString(), client);
  }
  /**
   * @param {this} other
   * @returns {boolean}
   */
  equals(other) {
    let account = false;
    if (this.aliasKey != null && other.aliasKey != null) {
      account = this.aliasKey.equals(other.aliasKey);
    } else if (this.evmAddress != null && other.evmAddress != null) {
      account = this.evmAddress.equals(other.evmAddress);
    } else if (this.aliasKey == null && other.aliasKey == null && this.evmAddress == null && other.evmAddress == null) {
      account = this.num.eq(other.num);
    }
    return this.shard.eq(other.shard) && this.realm.eq(other.realm) && account;
  }
  /**
   * @returns {AccountId}
   */
  clone() {
    const id2 = new _AccountId(this);
    id2._checksum = this._checksum;
    id2.aliasKey = this.aliasKey;
    id2.evmAddress = this.evmAddress;
    return id2;
  }
  /**
   * @param {AccountId} other
   * @returns {number}
   */
  compare(other) {
    let comparison = this.shard.compare(other.shard);
    if (comparison != 0) {
      return comparison;
    }
    comparison = this.realm.compare(other.realm);
    if (comparison != 0) {
      return comparison;
    }
    if (this.aliasKey != null && other.aliasKey != null) {
      const t = this.aliasKey.toString();
      const o = other.aliasKey.toString();
      if (t > o) {
        return 1;
      } else if (t < o) {
        return -1;
      } else {
        return 0;
      }
    } else if (this.evmAddress != null && other.evmAddress != null) {
      const t = this.evmAddress.toString();
      const o = other.evmAddress.toString();
      if (t > o) {
        return 1;
      } else if (t < o) {
        return -1;
      } else {
        return 0;
      }
    } else if (this.aliasKey == null && other.aliasKey == null && this.evmAddress == null && other.evmAddress == null) {
      return this.num.compare(other.num);
    } else {
      return 1;
    }
  }
};
Cache_default2.setAccountIdConstructor(
  (shard, realm, key) => new AccountId(shard, realm, import_long5.default.ZERO, key)
);

// node_modules/@hashgraph/sdk/src/grpc/GrpcStatus.js
var GrpcStatus = class _GrpcStatus {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {number} code
   * @returns {GrpcStatus}
   */
  static _fromValue(code) {
    switch (code) {
      case 0:
        return _GrpcStatus.Ok;
      case 1:
        return _GrpcStatus.Cancelled;
      case 2:
        return _GrpcStatus.Unknown;
      case 3:
        return _GrpcStatus.InvalidArgument;
      case 4:
        return _GrpcStatus.DeadlineExceeded;
      case 5:
        return _GrpcStatus.NotFound;
      case 6:
        return _GrpcStatus.AlreadyExists;
      case 7:
        return _GrpcStatus.PermissionDenied;
      case 8:
        return _GrpcStatus.ResourceExhausted;
      case 9:
        return _GrpcStatus.FailedPrecondition;
      case 10:
        return _GrpcStatus.Aborted;
      case 11:
        return _GrpcStatus.OutOfRange;
      case 12:
        return _GrpcStatus.Unimplemented;
      case 13:
        return _GrpcStatus.Internal;
      case 14:
        return _GrpcStatus.Unavailable;
      case 15:
        return _GrpcStatus.DataLoss;
      case 16:
        return _GrpcStatus.Unauthenticated;
      case 17:
        return _GrpcStatus.Timeout;
      case 18:
        return _GrpcStatus.GrpcWeb;
      default:
        throw new Error(
          "(BUG) non-exhaustive GrpcStatus switch statement"
        );
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _GrpcStatus.Ok:
        return "OK";
      case _GrpcStatus.Cancelled:
        return "CANCELLED";
      case _GrpcStatus.Unknown:
        return "UNKNOWN";
      case _GrpcStatus.InvalidArgument:
        return "INVALID_ARGUMENT";
      case _GrpcStatus.DeadlineExceeded:
        return "DEADLINE_EXCEEDED";
      case _GrpcStatus.NotFound:
        return "NOT_FOUND";
      case _GrpcStatus.AlreadyExists:
        return "ALREADY_EXISTS";
      case _GrpcStatus.PermissionDenied:
        return "PERMISSION_DENIED";
      case _GrpcStatus.Unauthenticated:
        return "UNAUTHENTICATED";
      case _GrpcStatus.ResourceExhausted:
        return "RESOURCE_EXHAUSTED";
      case _GrpcStatus.FailedPrecondition:
        return "FAILED_PRECONDITION";
      case _GrpcStatus.Aborted:
        return "ABORTED";
      case _GrpcStatus.OutOfRange:
        return "OUT_OF_RANGE";
      case _GrpcStatus.Unimplemented:
        return "UNIMPLEMENTED";
      case _GrpcStatus.Internal:
        return "INTERNAL";
      case _GrpcStatus.Unavailable:
        return "UNAVAILABLE";
      case _GrpcStatus.DataLoss:
        return "DATA_LOSS";
      case _GrpcStatus.Timeout:
        return "TIMEOUT";
      case _GrpcStatus.GrpcWeb:
        return "GRPC_WEB";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @returns {number}
   */
  valueOf() {
    return this._code;
  }
};
GrpcStatus.Ok = new GrpcStatus(0);
GrpcStatus.Cancelled = new GrpcStatus(1);
GrpcStatus.Unknown = new GrpcStatus(2);
GrpcStatus.InvalidArgument = new GrpcStatus(3);
GrpcStatus.DeadlineExceeded = new GrpcStatus(4);
GrpcStatus.NotFound = new GrpcStatus(5);
GrpcStatus.AlreadyExists = new GrpcStatus(6);
GrpcStatus.PermissionDenied = new GrpcStatus(7);
GrpcStatus.ResourceExhausted = new GrpcStatus(8);
GrpcStatus.FailedPrecondition = new GrpcStatus(9);
GrpcStatus.Aborted = new GrpcStatus(10);
GrpcStatus.OutOfRange = new GrpcStatus(11);
GrpcStatus.Unimplemented = new GrpcStatus(12);
GrpcStatus.Internal = new GrpcStatus(13);
GrpcStatus.Unavailable = new GrpcStatus(14);
GrpcStatus.DataLoss = new GrpcStatus(15);
GrpcStatus.Unauthenticated = new GrpcStatus(16);
GrpcStatus.Timeout = new GrpcStatus(17);
GrpcStatus.GrpcWeb = new GrpcStatus(18);

// node_modules/@hashgraph/sdk/src/grpc/GrpcServiceError.js
var GrpcServiceError = class _GrpcServiceError extends Error {
  /**
   * @param {GrpcStatus} status
   */
  constructor(status) {
    super(`gRPC service failed with status: ${status.toString()}`);
    this.status = status;
    this.name = "GrpcServiceError";
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, _GrpcServiceError);
    }
  }
  /**
   * @param {Error & { code?: number; details?: string }} obj
   * @returns {Error}
   */
  static _fromResponse(obj) {
    if (obj.code != null && obj.details != null) {
      const status = GrpcStatus._fromValue(obj.code);
      const err = new _GrpcServiceError(status);
      err.message = obj.details;
      return err;
    } else {
      return (
        /** @type {Error} */
        obj
      );
    }
  }
};

// node_modules/@hashgraph/sdk/src/transaction/List.js
var List = class _List {
  constructor() {
    this.list = [];
    this.locked = false;
    this.index = 0;
  }
  /**
   * Overwrite the entire list.
   *
   * @throws if the list is locked
   * @param {T[]} list
   * @returns {this}
   */
  setList(list) {
    if (this.locked) {
      throw new Error("list is locked");
    }
    this.list = list;
    this.index = 0;
    return this;
  }
  /**
   * Push items to the end of the list.
   *
   * @throws if the list is locked
   * @param {T[]} items
   * @returns {this}
   */
  push(...items) {
    if (this.locked) {
      throw new Error("list is locked");
    }
    this.list.push(...items);
    return this;
  }
  /**
   * Locks the list.
   *
   * @returns {this}
   */
  setLocked() {
    this.locked = true;
    return this;
  }
  /**
   * Clear the list
   */
  clear() {
    this.list = [];
    this.index = 0;
  }
  /**
   * The get value at a particular index.
   *
   * @param {number} index
   * @returns {T}
   */
  get(index) {
    return this.list[index];
  }
  /**
   * Set value at index
   *
   * @param {number} index
   * @param {T} item
   * @returns {this}
   */
  set(index, item) {
    if (index === this.length) {
      this.list.push(item);
    } else {
      this.list[index] = item;
    }
    return this;
  }
  /**
   * Set value at index if it's not already set
   *
   * @throws if the list is locked
   * @param {number} index
   * @param {() => T} lambda
   * @returns {this}
   */
  setIfAbsent(index, lambda) {
    if (index == this.length || this.list[index] == null) {
      this.set(index, lambda());
    }
    return this;
  }
  /**
   * Get the current value, and advance the index
   *
   * @returns {T}
   */
  get next() {
    return this.get(this.advance());
  }
  /**
   * Get the current value.
   *
   * @returns {T}
   */
  get current() {
    return this.get(this.index);
  }
  /**
   * Advance the index to the next element in a round robin fashion
   *
   * @returns {number}
   */
  advance() {
    const index = this.index;
    this.index = (this.index + 1) % this.list.length;
    return index;
  }
  /**
   * Is the list empty
   *
   * @returns {boolean}
   */
  get isEmpty() {
    return this.length === 0;
  }
  /**
   * Get the length of the list
   *
   * @returns {number}
   */
  get length() {
    return this.list.length;
  }
  /**
   * Shallow clone this list.
   * Perhaps we should explicitly call this `shallowClone()` since it doesn't
   * clone the list inside?
   *
   * @returns {List<T>}
   */
  clone() {
    const list = new _List();
    list.list = this.list;
    list.locked = this.locked;
    return list;
  }
};

// node_modules/@hashgraph/sdk/src/http/HttpStatus.js
var HttpStatus = class _HttpStatus {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {number} code
   * @returns {HttpStatus}
   */
  static _fromValue(code) {
    return new _HttpStatus(code);
  }
  /**
   * @returns {string}
   */
  toString() {
    return this._code.toString();
  }
  /**
   * @returns {number}
   */
  valueOf() {
    return this._code;
  }
};

// node_modules/@hashgraph/sdk/src/http/HttpError.js
var HttpError = class _HttpError extends Error {
  /**
   * @param {HttpStatus} status
   */
  constructor(status) {
    super(`failed with error code: ${status.toString()}`);
    this.status = status;
    this.name = "HttpError";
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, _HttpError);
    }
  }
};

// node_modules/@hashgraph/sdk/src/Executable.js
var ExecutionState = {
  Finished: "Finished",
  Retry: "Retry",
  Error: "Error"
};
var RST_STREAM = /\brst[^0-9a-zA-Z]stream\b/i;
var Executable = class {
  constructor() {
    this._maxAttempts = 10;
    this._nodeAccountIds = new List();
    this._signOnDemand = false;
    this._minBackoff = null;
    this._maxBackoff = 8e3;
    this._operator = null;
    this._requestTimeout = null;
    this._grpcDeadline = null;
    this._logger = null;
  }
  /**
   * Get the list of node account IDs on the request. If no nodes are set, then null is returned.
   * The reasoning for this is simply "legacy behavior".
   *
   * @returns {?AccountId[]}
   */
  get nodeAccountIds() {
    if (this._nodeAccountIds.isEmpty) {
      return null;
    } else {
      this._nodeAccountIds.setLocked();
      return this._nodeAccountIds.list;
    }
  }
  /**
   * Set the node account IDs on the request
   *
   * @param {AccountId[]} nodeIds
   * @returns {this}
   */
  setNodeAccountIds(nodeIds) {
    this._nodeAccountIds.setList(nodeIds).setLocked();
    return this;
  }
  /**
   * @deprecated
   * @returns {number}
   */
  get maxRetries() {
    console.warn("Deprecated: use maxAttempts instead");
    return this.maxAttempts;
  }
  /**
   * @param {number} maxRetries
   * @returns {this}
   */
  setMaxRetries(maxRetries) {
    console.warn("Deprecated: use setMaxAttempts() instead");
    return this.setMaxAttempts(maxRetries);
  }
  /**
   * Get the max attempts on the request
   *
   * @returns {number}
   */
  get maxAttempts() {
    return this._maxAttempts;
  }
  /**
   * Set the max attempts on the request
   *
   * @param {number} maxAttempts
   * @returns {this}
   */
  setMaxAttempts(maxAttempts) {
    this._maxAttempts = maxAttempts;
    return this;
  }
  /**
   * Get the grpc deadline
   *
   * @returns {?number}
   */
  get grpcDeadline() {
    return this._grpcDeadline;
  }
  /**
   * Set the grpc deadline
   *
   * @param {number} grpcDeadline
   * @returns {this}
   */
  setGrpcDeadline(grpcDeadline) {
    this._grpcDeadline = grpcDeadline;
    return this;
  }
  /**
   * Set the min backoff for the request
   *
   * @param {number} minBackoff
   * @returns {this}
   */
  setMinBackoff(minBackoff) {
    if (minBackoff == null) {
      throw new Error("minBackoff cannot be null.");
    } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {
      throw new Error("minBackoff cannot be larger than maxBackoff.");
    }
    this._minBackoff = minBackoff;
    return this;
  }
  /**
   * Get the min backoff
   *
   * @returns {number | null}
   */
  get minBackoff() {
    return this._minBackoff;
  }
  /**
   * Set the max backoff for the request
   *
   * @param {?number} maxBackoff
   * @returns {this}
   */
  setMaxBackoff(maxBackoff) {
    if (maxBackoff == null) {
      throw new Error("maxBackoff cannot be null.");
    } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {
      throw new Error("maxBackoff cannot be smaller than minBackoff.");
    }
    this._maxBackoff = maxBackoff;
    return this;
  }
  /**
   * Get the max backoff
   *
   * @returns {number}
   */
  get maxBackoff() {
    return this._maxBackoff;
  }
  /**
   * This method is responsible for doing any work before the executing process begins.
   * For paid queries this will result in executing a cost query, for transactions this
   * will make sure we save the operator and sign any requests that need to be signed
   * in case signing on demand is disabled.
   *
   * @abstract
   * @protected
   * @param {import("./client/Client.js").default<Channel, *>} client
   * @returns {Promise<void>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _beforeExecute(client) {
    throw new Error("not implemented");
  }
  /**
   * Create a protobuf request which will be passed into the `_execute()` method
   *
   * @abstract
   * @protected
   * @returns {Promise<RequestT>}
   */
  _makeRequestAsync() {
    throw new Error("not implemented");
  }
  /**
   * This name is a bit wrong now, but the purpose of this method is to map the
   * request and response into an error. This method will only be called when
   * `_shouldRetry` returned `ExecutionState.Error`
   *
   * @abstract
   * @internal
   * @param {RequestT} request
   * @param {ResponseT} response
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapStatusError(request, response) {
    throw new Error("not implemented");
  }
  /**
   * Map the request, response, and the node account ID used for this attempt into a response.
   * This method will only be called when `_shouldRetry` returned `ExecutionState.Finished`
   *
   * @abstract
   * @protected
   * @param {ResponseT} response
   * @param {AccountId} nodeAccountId
   * @param {RequestT} request
   * @returns {Promise<OutputT>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    throw new Error("not implemented");
  }
  /**
   * Perform a single grpc call with the given request. Each request has it's own
   * required service so we just pass in channel, and it'$ the request's responsiblity
   * to use the right service and call the right grpc method.
   *
   * @abstract
   * @internal
   * @param {Channel} channel
   * @param {RequestT} request
   * @returns {Promise<ResponseT>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _execute(channel, request) {
    throw new Error("not implemented");
  }
  /**
   * Return the current transaction ID for the request. All requests which are
   * use the same transaction ID for each node, but the catch is that `Transaction`
   * implicitly supports chunked transactions. Meaning there could be multiple
   * transaction IDs stored in the request, and a different transaction ID will be used
   * on subsequent calls to `execute()`
   *
   * FIXME: This method can most likely be removed, although some further inspection
   * is required.
   *
   * @abstract
   * @protected
   * @returns {TransactionId}
   */
  _getTransactionId() {
    throw new Error("not implemented");
  }
  /**
   * Return the log ID for this particular request
   *
   * Log IDs are simply a string constructed to make it easy to track each request's
   * execution even when mulitple requests are executing in parallel. Typically, this
   * method returns the format of `[<request type>.<timestamp of the transaction ID>]`
   *
   * Maybe we should deduplicate this using ${this.consturtor.name}
   *
   * @abstract
   * @internal
   * @returns {string}
   */
  _getLogId() {
    throw new Error("not implemented");
  }
  /**
   * Serialize the request into bytes
   *
   * @abstract
   * @param {RequestT} request
   * @returns {Uint8Array}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _requestToBytes(request) {
    throw new Error("not implemented");
  }
  /**
   * Serialize the response into bytes
   *
   * @abstract
   * @param {ResponseT} response
   * @returns {Uint8Array}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _responseToBytes(response) {
    throw new Error("not implemented");
  }
  /**
   * Advance the request to the next node
   *
   * FIXME: This method used to perform different code depending on if we're
   * executing a query or transaction, but that is no longer the case
   * and hence could be removed.
   *
   * @protected
   * @returns {void}
   */
  _advanceRequest() {
    this._nodeAccountIds.advance();
  }
  /**
   * Determine if we should continue the execution process, error, or finish.
   *
   * FIXME: This method should really be called something else. Initially it returned
   * a boolean so `shouldRetry` made sense, but now it returns an enum, so the name
   * no longer makes sense.
   *
   * @abstract
   * @protected
   * @param {RequestT} request
   * @param {ResponseT} response
   * @returns {[Status, ExecutionState]}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _shouldRetry(request, response) {
    throw new Error("not implemented");
  }
  /**
   * Determine if we should error based on the gRPC status
   *
   * Unlike `shouldRetry` this method does in fact still return a boolean
   *
   * @protected
   * @param {Error} error
   * @returns {boolean}
   */
  _shouldRetryExceptionally(error) {
    if (error instanceof GrpcServiceError) {
      return error.status._code === GrpcStatus.Timeout._code || error.status._code === GrpcStatus.Unavailable._code || error.status._code === GrpcStatus.ResourceExhausted._code || error.status._code === GrpcStatus.GrpcWeb._code || error.status._code === GrpcStatus.Internal._code && RST_STREAM.test(error.message);
    } else {
      return true;
    }
  }
  /**
   * A helper method for setting the operator on the request
   *
   * @internal
   * @param {AccountId} accountId
   * @param {PublicKey} publicKey
   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   * @returns {this}
   */
  _setOperatorWith(accountId, publicKey, transactionSigner) {
    this._operator = {
      transactionSigner,
      accountId,
      publicKey
    };
    return this;
  }
  /**
   * Execute this request using the signer
   *
   * This method is part of the signature providers feature
   * https://hips.hedera.com/hip/hip-338
   *
   * @param {Signer} signer
   * @returns {Promise<OutputT>}
   */
  async executeWithSigner(signer) {
    return signer.call(this);
  }
  /**
   * Execute the request using a client and an optional request timeout
   *
   * @template {Channel} ChannelT
   * @template {MirrorChannel} MirrorChannelT
   * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
   * @param {number=} requestTimeout
   * @returns {Promise<OutputT>}
   */
  async execute(client, requestTimeout) {
    this._logger = this._logger == null ? client._logger != null ? client._logger : null : this._logger;
    if (this._requestTimeout == null) {
      this._requestTimeout = requestTimeout != null ? requestTimeout : client.requestTimeout;
    }
    await this._beforeExecute(client);
    if (this._maxBackoff == null) {
      this._maxBackoff = client.maxBackoff;
    }
    if (this._minBackoff == null) {
      this._minBackoff = client.minBackoff;
    }
    const maxAttempts = client._maxAttempts != null ? client._maxAttempts : this._maxAttempts;
    const startTime = Date.now();
    let persistentError = null;
    for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
      if (this._requestTimeout != null && startTime + this._requestTimeout <= Date.now()) {
        throw new Error("timeout exceeded");
      }
      let nodeAccountId;
      let node;
      if (this._nodeAccountIds.isEmpty) {
        node = client._network.getNode();
        nodeAccountId = node.accountId;
        this._nodeAccountIds.setList([nodeAccountId]);
      } else {
        nodeAccountId = this._nodeAccountIds.current;
        node = client._network.getNode(nodeAccountId);
      }
      if (node == null) {
        throw new Error(
          `NodeAccountId not recognized: ${nodeAccountId.toString()}`
        );
      }
      const logId = this._getLogId();
      if (this._logger) {
        this._logger.debug(
          `[${logId}] Node AccountID: ${node.accountId.toString()}, IP: ${node.address.toString()}`
        );
      }
      const channel = node.getChannel();
      const request = await this._makeRequestAsync();
      this._advanceRequest();
      let response;
      if (!node.isHealthy()) {
        if (this._logger) {
          this._logger.debug(
            `[${logId}] node is not healthy, skipping waiting ${node.getRemainingTime()}`
          );
        }
        continue;
      }
      try {
        const promises = [];
        if (this._grpcDeadline != null) {
          promises.push(
            // eslint-disable-next-line ie11/no-loop-func
            new Promise(
              (_, reject) => setTimeout(
                // eslint-disable-next-line ie11/no-loop-func
                () => reject(new Error("grpc deadline exceeded")),
                /** @type {number=} */
                this._grpcDeadline
              )
            )
          );
        }
        if (this._logger) {
          this._logger.trace(
            `[${this._getLogId()}] sending protobuf ${encode(
              this._requestToBytes(request)
            )}`
          );
        }
        promises.push(this._execute(channel, request));
        response = /** @type {ResponseT} */
        await Promise.race(promises);
      } catch (err2) {
        const error = GrpcServiceError._fromResponse(
          /** @type {Error} */
          err2
        );
        persistentError = error;
        if (this._logger) {
          this._logger.debug(
            `[${logId}] received error ${JSON.stringify(error)}`
          );
        }
        if ((error instanceof GrpcServiceError || error instanceof HttpError) && this._shouldRetryExceptionally(error) && attempt <= maxAttempts) {
          if (this._logger) {
            this._logger.debug(
              `[${this._getLogId()}] node with accountId: ${node.accountId.toString()} and proxy IP: ${node.address.toString()} is unhealthy`
            );
          }
          client._network.increaseBackoff(node);
          continue;
        }
        throw err2;
      }
      if (this._logger) {
        this._logger.trace(
          `[${this._getLogId()}] sending protobuf ${encode(
            this._responseToBytes(response)
          )}`
        );
      }
      client._network.decreaseBackoff(node);
      const [err, shouldRetry] = this._shouldRetry(request, response);
      if (err != null) {
        persistentError = err;
      }
      switch (shouldRetry) {
        case ExecutionState.Retry:
          await delayForAttempt(
            attempt,
            this._minBackoff,
            this._maxBackoff
          );
          continue;
        case ExecutionState.Finished:
          return this._mapResponse(response, nodeAccountId, request);
        case ExecutionState.Error:
          throw this._mapStatusError(request, response);
        default:
          throw new Error(
            "(BUG) non-exhuastive switch statement for `ExecutionState`"
          );
      }
    }
    throw new Error(
      `max attempts of ${maxAttempts.toString()} was reached for request with last error being: ${persistentError != null ? persistentError.toString() : ""}`
    );
  }
  /**
   * The current purpose of this method is to easily support signature providers since
   * signature providers need to serialize _any_ request into bytes. `Query` and `Transaction`
   * already implement `toBytes()` so it only made sense to make it avaiable here too.
   *
   * @abstract
   * @returns {Uint8Array}
   */
  toBytes() {
    throw new Error("not implemented");
  }
  /**
   * Set logger
   *
   * @param {Logger} logger
   * @returns {this}
   */
  setLogger(logger15) {
    this._logger = logger15;
    return this;
  }
  /**
   * Get logger if set
   *
   * @returns {?Logger}
   */
  get logger() {
    return this._logger;
  }
};
function delayForAttempt(attempt, minBackoff, maxBackoff) {
  const ms = Math.min(
    Math.floor(minBackoff * Math.pow(2, attempt)),
    maxBackoff
  );
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/@hashgraph/sdk/src/Timestamp.js
var import_long6 = __toESM(require_long(), 1);
var MAX_NS = import_long6.default.fromNumber(1e9);
var generatedIds = /* @__PURE__ */ new Set();
var Timestamp = class _Timestamp {
  /**
   * @param {Long | number} seconds
   * @param {Long | number} nanos
   */
  constructor(seconds, nanos) {
    this.seconds = seconds instanceof import_long6.default ? seconds : import_long6.default.fromNumber(seconds);
    this.nanos = nanos instanceof import_long6.default ? nanos : import_long6.default.fromNumber(nanos);
    Object.freeze(this);
  }
  /**
   * @returns {Timestamp}
   */
  static generate() {
    const jitter = Math.floor(Math.random() * 5e3) + 8e3;
    const now = Date.now() - jitter;
    const seconds = Math.floor(now / 1e3) + Cache_default2.timeDrift;
    const nanos = Math.floor(now % 1e3) * 1e6 + Math.floor(Math.random() * 1e6);
    const timestamp = new _Timestamp(seconds, nanos);
    if (generatedIds.has(timestamp.toString())) {
      return this.generate();
    } else {
      generatedIds.add(timestamp.toString());
      return timestamp;
    }
  }
  /**
   * @param {string | number | Date} date
   * @returns {Timestamp}
   */
  static fromDate(date) {
    let nanos;
    if (typeof date === "number") {
      nanos = import_long6.default.fromNumber(date);
    } else if (typeof date === "string") {
      nanos = import_long6.default.fromNumber(Date.parse(date)).mul(1e6);
    } else if (date instanceof Date) {
      nanos = import_long6.default.fromNumber(date.getTime()).mul(1e6);
    } else {
      throw new TypeError(
        `invalid type '${typeof date}' for 'data', expected 'Date'`
      );
    }
    return new _Timestamp(0, 0).plusNanos(nanos);
  }
  /**
   * @returns {Date}
   */
  toDate() {
    return new Date(
      this.seconds.toInt() * 1e3 + Math.floor(this.nanos.toInt() / 1e6)
    );
  }
  /**
   * @param {Long | number} nanos
   * @returns {Timestamp}
   */
  plusNanos(nanos) {
    const ns = this.nanos.add(nanos);
    return new _Timestamp(this.seconds.add(ns.div(MAX_NS)), ns.mod(MAX_NS));
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ITimestamp}
   */
  _toProtobuf() {
    return {
      seconds: this.seconds,
      nanos: this.nanos.toInt()
    };
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITimestamp} timestamp
   * @returns {Timestamp}
   */
  static _fromProtobuf(timestamp) {
    return new _Timestamp(
      timestamp.seconds instanceof import_long6.default ? timestamp.seconds.toInt() : timestamp.seconds != null ? timestamp.seconds : 0,
      timestamp.nanos != null ? timestamp.nanos : 0
    );
  }
  /**
   * @returns {string}
   */
  toString() {
    const zeroPaddedNanos = String(this.nanos).padStart(9, "0");
    return `${this.seconds.toString()}.${zeroPaddedNanos}`;
  }
  /**
   * @param {Timestamp} other
   * @returns {number}
   */
  compare(other) {
    const comparison = this.seconds.compare(other.seconds);
    if (comparison != 0) {
      return comparison;
    }
    return this.nanos.compare(other.nanos);
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionId.js
var HashgraphProto3 = __toESM(require_lib(), 1);
var import_long7 = __toESM(require_long(), 1);
var TransactionId = class _TransactionId {
  /**
   * Don't use this method directly.
   * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.
   *
   * @param {?AccountId} accountId
   * @param {?Timestamp} validStart
   * @param {?boolean} scheduled
   * @param {?Long | number} nonce
   */
  constructor(accountId, validStart, scheduled = false, nonce = null) {
    this.accountId = accountId;
    this.validStart = validStart;
    this.scheduled = scheduled;
    this.nonce = null;
    if (nonce != null && nonce != 0) {
      this.setNonce(nonce);
    }
    Object.seal(this);
  }
  /**
   * @param {Long | number} nonce
   * @returns {TransactionId}
   */
  setNonce(nonce) {
    this.nonce = typeof nonce === "number" ? import_long7.default.fromNumber(nonce) : nonce;
    return this;
  }
  /**
   * @param {AccountId} accountId
   * @param {Timestamp} validStart
   * @returns {TransactionId}
   */
  static withValidStart(accountId, validStart) {
    return new _TransactionId(accountId, validStart);
  }
  /**
   * Generates a new transaction ID for the given account ID.
   *
   * Note that transaction IDs are made of the valid start of the transaction and the account
   * that will be charged the transaction fees for the transaction.
   *
   * @param {AccountId | string} id
   * @returns {TransactionId}
   */
  static generate(id2) {
    return new _TransactionId(
      typeof id2 === "string" ? AccountId.fromString(id2) : new AccountId(id2),
      Timestamp.generate()
    );
  }
  /**
   * @param {string} wholeId
   * @returns {TransactionId}
   */
  static fromString(wholeId) {
    let account, seconds, nanos, isScheduled, nonce;
    let rest;
    [account, rest] = wholeId.split("@");
    [seconds, rest] = rest.split(".");
    if (rest.includes("?")) {
      [nanos, rest] = rest.split("?scheduled");
      isScheduled = true;
      if (rest.includes("/")) {
        nonce = rest.replace("/", "");
      } else {
        nonce = null;
      }
    } else if (rest.includes("/")) {
      [nanos, nonce] = rest.split("/");
      isScheduled = false;
    } else {
      nanos = rest;
    }
    return new _TransactionId(
      AccountId.fromString(account),
      new Timestamp(import_long7.default.fromValue(seconds), import_long7.default.fromValue(nanos)),
      isScheduled,
      nonce != null ? import_long7.default.fromString(nonce) : null
    );
  }
  /**
   * @param {boolean} scheduled
   * @returns {this}
   */
  setScheduled(scheduled) {
    this.scheduled = scheduled;
    return this;
  }
  /**
   * @returns {string}
   */
  toString() {
    if (this.accountId != null && this.validStart != null) {
      const zeroPaddedNanos = String(this.validStart.nanos).padStart(
        9,
        "0"
      );
      const nonce = this.nonce != null ? "/".concat(this.nonce.toString()) : "";
      const scheduled = this.scheduled ? "?scheduled" : "";
      return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${zeroPaddedNanos}${scheduled}${nonce}`;
    } else {
      throw new Error("neither `accountId` nor `validStart` are set");
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransactionID} id
   * @returns {TransactionId}
   */
  static _fromProtobuf(id2) {
    if (id2.accountID != null && id2.transactionValidStart != null) {
      return new _TransactionId(
        AccountId._fromProtobuf(id2.accountID),
        Timestamp._fromProtobuf(id2.transactionValidStart),
        id2.scheduled != null ? id2.scheduled : void 0,
        id2.nonce != null ? id2.nonce : void 0
      );
    } else {
      throw new Error(
        "Neither `nonce` or `accountID` and `transactionValidStart` are set"
      );
    }
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ITransactionID}
   */
  _toProtobuf() {
    return {
      accountID: this.accountId != null ? this.accountId._toProtobuf() : null,
      transactionValidStart: this.validStart != null ? this.validStart._toProtobuf() : null,
      scheduled: this.scheduled,
      nonce: this.nonce != null ? this.nonce.toInt() : null
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionId}
   */
  static fromBytes(bytes3) {
    return _TransactionId._fromProtobuf(
      HashgraphProto3.proto.TransactionID.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto3.proto.TransactionID.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {TransactionId}
   */
  clone() {
    return new _TransactionId(
      this.accountId,
      this.validStart,
      this.scheduled,
      this.nonce
    );
  }
  /**
   * @param {TransactionId} other
   * @returns {number}
   */
  compare(other) {
    const comparison = (
      /** @type {AccountId} */
      this.accountId.compare(
        /** @type {AccountId} */
        other.accountId
      )
    );
    if (comparison != 0) {
      return comparison;
    }
    return (
      /** @type {Timestamp} */
      this.validStart.compare(
        /** @type {Timestamp} */
        other.validStart
      )
    );
  }
  /**
   * @param {Client} client
   * @returns {Promise<TransactionReceipt>}
   */
  getReceipt(client) {
    return Cache_default2.transactionReceiptQueryConstructor().setTransactionId(this).execute(client);
  }
  /**
   * @param {Client} client
   * @returns {Promise<TransactionRecord>}
   */
  async getRecord(client) {
    await this.getReceipt(client);
    return Cache_default2.transactionRecordQueryConstructor().setTransactionId(this).execute(client);
  }
};

// node_modules/@hashgraph/sdk/src/query/Query.js
var HashgraphProto4 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/PrecheckStatusError.js
var PrecheckStatusError = class extends StatusError {
  /**
   * @param {object} props
   * @param {Status} props.status
   * @param {TransactionId} props.transactionId
   * @param {?ContractFunctionResult} props.contractFunctionResult
   */
  constructor(props) {
    super(
      props,
      `transaction ${props.transactionId.toString()} failed precheck with status ${props.status.toString()}`
    );
    this.contractFunctionResult = props.contractFunctionResult;
  }
  /**
   * @returns {PrecheckStatusErrorJSON}
   */
  toJSON() {
    return {
      name: this.name,
      status: this.status.toString(),
      transactionId: this.transactionId.toString(),
      message: this.message,
      contractFunctionResult: this.contractFunctionResult
    };
  }
};

// node_modules/@hashgraph/sdk/src/MaxQueryPaymentExceeded.js
var MaxQueryPaymentExceeded = class extends Error {
  /**
   * @param {Hbar} queryCost
   * @param {Hbar} maxQueryPayment
   */
  constructor(queryCost, maxQueryPayment) {
    super();
    this.message = `query cost of ${queryCost.toString()} HBAR exceeds max set on client: ${maxQueryPayment.toString()} HBAR`;
    this.name = "MaxQueryPaymentExceededError";
    this.queryCost = queryCost;
    this.maxQueryPayment = maxQueryPayment;
  }
};

// node_modules/@hashgraph/sdk/src/query/Query.js
var import_long8 = __toESM(require_long(), 1);
var QUERY_REGISTRY = /* @__PURE__ */ new Map();
var Query = class extends Executable {
  constructor() {
    super();
    this._paymentTransactionId = null;
    this._paymentTransactions = [];
    this._queryPayment = null;
    this._maxQueryPayment = null;
    this._timestamp = Date.now();
  }
  /**
   * Deserialize a query from bytes. The bytes should be a `proto.Query`.
   *
   * @template T
   * @param {Uint8Array} bytes
   * @returns {Query<T>}
   */
  static fromBytes(bytes3) {
    const query = HashgraphProto4.proto.Query.decode(bytes3);
    if (query.query == null) {
      throw new Error("(BUG) query.query was not set in the protobuf");
    }
    const fromProtobuf = (
      /** @type {(query: HashgraphProto.proto.IQuery) => Query<T>} */
      QUERY_REGISTRY.get(query.query)
    );
    if (fromProtobuf == null) {
      throw new Error(
        `(BUG) Query.fromBytes() not implemented for type ${query.query}`
      );
    }
    return fromProtobuf(query);
  }
  /**
   * Serialize the query into bytes.
   *
   * **NOTE**: Does not preserve payment transactions
   *
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto4.proto.Query.encode(this._makeRequest()).finish();
  }
  /**
   * Set an explicit payment amount for this query.
   *
   * The client will submit exactly this amount for the payment of this query. Hedera
   * will not return any remainder.
   *
   * @param {Hbar} queryPayment
   * @returns {this}
   */
  setQueryPayment(queryPayment) {
    this._queryPayment = queryPayment;
    return this;
  }
  /**
   * Set the maximum payment allowable for this query.
   *
   * @param {Hbar} maxQueryPayment
   * @returns {this}
   */
  setMaxQueryPayment(maxQueryPayment) {
    this._maxQueryPayment = maxQueryPayment;
    return this;
  }
  /**
   * Fetch the cost of this query from a consensus node
   *
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    if (this._nodeAccountIds.isEmpty) {
      this._nodeAccountIds.setList(
        client._network.getNodeAccountIdsForExecute()
      );
    }
    if (COST_QUERY.length != 1) {
      throw new Error("CostQuery has not been loaded yet");
    }
    this._timestamp = Date.now();
    const cost = await COST_QUERY[0](this).execute(client);
    return Hbar.fromTinybars(
      cost._valueInTinybar.multipliedBy(1.1).toFixed(0)
    );
  }
  /**
   * Set he payment transaction explicitly
   *
   * @param {TransactionId} paymentTransactionId
   * @returns {this}
   */
  setPaymentTransactionId(paymentTransactionId) {
    this._paymentTransactionId = paymentTransactionId;
    return this;
  }
  /**
   * Get the payment transaction ID
   *
   * @returns {?TransactionId}
   */
  get paymentTransactionId() {
    return this._paymentTransactionId;
  }
  /**
   * Get the current transaction ID, and make sure it's not null
   *
   * @returns {TransactionId}
   */
  _getTransactionId() {
    if (this._paymentTransactionId == null) {
      throw new Error(
        "Query.PaymentTransactionId was not set duration execution"
      );
    }
    return this._paymentTransactionId;
  }
  /**
   * Is payment required for this query. By default most queries require payment
   * so the default implementation returns true.
   *
   * @protected
   * @returns {boolean}
   */
  _isPaymentRequired() {
    return true;
  }
  /**
   * Validate checksums of the query.
   *
   * @param {Client} client
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
  _validateChecksums(client) {
  }
  /**
   * Before we proceed exeuction, we need to do a couple checks
   *
   * @template {MirrorChannel} MirrorChannelT
   * @param {import("../client/Client.js").default<Channel, MirrorChannelT>} client
   * @returns {Promise<void>}
   */
  async _beforeExecute(client) {
    if (this._paymentTransactions.length > 0) {
      return;
    }
    if (client.isAutoValidateChecksumsEnabled()) {
      this._validateChecksums(client);
    }
    if (this._nodeAccountIds.isEmpty) {
      this._nodeAccountIds.setList(
        client._network.getNodeAccountIdsForExecute()
      );
    }
    this._operator = this._operator != null ? this._operator : client._operator;
    if (this._paymentTransactionId == null) {
      if (this._isPaymentRequired()) {
        if (this._operator != null) {
          this._paymentTransactionId = TransactionId.generate(
            this._operator.accountId
          );
        } else {
          throw new Error(
            "`client` must have an `operator` or an explicit payment transaction must be provided"
          );
        }
      } else {
        this._paymentTransactionId = TransactionId.generate(
          new AccountId(0)
        );
      }
    }
    let cost = new Hbar(0);
    const maxQueryPayment = this._maxQueryPayment != null ? this._maxQueryPayment : client.defaultMaxQueryPayment;
    if (this._queryPayment != null) {
      cost = this._queryPayment;
    } else if (this._paymentTransactions.length === 0 && this._isPaymentRequired()) {
      const actualCost = await this.getCost(client);
      if (maxQueryPayment.toTinybars().toInt() < actualCost.toTinybars().toInt()) {
        throw new MaxQueryPaymentExceeded(actualCost, maxQueryPayment);
      }
      cost = actualCost;
      if (this._logger) {
        this._logger.debug(
          `[${this._getLogId()}] received cost for query ${cost.toString()}`
        );
      }
    }
    this._queryPayment = cost;
    this._timestamp = Date.now();
    this._nodeAccountIds.setLocked();
    for (const nodeId of this._nodeAccountIds.list) {
      const logId = this._getLogId();
      const paymentTransactionId = (
        /** @type {import("../transaction/TransactionId.js").default} */
        this._paymentTransactionId
      );
      const paymentAmount = (
        /** @type {Hbar} */
        this._queryPayment
      );
      if (this._logger) {
        this._logger.debug(
          `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`
        );
      }
      this._paymentTransactions.push(
        await _makePaymentTransaction(
          paymentTransactionId,
          nodeId,
          this._isPaymentRequired() ? this._operator : null,
          paymentAmount
        )
      );
    }
  }
  /**
   * @abstract
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponseHeader(response) {
    throw new Error("not implemented");
  }
  /**
   * @protected
   * @returns {HashgraphProto.proto.IQueryHeader}
   */
  _makeRequestHeader() {
    let header = {};
    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
      header = {
        responseType: HashgraphProto4.proto.ResponseType.ANSWER_ONLY,
        payment: this._paymentTransactions[this._nodeAccountIds.index]
      };
    }
    return header;
  }
  /**
   * @abstract
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _onMakeRequest(header) {
    throw new Error("not implemented");
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IQuery}
   */
  _makeRequest() {
    let header = {};
    if (this._isPaymentRequired() && this._paymentTransactions != null) {
      header = {
        payment: this._paymentTransactions[this._nodeAccountIds.index],
        responseType: HashgraphProto4.proto.ResponseType.ANSWER_ONLY
      };
    }
    return this._onMakeRequest(header);
  }
  /**
   * @override
   * @internal
   * @returns {Promise<HashgraphProto.proto.IQuery>}
   */
  async _makeRequestAsync() {
    let header = {
      responseType: HashgraphProto4.proto.ResponseType.ANSWER_ONLY
    };
    if (this._isPaymentRequired() && this._paymentTransactions != null) {
      if (this._nodeAccountIds.locked) {
        header.payment = this._paymentTransactions[this._nodeAccountIds.index];
      } else {
        const logId = this._getLogId();
        const nodeId = this._nodeAccountIds.current;
        const paymentTransactionId = (
          /** @type {import("../transaction/TransactionId.js").default} */
          this._paymentTransactionId
        );
        const paymentAmount = (
          /** @type {Hbar} */
          this._queryPayment
        );
        if (this._logger) {
          this._logger.debug(
            `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`
          );
        }
        header.payment = await _makePaymentTransaction(
          paymentTransactionId,
          nodeId,
          this._isPaymentRequired() ? this._operator : null,
          paymentAmount
        );
      }
    }
    return this._onMakeRequest(header);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {[Status, ExecutionState]}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    const status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto4.proto.ResponseCodeEnum.OK
    );
    if (this._logger) {
      this._logger.debug(
        `[${this._getLogId()}] received status ${status.toString()}`
      );
    }
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.PlatformTransactionNotCreated:
        return [status, ExecutionState.Retry];
      case Status.Ok:
        return [status, ExecutionState.Finished];
      default:
        return [status, ExecutionState.Error];
    }
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    const status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto4.proto.ResponseCodeEnum.OK
    );
    return new PrecheckStatusError({
      status,
      transactionId: this._getTransactionId(),
      contractFunctionResult: null
    });
  }
  /**
   * @param {HashgraphProto.proto.Query} request
   * @returns {Uint8Array}
   */
  _requestToBytes(request) {
    return HashgraphProto4.proto.Query.encode(request).finish();
  }
  /**
   * @param {HashgraphProto.proto.Response} response
   * @returns {Uint8Array}
   */
  _responseToBytes(response) {
    return HashgraphProto4.proto.Response.encode(response).finish();
  }
};
async function _makePaymentTransaction(paymentTransactionId, nodeId, operator, paymentAmount) {
  const accountAmounts = [];
  if (operator != null) {
    accountAmounts.push({
      accountID: operator.accountId._toProtobuf(),
      amount: paymentAmount.negated().toTinybars()
    });
    accountAmounts.push({
      accountID: nodeId._toProtobuf(),
      amount: paymentAmount.toTinybars()
    });
  } else {
    accountAmounts.push({
      accountID: new AccountId(0)._toProtobuf(),
      // If the account ID is 0, shouldn't we just hard
      // code this value to 0? Same for the latter.
      amount: paymentAmount.negated().toTinybars()
    });
    accountAmounts.push({
      accountID: nodeId._toProtobuf(),
      amount: paymentAmount.toTinybars()
    });
  }
  const body = {
    transactionID: paymentTransactionId._toProtobuf(),
    nodeAccountID: nodeId._toProtobuf(),
    transactionFee: new Hbar(1).toTinybars(),
    transactionValidDuration: {
      seconds: import_long8.default.fromNumber(120)
    },
    cryptoTransfer: {
      transfers: {
        accountAmounts
      }
    }
  };
  const signedTransaction = {
    bodyBytes: HashgraphProto4.proto.TransactionBody.encode(body).finish()
  };
  if (operator != null) {
    const signature = await operator.transactionSigner(
      /** @type {Uint8Array} */
      signedTransaction.bodyBytes
    );
    signedTransaction.sigMap = {
      sigPair: [operator.publicKey._toProtobufSignature(signature)]
    };
  }
  return {
    signedTransactionBytes: HashgraphProto4.proto.SignedTransaction.encode(
      signedTransaction
    ).finish()
  };
}
var COST_QUERY = [];

// node_modules/@hashgraph/sdk/src/contract/ContractId.js
var HashgraphProto5 = __toESM(require_lib(), 1);
var import_long9 = __toESM(require_long(), 1);
var ContractId = class _ContractId extends Key2 {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   * @param {Uint8Array=} evmAddress
   */
  constructor(props, realm, num, evmAddress) {
    super();
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this.evmAddress = evmAddress != null ? evmAddress : null;
    this._checksum = null;
  }
  /**
   * @description This handles both long-zero format and evm address format addresses.
   * If an actual evm address is passed, please use `ContractId.populateAccountNum(client)` method
   * to get the actual `num` value, since there is no cryptographic relation to the evm address
   * and cannot be populated directly
   * @param {Long | number} shard
   * @param {Long | number} realm
   * @param {string} evmAddress
   * @returns {ContractId}
   */
  static fromEvmAddress(shard, realm, evmAddress) {
    if (isLongZeroAddress(decode(evmAddress))) {
      return new _ContractId(...fromSolidityAddress(evmAddress));
    } else {
      return new _ContractId(shard, realm, 0, decode(evmAddress));
    }
  }
  /**
   * @param {string} text
   * @returns {ContractId}
   */
  static fromString(text) {
    const result = fromStringSplitter(text);
    if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
      throw new Error("invalid format for entity ID");
    }
    const shard = result.shard != null ? import_long9.default.fromString(result.shard) : import_long9.default.ZERO;
    const realm = result.realm != null ? import_long9.default.fromString(result.realm) : import_long9.default.ZERO;
    const [num, evmAddress] = result.numOrHex.length < 40 ? [import_long9.default.fromString(result.numOrHex), void 0] : [import_long9.default.ZERO, decode(result.numOrHex)];
    return new _ContractId(shard, realm, num, evmAddress);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IContractID} id
   * @returns {ContractId}
   */
  static _fromProtobuf(id2) {
    const contractId = new _ContractId(
      id2.shardNum != null ? id2.shardNum : 0,
      id2.realmNum != null ? id2.realmNum : 0,
      id2.contractNum != null ? id2.contractNum : 0
    );
    return contractId;
  }
  /**
   * @returns {string | null}
   */
  get checksum() {
    return this._checksum;
  }
  /**
   * @description Gets the actual `num` field of the `ContractId` from the Mirror Node.
   * Should be used after generating `ContractId.fromEvmAddress()` because it sets the `num` field to `0`
   * automatically since there is no connection between the `num` and the `evmAddress`
   * @param {Client} client
   * @returns {Promise<ContractId>}
   */
  async populateAccountNum(client) {
    if (this.evmAddress === null) {
      throw new Error("field `evmAddress` should not be null");
    }
    const mirrorUrl = client.mirrorNetwork[0].slice(
      0,
      client.mirrorNetwork[0].indexOf(":")
    );
    const url = `https://${mirrorUrl}/api/v1/contracts/${encode(
      this.evmAddress
    )}`;
    const mirrorAccountId = (await axios_default.get(url)).data.contract_id;
    this.num = import_long9.default.fromString(
      mirrorAccountId.slice(mirrorAccountId.lastIndexOf(".") + 1)
    );
    return this;
  }
  /**
   * @deprecated - Use `validateChecksum` instead
   * @param {Client} client
   */
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  /**
   * @param {Client} client
   */
  validateChecksum(client) {
    validateChecksum(
      this.shard,
      this.realm,
      this.num,
      this._checksum,
      client
    );
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ContractId}
   */
  static fromBytes(bytes3) {
    return _ContractId._fromProtobuf(
      HashgraphProto5.proto.ContractID.decode(bytes3)
    );
  }
  /**
   * @deprecated - Use `fromEvmAddress` instead
   * @param {string} address
   * @returns {ContractId}
   */
  static fromSolidityAddress(address) {
    if (isLongZeroAddress(decode(address))) {
      return new _ContractId(...fromSolidityAddress(address));
    } else {
      return this.fromEvmAddress(0, 0, address);
    }
  }
  /**
   * @returns {string}
   */
  toSolidityAddress() {
    if (this.evmAddress != null) {
      return encode(this.evmAddress);
    } else {
      return toSolidityAddress([
        this.shard,
        this.realm,
        this.num
      ]);
    }
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IContractID}
   */
  _toProtobuf() {
    return {
      contractNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm,
      evmAddress: this.evmAddress
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    if (this.evmAddress != null) {
      return `${this.shard.toString()}.${this.realm.toString()}.${encode(
        this.evmAddress
      )}`;
    } else {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }
  }
  /**
   * @param {Client} client
   * @returns {string}
   */
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto5.proto.ContractID.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {ContractId}
   */
  clone() {
    const id2 = new _ContractId(this);
    id2._checksum = this._checksum;
    id2.evmAddress = this.evmAddress;
    return id2;
  }
  /**
   * @param {ContractId} other
   * @returns {number}
   */
  compare(other) {
    return compare2(
      [this.shard, this.realm, this.num],
      [other.shard, other.realm, other.num]
    );
  }
  /**
   * @param {this} other
   * @returns {boolean}
   */
  equals(other) {
    let evmAddresses = false;
    if (this.evmAddress != null && other.evmAddress != null) {
      evmAddresses = arrayEqual3(this.evmAddress, other.evmAddress);
    }
    return this.shard.eq(other.shard) && this.realm.eq(other.realm) && this.num.eq(other.num) && evmAddresses;
  }
  /**
   * @returns {HashgraphProto.proto.IKey}
   */
  _toProtobufKey() {
    return {
      contractID: this._toProtobuf()
    };
  }
  /**
   * @param {HashgraphProto.proto.IContractID} key
   * @returns {ContractId}
   */
  static __fromProtobufKey(key) {
    return _ContractId._fromProtobuf(key);
  }
};
Cache_default2.setContractId((key) => ContractId.__fromProtobufKey(key));

// node_modules/@hashgraph/sdk/src/file/FileId.js
var HashgraphProto6 = __toESM(require_lib(), 1);
var import_long10 = __toESM(require_long(), 1);
var FileId = class _FileId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {FileId}
   */
  static fromString(text) {
    const result = fromString(text);
    const id2 = new _FileId(result);
    id2._checksum = result.checksum;
    return id2;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IFileID} id
   * @returns {FileId}
   */
  static _fromProtobuf(id2) {
    const fileId = new _FileId(
      id2.shardNum != null ? import_long10.default.fromString(id2.shardNum.toString()) : 0,
      id2.realmNum != null ? import_long10.default.fromString(id2.realmNum.toString()) : 0,
      id2.fileNum != null ? import_long10.default.fromString(id2.fileNum.toString()) : 0
    );
    return fileId;
  }
  /**
   * @returns {string | null}
   */
  get checksum() {
    return this._checksum;
  }
  /**
   * @deprecated - Use `validateChecksum` instead
   * @param {Client} client
   */
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  /**
   * @param {Client} client
   */
  validateChecksum(client) {
    validateChecksum(
      this.shard,
      this.realm,
      this.num,
      this._checksum,
      client
    );
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FileId}
   */
  static fromBytes(bytes3) {
    return _FileId._fromProtobuf(HashgraphProto6.proto.FileID.decode(bytes3));
  }
  /**
   * @param {string} address
   * @returns {FileId}
   */
  static fromSolidityAddress(address) {
    const [shard, realm, file] = fromSolidityAddress(address);
    return new _FileId(shard, realm, file);
  }
  /**
   * @returns {string} solidity address
   */
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IFileID}
   */
  _toProtobuf() {
    return {
      fileNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  /**
   * @param {Client} client
   * @returns {string}
   */
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto6.proto.FileID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {FileId}
   */
  clone() {
    const id2 = new _FileId(this);
    id2._checksum = this._checksum;
    return id2;
  }
  /**
   * @param {FileId} other
   * @returns {number}
   */
  compare(other) {
    return compare2(
      [this.shard, this.realm, this.num],
      [other.shard, other.realm, other.num]
    );
  }
};
FileId.ADDRESS_BOOK = new FileId(102);
FileId.FEE_SCHEDULE = new FileId(111);
FileId.EXCHANGE_RATES = new FileId(112);

// node_modules/@hashgraph/sdk/src/topic/TopicId.js
var HashgraphProto7 = __toESM(require_lib(), 1);
var TopicId = class _TopicId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {TopicId}
   */
  static fromString(text) {
    const result = fromString(text);
    const id2 = new _TopicId(result);
    id2._checksum = result.checksum;
    return id2;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITopicID} id
   * @returns {TopicId}
   */
  static _fromProtobuf(id2) {
    const topicId = new _TopicId(
      id2.shardNum != null ? id2.shardNum : 0,
      id2.realmNum != null ? id2.realmNum : 0,
      id2.topicNum != null ? id2.topicNum : 0
    );
    return topicId;
  }
  /**
   * @returns {string | null}
   */
  get checksum() {
    return this._checksum;
  }
  /**
   * @deprecated - Use `validateChecksum` instead
   * @param {Client} client
   */
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  /**
   * @param {Client} client
   */
  validateChecksum(client) {
    validateChecksum(
      this.shard,
      this.realm,
      this.num,
      this._checksum,
      client
    );
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TopicId}
   */
  static fromBytes(bytes3) {
    return _TopicId._fromProtobuf(
      HashgraphProto7.proto.TopicID.decode(bytes3)
    );
  }
  /**
   * @param {string} address
   * @returns {TopicId}
   */
  static fromSolidityAddress(address) {
    const [shard, realm, topic] = fromSolidityAddress(address);
    return new _TopicId(shard, realm, topic);
  }
  /**
   * @returns {string}
   */
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  /**
   * @returns {HashgraphProto.proto.ITopicID}
   */
  _toProtobuf() {
    return {
      topicNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  /**
   * @param {Client} client
   * @returns {string}
   */
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto7.proto.TopicID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {TopicId}
   */
  clone() {
    const id2 = new _TopicId(this);
    id2._checksum = this._checksum;
    return id2;
  }
  /**
   * @param {TopicId} other
   * @returns {number}
   */
  compare(other) {
    return compare2(
      [this.shard, this.realm, this.num],
      [other.shard, other.realm, other.num]
    );
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenId.js
var HashgraphProto8 = __toESM(require_lib(), 1);
var TokenId = class _TokenId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {TokenId}
   */
  static fromString(text) {
    const result = fromString(text);
    const id2 = new _TokenId(result);
    id2._checksum = result.checksum;
    return id2;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITokenID} id
   * @returns {TokenId}
   */
  static _fromProtobuf(id2) {
    const tokenId = new _TokenId(
      id2.shardNum != null ? id2.shardNum : 0,
      id2.realmNum != null ? id2.realmNum : 0,
      id2.tokenNum != null ? id2.tokenNum : 0
    );
    return tokenId;
  }
  /**
   * @returns {string | null}
   */
  get checksum() {
    return this._checksum;
  }
  /**
   * @deprecated - Use `validateChecksum` instead
   * @param {Client} client
   */
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  /**
   * @param {Client} client
   */
  validateChecksum(client) {
    validateChecksum(
      this.shard,
      this.realm,
      this.num,
      this._checksum,
      client
    );
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TokenId}
   */
  static fromBytes(bytes3) {
    return _TokenId._fromProtobuf(
      HashgraphProto8.proto.TokenID.decode(bytes3)
    );
  }
  /**
   * @param {string} address
   * @returns {TokenId}
   */
  static fromSolidityAddress(address) {
    return new _TokenId(...fromSolidityAddress(address));
  }
  /**
   * @returns {string}
   */
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ITokenID}
   */
  _toProtobuf() {
    return {
      tokenNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  /**
   * @param {Client} client
   * @returns {string}
   */
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto8.proto.TokenID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {TokenId}
   */
  clone() {
    const id2 = new _TokenId(this);
    id2._checksum = this._checksum;
    return id2;
  }
  /**
   * @param {TokenId} other
   * @returns {number}
   */
  compare(other) {
    return compare2(
      [this.shard, this.realm, this.num],
      [other.shard, other.realm, other.num]
    );
  }
};

// node_modules/@hashgraph/sdk/src/schedule/ScheduleId.js
var HashgraphProto9 = __toESM(require_lib(), 1);
var ScheduleId = class _ScheduleId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {ScheduleId}
   */
  static fromString(text) {
    const result = fromString(text);
    const id2 = new _ScheduleId(result);
    id2._checksum = result.checksum;
    return id2;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IScheduleID} id
   * @returns {ScheduleId}
   */
  static _fromProtobuf(id2) {
    const scheduleId = new _ScheduleId(
      id2.shardNum != null ? id2.shardNum : 0,
      id2.realmNum != null ? id2.realmNum : 0,
      id2.scheduleNum != null ? id2.scheduleNum : 0
    );
    return scheduleId;
  }
  /**
   * @returns {string | null}
   */
  get checksum() {
    return this._checksum;
  }
  /**
   * @deprecated - Use `validateChecksum` instead
   * @param {Client} client
   */
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  /**
   * @param {Client} client
   */
  validateChecksum(client) {
    validateChecksum(
      this.shard,
      this.realm,
      this.num,
      this._checksum,
      client
    );
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScheduleId}
   */
  static fromBytes(bytes3) {
    return _ScheduleId._fromProtobuf(
      HashgraphProto9.proto.ScheduleID.decode(bytes3)
    );
  }
  /**
   * @param {string} address
   * @returns {ScheduleId}
   */
  static fromSolidityAddress(address) {
    return new _ScheduleId(...fromSolidityAddress(address));
  }
  /**
   * @returns {string}
   */
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ScheduleID}
   */
  _toProtobuf() {
    return {
      scheduleNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  /**
   * @param {Client} client
   * @returns {string}
   */
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto9.proto.ScheduleID.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {ScheduleId}
   */
  clone() {
    const id2 = new _ScheduleId(this);
    id2._checksum = this._checksum;
    return id2;
  }
  /**
   * @param {ScheduleId} other
   * @returns {number}
   */
  compare(other) {
    return compare2(
      [this.shard, this.realm, this.num],
      [other.shard, other.realm, other.num]
    );
  }
};

// node_modules/@hashgraph/sdk/src/ExchangeRate.js
var import_long11 = __toESM(require_long(), 1);
var ExchangeRate = class _ExchangeRate {
  /**
   * @private
   * @param {object} props
   * @param {number} props.hbars
   * @param {number} props.cents
   * @param {Date} props.expirationTime
   */
  constructor(props) {
    this.hbars = props.hbars;
    this.cents = props.cents;
    this.expirationTime = props.expirationTime;
    this.exchangeRateInCents = props.cents / props.hbars;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {import("@hashgraph/proto").proto.IExchangeRate} rate
   * @returns {ExchangeRate}
   */
  static _fromProtobuf(rate) {
    return new _ExchangeRate({
      hbars: (
        /** @type {number} */
        rate.hbarEquiv
      ),
      cents: (
        /** @type {number} */
        rate.centEquiv
      ),
      expirationTime: new Date(
        rate.expirationTime != null ? rate.expirationTime.seconds != null ? import_long11.default.isLong(rate.expirationTime.seconds) ? rate.expirationTime.seconds.toInt() * 1e3 : rate.expirationTime.seconds : 0 : 0
      )
    });
  }
  /**
   * @internal
   * @returns {import("@hashgraph/proto").proto.IExchangeRate}
   */
  _toProtobuf() {
    return {
      hbarEquiv: this.hbars,
      centEquiv: this.cents,
      expirationTime: {
        seconds: import_long11.default.fromNumber(
          Math.trunc(this.expirationTime.getTime() / 1e3)
        )
      }
    };
  }
  /**
   * @returns {ExchangeRateJSON}
   */
  toJSON() {
    return {
      hbars: this.hbars,
      cents: this.cents,
      expirationTime: this.expirationTime,
      exchangeRateInCents: this.exchangeRateInCents
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionReceipt.js
var import_long12 = __toESM(require_long(), 1);
var HashgraphProto10 = __toESM(require_lib(), 1);
var TransactionReceipt = class _TransactionReceipt {
  /**
   * @private
   * @param {object} props
   * @param {Status} props.status
   * @param {?AccountId} props.accountId
   * @param {?FileId} props.fileId
   * @param {?ContractId} props.contractId
   * @param {?TopicId} props.topicId
   * @param {?TokenId} props.tokenId
   * @param {?ScheduleId} props.scheduleId
   * @param {?ExchangeRate} props.exchangeRate
   * @param {?Long} props.topicSequenceNumber
   * @param {?Uint8Array} props.topicRunningHash
   * @param {?Long} props.totalSupply
   * @param {?TransactionId} props.scheduledTransactionId
   * @param {Long[]} props.serials
   * @param {TransactionReceipt[]} props.duplicates
   * @param {TransactionReceipt[]} props.children
   */
  constructor(props) {
    this.status = props.status;
    this.accountId = props.accountId;
    this.fileId = props.fileId;
    this.contractId = props.contractId;
    this.topicId = props.topicId;
    this.tokenId = props.tokenId;
    this.scheduleId = props.scheduleId;
    this.exchangeRate = props.exchangeRate;
    this.topicSequenceNumber = props.topicSequenceNumber;
    this.topicRunningHash = props.topicRunningHash;
    this.totalSupply = props.totalSupply;
    this.scheduledTransactionId = props.scheduledTransactionId;
    this.serials = props.serials ?? [];
    this.duplicates = props.duplicates ?? [];
    this.children = props.children ?? [];
    Object.freeze(this);
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ITransactionGetReceiptResponse}
   */
  _toProtobuf() {
    const duplicates = this.duplicates.map(
      (receipt) => (
        /** @type {HashgraphProto.proto.ITransactionReceipt} */
        receipt._toProtobuf().receipt
      )
    );
    const children = this.children.map(
      (receipt) => (
        /** @type {HashgraphProto.proto.ITransactionReceipt} */
        receipt._toProtobuf().receipt
      )
    );
    return {
      duplicateTransactionReceipts: duplicates,
      childTransactionReceipts: children,
      receipt: {
        status: this.status.valueOf(),
        accountID: this.accountId != null ? this.accountId._toProtobuf() : null,
        fileID: this.fileId != null ? this.fileId._toProtobuf() : null,
        contractID: this.contractId != null ? this.contractId._toProtobuf() : null,
        topicID: this.topicId != null ? this.topicId._toProtobuf() : null,
        tokenID: this.tokenId != null ? this.tokenId._toProtobuf() : null,
        scheduleID: this.scheduleId != null ? this.scheduleId._toProtobuf() : null,
        topicRunningHash: this.topicRunningHash == null ? null : this.topicRunningHash,
        topicSequenceNumber: this.topicSequenceNumber,
        exchangeRate: {
          nextRate: null,
          currentRate: this.exchangeRate != null ? this.exchangeRate._toProtobuf() : null
        },
        scheduledTransactionID: this.scheduledTransactionId != null ? this.scheduledTransactionId._toProtobuf() : null,
        serialNumbers: this.serials,
        newTotalSupply: this.totalSupply
      }
    };
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransactionGetReceiptResponse} response
   * @returns {TransactionReceipt}
   */
  static _fromProtobuf(response) {
    const receipt = (
      /** @type {HashgraphProto.proto.ITransactionReceipt} */
      response.receipt
    );
    const exchangeRateSet = (
      /** @type {HashgraphProto.proto.IExchangeRateSet} */
      receipt.exchangeRate
    );
    const children = response.childTransactionReceipts != null ? response.childTransactionReceipts.map(
      (child) => _TransactionReceipt._fromProtobuf({ receipt: child })
    ) : [];
    const duplicates = response.duplicateTransactionReceipts != null ? response.duplicateTransactionReceipts.map(
      (duplicate) => _TransactionReceipt._fromProtobuf({ receipt: duplicate })
    ) : [];
    return new _TransactionReceipt({
      status: Status._fromCode(
        receipt.status != null ? receipt.status : 0
      ),
      accountId: receipt.accountID != null ? AccountId._fromProtobuf(receipt.accountID) : null,
      fileId: receipt.fileID != null ? FileId._fromProtobuf(receipt.fileID) : null,
      contractId: receipt.contractID != null ? ContractId._fromProtobuf(receipt.contractID) : null,
      topicId: receipt.topicID != null ? TopicId._fromProtobuf(receipt.topicID) : null,
      tokenId: receipt.tokenID != null ? TokenId._fromProtobuf(receipt.tokenID) : null,
      scheduleId: receipt.scheduleID != null ? ScheduleId._fromProtobuf(receipt.scheduleID) : null,
      exchangeRate: receipt.exchangeRate != null ? ExchangeRate._fromProtobuf(
        /** @type {HashgraphProto.proto.IExchangeRate} */
        exchangeRateSet.currentRate
      ) : null,
      topicSequenceNumber: receipt.topicSequenceNumber == null ? null : import_long12.default.fromString(receipt.topicSequenceNumber.toString()),
      topicRunningHash: receipt.topicRunningHash != null ? new Uint8Array(receipt.topicRunningHash) : null,
      totalSupply: receipt.newTotalSupply != null ? import_long12.default.fromString(receipt.newTotalSupply.toString()) : null,
      scheduledTransactionId: receipt.scheduledTransactionID != null ? TransactionId._fromProtobuf(
        receipt.scheduledTransactionID
      ) : null,
      serials: receipt.serialNumbers != null ? receipt.serialNumbers.map(
        (serial) => import_long12.default.fromValue(serial)
      ) : [],
      children,
      duplicates
    });
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionReceipt}
   */
  static fromBytes(bytes3) {
    return _TransactionReceipt._fromProtobuf(
      HashgraphProto10.proto.TransactionGetReceiptResponse.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto10.proto.TransactionGetReceiptResponse.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {TransactionReceiptJSON}
   */
  toJSON() {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    return {
      status: this.status.toString(),
      accountId: ((_a2 = this.accountId) == null ? void 0 : _a2.toString()) || null,
      filedId: ((_b = this.fileId) == null ? void 0 : _b.toString()) || null,
      contractId: ((_c = this.contractId) == null ? void 0 : _c.toString()) || null,
      topicId: ((_d = this.topicId) == null ? void 0 : _d.toString()) || null,
      tokenId: ((_e = this.tokenId) == null ? void 0 : _e.toString()) || null,
      scheduleId: ((_f = this.scheduleId) == null ? void 0 : _f.toString()) || null,
      exchangeRate: ((_g = this.exchangeRate) == null ? void 0 : _g.toJSON()) || null,
      topicSequenceNumber: ((_h = this.topicSequenceNumber) == null ? void 0 : _h.toString()) || null,
      topicRunningHash: this.topicRunningHash != null ? encode(this.topicRunningHash) : null,
      totalSupply: ((_i = this.totalSupply) == null ? void 0 : _i.toString()) || null,
      scheduledTransactionId: ((_j = this.scheduledTransactionId) == null ? void 0 : _j.toString()) || null,
      serials: this.serials.map((serial) => serial.toString()),
      duplicates: this.duplicates.map((receipt) => receipt.toJSON()),
      children: this.children.map((receipt) => receipt.toJSON())
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionReceiptQuery.js
var HashgraphProto11 = __toESM(require_lib(), 1);
var { proto: proto11 } = HashgraphProto11;
var TransactionReceiptQuery = class _TransactionReceiptQuery extends Query {
  /**
   * @param {object} [props]
   * @param {TransactionId | string} [props.transactionId]
   * @param {boolean} [props.includeDuplicates]
   * @param {boolean} [props.includeChildren]
   * @param {boolean} [props.validateStatus]
   */
  constructor(props = {}) {
    super();
    this._transactionId = null;
    this._includeChildren = null;
    this._includeDuplicates = null;
    this._validateStatus = true;
    if (props.transactionId != null) {
      this.setTransactionId(props.transactionId);
    }
    if (props.includeChildren != null) {
      this.setIncludeChildren(props.includeChildren);
    }
    if (props.includeDuplicates != null) {
      this.setIncludeDuplicates(props.includeDuplicates);
    }
    if (props.validateStatus != null) {
      this.setValidateStatus(props.validateStatus);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {TransactionReceiptQuery}
   */
  static _fromProtobuf(query) {
    const receipt = (
      /** @type {HashgraphProto.proto.ITransactionGetReceiptQuery} */
      query.transactionGetReceipt
    );
    return new _TransactionReceiptQuery({
      transactionId: receipt.transactionID ? TransactionId._fromProtobuf(receipt.transactionID) : void 0,
      includeDuplicates: receipt.includeDuplicates != null ? receipt.includeDuplicates : void 0,
      includeChildren: receipt.includeChildReceipts != null ? receipt.includeChildReceipts : void 0
    });
  }
  /**
   * @returns {?TransactionId}
   */
  get transactionId() {
    return this._transactionId;
  }
  /**
   * Set the transaction ID for which the receipt is being requested.
   *
   * @param {TransactionId | string} transactionId
   * @returns {this}
   */
  setTransactionId(transactionId) {
    this._transactionId = typeof transactionId === "string" ? TransactionId.fromString(transactionId) : transactionId.clone();
    return this;
  }
  /**
   * @param {boolean} includeDuplicates
   * @returns {TransactionReceiptQuery}
   */
  setIncludeDuplicates(includeDuplicates) {
    this._includeDuplicates = includeDuplicates;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get includeDuplicates() {
    return this._includeDuplicates != null ? this._includeDuplicates : false;
  }
  /**
   * @param {boolean} includeChildren
   * @returns {TransactionReceiptQuery}
   */
  setIncludeChildren(includeChildren) {
    this._includeChildren = includeChildren;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get includeChildren() {
    return this._includeChildren != null ? this._includeChildren : false;
  }
  /**
   * @param {boolean} validateStatus
   * @returns {this}
   */
  setValidateStatus(validateStatus) {
    this._validateStatus = validateStatus;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get validateStatus() {
    return this._validateStatus;
  }
  /**
   * @override
   * @protected
   * @returns {boolean}
   */
  _isPaymentRequired() {
    return false;
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {[Status, ExecutionState]}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : proto11.ResponseCodeEnum.OK
    );
    if (this._logger) {
      this._logger.debug(
        `[${this._getLogId()}] received node precheck status ${status.toString()}`
      );
    }
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
        return [status, ExecutionState.Retry];
      case Status.Ok:
        break;
      default:
        return [status, ExecutionState.Error];
    }
    const transactionGetReceipt = (
      /** @type {HashgraphProto.proto.ITransactionGetReceiptResponse} */
      response.transactionGetReceipt
    );
    const receipt = (
      /** @type {HashgraphProto.proto.ITransactionReceipt} */
      transactionGetReceipt.receipt
    );
    const receiptStatusCode = (
      /** @type {HashgraphProto.proto.ResponseCodeEnum} */
      receipt.status
    );
    status = Status._fromCode(receiptStatusCode);
    if (this._logger) {
      this._logger.debug(
        `[${this._getLogId()}] received receipt status ${status.toString()}`
      );
    }
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
        return [status, ExecutionState.Retry];
      case Status.Success:
        return [status, ExecutionState.Finished];
      default:
        return [
          status,
          this._validateStatus ? ExecutionState.Error : ExecutionState.Finished
        ];
    }
  }
  /**
   * @returns {TransactionId}
   */
  _getTransactionId() {
    if (this._transactionId != null) {
      return this._transactionId;
    }
    return super._getTransactionId();
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : proto11.ResponseCodeEnum.OK
    );
    switch (status) {
      case Status.Ok:
        break;
      default:
        return new PrecheckStatusError({
          status,
          transactionId: this._getTransactionId(),
          contractFunctionResult: null
        });
    }
    const transactionGetReceipt = (
      /** @type {HashgraphProto.proto.ITransactionGetReceiptResponse} */
      response.transactionGetReceipt
    );
    const receipt = (
      /** @type {HashgraphProto.proto.ITransactionReceipt} */
      transactionGetReceipt.receipt
    );
    const receiptStatusCode = (
      /** @type {HashgraphProto.proto.ResponseCodeEnum} */
      receipt.status
    );
    status = Status._fromCode(receiptStatusCode);
    if (this._transactionId == null) {
      throw new Error(
        "Failed to construct `ReceiptStatusError` because `transactionId` is `null`"
      );
    }
    return new ReceiptStatusError({
      status,
      transactionId: this._transactionId,
      transactionReceipt: TransactionReceipt._fromProtobuf(
        transactionGetReceipt
      )
    });
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._transactionId != null && this._transactionId.accountId != null) {
      this._transactionId.accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.getTransactionReceipts(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const transactionGetReceipt = (
      /** @type {HashgraphProto.proto.ITransactionGetReceiptResponse} */
      response.transactionGetReceipt
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      transactionGetReceipt.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<TransactionReceipt>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const transactionGetReceipt = (
      /** @type {HashgraphProto.proto.ITransactionGetReceiptResponse} */
      response.transactionGetReceipt
    );
    return Promise.resolve(
      TransactionReceipt._fromProtobuf(transactionGetReceipt)
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      transactionGetReceipt: {
        header,
        transactionID: this._transactionId != null ? this._transactionId._toProtobuf() : null,
        includeDuplicates: this._includeDuplicates,
        includeChildReceipts: this._includeChildren
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    return `TransactionReceiptQuery:${this._timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set(
  "transactionGetReceipt",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TransactionReceiptQuery._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/Transfer.js
var Transfer = class _Transfer {
  /**
   * @internal
   * @param {object} props
   * @param {AccountId | string} props.accountId
   * @param {number | string | Long | BigNumber | Hbar} props.amount
   * @param {boolean} props.isApproved
   */
  constructor(props) {
    this.accountId = props.accountId instanceof AccountId ? props.accountId : AccountId.fromString(props.accountId);
    this.amount = props.amount instanceof Hbar ? props.amount : new Hbar(props.amount);
    this.isApproved = props.isApproved;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IAccountAmount[]} accountAmounts
   * @returns {Transfer[]}
   */
  static _fromProtobuf(accountAmounts) {
    const transfers = [];
    for (const transfer of accountAmounts) {
      transfers.push(
        new _Transfer({
          accountId: AccountId._fromProtobuf(
            /** @type {HashgraphProto.proto.IAccountID} */
            transfer.accountID
          ),
          amount: Hbar.fromTinybars(
            transfer.amount != null ? transfer.amount : 0
          ),
          isApproved: (
            /** @type {boolean} */
            transfer.isApproval
          )
        })
      );
    }
    return transfers;
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IAccountAmount}
   */
  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      amount: this.amount.toTinybars(),
      isApproval: this.isApproved
    };
  }
  /**
   * @returns {TransferJSON}
   */
  toJSON() {
    return {
      accountId: this.accountId.toString(),
      amount: this.amount.toTinybars().toString(),
      isApproved: this.isApproved
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/src/contract/ContractLogInfo.js
var ContractLogInfo = class _ContractLogInfo {
  /**
   * @param {object} props
   * @param {ContractId} props.contractId
   * @param {Uint8Array} props.bloom
   * @param {Uint8Array[]} props.topics
   * @param {Uint8Array} props.data
   */
  constructor(props) {
    this.contractId = props.contractId;
    this.bloom = props.bloom;
    this.topics = props.topics;
    this.data = props.data;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IContractLoginfo} info
   * @returns {ContractLogInfo}
   */
  static _fromProtobuf(info) {
    return new _ContractLogInfo({
      contractId: ContractId._fromProtobuf(
        /** @type {HashgraphProto.proto.IContractID} */
        info.contractID
      ),
      bloom: info.bloom != null ? info.bloom : new Uint8Array(),
      topics: info.topic != null ? info.topic : [],
      data: info.data != null ? info.data : new Uint8Array()
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IContractLoginfo}
   */
  _toProtobuf() {
    return {
      contractID: this.contractId._toProtobuf(),
      bloom: this.bloom,
      topic: this.topics,
      data: this.data
    };
  }
};

// node_modules/@hashgraph/sdk/src/encoding/utf8.browser.js
function decode7(data) {
  return new TextDecoder().decode(data);
}
function encode5(text) {
  return new TextEncoder().encode(text);
}

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn2 = __toESM(require_bn2());

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3 = "bignumber/5.7.0";

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN2 = import_bn2.default.BN;
var logger2 = new Logger(version3);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
var _warnedToStringRadix = false;
var BigNumber = class _BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard) {
      logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return _BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = _BigNumber.from(other);
    if (o.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof _BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new _BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new _BigNumber(_constructorGuard, toHex(new BN2(value)));
      }
      return logger2.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return _BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return _BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return _BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return _BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return _BigNumber.from(hex);
          }
        }
      }
    }
    return logger2.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN2("-" + hex.substring(3), 16);
  }
  return new BN2(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN2(value, 36).toString(16);
}

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
var logger3 = new Logger(version3);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class _FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof _FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger3.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key, type, defaultValue) => {
        if (value[key] == null) {
          return defaultValue;
        }
        if (typeof value[key] !== type) {
          logger3.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }
        return value[key];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new _FixedFormat(_constructorGuard2, signed2, width, decimals);
  }
};
var FixedNumber = class _FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = _FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = _FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = _FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return _FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return _FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return _FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return _FixedNumber.fromBytes(value, format);
    }
    try {
      return _FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version4 = "properties/5.7.0";

// node_modules/@ethersproject/properties/lib.esm/index.js
var logger4 = new Logger(version4);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@ethersproject/abi/lib.esm/_version.js
var version5 = "abi/5.7.0";

// node_modules/@ethersproject/abi/lib.esm/fragments.js
var logger5 = new Logger(version5);
var _constructorGuard3 = {};
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger5.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger5.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key in params) {
    defineReadOnly(object, key, params[key]);
  }
}
var FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = class _ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: _ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return _ParamType.fromString(value, allowIndexed);
    }
    return _ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (_ParamType.isParamType(value)) {
      return value;
    }
    return new _ParamType(_constructorGuard3, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(_ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return _ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
};
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

// node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
var logger6 = new Logger(version5);
var Coder = class {
  constructor(name, type, localName, dynamic) {
    this.name = name;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger6.throwArgumentError(message, this.localName, value);
  }
};
var Writer = class {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat2(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes3 = arrayify(value);
    const paddingOffset = bytes3.length % this.wordSize;
    if (paddingOffset) {
      bytes3 = concat2([bytes3, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes3);
  }
  _getValue(value) {
    let bytes3 = arrayify(BigNumber.from(value));
    if (bytes3.length > this.wordSize) {
      logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes3.length
      });
    }
    if (bytes3.length % this.wordSize) {
      bytes3 = concat2([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
    }
    return bytes3;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
};
var Reader = class _Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name, value) {
    let match = name.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name, value);
    }
    return _Reader.coerce(name, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new _Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes3 = this._peekBytes(0, length, !!loose);
    this._offset += bytes3.length;
    return bytes3.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
};

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak2562(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version6 = "rlp/5.7.0";

// node_modules/@ethersproject/rlp/lib.esm/index.js
var logger7 = new Logger(version6);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger7.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode6(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode8(data) {
  const bytes3 = arrayify(data);
  const decoded = _decode(bytes3, 0);
  if (decoded.consumed !== bytes3.length) {
    logger7.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/@ethersproject/address/lib.esm/_version.js
var version7 = "address/5.7.0";

// node_modules/@ethersproject/address/lib.esm/index.js
var logger8 = new Logger(version7);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak2562(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger8.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger8.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/array.js
var logger9 = new Logger(version5);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      if (!name) {
        logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name]) {
        logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name] = true;
      return values[name];
    });
  } else {
    logger9.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger9.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var ArrayCoder = class extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger9.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder = class extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
};

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2 = BigNumber.from(-1);
var Zero2 = BigNumber.from(0);
var One = BigNumber.from(1);
var Two = BigNumber.from(2);
var WeiPerEther = BigNumber.from("1000000000000000000");
var MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder = class extends Coder {
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    this.size = size;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v = BigNumber.from(value);
    let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne2))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v.lt(Zero2) || v.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v = v.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
};

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version8 = "strings/5.7.0";

// node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger10 = new Logger(version8);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes3, output, badCodepoint) {
  return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes3.length; o++) {
      if (bytes3[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes3.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes3, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes3, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes3 = arrayify(bytes3);
  const result = [];
  let i = 0;
  while (i < bytes3.length) {
    const c = bytes3[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes3, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes3, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes3.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes3, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes3[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes3, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger10.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger11 = new Logger(version5);
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = class {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger11.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger11.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger11.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
};
var defaultAbiCoder = new AbiCoder();

// node_modules/@ethersproject/hash/lib.esm/_version.js
var version9 = "hash/5.7.0";

// node_modules/@ethersproject/base64/lib.esm/base64.js
function decode9(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify(data);
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes3) {
  let pos = 0;
  function u16() {
    return bytes3[pos++] << 8 | bytes3[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes3[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = Math.pow(2, N2);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N2; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 2:
        return offset + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 1:
        return offset + bytes3[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(bytes3) {
  return read_payload(decode_arithmetic(bytes3));
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n, next) {
  let v = Array(n);
  for (let i = 0; i < n; i++)
    v[i] = 1 + next();
  return v;
}
function read_ascending(n, next) {
  let v = Array(n);
  for (let i = 0, x = -1; i < n; i++)
    v[i] = x += 1 + next();
  return v;
}
function read_deltas(n, next) {
  let v = Array(n);
  for (let i = 0, x = 0; i < n; i++)
    v[i] = x += signed(next());
  return v;
}
function read_member_array(next, lookup) {
  let v = read_ascending(next(), next);
  let n = next();
  let vX = read_ascending(n, next);
  let vN = read_counts(n, next);
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < vN[i]; j++) {
      v.push(vX[i] + j);
    }
  }
  return lookup ? v.map((x) => lookup[x]) : v;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v = [];
  while (true) {
    let i = next();
    if (i == 0)
      break;
    v.push(i);
  }
  return v;
}
function read_transposed(n, w, next) {
  let m = Array(n).fill(void 0).map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return flat(m.map((v, i) => {
    const x = v[0], ys = v.slice(1);
    return Array(vN[i]).fill(void 0).map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  }));
}
function read_replacement_table(w, next) {
  let n = 1 + next();
  let m = read_transposed(n, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a, b) => a - b);
  return read2();
  function read2() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read2() });
    }
    branches.sort((a, b) => b.set.size - a.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js
function getData() {
  return read_compressed_payload(decode9("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js
var r = getData();
var VALID = new Set(read_member_array(r));
var IGNORED = new Set(read_member_array(r));
var MAPPED = read_mapped_map(r);
var EMOJI_ROOT = read_emoji_trie(r);

// node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger12 = new Logger(version9);
var Zeros = new Uint8Array(32);
Zeros.fill(0);

// node_modules/@ethersproject/hash/lib.esm/typed-data.js
var logger13 = new Logger(version9);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne3 = BigNumber.from(-1);
var Zero3 = BigNumber.from(0);
var One2 = BigNumber.from(1);
var MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue = hexZeroPad(One2.toHexString(), 32);
var hexFalse = hexZeroPad(Zero3.toHexString(), 32);
function checkString(key) {
  return function(value) {
    if (typeof value !== "string") {
      logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    }
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes3 = arrayify(value);
      if (bytes3.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes3);
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/@ethersproject/abi/lib.esm/interface.js
var logger14 = new Logger(version5);

// node_modules/@hashgraph/sdk/src/contract/ContractFunctionResult.js
var import_long14 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/contract/ContractNonceInfo.js
var import_long13 = __toESM(require_long(), 1);
var protos = __toESM(require_lib(), 1);
var { proto: proto12 } = protos;
var ContractNonceInfo = class _ContractNonceInfo {
  /**
   * @param {object} props
   * @param {ContractId} props.contractId
   * @param {Long} props.nonce
   */
  constructor(props) {
    this.contractId = props.contractId;
    this.nonce = props.nonce;
    Object.freeze(this);
  }
  /**
   *  Extract the contractNonce from the protobuf.
   *
   * @internal
   * @param {HashgraphProto.proto.IContractNonceInfo} contractNonceInfo the protobuf
   * @returns {ContractNonceInfo} the contract object
   */
  static _fromProtobuf(contractNonceInfo) {
    return new _ContractNonceInfo({
      contractId: ContractId._fromProtobuf(
        /** @type {HashgraphProto.proto.IContractID} */
        contractNonceInfo.contractId
      ),
      nonce: contractNonceInfo.nonce != null ? contractNonceInfo.nonce : import_long13.default.ZERO
    });
  }
  /**
   * Build the protobuf
   *
   * @internal
   * @returns {HashgraphProto.proto.IContractNonceInfo} the protobuf representation
   */
  _toProtobuf() {
    return {
      contractId: this.contractId._toProtobuf(),
      nonce: this.nonce
    };
  }
  /**
   * Extract the contractNonce from a byte array.
   *
   * @param {Uint8Array} bytes the byte array
   * @returns {ContractNonceInfo} the extracted contract nonce info
   */
  static fromBytes(bytes3) {
    return _ContractNonceInfo._fromProtobuf(
      proto12.ContractNonceInfo.decode(bytes3)
    );
  }
  /**
   * Create a byte array representation.
   *
   * @returns {Uint8Array} the byte array representation
   */
  toBytes() {
    return proto12.ContractNonceInfo.encode(this._toProtobuf()).finish();
  }
  /**
   * Create a JSON representation.
   *
   * @returns {ContractNonceInfoJSON} the JSON representation
   */
  toJSON() {
    return {
      contractId: this.contractId.toString(),
      nonce: this.nonce.toNumber()
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @param {this} other
   * @returns {boolean}
   */
  equals(other) {
    return this.contractId.equals(other.contractId) && this.nonce.eq(other.nonce);
  }
};

// node_modules/@hashgraph/sdk/src/contract/ContractFunctionResult.js
var ContractFunctionResult = class _ContractFunctionResult {
  /**
   * Constructor isn't part of the stable API
   *
   * @param {object} result
   * @param {boolean} result._createResult
   * @param {?ContractId} result.contractId
   * @param {?string} result.errorMessage
   * @param {Uint8Array} result.bloom
   * @param {Long} result.gasUsed
   * @param {ContractLogInfo[]} result.logs
   * @param {ContractId[]} result.createdContractIds
   * @param {Uint8Array | null} result.evmAddress
   * @param {Uint8Array} result.bytes
   * @param {Long} result.gas
   * @param {Long} result.amount
   * @param {Uint8Array} result.functionParameters
   * @param {?AccountId} result.senderAccountId
   * @param {ContractStateChange[]} result.stateChanges
   * @param {ContractNonceInfo[]} result.contractNonces
   * @param {Long | null} result.signerNonce
   */
  constructor(result) {
    this._createResult = result._createResult;
    this.contractId = result.contractId;
    this.bytes = result.bytes;
    this.errorMessage = result.errorMessage;
    this.bloom = result.bloom;
    this.gasUsed = result.gasUsed;
    this.logs = result.logs;
    this.createdContractIds = result.createdContractIds;
    this.evmAddress = result.evmAddress;
    this.stateChanges = result.stateChanges;
    this.gas = result.gas;
    this.amount = result.amount;
    this.functionParameters = result.functionParameters;
    this.senderAccountId = result.senderAccountId;
    this.contractNonces = result.contractNonces;
    this.signerNonce = result.signerNonce;
  }
  /**
   * @param {HashgraphProto.proto.IContractFunctionResult} result
   * @param {boolean} _createResult
   * @returns {ContractFunctionResult}
   */
  static _fromProtobuf(result, _createResult) {
    const contractId = (
      /** @type {HashgraphProto.proto.IContractID | null} */
      result.contractID
    );
    const gasUsed = (
      /** @type {Long} */
      result.gasUsed
    );
    const gas = (
      /** @type {Long} */
      result.gas ? result.gas : -1
    );
    const amount = (
      /** @type {Long} */
      result.amount ? result.amount : -1
    );
    return new _ContractFunctionResult({
      _createResult,
      bytes: (
        /** @type {Uint8Array} */
        result.contractCallResult
      ),
      contractId: contractId != null ? ContractId._fromProtobuf(contractId) : null,
      errorMessage: result.errorMessage != null ? result.errorMessage : null,
      bloom: (
        /** @type {Uint8Array} */
        result.bloom
      ),
      gasUsed: gasUsed instanceof import_long14.default ? gasUsed : import_long14.default.fromValue(gasUsed),
      logs: (result.logInfo != null ? result.logInfo : []).map(
        (info) => ContractLogInfo._fromProtobuf(info)
      ),
      createdContractIds: (result.createdContractIDs != null ? result.createdContractIDs : []).map((contractId2) => ContractId._fromProtobuf(contractId2)),
      evmAddress: result.evmAddress != null && result.evmAddress.value != null ? result.evmAddress.value : null,
      stateChanges: [],
      gas: gas instanceof import_long14.default ? gas : import_long14.default.fromValue(gas),
      amount: amount instanceof import_long14.default ? amount : import_long14.default.fromValue(amount),
      functionParameters: (
        /** @type {Uint8Array} */
        result.functionParameters
      ),
      senderAccountId: result.senderId != null ? AccountId._fromProtobuf(result.senderId) : null,
      contractNonces: (result.contractNonces != null ? result.contractNonces : []).map(
        (contractNonce) => ContractNonceInfo._fromProtobuf(contractNonce)
      ),
      signerNonce: result.signerNonce != null ? result.signerNonce.value ? result.signerNonce.value : null : null
    });
  }
  /**
   * @returns {Uint8Array}
   */
  asBytes() {
    return this.bytes;
  }
  /**
   * @param {number} [index]
   * @returns {string}
   */
  getString(index) {
    return decode7(this.getBytes(index));
  }
  /**
   * @private
   * @param {number} [index]
   * @returns {Uint8Array}
   */
  getBytes(index) {
    const offset = this.getInt32(index);
    const len = safeView(this.bytes).getInt32(offset + 28);
    return this.bytes.subarray(offset + 32, offset + 32 + len);
  }
  /**
   * @param {number} [index]
   * @returns {Uint8Array}
   */
  getBytes32(index) {
    return this.bytes.subarray(
      (index != null ? index : 0) * 32,
      (index != null ? index : 0) * 32 + 32
    );
  }
  /**
   * @param {number} [index]
   * @returns {boolean}
   */
  getBool(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31] !== 0;
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getInt8(index) {
    const position = (index != null ? index : 0) * 32 + 31;
    return safeView(this.bytes).getInt8(position);
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getUint8(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31];
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getInt16(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getInt32(position);
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getUint16(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getUint32(position);
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getInt24(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getInt32(position);
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getUint24(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getUint32(position);
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getInt32(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getInt32(position);
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */
  getUint32(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getUint32(position);
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt40(index) {
    const result = defaultAbiCoder.decode(
      ["int40"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint40(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(27, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt48(index) {
    const result = defaultAbiCoder.decode(
      ["int48"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint48(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(26, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt56(index) {
    const result = defaultAbiCoder.decode(
      ["int56"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint56(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(25, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt64(index) {
    const result = defaultAbiCoder.decode(
      ["int64"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint64(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(24, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt72(index) {
    const result = defaultAbiCoder.decode(
      ["int72"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint72(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(23, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt80(index) {
    const result = defaultAbiCoder.decode(
      ["int80"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint80(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(22, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt88(index) {
    const result = defaultAbiCoder.decode(
      ["int88"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint88(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(21, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt96(index) {
    const result = defaultAbiCoder.decode(
      ["int96"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint96(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(20, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt104(index) {
    const result = defaultAbiCoder.decode(
      ["int104"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint104(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(19, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt112(index) {
    const result = defaultAbiCoder.decode(
      ["int112"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint112(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(18, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt120(index) {
    const result = defaultAbiCoder.decode(
      ["int120"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint120(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(17, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt128(index) {
    const result = defaultAbiCoder.decode(
      ["int128"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint128(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(16, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt136(index) {
    const result = defaultAbiCoder.decode(
      ["int136"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint136(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(15, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt144(index) {
    const result = defaultAbiCoder.decode(
      ["int144"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint144(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(14, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt152(index) {
    const result = defaultAbiCoder.decode(
      ["int152"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint152(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(13, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt160(index) {
    const result = defaultAbiCoder.decode(
      ["int160"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint160(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(12, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt168(index) {
    const result = defaultAbiCoder.decode(
      ["int168"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint168(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(11, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt176(index) {
    const result = defaultAbiCoder.decode(
      ["int176"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint176(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(10, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt184(index) {
    const result = defaultAbiCoder.decode(
      ["int184"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint184(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(9, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt192(index) {
    const result = defaultAbiCoder.decode(
      ["int192"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint192(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(8, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt200(index) {
    const result = defaultAbiCoder.decode(
      ["int200"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint200(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(7, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt208(index) {
    const result = defaultAbiCoder.decode(
      ["int208"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint208(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(6, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt216(index) {
    const result = defaultAbiCoder.decode(
      ["int216"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint216(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(5, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt224(index) {
    const result = defaultAbiCoder.decode(
      ["int224"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint224(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(4, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt232(index) {
    const result = defaultAbiCoder.decode(
      ["int232"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint232(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(3, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt240(index) {
    const result = defaultAbiCoder.decode(
      ["int240"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint240(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(2, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt248(index) {
    const result = defaultAbiCoder.decode(
      ["int248"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint248(index) {
    return new bignumber_default(
      encode(this._getBytes32(index).subarray(1, 32)),
      16
    );
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getInt256(index) {
    const result = defaultAbiCoder.decode(
      ["int256"],
      this._getBytes32(index != null ? index : 0)
    );
    return new bignumber_default(result.toString());
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */
  getUint256(index) {
    return new bignumber_default(encode(this._getBytes32(index)), 16);
  }
  /**
   * @param {number} [index]
   * @returns {string}
   */
  getAddress(index) {
    return encode(
      this.bytes.subarray(
        (index != null ? index : 0) * 32 + 12,
        (index != null ? index : 0) * 32 + 32
      )
    );
  }
  /**
   * @description Decode the data according to the array of types, each of which may be a string or ParamType.
   * @param {Array<string | ParamType>} types
   * @returns {string | any}
   */
  getResult(types) {
    return defaultAbiCoder.decode(types, this.bytes);
  }
  /**
   * @param {number} [index]
   * @returns {Uint8Array}
   */
  _getBytes32(index) {
    return this.bytes.subarray(
      (index != null ? index : 0) * 32,
      (index != null ? index : 0) * 32 + 32
    );
  }
  /**
   * @returns {HashgraphProto.proto.IContractFunctionResult}
   */
  _toProtobuf() {
    return {
      contractID: this.contractId != null ? this.contractId._toProtobuf() : null,
      contractCallResult: this.bytes,
      errorMessage: this.errorMessage,
      bloom: this.bloom,
      gasUsed: this.gasUsed,
      logInfo: this.logs.map((log) => log._toProtobuf()),
      // eslint-disable-next-line deprecation/deprecation
      createdContractIDs: this.createdContractIds.map(
        (id2) => id2._toProtobuf()
      ),
      evmAddress: this.evmAddress != null ? {
        value: this.evmAddress
      } : null,
      gas: this.gas,
      amount: this.amount,
      functionParameters: this.functionParameters,
      senderId: this.senderAccountId != null ? this.senderAccountId._toProtobuf() : null,
      contractNonces: this.contractNonces.map(
        (contractNonce) => contractNonce._toProtobuf()
      ),
      signerNonce: this.signerNonce != null ? {
        value: this.signerNonce
      } : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/ObjectMap.js
var ObjectMap = class {
  /**
   * @param {(s: string) => KeyT} fromString
   */
  constructor(fromString2) {
    this._map = /* @__PURE__ */ new Map();
    this.__map = /* @__PURE__ */ new Map();
    this._fromString = fromString2;
  }
  /**
   * Get a value by key or string.
   *
   * This is the main benefit of this class. If a user provides a `KeyT` we
   * implicitly serialize it to a string and use the string version. Otherwise
   * the user will get `undefined` even for a key that exists in the map since
   * the `KeyT` the provided has a different pointer than the one we have stored.
   * The string version doesn't have this issue since JS hashes the string and
   * that would result in both `KeyT` hitting the same value even if they're
   * different pointers.
   *
   * @param {KeyT | string} key
   * @returns {?ValueT}
   */
  get(key) {
    const k = typeof key === "string" ? key : key.toString();
    const value = this._map.get(k);
    return value != null ? value : null;
  }
  /**
   * Set the key to a value in both maps
   *
   * @internal
   * @param {KeyT} key
   * @param {ValueT} value
   */
  _set(key, value) {
    const k = typeof key === "string" ? key : key.toString();
    this._map.set(k, value);
    this.__map.set(key, value);
  }
  /**
   * Create iterator of values
   *
   * @returns {IterableIterator<ValueT>}
   */
  values() {
    return this._map.values();
  }
  /**
   * Get the size of the map
   *
   * @returns {number}
   */
  get size() {
    return this._map.size;
  }
  /**
   * Get the keys of the map.
   *
   * @returns {IterableIterator<KeyT>}
   */
  keys() {
    return this.__map.keys();
  }
  /**
   * Create an iterator over key, value pairs
   *
   * @returns {IterableIterator<[KeyT, ValueT]>}
   */
  [Symbol.iterator]() {
    return this.__map[Symbol.iterator]();
  }
  /**
   * Stringify the map into _something_ readable.
   * **NOTE**: This implementation is not stable and can change.
   *
   * @returns {string}
   */
  toString() {
    const map = {};
    for (const [key, value] of this._map) {
      map[key] = value;
    }
    return JSON.stringify(map);
  }
  toJSON() {
    const obj = {};
    this._map.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenTransferAccountMap.js
var TokenTransferAccountMap = class extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
  toJSON() {
    const obj = {};
    this._map.forEach((value, key) => {
      obj[key] = value.toString();
    });
    return obj;
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenTransferMap.js
var TokenTransferMap = class _TokenTransferMap extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
  /**
   * @internal
   * @param {TokenId} tokenId
   * @param {AccountId} accountId
   * @param {Long} amount
   */
  __set(tokenId, accountId, amount) {
    const token = tokenId.toString();
    let _map = this._map.get(token);
    if (_map == null) {
      _map = new TokenTransferAccountMap();
      this._map.set(token, _map);
      this.__map.set(tokenId, _map);
    }
    _map._set(accountId, amount);
  }
  /**
   * @param {HashgraphProto.proto.ITokenTransferList[]} transfers
   * @returns {TokenTransferMap}
   */
  static _fromProtobuf(transfers) {
    const tokenTransfersMap = new _TokenTransferMap();
    for (const transfer of transfers) {
      const token = TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        transfer.token
      );
      for (const aa of transfer.transfers != null ? transfer.transfers : []) {
        const account = AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          aa.accountID
        );
        tokenTransfersMap.__set(
          token,
          account,
          /** @type {Long} */
          aa.amount
        );
      }
    }
    return tokenTransfersMap;
  }
  /**
   * @returns {HashgraphProto.proto.ITokenTransferList[]}
   */
  _toProtobuf() {
    const tokenTransferList = [];
    for (const [tokenId, value] of this) {
      const transfers = [];
      for (const [accountId, amount] of value) {
        transfers.push({
          accountID: accountId._toProtobuf(),
          amount
        });
      }
      tokenTransferList.push({
        token: tokenId._toProtobuf(),
        transfers
      });
    }
    return tokenTransferList;
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenNftTransferMap.js
var import_long15 = __toESM(require_long(), 1);
var TokenNftTransferMap = class _TokenNftTransferMap extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
  /**
   * @internal
   * @param {TokenId} tokenId
   * @param {NftTransfer} nftTransfer
   */
  __set(tokenId, nftTransfer) {
    const token = tokenId.toString();
    let _map = this._map.get(token);
    if (_map == null) {
      _map = [];
      this._map.set(token, _map);
      this.__map.set(tokenId, _map);
    }
    _map.push(nftTransfer);
  }
  /**
   * @param {HashgraphProto.proto.ITokenTransferList[]} transfers
   * @returns {TokenNftTransferMap}
   */
  static _fromProtobuf(transfers) {
    const tokenTransfersMap = new _TokenNftTransferMap();
    for (const transfer of transfers) {
      const token = TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        transfer.token
      );
      for (const aa of transfer.nftTransfers != null ? transfer.nftTransfers : []) {
        const sender = AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          aa.senderAccountID
        );
        const recipient = AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          aa.receiverAccountID
        );
        tokenTransfersMap.__set(token, {
          sender,
          recipient,
          serial: import_long15.default.fromValue(
            /** @type {Long} */
            aa.serialNumber
          ),
          isApproved: false
        });
      }
    }
    return tokenTransfersMap;
  }
  /**
   * @returns {HashgraphProto.proto.ITokenTransferList[]}
   */
  _toProtobuf() {
    const tokenTransferList = [];
    for (const [tokenId, value] of this) {
      const transfers = [];
      for (const transfer of value) {
        transfers.push({
          senderAccountID: transfer.sender._toProtobuf(),
          receiverAccountID: transfer.recipient._toProtobuf(),
          serialNumber: transfer.serial
        });
      }
      tokenTransferList.push({
        token: tokenId._toProtobuf(),
        nftTransfers: transfers
      });
    }
    return tokenTransferList;
  }
  toJSON() {
    const obj = {};
    this._map.forEach((value, key) => {
      obj[key] = value.map((nftTransfer) => ({
        sender: nftTransfer.sender.toString(),
        recipient: nftTransfer.recipient.toString(),
        serial: nftTransfer.serial,
        isApproved: nftTransfer.isApproved
      }));
    });
    return obj;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionRecord.js
var HashgraphProto12 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/token/AssessedCustomFee.js
var import_long16 = __toESM(require_long(), 1);
var AssessedCustomFee = class _AssessedCustomFee {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.feeCollectorAccountId]
   * @param {TokenId | string} [props.tokenId]
   * @param {Long | number} [props.amount]
   * @param {AccountId[]} [props.payerAccountIds]
   */
  constructor(props = {}) {
    this._feeCollectorAccountId = null;
    if (props.feeCollectorAccountId != null) {
      this.setFeeCollectorAccountId(props.feeCollectorAccountId);
    }
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    this._amount = null;
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    this._payerAccountIds = null;
    if (props.payerAccountIds != null) {
      this.setPayerAccountIds(props.payerAccountIds);
    }
  }
  /**
   * @returns {?AccountId}
   */
  get feeCollectorAccountId() {
    return this._feeCollectorAccountId;
  }
  /**
   * @param {AccountId | string} feeCollectorAccountId
   * @returns {this}
   */
  setFeeCollectorAccountId(feeCollectorAccountId) {
    this._feeCollectorAccountId = typeof feeCollectorAccountId === "string" ? AccountId.fromString(feeCollectorAccountId) : feeCollectorAccountId;
    return this;
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {AssessedCustomFee}
   */
  setAmount(amount) {
    this._amount = typeof amount === "number" ? import_long16.default.fromNumber(amount) : amount;
    return this;
  }
  /**
   * @returns {?AccountId[]}
   */
  get payerAccountIds() {
    return this._payerAccountIds;
  }
  /**
   * @param {AccountId[]} payerAccountIds
   * @returns {AssessedCustomFee}
   */
  setPayerAccountIds(payerAccountIds) {
    this._payerAccountIds = payerAccountIds;
    return this;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IAssessedCustomFee} fee
   * @returns {AssessedCustomFee}
   */
  static _fromProtobuf(fee) {
    return new _AssessedCustomFee({
      feeCollectorAccountId: fee.feeCollectorAccountId != null ? AccountId._fromProtobuf(fee.feeCollectorAccountId) : void 0,
      tokenId: fee.tokenId != null ? TokenId._fromProtobuf(fee.tokenId) : void 0,
      amount: fee.amount != null ? fee.amount : void 0,
      payerAccountIds: fee.effectivePayerAccountId != null ? fee.effectivePayerAccountId.map(
        (id2) => AccountId._fromProtobuf(id2)
      ) : void 0
    });
  }
  /**
   * @internal
   * @abstract
   * @returns {HashgraphProto.proto.IAssessedCustomFee}
   */
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      amount: this._amount,
      effectivePayerAccountId: this._payerAccountIds != null ? this._payerAccountIds.map((id2) => id2._toProtobuf()) : null
    };
  }
  /**
   * @returns {AssessedCustomFeeJSON}
   */
  toJSON() {
    var _a2, _b, _c, _d;
    return {
      feeCollectorAccountId: ((_a2 = this.feeCollectorAccountId) == null ? void 0 : _a2.toString()) || null,
      tokenId: ((_b = this._tokenId) == null ? void 0 : _b.toString()) || null,
      amount: ((_c = this._amount) == null ? void 0 : _c.toString()) || null,
      payerAccountIds: ((_d = this._payerAccountIds) == null ? void 0 : _d.map((id2) => id2.toString())) || []
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenAssociation.js
var TokenAssociation = class _TokenAssociation {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.accountId]
   * @param {TokenId | string} [props.tokenId]
   */
  constructor(props = {}) {
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    this._defaultMaxTransactionFee = new Hbar(5);
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId;
    return this;
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
    return this;
  }
  /**
   * @internal
   * @abstract
   * @param {HashgraphProto.proto.ITokenAssociation} association
   * @returns {TokenAssociation}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _fromProtobuf(association) {
    return new _TokenAssociation({
      accountId: association.accountId != null ? AccountId._fromProtobuf(association.accountId) : void 0,
      tokenId: association.tokenId != null ? TokenId._fromProtobuf(association.tokenId) : void 0
    });
  }
  /**
   * @internal
   * @abstract
   * @returns {HashgraphProto.proto.ITokenAssociation}
   */
  _toProtobuf() {
    return {
      accountId: this._accountId != null ? this._accountId._toProtobuf() : void 0,
      tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : void 0
    };
  }
  /**
   * @returns {TokenAssociationJSON}
   */
  toJSON() {
    var _a2, _b;
    return {
      accountId: ((_a2 = this._accountId) == null ? void 0 : _a2.toString()) || null,
      tokenId: ((_b = this._tokenId) == null ? void 0 : _b.toString()) || null
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenTransfer.js
var import_long17 = __toESM(require_long(), 1);
var TokenTransfer = class _TokenTransfer {
  /**
   * @internal
   * @param {object} props
   * @param {TokenId | string} props.tokenId
   * @param {AccountId | string} props.accountId
   * @param {number | null} props.expectedDecimals
   * @param {Long | number} props.amount
   * @param {boolean} props.isApproved
   */
  constructor(props) {
    this.tokenId = props.tokenId instanceof TokenId ? props.tokenId : TokenId.fromString(props.tokenId);
    this.accountId = props.accountId instanceof AccountId ? props.accountId : AccountId.fromString(props.accountId);
    this.expectedDecimals = props.expectedDecimals;
    this.amount = import_long17.default.fromValue(props.amount);
    this.isApproved = props.isApproved;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITokenTransferList[]} tokenTransfers
   * @returns {TokenTransfer[]}
   */
  static _fromProtobuf(tokenTransfers) {
    const transfers = [];
    for (const tokenTransfer of tokenTransfers) {
      const tokenId = TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        tokenTransfer.token
      );
      const expectedDecimals = tokenTransfer.expectedDecimals != null ? (
        /** @type {number | null } */
        tokenTransfer.expectedDecimals.value
      ) : null;
      for (const transfer of tokenTransfer.transfers != null ? tokenTransfer.transfers : []) {
        transfers.push(
          new _TokenTransfer({
            tokenId,
            accountId: AccountId._fromProtobuf(
              /** @type {HashgraphProto.proto.IAccountID} */
              transfer.accountID
            ),
            expectedDecimals,
            amount: transfer.amount != null ? transfer.amount : import_long17.default.ZERO,
            isApproved: transfer.isApproval == true
          })
        );
      }
    }
    return transfers;
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IAccountAmount}
   */
  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      amount: this.amount,
      isApproval: this.isApproved
    };
  }
  /**
   * @returns {TokenTransferJSON}
   */
  toJSON() {
    return {
      tokenId: this.tokenId.toString(),
      accountId: this.accountId.toString(),
      expectedDecimals: this.expectedDecimals,
      amount: this.amount.toString(),
      isApproved: this.isApproved
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionRecord.js
var TransactionRecord = class _TransactionRecord {
  /**
   * @private
   * @param {object} props
   * @param {ContractFunctionResult} [props.contractFunctionResult]
   * @param {TransactionReceipt} props.receipt
   * @param {Uint8Array} props.transactionHash
   * @param {Timestamp} props.consensusTimestamp
   * @param {TransactionId} props.transactionId
   * @param {string} props.transactionMemo
   * @param {Hbar} props.transactionFee
   * @param {Transfer[]} props.transfers
   * @param {TokenTransferMap} props.tokenTransfers
   * @param {TokenTransfer[]} props.tokenTransfersList
   * @param {?ScheduleId} props.scheduleRef
   * @param {AssessedCustomFee[]} props.assessedCustomFees
   * @param {TokenNftTransferMap} props.nftTransfers
   * @param {TokenAssocation[]} props.automaticTokenAssociations
   * @param {Timestamp | null} props.parentConsensusTimestamp
   * @param {PublicKey | null} props.aliasKey
   * @param {TransactionRecord[]} props.duplicates
   * @param {TransactionRecord[]} props.children
   * @param {HbarAllowance[]} props.hbarAllowanceAdjustments
   * @param {TokenAllowance[]} props.tokenAllowanceAdjustments
   * @param {TokenNftAllowance[]} props.nftAllowanceAdjustments
   * @param {?Uint8Array} props.ethereumHash
   * @param {Transfer[]} props.paidStakingRewards
   * @param {?Uint8Array} props.prngBytes
   * @param {?number} props.prngNumber
   * @param {?EvmAddress} props.evmAddress
   */
  constructor(props) {
    this.receipt = props.receipt;
    this.transactionHash = props.transactionHash;
    this.consensusTimestamp = props.consensusTimestamp;
    this.transactionId = props.transactionId;
    this.transactionMemo = props.transactionMemo;
    this.transactionFee = props.transactionFee;
    this.transfers = props.transfers;
    this.contractFunctionResult = props.contractFunctionResult != null ? props.contractFunctionResult : null;
    this.tokenTransfers = props.tokenTransfers;
    this.tokenTransfersList = props.tokenTransfersList;
    this.scheduleRef = props.scheduleRef;
    this.assessedCustomFees = props.assessedCustomFees;
    this.nftTransfers = props.nftTransfers;
    this.automaticTokenAssociations = props.automaticTokenAssociations;
    this.parentConsensusTimestamp = props.parentConsensusTimestamp;
    this.aliasKey = props.aliasKey;
    this.duplicates = props.duplicates;
    this.children = props.children;
    this.hbarAllowanceAdjustments = props.hbarAllowanceAdjustments;
    this.tokenAllowanceAdjustments = props.tokenAllowanceAdjustments;
    this.nftAllowanceAdjustments = props.nftAllowanceAdjustments;
    this.ethereumHash = props.ethereumHash;
    this.paidStakingRewards = props.paidStakingRewards;
    this.prngBytes = props.prngBytes;
    this.prngNumber = props.prngNumber;
    this.evmAddress = props.evmAddress;
    Object.freeze(this);
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ITransactionGetRecordResponse}
   */
  _toProtobuf() {
    const tokenTransfers = this.tokenTransfers._toProtobuf();
    const nftTransfers = this.nftTransfers._toProtobuf();
    const tokenTransferLists = [];
    for (const tokenTransfer of tokenTransfers) {
      for (const nftTransfer of nftTransfers) {
        if (tokenTransfer.token != null && nftTransfer.token != null && tokenTransfer.token.shardNum === nftTransfer.token.shardNum && tokenTransfer.token.realmNum === nftTransfer.token.realmNum && tokenTransfer.token.tokenNum === nftTransfer.token.tokenNum) {
          tokenTransferLists.push({
            token: tokenTransfer.token,
            transfers: tokenTransfer.transfers,
            nftTransfers: tokenTransfer.nftTransfers
          });
        } else {
          tokenTransferLists.push(tokenTransfer);
          tokenTransferLists.push(nftTransfer);
        }
      }
    }
    const duplicates = this.duplicates.map(
      (record) => (
        /** @type {HashgraphProto.proto.ITransactionRecord} */
        record._toProtobuf().transactionRecord
      )
    );
    const children = this.children.map(
      (record) => (
        /** @type {HashgraphProto.proto.ITransactionRecord} */
        record._toProtobuf().transactionRecord
      )
    );
    return {
      duplicateTransactionRecords: duplicates,
      childTransactionRecords: children,
      transactionRecord: {
        receipt: this.receipt._toProtobuf().receipt,
        transactionHash: this.transactionHash != null ? this.transactionHash : null,
        consensusTimestamp: this.consensusTimestamp != null ? this.consensusTimestamp._toProtobuf() : null,
        transactionID: this.transactionId != null ? this.transactionId._toProtobuf() : null,
        memo: this.transactionMemo != null ? this.transactionMemo : null,
        transactionFee: this.transactionFee != null ? this.transactionFee.toTinybars() : null,
        contractCallResult: this.contractFunctionResult != null && !this.contractFunctionResult._createResult ? this.contractFunctionResult._toProtobuf() : null,
        contractCreateResult: this.contractFunctionResult != null && this.contractFunctionResult._createResult ? this.contractFunctionResult._toProtobuf() : null,
        transferList: this.transfers != null ? {
          accountAmounts: this.transfers.map(
            (transfer) => transfer._toProtobuf()
          )
        } : null,
        tokenTransferLists,
        scheduleRef: this.scheduleRef != null ? this.scheduleRef._toProtobuf() : null,
        assessedCustomFees: this.assessedCustomFees.map(
          (fee) => fee._toProtobuf()
        ),
        automaticTokenAssociations: this.automaticTokenAssociations.map(
          (association) => association._toProtobuf()
        ),
        parentConsensusTimestamp: this.parentConsensusTimestamp != null ? this.parentConsensusTimestamp._toProtobuf() : null,
        alias: this.aliasKey != null ? HashgraphProto12.proto.Key.encode(
          this.aliasKey._toProtobufKey()
        ).finish() : null,
        ethereumHash: this.ethereumHash,
        paidStakingRewards: this.paidStakingRewards.map(
          (transfer) => transfer._toProtobuf()
        ),
        prngBytes: this.prngBytes,
        prngNumber: this.prngNumber != null ? this.prngNumber : null,
        evmAddress: this.evmAddress != null ? this.evmAddress.toBytes() : null
      }
    };
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransactionGetRecordResponse} response
   * @returns {TransactionRecord}
   */
  static _fromProtobuf(response) {
    const record = (
      /** @type {HashgraphProto.proto.ITransactionRecord} */
      response.transactionRecord
    );
    let aliasKey = record.alias != null && record.alias.length > 0 ? Key2._fromProtobufKey(
      HashgraphProto12.proto.Key.decode(record.alias)
    ) : null;
    if (!(aliasKey instanceof PublicKey2)) {
      aliasKey = null;
    }
    const children = response.childTransactionRecords != null ? response.childTransactionRecords.map(
      (child) => _TransactionRecord._fromProtobuf({
        transactionRecord: child
      })
    ) : [];
    const duplicates = response.duplicateTransactionRecords != null ? response.duplicateTransactionRecords.map(
      (duplicate) => _TransactionRecord._fromProtobuf({
        transactionRecord: duplicate
      })
    ) : [];
    const contractFunctionResult = record.contractCallResult != null ? ContractFunctionResult._fromProtobuf(
      record.contractCallResult,
      false
    ) : record.contractCreateResult != null ? ContractFunctionResult._fromProtobuf(
      record.contractCreateResult,
      true
    ) : void 0;
    return new _TransactionRecord({
      receipt: TransactionReceipt._fromProtobuf({
        receipt: (
          /** @type {HashgraphProto.proto.ITransactionReceipt} */
          record.receipt
        )
      }),
      transactionHash: record.transactionHash != null ? record.transactionHash : new Uint8Array(),
      consensusTimestamp: Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        record.consensusTimestamp
      ),
      transactionId: TransactionId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITransactionID} */
        record.transactionID
      ),
      transactionMemo: record.memo != null ? record.memo : "",
      transactionFee: Hbar.fromTinybars(
        record.transactionFee != null ? record.transactionFee : 0
      ),
      transfers: Transfer._fromProtobuf(
        record.transferList != null ? record.transferList.accountAmounts != null ? record.transferList.accountAmounts : [] : []
      ),
      contractFunctionResult,
      tokenTransfers: TokenTransferMap._fromProtobuf(
        record.tokenTransferLists != null ? record.tokenTransferLists : []
      ),
      tokenTransfersList: TokenTransfer._fromProtobuf(
        record.tokenTransferLists != null ? record.tokenTransferLists : []
      ),
      scheduleRef: record.scheduleRef != null ? ScheduleId._fromProtobuf(record.scheduleRef) : null,
      assessedCustomFees: record.assessedCustomFees != null ? record.assessedCustomFees.map(
        (fee) => AssessedCustomFee._fromProtobuf(fee)
      ) : [],
      nftTransfers: TokenNftTransferMap._fromProtobuf(
        record.tokenTransferLists != null ? record.tokenTransferLists : []
      ),
      automaticTokenAssociations: record.automaticTokenAssociations != null ? record.automaticTokenAssociations.map(
        (association) => TokenAssociation._fromProtobuf(association)
      ) : [],
      parentConsensusTimestamp: record.parentConsensusTimestamp != null ? Timestamp._fromProtobuf(record.parentConsensusTimestamp) : null,
      aliasKey,
      duplicates,
      children,
      hbarAllowanceAdjustments: [],
      tokenAllowanceAdjustments: [],
      nftAllowanceAdjustments: [],
      ethereumHash: record.ethereumHash != null ? record.ethereumHash : null,
      paidStakingRewards: record.paidStakingRewards != null ? Transfer._fromProtobuf(record.paidStakingRewards) : [],
      prngBytes: record.prngBytes != null ? record.prngBytes : null,
      prngNumber: record.prngNumber != null ? record.prngNumber : null,
      evmAddress: record.evmAddress != null ? EvmAddress.fromBytes(record.evmAddress) : null
    });
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionRecord}
   */
  static fromBytes(bytes3) {
    return _TransactionRecord._fromProtobuf(
      HashgraphProto12.proto.TransactionGetRecordResponse.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto12.proto.TransactionGetRecordResponse.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {TransactionRecordJSON}
   */
  toJSON() {
    var _a2, _b, _c, _d;
    return {
      receipt: this.receipt.toJSON(),
      transactionHash: encode(this.transactionHash),
      consensusTimestamp: this.consensusTimestamp.toDate(),
      transactionId: this.transactionId.toString(),
      transactionMemo: this.transactionMemo,
      transactionFee: this.transactionFee.toTinybars().toString(),
      transfers: this.transfers.map((transfer) => transfer.toJSON()),
      tokenTransfers: this.tokenTransfers,
      tokenTransfersList: this.tokenTransfersList.map(
        (transfer) => transfer.toJSON()
      ),
      scheduleRef: ((_a2 = this.scheduleRef) == null ? void 0 : _a2.toString()) || null,
      assessedCustomFees: this.assessedCustomFees,
      nftTransfers: this.nftTransfers,
      automaticTokenAssociations: this.automaticTokenAssociations,
      parentConsensusTimestamp: ((_b = this.parentConsensusTimestamp) == null ? void 0 : _b.toDate()) || null,
      aliasKey: ((_c = this.aliasKey) == null ? void 0 : _c.toString()) || null,
      duplicates: this.duplicates,
      children: this.children,
      ethereumHash: this.ethereumHash != null ? encode(this.ethereumHash) : null,
      paidStakingRewards: this.paidStakingRewards,
      prngBytes: this.prngBytes != null ? encode(this.prngBytes) : null,
      prngNumber: this.prngNumber,
      evmAddress: ((_d = this.evmAddress) == null ? void 0 : _d.toString()) || null
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/src/RecordStatusError.js
var RecordStatusError = class extends StatusError {
  /**
   * @param {object} props
   * @param {TransactionRecord} props.transactionRecord
   * @param {Status} props.status
   * @param {TransactionId} props.transactionId
   */
  constructor(props) {
    super(
      props,
      `Record for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`
    );
    this.transactionRecord = props.transactionRecord;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionRecordQuery.js
var HashgraphProto13 = __toESM(require_lib(), 1);
var { proto: proto15 } = HashgraphProto13;
var TransactionRecordQuery = class _TransactionRecordQuery extends Query {
  /**
   * @param {object} [props]
   * @param {TransactionId} [props.transactionId]
   * @param {boolean} [props.includeChildren]
   * @param {boolean} [props.includeDuplicates]
   * @param {boolean} [props.validateReceiptStatus]
   */
  constructor(props = {}) {
    super();
    this._transactionId = null;
    this._includeChildren = null;
    this._includeDuplicates = null;
    this._validateReceiptStatus = true;
    if (props.transactionId != null) {
      this.setTransactionId(props.transactionId);
    }
    if (props.includeChildren != null) {
      this.setIncludeChildren(props.includeChildren);
    }
    if (props.includeDuplicates != null) {
      this.setIncludeDuplicates(props.includeDuplicates);
    }
    if (props.validateReceiptStatus != null) {
      this.setValidateReceiptStatus(props.validateReceiptStatus);
    }
  }
  /**
   * @returns {?TransactionId}
   */
  get transactionId() {
    return this._transactionId;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {TransactionRecordQuery}
   */
  static _fromProtobuf(query) {
    const record = (
      /** @type {HashgraphProto.proto.ITransactionGetRecordQuery} */
      query.transactionGetRecord
    );
    return new _TransactionRecordQuery({
      transactionId: record.transactionID ? TransactionId._fromProtobuf(record.transactionID) : void 0,
      includeChildren: record.includeChildRecords != null ? record.includeChildRecords : void 0,
      includeDuplicates: record.includeDuplicates != null ? record.includeDuplicates : void 0
    });
  }
  /**
   * Set the transaction ID for which the record is being requested.
   *
   * @param {TransactionId | string} transactionId
   * @returns {TransactionRecordQuery}
   */
  setTransactionId(transactionId) {
    this._transactionId = typeof transactionId === "string" ? TransactionId.fromString(transactionId) : transactionId.clone();
    return this;
  }
  /**
   * @param {boolean} includeChildren
   * @returns {TransactionRecordQuery}
   */
  setIncludeChildren(includeChildren) {
    this._includeChildren = includeChildren;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get includeChildren() {
    return this._includeChildren != null ? this._includeChildren : false;
  }
  /**
   * @param {boolean} includeDuplicates
   * @returns {TransactionRecordQuery}
   */
  setIncludeDuplicates(includeDuplicates) {
    this._duplicates = includeDuplicates;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get includeDuplicates() {
    return this._duplicates != null ? this._duplicates : false;
  }
  /**
   * @param {boolean} validateReceiptStatus
   * @returns {this}
   */
  setValidateReceiptStatus(validateReceiptStatus) {
    this._validateReceiptStatus = validateReceiptStatus;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get validateReceiptStatus() {
    return this._validateReceiptStatus;
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {[Status, ExecutionState]}
   */
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : proto15.ResponseCodeEnum.OK
    );
    if (this._logger) {
      this._logger.debug(
        `[${this._getLogId()}] received node precheck status ${status.toString()}`
      );
    }
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
      case Status.RecordNotFound:
        return [status, ExecutionState.Retry];
      case Status.Ok:
        break;
      default:
        return [status, ExecutionState.Error];
    }
    const transactionGetRecord = (
      /** @type {HashgraphProto.proto.ITransactionGetRecordResponse} */
      response.transactionGetRecord
    );
    const header = (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      transactionGetRecord.header
    );
    if (header.responseType === HashgraphProto13.proto.ResponseType.COST_ANSWER) {
      return [status, ExecutionState.Finished];
    }
    const record = (
      /** @type {HashgraphProto.proto.ITransactionRecord} */
      transactionGetRecord.transactionRecord
    );
    const receipt = (
      /** @type {HashgraphProto.proto.ITransactionReceipt} */
      record.receipt
    );
    const receiptStatusCode = (
      /** @type {HashgraphProto.proto.ResponseCodeEnum} */
      receipt.status
    );
    status = Status._fromCode(receiptStatusCode);
    if (this._logger) {
      this._logger.debug(
        `[${this._getLogId()}] received record's receipt ${status.toString()}`
      );
    }
    switch (status) {
      case Status.Ok:
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
      case Status.RecordNotFound:
        return [status, ExecutionState.Retry];
      case Status.Success:
        return [status, ExecutionState.Finished];
      default:
        return [
          status,
          this._validateReceiptStatus ? ExecutionState.Error : ExecutionState.Finished
        ];
    }
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : proto15.ResponseCodeEnum.OK
    );
    switch (status) {
      case Status.Ok:
        break;
      case Status.ContractRevertExecuted:
        return new RecordStatusError({
          status,
          transactionId: this._getTransactionId(),
          transactionRecord: TransactionRecord._fromProtobuf({
            transactionRecord: (
              // @ts-ignore
              response.transactionGetRecord.transactionRecord
            )
          })
        });
      default:
        return new PrecheckStatusError({
          status,
          transactionId: this._getTransactionId(),
          contractFunctionResult: null
        });
    }
    const transactionGetRecord = (
      /** @type {HashgraphProto.proto.ITransactionGetRecordResponse} */
      response.transactionGetRecord
    );
    const record = (
      /** @type {HashgraphProto.proto.ITransactionRecord} */
      transactionGetRecord.transactionRecord
    );
    const receipt = (
      /** @type {HashgraphProto.proto.ITransactionReceipt} */
      record.receipt
    );
    const receiptStatusError = (
      /** @type {HashgraphProto.proto.ResponseCodeEnum} */
      receipt.status
    );
    status = Status._fromCode(receiptStatusError);
    switch (status) {
      case Status.ContractRevertExecuted:
        return new RecordStatusError({
          status,
          transactionId: this._getTransactionId(),
          transactionRecord: TransactionRecord._fromProtobuf({
            transactionRecord: (
              // @ts-ignore
              response.transactionGetRecord.transactionRecord
            )
          })
        });
      default:
        return new ReceiptStatusError({
          status,
          transactionId: this._getTransactionId(),
          transactionReceipt: TransactionReceipt._fromProtobuf({
            receipt
          })
        });
    }
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._transactionId != null && this._transactionId.accountId != null) {
      this._transactionId.accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.getTxRecordByTxID(request);
  }
  /**
   * @override
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const transactionGetRecord = (
      /** @type {HashgraphProto.proto.ITransactionGetRecordResponse} */
      response.transactionGetRecord
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      transactionGetRecord.header
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<TransactionRecord>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const record = (
      /** @type {HashgraphProto.proto.ITransactionGetRecordResponse} */
      response.transactionGetRecord
    );
    return Promise.resolve(TransactionRecord._fromProtobuf(record));
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      transactionGetRecord: {
        header,
        transactionID: this._transactionId != null ? this._transactionId._toProtobuf() : null,
        includeChildRecords: this._includeChildren,
        includeDuplicates: this._includeDuplicates
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `TransactionRecordQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set(
  "transactionGetRecord",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TransactionRecordQuery._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/transaction/TransactionResponse.js
var TransactionResponse = class _TransactionResponse {
  /**
   * @internal
   * @param {object} props
   * @param {AccountId} props.nodeId
   * @param {Uint8Array} props.transactionHash
   * @param {TransactionId} props.transactionId
   */
  constructor(props) {
    this.nodeId = props.nodeId;
    this.transactionHash = props.transactionHash;
    this.transactionId = props.transactionId;
    Object.freeze(this);
  }
  /**
   * @param {TransactionResponseJSON} json
   * @returns {TransactionResponse}
   */
  static fromJSON(json) {
    return new _TransactionResponse({
      nodeId: AccountId.fromString(json.nodeId),
      transactionHash: decode(json.transactionHash),
      transactionId: TransactionId.fromString(json.transactionId)
    });
  }
  /**
   * @param {Client} client
   * @returns {Promise<TransactionReceipt>}
   */
  async getReceipt(client) {
    const receipt = await this.getReceiptQuery().execute(client);
    if (receipt.status !== Status.Success) {
      throw new ReceiptStatusError({
        transactionReceipt: receipt,
        status: receipt.status,
        transactionId: this.transactionId
      });
    }
    return receipt;
  }
  /**
   * getRecord is calling getReceipt and in case the receipt status code is not OK, only the receipt is returned.
   *
   * @param {Client} client
   * @returns {Promise<TransactionRecord>}
   */
  async getRecord(client) {
    await this.getReceipt(client);
    return this.getRecordQuery().execute(client);
  }
  /**
   * getVerboseRecord is calling getReceipt and in case the receipt status code is not OK, the record is returned.
   *
   * @param {Client} client
   * @returns {Promise<TransactionRecord>}
   */
  async getVerboseRecord(client) {
    try {
      await this.getReceiptQuery().execute(client);
      return this.getRecordQuery().execute(client);
    } catch (e) {
      return this.getRecordQuery().execute(client);
    }
  }
  /**
   * @param {Signer} signer
   * @returns {Promise<TransactionReceipt>}
   */
  async getReceiptWithSigner(signer) {
    const receipt = await this.getReceiptQuery().executeWithSigner(signer);
    if (receipt.status !== Status.Success) {
      throw new ReceiptStatusError({
        transactionReceipt: receipt,
        status: receipt.status,
        transactionId: this.transactionId
      });
    }
    return receipt;
  }
  /**
   * @param {Signer} signer
   * @returns {Promise<TransactionRecord>}
   */
  async getRecordWithSigner(signer) {
    await this.getReceiptWithSigner(signer);
    return this.getRecordQuery().executeWithSigner(signer);
  }
  /**
   * @returns {TransactionReceiptQuery}
   */
  getReceiptQuery() {
    return new TransactionReceiptQuery().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]);
  }
  /**
   * @returns {TransactionRecordQuery}
   */
  getRecordQuery() {
    return new TransactionRecordQuery().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]);
  }
  /**
   * @returns {TransactionResponseJSON}
   */
  toJSON() {
    return {
      nodeId: this.nodeId.toString(),
      transactionHash: encode(this.transactionHash),
      transactionId: this.transactionId.toString()
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/src/cryptography/sha384.browser.js
async function digest2(data) {
  return new Uint8Array(await window.crypto.subtle.digest("SHA-384", data));
}

// node_modules/@hashgraph/sdk/src/transaction/TransactionHashMap.js
var TransactionHashMap = class _TransactionHashMap extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
  /**
   * @param {import("./Transaction.js").default} transaction
   * @returns {Promise<TransactionHashMap>}
   */
  static async _fromTransaction(transaction) {
    const hashes = new _TransactionHashMap();
    for (let i = 0; i < transaction._nodeAccountIds.length; i++) {
      const nodeAccountId = transaction._nodeAccountIds.list[i];
      const tx = (
        /** @type {HashgraphProto.proto.ITransaction} */
        transaction._transactions.get(i)
      );
      const hash2 = await digest2(
        /** @type {Uint8Array} */
        tx.signedTransactionBytes
      );
      hashes._set(nodeAccountId, hash2);
    }
    return hashes;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/NodeAccountIdSignatureMap.js
var NodeAccountIdSignatureMap = class _NodeAccountIdSignatureMap extends ObjectMap {
  constructor() {
    super((s) => PublicKey2.fromString(s));
  }
  /**
   * @param {import("@hashgraph/proto").proto.ISignatureMap} sigMap
   * @returns {NodeAccountIdSignatureMap}
   */
  static _fromTransactionSigMap(sigMap) {
    const signatures = new _NodeAccountIdSignatureMap();
    const sigPairs = sigMap.sigPair != null ? sigMap.sigPair : [];
    for (const sigPair of sigPairs) {
      if (sigPair.pubKeyPrefix != null) {
        if (sigPair.ed25519 != null) {
          signatures._set(
            PublicKey2.fromBytesED25519(sigPair.pubKeyPrefix),
            sigPair.ed25519
          );
        } else if (sigPair.ECDSASecp256k1 != null) {
          signatures._set(
            PublicKey2.fromBytesECDSA(sigPair.pubKeyPrefix),
            sigPair.ECDSASecp256k1
          );
        }
      }
    }
    return signatures;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/SignatureMap.js
var SignatureMap = class _SignatureMap extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
  /**
   * @param {import("./Transaction.js").default} transaction
   * @returns {SignatureMap}
   */
  static _fromTransaction(transaction) {
    const signatures = new _SignatureMap();
    for (let i = 0; i < transaction._nodeAccountIds.length; i++) {
      const sigMap = transaction._signedTransactions.get(i).sigMap;
      if (sigMap != null) {
        signatures._set(
          transaction._nodeAccountIds.list[i],
          NodeAccountIdSignatureMap._fromTransactionSigMap(sigMap)
        );
      }
    }
    return signatures;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/Transaction.js
var import_long18 = __toESM(require_long(), 1);
var HashgraphProto14 = __toESM(require_lib(), 1);
var DEFAULT_AUTO_RENEW_PERIOD = import_long18.default.fromValue(7776e3);
var DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(
  import_long18.default.fromString("9223372036854775807")
);
var DEFAULT_TRANSACTION_VALID_DURATION = 120;
var CHUNK_SIZE = 1024;
var TRANSACTION_REGISTRY = /* @__PURE__ */ new Map();
var Transaction = class extends Executable {
  // A SDK transaction is composed of multiple, raw protobuf transactions.
  // These should be functionally identical, with the exception of pointing to
  // different nodes.
  // When retrying a transaction after a network error or retry-able
  // status response, we try a different transaction and thus a different node.
  constructor() {
    super();
    this._transactions = new List();
    this._signedTransactions = new List();
    this._signerPublicKeys = /* @__PURE__ */ new Set();
    this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;
    this._defaultMaxTransactionFee = new Hbar(2);
    this._maxTransactionFee = null;
    this._transactionMemo = "";
    this._transactionIds = new List();
    this._publicKeys = [];
    this._transactionSigners = [];
    this._regenerateTransactionId = null;
  }
  /**
   * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or
   * `proto.TransactionList`.
   *
   * @param {Uint8Array} bytes
   * @returns {Transaction}
   */
  static fromBytes(bytes3) {
    const signedTransactions = [];
    const transactionIds = [];
    const nodeIds = [];
    const transactionIdStrings = [];
    const nodeIdStrings = [];
    const bodies = [];
    const list = HashgraphProto14.proto.TransactionList.decode(bytes3).transactionList;
    if (list.length === 0) {
      const transaction = HashgraphProto14.proto.Transaction.decode(bytes3);
      if (transaction.signedTransactionBytes.length !== 0) {
        list.push(transaction);
      } else {
        list.push({
          signedTransactionBytes: HashgraphProto14.proto.SignedTransaction.encode({
            sigMap: transaction.sigMap,
            bodyBytes: transaction.bodyBytes
          }).finish()
        });
      }
    }
    for (const transaction of list) {
      if (transaction.bodyBytes == null && transaction.signedTransactionBytes == null) {
        throw new Error(
          "bodyBytes and signedTransactionBytes are null"
        );
      }
      if (transaction.bodyBytes && transaction.bodyBytes.length != 0) {
        const body2 = HashgraphProto14.proto.TransactionBody.decode(
          transaction.bodyBytes
        );
        if (body2.transactionID != null) {
          const transactionId = TransactionId._fromProtobuf(
            /** @type {HashgraphProto.proto.ITransactionID} */
            body2.transactionID
          );
          if (!transactionIdStrings.includes(transactionId.toString())) {
            transactionIds.push(transactionId);
            transactionIdStrings.push(transactionId.toString());
          }
        }
        if (body2.nodeAccountID != null) {
          const nodeAccountId = AccountId._fromProtobuf(
            /** @type {HashgraphProto.proto.IAccountID} */
            body2.nodeAccountID
          );
          if (!nodeIdStrings.includes(nodeAccountId.toString())) {
            nodeIds.push(nodeAccountId);
            nodeIdStrings.push(nodeAccountId.toString());
          }
        }
        if (body2.data == null) {
          throw new Error(
            "(BUG) body.data was not set in the protobuf"
          );
        }
        bodies.push(body2);
      }
      if (transaction.signedTransactionBytes && transaction.signedTransactionBytes.length != 0) {
        const signedTransaction = HashgraphProto14.proto.SignedTransaction.decode(
          transaction.signedTransactionBytes
        );
        signedTransactions.push(signedTransaction);
        const body2 = HashgraphProto14.proto.TransactionBody.decode(
          signedTransaction.bodyBytes
        );
        if (body2.transactionID != null) {
          const transactionId = TransactionId._fromProtobuf(
            /** @type {HashgraphProto.proto.ITransactionID} */
            body2.transactionID
          );
          if (!transactionIdStrings.includes(transactionId.toString())) {
            transactionIds.push(transactionId);
            transactionIdStrings.push(transactionId.toString());
          }
        }
        if (body2.nodeAccountID != null) {
          const nodeAccountId = AccountId._fromProtobuf(
            /** @type {HashgraphProto.proto.IAccountID} */
            body2.nodeAccountID
          );
          if (!nodeIdStrings.includes(nodeAccountId.toString())) {
            nodeIds.push(nodeAccountId);
            nodeIdStrings.push(nodeAccountId.toString());
          }
        }
        if (body2.data == null) {
          throw new Error(
            "(BUG) body.data was not set in the protobuf"
          );
        }
        bodies.push(body2);
      }
    }
    const body = bodies[0];
    if (body == null || body.data == null) {
      throw new Error(
        "No transaction found in bytes or failed to decode TransactionBody"
      );
    }
    const fromProtobuf = TRANSACTION_REGISTRY.get(body.data);
    if (fromProtobuf == null) {
      throw new Error(
        `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`
      );
    }
    return fromProtobuf(
      list,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * Convert this transaction a `ScheduleCreateTransaction`
   *
   * @returns {ScheduleCreateTransaction}
   */
  schedule() {
    this._requireNotFrozen();
    if (SCHEDULE_CREATE_TRANSACTION.length != 1) {
      throw new Error(
        "ScheduleCreateTransaction has not been loaded yet"
      );
    }
    return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);
  }
  /**
   * This method is called by each `*Transaction._fromProtobuf()` method. It does
   * all the finalization before the user gets hold of a complete `Transaction`
   *
   * @template {Transaction} TransactionT
   * @param {TransactionT} transaction
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TransactionT}
   */
  static _fromProtobufTransactions(transaction, transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    for (let i = 0; i < transactionIds.length; i++) {
      for (let j = 0; j < nodeIds.length - 1; j++) {
        if (!compare(
          bodies[i * nodeIds.length + j],
          bodies[i * nodeIds.length + j + 1],
          // eslint-disable-next-line ie11/no-collection-args
          /* @__PURE__ */ new Set(["nodeAccountID"])
        )) {
          throw new Error("failed to validate transaction bodies");
        }
      }
    }
    const zero = new AccountId(0);
    for (let i = 0; i < nodeIds.length; i++) {
      if (nodeIds[i].equals(zero)) {
        nodeIds.splice(i--, 1);
      }
    }
    transaction._transactions.setList(transactions);
    transaction._signedTransactions.setList(signedTransactions);
    transaction._transactionIds.setList(transactionIds);
    transaction._nodeAccountIds.setList(nodeIds);
    transaction._transactionValidDuration = body.transactionValidDuration != null && body.transactionValidDuration.seconds != null ? import_long18.default.fromValue(body.transactionValidDuration.seconds).toInt() : DEFAULT_TRANSACTION_VALID_DURATION;
    transaction._maxTransactionFee = body.transactionFee != null && body.transactionFee > new import_long18.default(0, 0, true) ? Hbar.fromTinybars(body.transactionFee) : null;
    transaction._transactionMemo = body.memo != null ? body.memo : "";
    for (let i = 0; i < nodeIds.length; i++) {
      const tx = signedTransactions[i] || transactions[i];
      if (tx.sigMap != null && tx.sigMap.sigPair != null) {
        for (const sigPair of tx.sigMap.sigPair) {
          transaction._signerPublicKeys.add(
            encode(
              /** @type {Uint8Array} */
              sigPair.pubKeyPrefix
            )
          );
          transaction._publicKeys.push(
            PublicKey2.fromBytes(
              /** @type {Uint8Array} */
              sigPair.pubKeyPrefix
            )
          );
          transaction._transactionSigners.push(null);
        }
      }
    }
    return transaction;
  }
  /**
   * Set the node account IDs
   *
   * @override
   * @param {AccountId[]} nodeIds
   * @returns {this}
   */
  setNodeAccountIds(nodeIds) {
    this._requireNotFrozen();
    super.setNodeAccountIds(nodeIds);
    return this;
  }
  /**
   * Get the transaction valid duration
   *
   * @returns {number}
   */
  get transactionValidDuration() {
    return this._transactionValidDuration;
  }
  /**
   * Sets the duration (in seconds) that this transaction is valid for.
   *
   * This is defaulted to 120 seconds (from the time its executed).
   *
   * @param {number} validDuration
   * @returns {this}
   */
  setTransactionValidDuration(validDuration) {
    this._requireNotFrozen();
    this._transactionValidDuration = validDuration;
    return this;
  }
  /**
   * Get the max transaction fee
   *
   * @returns {?Hbar}
   */
  get maxTransactionFee() {
    return this._maxTransactionFee;
  }
  /**
   * Set the maximum transaction fee the operator (paying account)
   * is willing to pay.
   *
   * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee
   * @returns {this}
   */
  setMaxTransactionFee(maxTransactionFee) {
    this._requireNotFrozen();
    this._maxTransactionFee = maxTransactionFee instanceof Hbar ? maxTransactionFee : new Hbar(maxTransactionFee);
    return this;
  }
  /**
   * Is transaction ID regeneration enabled
   *
   * @returns {?boolean}
   */
  get regenerateTransactionId() {
    return this._regenerateTransactionId;
  }
  /**
   * Set the maximum transaction fee the operator (paying account)
   * is willing to pay.
   *
   * @param {boolean} regenerateTransactionId
   * @returns {this}
   */
  setRegenerateTransactionId(regenerateTransactionId) {
    this._requireNotFrozen();
    this._regenerateTransactionId = regenerateTransactionId;
    return this;
  }
  /**
   * Get the transaction memo
   *
   * @returns {string}
   */
  get transactionMemo() {
    return this._transactionMemo;
  }
  /**
   * Set a note or description to be recorded in the transaction
   * record (maximum length of 100 bytes).
   *
   * @param {string} transactionMemo
   * @returns {this}
   */
  setTransactionMemo(transactionMemo) {
    this._requireNotFrozen();
    this._transactionMemo = transactionMemo;
    return this;
  }
  /**
   * Get the curent transaction ID
   *
   * @returns {?TransactionId}
   */
  get transactionId() {
    if (this._transactionIds.isEmpty) {
      return null;
    }
    this._transactionIds.setLocked();
    return this._transactionIds.current;
  }
  /**
   * Set the ID for this transaction.
   *
   * The transaction ID includes the operator's account ( the account paying the transaction
   * fee). If two transactions have the same transaction ID, they won't both have an effect. One
   * will complete normally and the other will fail with a duplicate transaction status.
   *
   * Normally, you should not use this method. Just before a transaction is executed, a
   * transaction ID will be generated from the operator on the client.
   *
   * @param {TransactionId} transactionId
   * @returns {this}
   */
  setTransactionId(transactionId) {
    this._requireNotFrozen();
    this._transactionIds.setList([transactionId]).setLocked();
    return this;
  }
  /**
   * Sign the transaction with the private key
   * **NOTE**: This is a thin wrapper around `.signWith()`
   *
   * @param {PrivateKey} privateKey
   * @returns {Promise<this>}
   */
  sign(privateKey) {
    return this.signWith(
      privateKey.publicKey,
      (message) => Promise.resolve(privateKey.sign(message))
    );
  }
  /**
   * Sign the transaction with the public key and signer function
   *
   * If sign on demand is enabled no signing will be done immediately, instead
   * the private key signing function and public key are saved to be used when
   * a user calls an exit condition method (not sure what a better name for this is)
   * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.
   *
   * @param {PublicKey} publicKey
   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   * @returns {Promise<this>}
   */
  async signWith(publicKey, transactionSigner) {
    if (!this._signOnDemand) {
      this._requireFrozen();
    }
    const publicKeyData = publicKey.toBytesRaw();
    const publicKeyHex = encode(publicKeyData);
    if (this._signerPublicKeys.has(publicKeyHex)) {
      return this;
    }
    this._transactions.clear();
    this._signerPublicKeys.add(publicKeyHex);
    if (this._signOnDemand) {
      this._publicKeys.push(publicKey);
      this._transactionSigners.push(transactionSigner);
      return this;
    }
    this._transactionIds.setLocked();
    this._nodeAccountIds.setLocked();
    for (const signedTransaction of this._signedTransactions.list) {
      const bodyBytes = (
        /** @type {Uint8Array} */
        signedTransaction.bodyBytes
      );
      const signature = await transactionSigner(bodyBytes);
      if (signedTransaction.sigMap == null) {
        signedTransaction.sigMap = {};
      }
      if (signedTransaction.sigMap.sigPair == null) {
        signedTransaction.sigMap.sigPair = [];
      }
      signedTransaction.sigMap.sigPair.push(
        publicKey._toProtobufSignature(signature)
      );
    }
    return this;
  }
  /**
   * Sign the transaction with the client operator. This is a thin wrapper
   * around `.signWith()`
   *
   * **NOTE**: If client does not have an operator set, this method will throw
   *
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<this>}
   */
  signWithOperator(client) {
    const operator = client._operator;
    if (operator == null) {
      throw new Error(
        "`client` must have an operator to sign with the operator"
      );
    }
    if (!this._isFrozen()) {
      this.freezeWith(client);
    }
    return this.signWith(operator.publicKey, operator.transactionSigner);
  }
  /**
   * Add a signature explicitly
   *
   * This method requires the transaction to have exactly 1 node account ID set
   * since different node account IDs have different byte representations and
   * hence the same signature would not work for all transactions that are the same
   * except for node account ID being different.
   *
   * @param {PublicKey} publicKey
   * @param {Uint8Array} signature
   * @returns {this}
   */
  addSignature(publicKey, signature) {
    this._requireOneNodeAccountId();
    if (!this.isFrozen()) {
      this.freeze();
    }
    const publicKeyData = publicKey.toBytesRaw();
    const publicKeyHex = encode(publicKeyData);
    if (this._signerPublicKeys.has(publicKeyHex)) {
      return this;
    }
    this._transactions.clear();
    this._transactionIds.setLocked();
    this._nodeAccountIds.setLocked();
    this._signedTransactions.setLocked();
    for (const transaction of this._signedTransactions.list) {
      if (transaction.sigMap == null) {
        transaction.sigMap = {};
      }
      if (transaction.sigMap.sigPair == null) {
        transaction.sigMap.sigPair = [];
      }
      transaction.sigMap.sigPair.push(
        publicKey._toProtobufSignature(signature)
      );
    }
    this._signerPublicKeys.add(publicKeyHex);
    this._publicKeys.push(publicKey);
    this._transactionSigners.push(null);
    return this;
  }
  /**
   * Get the current signatures on the request
   *
   * **NOTE**: Does NOT support sign on demand
   *
   * @returns {SignatureMap}
   */
  getSignatures() {
    this._requireFrozen();
    this._requireNotSignOnDemand();
    this._buildAllTransactions();
    this._transactionIds.setLocked();
    this._nodeAccountIds.setLocked();
    return SignatureMap._fromTransaction(this);
  }
  /**
   * Get the current signatures on the request
   *
   * **NOTE**: Supports sign on demand
   *
   * @returns {Promise<SignatureMap>}
   */
  async getSignaturesAsync() {
    this._transactionIds.setLocked();
    this._nodeAccountIds.setLocked();
    await this._buildAllTransactionsAsync();
    this._transactions.setLocked();
    this._signedTransactions.setLocked();
    return SignatureMap._fromTransaction(this);
  }
  /**
   * Not sure why this is called `setTransactionId()` when it doesn't set anything...
   * FIXME: Remove this?
   */
  _setTransactionId() {
    if (this._operatorAccountId == null && this._transactionIds.isEmpty) {
      throw new Error(
        "`transactionId` must be set or `client` must be provided with `freezeWith`"
      );
    }
  }
  /**
   * Set the node account IDs using the client
   *
   * @param {?import("../client/Client.js").default<Channel, *>} client
   */
  _setNodeAccountIds(client) {
    if (!this._nodeAccountIds.isEmpty) {
      return;
    }
    if (client == null) {
      throw new Error(
        "`nodeAccountId` must be set or `client` must be provided with `freezeWith`"
      );
    }
    this._nodeAccountIds.setList(
      client._network.getNodeAccountIdsForExecute()
    );
  }
  /**
   * Build all the signed transactions from the node account IDs
   *
   * @private
   */
  _buildSignedTransactions() {
    if (this._signedTransactions.locked) {
      return;
    }
    this._signedTransactions.setList(
      this._nodeAccountIds.list.map(
        (nodeId) => this._makeSignedTransaction(nodeId)
      )
    );
  }
  /**
   * Build all the signed transactions from the node account IDs
   *
   * @private
   */
  _buildIncompletedTransactions() {
    if (this._nodeAccountIds.length == 0) {
      this._transactions.setList([this._makeSignedTransaction(null)]);
    } else {
      this._transactions.setList(
        this._nodeAccountIds.list.map(
          (nodeId) => this._makeSignedTransaction(nodeId)
        )
      );
    }
  }
  /**
   * Freeze this transaction from future modification to prepare for
   * signing or serialization.
   *
   * @returns {this}
   */
  freeze() {
    return this.freezeWith(null);
  }
  /**
   * @param {?AccountId} accountId
   */
  _freezeWithAccountId(accountId) {
    if (this._operatorAccountId == null) {
      this._operatorAccountId = accountId;
    }
  }
  /**
   * Freeze this transaction from further modification to prepare for
   * signing or serialization.
   *
   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
   * nodes to prepare this transaction for.
   *
   * @param {?import("../client/Client.js").default<Channel, *>} client
   * @returns {this}
   */
  freezeWith(client) {
    this._signOnDemand = client != null ? client.signOnDemand : false;
    this._operator = client != null ? client._operator : null;
    this._freezeWithAccountId(
      client != null ? client.operatorAccountId : null
    );
    this._maxTransactionFee = this._maxTransactionFee == null ? client != null && client.defaultMaxTransactionFee != null ? client.defaultMaxTransactionFee : this._defaultMaxTransactionFee : this._maxTransactionFee;
    this._regenerateTransactionId = client != null && this._regenerateTransactionId == null ? client.defaultRegenerateTransactionId : this._regenerateTransactionId;
    this._setNodeAccountIds(client);
    this._setTransactionId();
    if (client != null) {
      for (const transactionId of this._transactionIds.list) {
        if (transactionId.accountId != null) {
          transactionId.accountId.validateChecksum(client);
        }
      }
    }
    this._buildNewTransactionIdList();
    if (!this._signOnDemand) {
      this._buildSignedTransactions();
    }
    return this;
  }
  /**
   * Sign the transaction using a signer
   *
   * This is part of the signature provider feature
   *
   * @param {Signer} signer
   * @returns {Promise<this>}
   */
  async signWithSigner(signer) {
    await signer.signTransaction(this);
    return this;
  }
  /**
   * Freeze the transaction using a signer
   *
   * This is part of the signature provider feature.
   *
   * @param {Signer} signer
   * @returns {Promise<this>}
   */
  async freezeWithSigner(signer) {
    await signer.populateTransaction(this);
    this.freeze();
    return this;
  }
  /**
   * Serialize the request into bytes. This will encode all the transactions
   * into a `proto.TransactionList` and return the encoded protobuf.
   *
   * **NOTE**: Does not support sign on demand
   *
   * @returns {Uint8Array}
   */
  toBytes() {
    this._requireNotSignOnDemand();
    if (this._isFrozen()) {
      this._transactionIds.setLocked();
      this._nodeAccountIds.setLocked();
      this._buildAllTransactions();
    } else {
      this._buildIncompletedTransactions();
    }
    return HashgraphProto14.proto.TransactionList.encode({
      transactionList: (
        /** @type {HashgraphProto.proto.ITransaction[]} */
        this._transactions.list
      )
    }).finish();
  }
  /**
   * Serialize the transaction into bytes
   *
   * **NOTE**: Supports sign on demand
   *
   * @returns {Promise<Uint8Array>}
   */
  async toBytesAsync() {
    this._transactionIds.setLocked();
    this._nodeAccountIds.setLocked();
    await this._buildAllTransactionsAsync();
    this._transactions.setLocked();
    this._signedTransactions.setLocked();
    return HashgraphProto14.proto.TransactionList.encode({
      transactionList: (
        /** @type {HashgraphProto.proto.ITransaction[]} */
        this._transactions.list
      )
    }).finish();
  }
  /**
   * Get the transaction hash
   *
   * @returns {Promise<Uint8Array>}
   */
  async getTransactionHash() {
    this._requireFrozen();
    this._transactionIds.setLocked();
    this._nodeAccountIds.setLocked();
    await this._buildAllTransactionsAsync();
    this._transactions.setLocked();
    this._signedTransactions.setLocked();
    return digest2(
      /** @type {Uint8Array} */
      /** @type {HashgraphProto.proto.ITransaction} */
      this._transactions.get(0).signedTransactionBytes
    );
  }
  /**
   * Get all the transaction hashes
   *
   * @returns {Promise<TransactionHashMap>}
   */
  async getTransactionHashPerNode() {
    this._requireFrozen();
    this._transactionIds.setLocked();
    this._nodeAccountIds.setLocked();
    await this._buildAllTransactionsAsync();
    return await TransactionHashMap._fromTransaction(this);
  }
  /**
   * Is transaction frozen
   *
   * @returns {boolean}
   */
  isFrozen() {
    return this._signedTransactions.length > 0;
  }
  /**
   * Get the current transaction ID, and make sure it's not null
   *
   * @protected
   * @returns {TransactionId}
   */
  _getTransactionId() {
    const transactionId = this.transactionId;
    if (transactionId == null) {
      throw new Error(
        "transaction must have been frozen before getting the transaction ID, try calling `freeze`"
      );
    }
    return transactionId;
  }
  /**
   * @param {Client} client
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
  _validateChecksums(client) {
  }
  /**
   * Before we proceed exeuction, we need to do a couple checks
   *
   * @override
   * @protected
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<void>}
   */
  async _beforeExecute(client) {
    if (this._logger) {
      this._logger.info(
        `Network used: ${client._network.networkName}`
        // eslint-disable-line @typescript-eslint/restrict-template-expressions
      );
    }
    if (!this._isFrozen()) {
      this.freezeWith(client);
    }
    if (client.isAutoValidateChecksumsEnabled()) {
      this._validateChecksums(client);
    }
    if (this._operator == null || this._operator == void 0) {
      this._operator = client != null ? client._operator : null;
    }
    if (this._operatorAccountId == null || this._operatorAccountId == void 0) {
      this._operatorAccountId = client != null && client._operator != null ? client._operator.accountId : null;
    }
    if (this._operator != null) {
      await this.signWith(
        this._operator.publicKey,
        this._operator.transactionSigner
      );
    }
  }
  /**
   * Construct a protobuf transaction
   *
   * @override
   * @internal
   * @returns {Promise<HashgraphProto.proto.ITransaction>}
   */
  async _makeRequestAsync() {
    const index = this._transactionIds.index * this._nodeAccountIds.length + this._nodeAccountIds.index;
    if (!this._signOnDemand) {
      this._buildTransaction(index);
      return (
        /** @type {HashgraphProto.proto.ITransaction} */
        this._transactions.get(index)
      );
    }
    return await this._buildTransactionAsync();
  }
  /**
   * Sign a `proto.SignedTransaction` with all the keys
   *
   * @private
   * @returns {Promise<HashgraphProto.proto.ISignedTransaction>}
   */
  async _signTransaction() {
    const signedTransaction = this._makeSignedTransaction(
      this._nodeAccountIds.next
    );
    const bodyBytes = (
      /** @type {Uint8Array} */
      signedTransaction.bodyBytes
    );
    for (let j = 0; j < this._publicKeys.length; j++) {
      const publicKey = this._publicKeys[j];
      const transactionSigner = this._transactionSigners[j];
      if (transactionSigner == null) {
        continue;
      }
      const signature = await transactionSigner(bodyBytes);
      if (signedTransaction.sigMap == null) {
        signedTransaction.sigMap = {};
      }
      if (signedTransaction.sigMap.sigPair == null) {
        signedTransaction.sigMap.sigPair = [];
      }
      signedTransaction.sigMap.sigPair.push(
        publicKey._toProtobufSignature(signature)
      );
    }
    return signedTransaction;
  }
  /**
   * Construct a new transaction ID at the current index
   *
   * @private
   */
  _buildNewTransactionIdList() {
    if (this._transactionIds.locked || this._operatorAccountId == null) {
      return;
    }
    const transactionId = TransactionId.withValidStart(
      this._operatorAccountId,
      Timestamp.generate()
    );
    this._transactionIds.set(this._transactionIds.index, transactionId);
  }
  /**
   * Build each signed transaction in a loop
   *
   * @private
   */
  _buildAllTransactions() {
    for (let i = 0; i < this._signedTransactions.length; i++) {
      this._buildTransaction(i);
    }
  }
  /**
   * Build and and sign each transaction in a loop
   *
   * This method is primary used in the exist condition methods
   * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`
   *
   * @private
   */
  async _buildAllTransactionsAsync() {
    if (!this._signOnDemand) {
      this._buildAllTransactions();
      return;
    }
    this._buildSignedTransactions();
    if (this._transactions.locked) {
      return;
    }
    for (let i = 0; i < this._signedTransactions.length; i++) {
      this._transactions.push(await this._buildTransactionAsync());
    }
  }
  /**
   * Build a transaction at a particular index
   *
   * @private
   * @param {number} index
   */
  _buildTransaction(index) {
    if (this._transactions.length < index) {
      for (let i = this._transactions.length; i < index; i++) {
        this._transactions.push(null);
      }
    }
    if (this._transactions.list[index] != null) {
      this._transactions.set(index, {
        signedTransactionBytes: HashgraphProto14.proto.SignedTransaction.encode(
          this._signedTransactions.get(index)
        ).finish()
      });
    }
    this._transactions.setIfAbsent(index, () => {
      return {
        signedTransactionBytes: HashgraphProto14.proto.SignedTransaction.encode(
          this._signedTransactions.get(index)
        ).finish()
      };
    });
  }
  /**
   * Build a trransaction using the current index, where the current
   * index is determined by `this._nodeAccountIds.index` and
   * `this._transactionIds.index`
   *
   * @private
   * @returns {Promise<HashgraphProto.proto.ITransaction>}
   */
  async _buildTransactionAsync() {
    return {
      signedTransactionBytes: HashgraphProto14.proto.SignedTransaction.encode(
        await this._signTransaction()
      ).finish()
    };
  }
  /**
   * Determine what execution state we're in.
   *
   * @override
   * @internal
   * @param {HashgraphProto.proto.ITransaction} request
   * @param {HashgraphProto.proto.ITransactionResponse} response
   * @returns {[Status, ExecutionState]}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = response;
    const status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto14.proto.ResponseCodeEnum.OK
    );
    if (this._logger) {
      this._logger.debug(
        `[${this._getLogId()}] received status ${status.toString()}`
      );
      this._logger.info(
        `SDK Transaction Status Response: ${status.toString()}`
      );
    }
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.PlatformTransactionNotCreated:
      case Status.PlatformNotActive:
        return [status, ExecutionState.Retry];
      case Status.Ok:
        return [status, ExecutionState.Finished];
      case Status.TransactionExpired:
        if (this._transactionIds.locked || this._regenerateTransactionId != null && !this._regenerateTransactionId) {
          return [status, ExecutionState.Error];
        } else {
          this._buildNewTransactionIdList();
          return [status, ExecutionState.Retry];
        }
      default:
        return [status, ExecutionState.Error];
    }
  }
  /**
   * Map the request and response into a precheck status error
   *
   * @override
   * @internal
   * @param {HashgraphProto.proto.ITransaction} request
   * @param {HashgraphProto.proto.ITransactionResponse} response
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = response;
    const status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto14.proto.ResponseCodeEnum.OK
    );
    if (this._logger) {
      this._logger.info(
        // @ts-ignore
        `Transaction Error Info: ${status.toString()}, ${this.transactionId.toString()}`
        // eslint-disable-line @typescript-eslint/restrict-template-expressions
      );
    }
    return new PrecheckStatusError({
      status,
      transactionId: this._getTransactionId(),
      contractFunctionResult: null
    });
  }
  /**
   * Map the request, response, and node account ID into a `TransactionResponse`
   *
   * @override
   * @protected
   * @param {HashgraphProto.proto.ITransactionResponse} response
   * @param {AccountId} nodeId
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<TransactionResponse>}
   */
  async _mapResponse(response, nodeId, request) {
    const transactionHash = await digest2(
      /** @type {Uint8Array} */
      request.signedTransactionBytes
    );
    const transactionId = this._getTransactionId();
    this._transactionIds.advance();
    if (this._logger) {
      this._logger.info(
        `Transaction Info: ${JSON.stringify(
          new TransactionResponse({
            nodeId,
            transactionHash,
            transactionId
          }).toJSON()
        )}`
      );
    }
    return new TransactionResponse({
      nodeId,
      transactionHash,
      transactionId
    });
  }
  /**
   * Make a signed transaction given a node account ID
   *
   * @internal
   * @param {?AccountId} nodeId
   * @returns {HashgraphProto.proto.ISignedTransaction}
   */
  _makeSignedTransaction(nodeId) {
    const body = this._makeTransactionBody(nodeId);
    if (this._logger) {
      this._logger.info(`Transaction Body: ${JSON.stringify(body)}`);
    }
    const bodyBytes = HashgraphProto14.proto.TransactionBody.encode(body).finish();
    return {
      sigMap: {
        sigPair: []
      },
      bodyBytes
    };
  }
  /**
   * Make a protobuf transaction body
   *
   * @private
   * @param {?AccountId} nodeId
   * @returns {HashgraphProto.proto.ITransactionBody}
   */
  _makeTransactionBody(nodeId) {
    return {
      [this._getTransactionDataCase()]: this._makeTransactionData(),
      transactionFee: this._maxTransactionFee != null ? this._maxTransactionFee.toTinybars() : null,
      memo: this._transactionMemo,
      transactionID: this._transactionIds.current != null ? this._transactionIds.current._toProtobuf() : null,
      nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,
      transactionValidDuration: {
        seconds: import_long18.default.fromNumber(this._transactionValidDuration)
      }
    };
  }
  /**
   * This method returns a key for the `data` field in a transaction body.
   * Each transaction overwrite this to make sure when we build the transaction body
   * we set the right data field.
   *
   * @abstract
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    throw new Error("not implemented");
  }
  /**
   * Make a scheduled transaction body
   * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent
   *
   * @internal
   * @returns {HashgraphProto.proto.ISchedulableTransactionBody}
   */
  _getScheduledTransactionBody() {
    return {
      memo: this.transactionMemo,
      transactionFee: this._maxTransactionFee == null ? this._defaultMaxTransactionFee.toTinybars() : this._maxTransactionFee.toTinybars(),
      [this._getTransactionDataCase()]: this._makeTransactionData()
    };
  }
  /**
   * Make the transaction body data.
   *
   * @abstract
   * @protected
   * @returns {object}
   */
  _makeTransactionData() {
    throw new Error("not implemented");
  }
  /**
   * FIXME: Why do we have `isFrozen` and `_isFrozen()`?
   *
   * @protected
   * @returns {boolean}
   */
  _isFrozen() {
    return this._signOnDemand || this._signedTransactions.length > 0;
  }
  /**
   * Require the transaction to NOT be frozen
   *
   * @internal
   */
  _requireNotFrozen() {
    if (this._isFrozen()) {
      throw new Error(
        "transaction is immutable; it has at least one signature or has been explicitly frozen"
      );
    }
  }
  /**
   * Require the transaction to have sign on demand disabled
   *
   * @internal
   */
  _requireNotSignOnDemand() {
    if (this._signOnDemand) {
      throw new Error(
        "Please use `toBytesAsync()` if `signOnDemand` is enabled"
      );
    }
  }
  /**
   * Require the transaction to be frozen
   *
   * @internal
   */
  _requireFrozen() {
    if (!this._isFrozen()) {
      throw new Error(
        "transaction must have been frozen before calculating the hash will be stable, try calling `freeze`"
      );
    }
  }
  /**
   * Require the transaction to have a single node account ID set
   *
   * @internal
   * @protected
   */
  _requireOneNodeAccountId() {
    if (this._nodeAccountIds.length != 1) {
      throw "transaction did not have exactly one node ID set";
    }
  }
  /**
   * @param {HashgraphProto.proto.Transaction} request
   * @returns {Uint8Array}
   */
  _requestToBytes(request) {
    return HashgraphProto14.proto.Transaction.encode(request).finish();
  }
  /**
   * @param {HashgraphProto.proto.TransactionResponse} response
   * @returns {Uint8Array}
   */
  _responseToBytes(response) {
    return HashgraphProto14.proto.TransactionResponse.encode(
      response
    ).finish();
  }
};
var SCHEDULE_CREATE_TRANSACTION = [];

// node_modules/@hashgraph/sdk/src/token/NftId.js
var HashgraphProto15 = __toESM(require_lib(), 1);
var import_long19 = __toESM(require_long(), 1);
var NftId = class _NftId {
  /**
   * @param {TokenId} token
   * @param {number | Long} serial
   */
  constructor(token, serial) {
    this.tokenId = token;
    this.serial = typeof serial === "number" ? import_long19.default.fromNumber(serial) : serial;
    Object.freeze(this);
  }
  /**
   * @param {string} text
   * @returns {NftId}
   */
  static fromString(text) {
    const strings = text.split("/").length > 1 ? text.split("/") : text.split("@");
    for (const string of strings) {
      if (string === "") {
        throw new Error(
          "invalid format for NftId: use [token]/[serial] or [token]@[serial]"
        );
      }
    }
    const token = TokenId.fromString(strings[0]);
    const serial = import_long19.default.fromString(strings[1]);
    return new _NftId(token, serial);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.INftID} id
   * @returns {NftId}
   */
  static _fromProtobuf(id2) {
    return new _NftId(
      TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        id2.token_ID
      ),
      id2.serialNumber != null ? id2.serialNumber : import_long19.default.ZERO
    );
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NftId}
   */
  static fromBytes(bytes3) {
    return _NftId._fromProtobuf(HashgraphProto15.proto.NftID.decode(bytes3));
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.INftID}
   */
  _toProtobuf() {
    return {
      token_ID: this.tokenId._toProtobuf(),
      serialNumber: import_long19.default.fromValue(
        this.serial !== void 0 ? this.serial : 0
      )
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return `${this.tokenId.toString()}/${this.serial.toString()}`;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto15.proto.NftID.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountAllowanceAdjustTransaction.js
var import_long22 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/account/HbarAllowance.js
var HbarAllowance = class _HbarAllowance {
  /**
   * @internal
   * @param {object} props
   * @param {AccountId | null} props.spenderAccountId
   * @param {AccountId | null} props.ownerAccountId
   * @param {Hbar | null} props.amount
   */
  constructor(props) {
    this.spenderAccountId = props.spenderAccountId;
    this.ownerAccountId = props.ownerAccountId;
    this.amount = props.amount;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ICryptoAllowance} allowance
   * @returns {HbarAllowance}
   */
  static _fromProtobuf(allowance) {
    return new _HbarAllowance({
      spenderAccountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        allowance.spender
      ),
      ownerAccountId: allowance.owner != null ? AccountId._fromProtobuf(
        /**@type {HashgraphProto.proto.IAccountID}*/
        allowance.owner
      ) : null,
      amount: Hbar.fromTinybars(
        allowance.amount != null ? allowance.amount : 0
      )
    });
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IGrantedCryptoAllowance} allowance
   * @param {AccountId} ownerAccountId
   * @returns {HbarAllowance}
   */
  static _fromGrantedProtobuf(allowance, ownerAccountId) {
    return new _HbarAllowance({
      spenderAccountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        allowance.spender
      ),
      ownerAccountId,
      amount: Hbar.fromTinybars(
        allowance.amount != null ? allowance.amount : 0
      )
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ICryptoAllowance}
   */
  _toProtobuf() {
    return {
      owner: this.ownerAccountId != null ? this.ownerAccountId._toProtobuf() : null,
      spender: this.spenderAccountId != null ? this.spenderAccountId._toProtobuf() : null,
      amount: this.amount != null ? this.amount.toTinybars() : null
    };
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this.spenderAccountId != null) {
      this.spenderAccountId.validateChecksum(client);
    }
    if (this.spenderAccountId != null) {
      this.spenderAccountId.validateChecksum(client);
    }
  }
  /**
   * @returns {object}
   */
  toJSON() {
    return {
      ownerAccountId: this.ownerAccountId != null ? this.ownerAccountId.toString() : null,
      spenderAccountId: this.spenderAccountId != null ? this.spenderAccountId.toString() : null,
      amount: this.amount != null ? this.amount.toString() : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenAllowance.js
var import_long20 = __toESM(require_long(), 1);
var TokenAllowance = class _TokenAllowance {
  /**
   * @internal
   * @param {object} props
   * @param {TokenId} props.tokenId
   * @param {AccountId | null} props.spenderAccountId
   * @param {AccountId | null} props.ownerAccountId
   * @param {Long | null} props.amount
   */
  constructor(props) {
    this.tokenId = props.tokenId;
    this.spenderAccountId = props.spenderAccountId;
    this.ownerAccountId = props.ownerAccountId;
    this.amount = props.amount;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITokenAllowance} allowance
   * @returns {TokenAllowance}
   */
  static _fromProtobuf(allowance) {
    return new _TokenAllowance({
      tokenId: TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        allowance.tokenId
      ),
      spenderAccountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        allowance.spender
      ),
      ownerAccountId: allowance.owner != null ? AccountId._fromProtobuf(
        /**@type {HashgraphProto.proto.IAccountID}*/
        allowance.owner
      ) : null,
      amount: allowance.amount != null ? import_long20.default.fromValue(
        /** @type {Long} */
        allowance.amount
      ) : null
    });
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IGrantedTokenAllowance} allowance
   * @param {AccountId} ownerAccountId
   * @returns {TokenAllowance}
   */
  static _fromGrantedProtobuf(allowance, ownerAccountId) {
    return new _TokenAllowance({
      tokenId: TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        allowance.tokenId
      ),
      spenderAccountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        allowance.spender
      ),
      ownerAccountId,
      amount: allowance.amount != null ? import_long20.default.fromValue(
        /** @type {Long} */
        allowance.amount
      ) : null
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ITokenAllowance}
   */
  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      spender: this.spenderAccountId != null ? this.spenderAccountId._toProtobuf() : null,
      owner: this.ownerAccountId != null ? this.ownerAccountId._toProtobuf() : null,
      amount: this.amount
    };
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    this.tokenId.validateChecksum(client);
    if (this.ownerAccountId != null) {
      this.ownerAccountId.validateChecksum(client);
    }
    if (this.spenderAccountId != null) {
      this.spenderAccountId.validateChecksum(client);
    }
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenNftAllowance.js
var import_long21 = __toESM(require_long(), 1);
var TokenNftAllowance = class _TokenNftAllowance {
  /**
   * @internal
   * @param {object} props
   * @param {TokenId} props.tokenId
   * @param {AccountId | null} props.spenderAccountId
   * @param {AccountId | null} props.ownerAccountId
   * @param {Long[] | null} props.serialNumbers
   * @param {boolean | null} props.allSerials
   * @param {AccountId | null} props.delegatingSpender
   */
  constructor(props) {
    this.tokenId = props.tokenId;
    this.spenderAccountId = props.spenderAccountId;
    this.ownerAccountId = props.ownerAccountId;
    this.serialNumbers = props.serialNumbers;
    this.allSerials = props.allSerials;
    this.delegatingSpender = props.delegatingSpender;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.INftAllowance} allowance
   * @returns {TokenNftAllowance}
   */
  static _fromProtobuf(allowance) {
    const allSerials = allowance.approvedForAll != null && allowance.approvedForAll.value == true;
    return new _TokenNftAllowance({
      tokenId: TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        allowance.tokenId
      ),
      spenderAccountId: allowance.spender != null ? AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        allowance.spender
      ) : null,
      ownerAccountId: allowance.owner != null ? AccountId._fromProtobuf(
        /**@type {HashgraphProto.proto.IAccountID}*/
        allowance.owner
      ) : null,
      serialNumbers: allSerials ? null : allowance.serialNumbers != null ? allowance.serialNumbers.map(
        (serialNumber) => import_long21.default.fromValue(serialNumber)
      ) : [],
      allSerials,
      delegatingSpender: allowance.delegatingSpender != null ? AccountId._fromProtobuf(
        /**@type {HashgraphProto.proto.IAccountID}*/
        allowance.delegatingSpender
      ) : null
    });
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IGrantedNftAllowance} allowance
   * @param {AccountId} ownerAccountId
   * @returns {TokenNftAllowance}
   */
  static _fromGrantedProtobuf(allowance, ownerAccountId) {
    return new _TokenNftAllowance({
      tokenId: TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        allowance.tokenId
      ),
      spenderAccountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        allowance.spender
      ),
      ownerAccountId,
      serialNumbers: [],
      allSerials: null,
      delegatingSpender: null
    });
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.INftRemoveAllowance} allowance
   * @returns {TokenNftAllowance}
   */
  static _fromRemoveProtobuf(allowance) {
    return new _TokenNftAllowance({
      tokenId: TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        allowance.tokenId
      ),
      spenderAccountId: null,
      ownerAccountId: allowance.owner != null ? AccountId._fromProtobuf(
        /**@type {HashgraphProto.proto.IAccountID}*/
        allowance.owner
      ) : null,
      serialNumbers: allowance.serialNumbers != null ? allowance.serialNumbers.map(
        (serialNumber) => import_long21.default.fromValue(serialNumber)
      ) : [],
      allSerials: null,
      delegatingSpender: null
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.INftAllowance}
   */
  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      spender: this.spenderAccountId != null ? this.spenderAccountId._toProtobuf() : null,
      owner: this.ownerAccountId != null ? this.ownerAccountId._toProtobuf() : null,
      approvedForAll: this.serialNumbers == null ? { value: this.allSerials } : null,
      serialNumbers: this.serialNumbers,
      delegatingSpender: this.delegatingSpender != null ? this.delegatingSpender._toProtobuf() : null
    };
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    this.tokenId.validateChecksum(client);
    if (this.ownerAccountId != null) {
      this.ownerAccountId.validateChecksum(client);
    }
    if (this.spenderAccountId != null) {
      this.spenderAccountId.validateChecksum(client);
    }
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountAllowanceAdjustTransaction.js
var AccountAllowanceAdjustTransaction = class extends Transaction {
  /**
   * @param {object} [props]
   * @param {HbarAllowance[]} [props.hbarAllowances]
   * @param {TokenAllowance[]} [props.tokenAllowances]
   * @param {TokenNftAllowance[]} [props.nftAllowances]
   */
  constructor(props = {}) {
    super();
    this._hbarAllowances = props.hbarAllowances != null ? props.hbarAllowances : [];
    this._tokenAllowances = props.tokenAllowances != null ? props.tokenAllowances : [];
    this._nftAllowances = props.nftAllowances != null ? props.nftAllowances : [];
  }
  /**
   * @returns {HbarAllowance[]}
   */
  get hbarAllowances() {
    return this._hbarAllowances;
  }
  /**
   * @deprecated
   * @param {AccountId | string} spenderAccountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  addHbarAllowance(spenderAccountId, amount) {
    const value = amount instanceof Hbar ? amount : new Hbar(amount);
    return this._adjustHbarAllowance(
      null,
      spenderAccountId,
      requireNotNegative(value)
    );
  }
  /**
   * @param {AccountId | string | null} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {Hbar} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  _adjustHbarAllowance(ownerAccountId, spenderAccountId, amount) {
    this._requireNotFrozen();
    this._hbarAllowances.push(
      new HbarAllowance({
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          spenderAccountId.toSolidityAddress()
        ) : spenderAccountId,
        ownerAccountId: typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          ownerAccountId.toSolidityAddress()
        ) : ownerAccountId,
        amount
      })
    );
    return this;
  }
  /**
   * @deprecated
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  grantHbarAllowance(ownerAccountId, spenderAccountId, amount) {
    const value = amount instanceof Hbar ? amount : new Hbar(amount);
    return this._adjustHbarAllowance(
      ownerAccountId,
      spenderAccountId,
      requireNotNegative(value)
    );
  }
  /**
   * @deprecated
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  revokeHbarAllowance(ownerAccountId, spenderAccountId, amount) {
    const value = amount instanceof Hbar ? amount : new Hbar(amount);
    return this._adjustHbarAllowance(
      ownerAccountId,
      spenderAccountId,
      requireNotNegative(value).negated()
    );
  }
  /**
   * @returns {TokenAllowance[]}
   */
  get tokenAllowances() {
    return this._tokenAllowances;
  }
  /**
   * @deprecated
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} spenderAccountId
   * @param {Long | number} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  addTokenAllowance(tokenId, spenderAccountId, amount) {
    return this._adjustTokenAllowance(
      tokenId,
      null,
      spenderAccountId,
      requireNotNegative(import_long22.default.fromValue(amount))
    );
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string | null} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {Long | number} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  _adjustTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
    this._requireNotFrozen();
    this._tokenAllowances.push(
      new TokenAllowance({
        tokenId: typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId,
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          spenderAccountId.toSolidityAddress()
        ) : spenderAccountId,
        ownerAccountId: typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          ownerAccountId.toSolidityAddress()
        ) : ownerAccountId,
        amount: typeof amount === "number" ? import_long22.default.fromNumber(amount) : amount
      })
    );
    return this;
  }
  /**
   * @deprecated
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @param {Long | number} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  grantTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
    return this._adjustTokenAllowance(
      tokenId,
      ownerAccountId,
      spenderAccountId,
      requireNotNegative(import_long22.default.fromValue(amount))
    );
  }
  /**
   * @deprecated
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @param {Long | number} amount
   * @returns {AccountAllowanceAdjustTransaction}
   */
  revokeTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
    return this._adjustTokenAllowance(
      tokenId,
      ownerAccountId,
      spenderAccountId,
      requireNotNegative(import_long22.default.fromValue(amount))
    );
  }
  /**
   * @deprecated
   * @param {NftId | string} nftId
   * @param {AccountId | string} spenderAccountId
   * @returns {AccountAllowanceAdjustTransaction}
   */
  addTokenNftAllowance(nftId, spenderAccountId) {
    const id2 = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
    return this._adjustTokenNftAllowance(id2, null, spenderAccountId);
  }
  /**
   * @param {NftId} nftId
   * @param {AccountId | string | null} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @returns {AccountAllowanceAdjustTransaction}
   */
  _adjustTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
    this._requireNotFrozen();
    const spender = typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
      0,
      0,
      spenderAccountId.toSolidityAddress()
    ) : spenderAccountId;
    const owner = typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
      0,
      0,
      ownerAccountId.toSolidityAddress()
    ) : ownerAccountId;
    let found = false;
    for (const allowance of this._nftAllowances) {
      if (allowance.tokenId.compare(nftId.tokenId) === 0 && allowance.spenderAccountId != null && allowance.spenderAccountId.compare(spender) === 0) {
        if (allowance.serialNumbers != null) {
          allowance.serialNumbers.push(nftId.serial);
        }
        found = true;
        break;
      }
    }
    if (!found) {
      this._nftAllowances.push(
        new TokenNftAllowance({
          tokenId: nftId.tokenId,
          spenderAccountId: spender,
          serialNumbers: [nftId.serial],
          ownerAccountId: owner,
          allSerials: false,
          delegatingSpender: null
        })
      );
    }
    return this;
  }
  /**
   * @deprecated
   * @param {NftId | string} nftId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @returns {AccountAllowanceAdjustTransaction}
   */
  grantTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
    const id2 = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
    requireNotNegative(id2.serial);
    return this._adjustTokenNftAllowance(
      id2,
      ownerAccountId,
      spenderAccountId
    );
  }
  /**
   * @deprecated
   * @param {NftId | string} nftId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @returns {AccountAllowanceAdjustTransaction}
   */
  revokeTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
    const id2 = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
    requireNotNegative(id2.serial);
    return this._adjustTokenNftAllowance(
      new NftId(id2.tokenId, id2.serial.negate()),
      ownerAccountId,
      spenderAccountId
    );
  }
  /**
   * @deprecated - use `grantTokenNftAllowanceAllSerials()` instead
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} spenderAccountId
   * @returns {AccountAllowanceAdjustTransaction}
   */
  addAllTokenNftAllowance(tokenId, spenderAccountId) {
    return this._adjustTokenNftAllowanceAllSerials(
      tokenId,
      null,
      spenderAccountId,
      true
    );
  }
  /**
   * @deprecated
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @returns {AccountAllowanceAdjustTransaction}
   */
  grantTokenNftAllowanceAllSerials(tokenId, ownerAccountId, spenderAccountId) {
    return this._adjustTokenNftAllowanceAllSerials(
      tokenId,
      ownerAccountId,
      spenderAccountId,
      true
    );
  }
  /**
   * @deprecated
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @returns {AccountAllowanceAdjustTransaction}
   */
  revokeTokenNftAllowanceAllSerials(tokenId, ownerAccountId, spenderAccountId) {
    return this._adjustTokenNftAllowanceAllSerials(
      tokenId,
      ownerAccountId,
      spenderAccountId,
      false
    );
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string | null} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {boolean} allSerials
   * @returns {AccountAllowanceAdjustTransaction}
   */
  _adjustTokenNftAllowanceAllSerials(tokenId, ownerAccountId, spenderAccountId, allSerials) {
    this._requireNotFrozen();
    this._nftAllowances.push(
      new TokenNftAllowance({
        tokenId: typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId,
        ownerAccountId: ownerAccountId != null ? typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          ownerAccountId.toSolidityAddress()
        ) : ownerAccountId : null,
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          spenderAccountId.toSolidityAddress()
        ) : spenderAccountId,
        serialNumbers: null,
        allSerials,
        delegatingSpender: null
      })
    );
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    this._hbarAllowances.map(
      (allowance) => allowance._validateChecksums(client)
    );
    this._tokenAllowances.map(
      (allowance) => allowance._validateChecksums(client)
    );
    this._nftAllowances.map(
      (allowance) => allowance._validateChecksums(client)
    );
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _execute(channel, request) {
    return Promise.reject(
      new Error("This feature has been deprecated for this class.")
    );
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * @deprecated
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    throw new Error("This feature has been deprecated for this class.");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * @override
   * @protected
   * @returns {object}
   */
  _makeTransactionData() {
    throw new Error("This feature has been deprecated.");
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `AccountAllowanceAdjustTransaction:${timestamp.toString()}`;
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountAllowanceApproveTransaction.js
var import_long23 = __toESM(require_long(), 1);
var AccountAllowanceApproveTransaction = class _AccountAllowanceApproveTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {HbarAllowance[]} [props.hbarApprovals]
   * @param {TokenAllowance[]} [props.tokenApprovals]
   * @param {TokenNftAllowance[]} [props.nftApprovals]
   */
  constructor(props = {}) {
    super();
    this._hbarApprovals = props.hbarApprovals != null ? props.hbarApprovals : [];
    this._tokenApprovals = props.tokenApprovals != null ? props.tokenApprovals : [];
    this._nftApprovals = props.nftApprovals != null ? props.nftApprovals : [];
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {AccountAllowanceApproveTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const allowanceApproval = (
      /** @type {HashgraphProto.proto.ICryptoApproveAllowanceTransactionBody} */
      body.cryptoApproveAllowance
    );
    return Transaction._fromProtobufTransactions(
      new _AccountAllowanceApproveTransaction({
        hbarApprovals: (allowanceApproval.cryptoAllowances != null ? allowanceApproval.cryptoAllowances : []).map((approval) => HbarAllowance._fromProtobuf(approval)),
        tokenApprovals: (allowanceApproval.tokenAllowances != null ? allowanceApproval.tokenAllowances : []).map((approval) => TokenAllowance._fromProtobuf(approval)),
        nftApprovals: (allowanceApproval.nftAllowances != null ? allowanceApproval.nftAllowances : []).map((approval) => TokenNftAllowance._fromProtobuf(approval))
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {HbarAllowance[]}
   */
  get hbarApprovals() {
    return this._hbarApprovals;
  }
  /**
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {AccountAllowanceApproveTransaction}
   */
  approveHbarAllowance(ownerAccountId, spenderAccountId, amount) {
    this._requireNotFrozen();
    this._hbarApprovals.push(
      new HbarAllowance({
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          spenderAccountId.toSolidityAddress()
        ) : spenderAccountId,
        ownerAccountId: typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          ownerAccountId.toSolidityAddress()
        ) : ownerAccountId,
        amount: amount instanceof Hbar ? amount : new Hbar(amount)
      })
    );
    return this;
  }
  /**
   * @deprecated - Use `approveHbarAllowance()` instead
   * @param {AccountId | string} spenderAccountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {AccountAllowanceApproveTransaction}
   */
  addHbarAllowance(spenderAccountId, amount) {
    this._requireNotFrozen();
    this._hbarApprovals.push(
      new HbarAllowance({
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId,
        amount: amount instanceof Hbar ? amount : new Hbar(amount),
        ownerAccountId: null
      })
    );
    return this;
  }
  /**
   * @returns {TokenAllowance[]}
   */
  get tokenApprovals() {
    return this._tokenApprovals;
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {Long | number} amount
   * @returns {AccountAllowanceApproveTransaction}
   */
  approveTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
    this._requireNotFrozen();
    this._tokenApprovals.push(
      new TokenAllowance({
        tokenId: typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId,
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          spenderAccountId.toSolidityAddress()
        ) : spenderAccountId,
        ownerAccountId: typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          ownerAccountId.toSolidityAddress()
        ) : ownerAccountId,
        amount: typeof amount === "number" ? import_long23.default.fromNumber(amount) : amount
      })
    );
    return this;
  }
  /**
   * @deprecated - Use `approveTokenAllowance()` instead
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} spenderAccountId
   * @param {Long | number} amount
   * @returns {AccountAllowanceApproveTransaction}
   */
  addTokenAllowance(tokenId, spenderAccountId, amount) {
    this._requireNotFrozen();
    this._tokenApprovals.push(
      new TokenAllowance({
        tokenId: typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId,
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId,
        amount: typeof amount === "number" ? import_long23.default.fromNumber(amount) : amount,
        ownerAccountId: null
      })
    );
    return this;
  }
  /**
   * @deprecated - Use `approveTokenNftAllowance()` instead
   * @param {NftId | string} nftId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @returns {AccountAllowanceApproveTransaction}
   */
  addTokenNftAllowance(nftId, spenderAccountId) {
    return this._approveTokenNftAllowance(
      nftId,
      null,
      spenderAccountId,
      null
    );
  }
  /**
   * @returns {TokenNftAllowance[]}
   */
  get tokenNftApprovals() {
    return this._nftApprovals;
  }
  /**
   * @param {NftId | string} nftId
   * @param {AccountId | string | null} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {AccountId | string | null} delegatingSpender
   * @returns {AccountAllowanceApproveTransaction}
   */
  _approveTokenNftAllowance(nftId, ownerAccountId, spenderAccountId, delegatingSpender) {
    this._requireNotFrozen();
    const id2 = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
    const spender = typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
      0,
      0,
      spenderAccountId.toSolidityAddress()
    ) : spenderAccountId;
    let found = false;
    for (const allowance of this._nftApprovals) {
      if (allowance.tokenId.compare(id2.tokenId) === 0 && allowance.spenderAccountId != null && allowance.spenderAccountId.compare(spender) === 0) {
        if (allowance.serialNumbers != null) {
          allowance.serialNumbers.push(id2.serial);
        }
        found = true;
        break;
      }
    }
    if (!found) {
      this._nftApprovals.push(
        new TokenNftAllowance({
          tokenId: id2.tokenId,
          spenderAccountId: spender,
          ownerAccountId: typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
            0,
            0,
            ownerAccountId.toSolidityAddress()
          ) : ownerAccountId,
          serialNumbers: [id2.serial],
          allSerials: false,
          delegatingSpender: typeof delegatingSpender === "string" ? AccountId.fromString(delegatingSpender) : delegatingSpender
        })
      );
    }
    return this;
  }
  /**
   * @param {NftId | string} nftId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @returns {AccountAllowanceApproveTransaction}
   */
  approveTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
    return this._approveTokenNftAllowance(
      nftId,
      ownerAccountId,
      spenderAccountId,
      null
    );
  }
  /**
   * @param {NftId | string} nftId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {AccountId | string} delegatingSpender
   * @returns {AccountAllowanceApproveTransaction}
   */
  approveTokenNftAllowanceWithDelegatingSpender(nftId, ownerAccountId, spenderAccountId, delegatingSpender) {
    return this._approveTokenNftAllowance(
      nftId,
      ownerAccountId,
      spenderAccountId,
      delegatingSpender
    );
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string | null} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @param {boolean} allSerials
   * @returns {AccountAllowanceApproveTransaction}
   */
  _approveAllTokenNftAllowance(tokenId, ownerAccountId, spenderAccountId, allSerials) {
    this._requireNotFrozen();
    this._nftApprovals.push(
      new TokenNftAllowance({
        tokenId: typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId,
        spenderAccountId: typeof spenderAccountId === "string" ? AccountId.fromString(spenderAccountId) : spenderAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          spenderAccountId.toSolidityAddress()
        ) : spenderAccountId,
        ownerAccountId: typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId instanceof ContractId ? AccountId.fromEvmAddress(
          0,
          0,
          ownerAccountId.toSolidityAddress()
        ) : ownerAccountId,
        serialNumbers: null,
        allSerials,
        delegatingSpender: null
      })
    );
    return this;
  }
  /**
   * @deprecated - Use `approveTokenNftAllowanceAllSerials()` instead
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | string} spenderAccountId
   * @returns {AccountAllowanceApproveTransaction}
   */
  addAllTokenNftAllowance(tokenId, ownerAccountId, spenderAccountId) {
    return this._approveAllTokenNftAllowance(
      tokenId,
      ownerAccountId,
      spenderAccountId,
      true
    );
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @returns {AccountAllowanceApproveTransaction}
   */
  approveTokenNftAllowanceAllSerials(tokenId, ownerAccountId, spenderAccountId) {
    return this._approveAllTokenNftAllowance(
      tokenId,
      ownerAccountId,
      spenderAccountId,
      true
    );
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} ownerAccountId
   * @param {AccountId | ContractId | string} spenderAccountId
   * @returns {AccountAllowanceApproveTransaction}
   */
  deleteTokenNftAllowanceAllSerials(tokenId, ownerAccountId, spenderAccountId) {
    return this._approveAllTokenNftAllowance(
      tokenId,
      ownerAccountId,
      spenderAccountId,
      false
    );
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    this._hbarApprovals.map(
      (approval) => approval._validateChecksums(client)
    );
    this._tokenApprovals.map(
      (approval) => approval._validateChecksums(client)
    );
    this._nftApprovals.map(
      (approval) => approval._validateChecksums(client)
    );
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.approveAllowances(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoApproveAllowance";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoApproveAllowanceTransactionBody}
   */
  _makeTransactionData() {
    return {
      cryptoAllowances: this._hbarApprovals.map(
        (approval) => approval._toProtobuf()
      ),
      tokenAllowances: this._tokenApprovals.map(
        (approval) => approval._toProtobuf()
      ),
      nftAllowances: this._nftApprovals.map(
        (approval) => approval._toProtobuf()
      )
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `AccountAllowanceApproveTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoApproveAllowance",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  AccountAllowanceApproveTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/AccountAllowanceDeleteTransaction.js
var AccountAllowanceDeleteTransaction = class _AccountAllowanceDeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {HbarAllowance[]} [props.hbarAllowances]
   * @param {TokenAllowance[]} [props.tokenAllowances]
   * @param {TokenNftAllowance[]} [props.nftAllowances]
   */
  constructor(props = {}) {
    super();
    this._nftAllowances = props.nftAllowances != null ? props.nftAllowances : [];
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {AccountAllowanceDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const allowance = (
      /** @type {HashgraphProto.proto.ICryptoDeleteAllowanceTransactionBody} */
      body.cryptoDeleteAllowance
    );
    return Transaction._fromProtobufTransactions(
      new _AccountAllowanceDeleteTransaction({
        nftAllowances: (allowance.nftAllowances != null ? allowance.nftAllowances : []).map(
          (allowance2) => TokenNftAllowance._fromProtobuf(allowance2)
        )
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {TokenNftAllowance[]}
   */
  get tokenNftAllowanceDeletions() {
    return this._nftAllowances;
  }
  /**
   * @description If you want to remove allowance for all serials of a NFT
   *      - use AccountAllowanceApproveTransaction().deleteTokenNftAllowanceAllSerials()
   * @param {NftId | string} nftId
   * @param {AccountId | string} ownerAccountId
   * @returns {AccountAllowanceDeleteTransaction}
   */
  deleteAllTokenNftAllowances(nftId, ownerAccountId) {
    this._requireNotFrozen();
    const id2 = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
    const owner = typeof ownerAccountId === "string" ? AccountId.fromString(ownerAccountId) : ownerAccountId;
    let found = false;
    for (const allowance of this._nftAllowances) {
      if (allowance.tokenId.compare(id2.tokenId) === 0) {
        if (allowance.serialNumbers != null) {
          allowance.serialNumbers.push(id2.serial);
        }
        found = true;
        break;
      }
    }
    if (!found) {
      this._nftAllowances.push(
        new TokenNftAllowance({
          tokenId: id2.tokenId,
          spenderAccountId: null,
          serialNumbers: [id2.serial],
          ownerAccountId: owner,
          allSerials: false,
          delegatingSpender: null
        })
      );
    }
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    this._nftAllowances.map(
      (allowance) => allowance._validateChecksums(client)
    );
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.deleteAllowances(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoDeleteAllowance";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoDeleteAllowanceTransactionBody}
   */
  _makeTransactionData() {
    return {
      nftAllowances: this._nftAllowances.map(
        (allowance) => allowance._toProtobuf()
      )
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `AccountAllowanceDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoDeleteAllowance",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  AccountAllowanceDeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/AccountBalance.js
var import_long24 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/account/TokenBalanceMap.js
var TokenBalanceMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenDecimalMap.js
var TokenDecimalMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountBalance.js
var HashgraphProto16 = __toESM(require_lib(), 1);
var AccountBalance = class _AccountBalance {
  /**
   * @private
   * @param {object} props
   * @param {Hbar} props.hbars
   * @param {?TokenBalanceMap} props.tokens
   * @param {?TokenDecimalMap} props.tokenDecimals
   */
  constructor(props) {
    this.hbars = props.hbars;
    this.tokens = props.tokens;
    this.tokenDecimals = props.tokenDecimals;
    Object.freeze(this);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AccountBalance}
   */
  static fromBytes(bytes3) {
    return _AccountBalance._fromProtobuf(
      HashgraphProto16.proto.CryptoGetAccountBalanceResponse.decode(bytes3)
    );
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ICryptoGetAccountBalanceResponse} accountBalance
   * @returns {AccountBalance}
   */
  static _fromProtobuf(accountBalance) {
    const tokenBalances = new TokenBalanceMap();
    const tokenDecimals = new TokenDecimalMap();
    if (accountBalance.tokenBalances != null) {
      for (const balance of accountBalance.tokenBalances) {
        const tokenId = TokenId._fromProtobuf(
          /** @type {HashgraphProto.proto.ITokenID} */
          balance.tokenId
        );
        tokenDecimals._set(
          tokenId,
          balance.decimals != null ? balance.decimals : 0
        );
        tokenBalances._set(
          tokenId,
          import_long24.default.fromValue(
            /** @type {Long} */
            balance.balance
          )
        );
      }
    }
    return new _AccountBalance({
      hbars: Hbar.fromTinybars(
        /** @type {Long} */
        accountBalance.balance
      ),
      tokens: tokenBalances,
      tokenDecimals
    });
  }
  /**
   * @returns {HashgraphProto.proto.ICryptoGetAccountBalanceResponse}
   */
  _toProtobuf() {
    const list = [];
    for (const [key, value] of this.tokens != null ? this.tokens : []) {
      list.push({
        tokenId: key._toProtobuf(),
        balance: value,
        decimals: (
          // eslint-disable-next-line deprecation/deprecation
          this.tokenDecimals != null ? (
            // eslint-disable-next-line deprecation/deprecation
            this.tokenDecimals.get(key)
          ) : null
        )
      });
    }
    return {
      balance: this.hbars.toTinybars(),
      tokenBalances: list
    };
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto16.proto.CryptoGetAccountBalanceResponse.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @returns {AccountBalanceJson}
   */
  toJSON() {
    const tokens = [];
    for (const [key, value] of this.tokens != null ? this.tokens : []) {
      const decimals = (
        // eslint-disable-next-line deprecation/deprecation
        this.tokenDecimals != null ? this.tokenDecimals.get(key) : null
      );
      tokens.push({
        tokenId: key.toString(),
        balance: value.toString(),
        decimals: decimals != null ? decimals : 0
      });
    }
    return {
      hbars: this.hbars.toString(),
      tokens
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountBalanceQuery.js
var AccountBalanceQuery = class _AccountBalanceQuery extends Query {
  /**
   * @param {object} [props]
   * @param {AccountId | string} [props.accountId]
   * @param {ContractId | string} [props.contractId]
   */
  constructor(props = {}) {
    super();
    this._accountId = null;
    this._contractId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {AccountBalanceQuery}
   */
  static _fromProtobuf(query) {
    const balance = (
      /** @type {HashgraphProto.proto.ICryptoGetAccountBalanceQuery} */
      query.cryptogetAccountBalance
    );
    return new _AccountBalanceQuery({
      accountId: balance.accountID != null ? AccountId._fromProtobuf(balance.accountID) : void 0,
      contractId: balance.contractID != null ? ContractId._fromProtobuf(balance.contractID) : void 0
    });
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the balance is being requested.
   *
   * This is mutually exclusive with `setContractId`.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the balance is being requested.
   *
   * This is mutually exclusive with `setAccountId`.
   *
   * @param {ContractId | string} contractId
   * @returns {this}
   */
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @protected
   * @override
   * @returns {boolean}
   */
  _isPaymentRequired() {
    return false;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.cryptoGetBalance(request);
  }
  /**
   * @override
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const cryptogetAccountBalance = (
      /** @type {HashgraphProto.proto.ICryptoGetAccountBalanceResponse} */
      response.cryptogetAccountBalance
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      cryptogetAccountBalance.header
    );
  }
  /**
   * @override
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<AccountBalance>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const cryptogetAccountBalance = (
      /** @type {HashgraphProto.proto.ICryptoGetAccountBalanceResponse} */
      response.cryptogetAccountBalance
    );
    return Promise.resolve(
      AccountBalance._fromProtobuf(cryptogetAccountBalance)
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      cryptogetAccountBalance: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    return `AccountBalanceQuery:${this._timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set(
  "cryptogetAccountBalance",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  AccountBalanceQuery._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/AccountCreateTransaction.js
var HashgraphProto17 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/Duration.js
var import_long25 = __toESM(require_long(), 1);
var Duration2 = class _Duration {
  /**
   * @param {Long | number} seconds
   */
  constructor(seconds) {
    this.seconds = seconds instanceof import_long25.default ? seconds : import_long25.default.fromNumber(seconds);
    Object.freeze(this);
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IDuration}
   */
  _toProtobuf() {
    return {
      seconds: this.seconds
    };
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IDuration} duration
   * @returns {Duration}
   */
  static _fromProtobuf(duration) {
    return new _Duration(
      /** @type {Long} */
      duration.seconds
    );
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountCreateTransaction.js
var import_long26 = __toESM(require_long(), 1);
var AccountCreateTransaction = class _AccountCreateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {Key} [props.key]
   * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
   * @param {boolean} [props.receiverSignatureRequired]
   * @param {AccountId} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.accountMemo]
   * @param {Long | number} [props.maxAutomaticTokenAssociations]
   * @param {AccountId | string} [props.stakedAccountId]
   * @param {Long | number} [props.stakedNodeId]
   * @param {boolean} [props.declineStakingReward]
   * @param {EvmAddress} [props.alias]
   */
  constructor(props = {}) {
    super();
    this._key = null;
    this._initialBalance = null;
    this._sendRecordThreshold = DEFAULT_RECORD_THRESHOLD;
    this._receiveRecordThreshold = DEFAULT_RECORD_THRESHOLD;
    this._receiverSignatureRequired = false;
    this._proxyAccountId = null;
    this._autoRenewPeriod = new Duration2(DEFAULT_AUTO_RENEW_PERIOD);
    this._accountMemo = null;
    this._maxAutomaticTokenAssociations = null;
    this._stakedAccountId = null;
    this._stakedNodeId = null;
    this._declineStakingReward = false;
    this._alias = null;
    if (props.key != null) {
      this.setKey(props.key);
    }
    if (props.receiverSignatureRequired != null) {
      this.setReceiverSignatureRequired(props.receiverSignatureRequired);
    }
    if (props.initialBalance != null) {
      this.setInitialBalance(props.initialBalance);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.accountMemo != null) {
      this.setAccountMemo(props.accountMemo);
    }
    if (props.maxAutomaticTokenAssociations != null) {
      this.setMaxAutomaticTokenAssociations(
        props.maxAutomaticTokenAssociations
      );
    }
    if (props.stakedAccountId != null) {
      this.setStakedAccountId(props.stakedAccountId);
    }
    if (props.stakedNodeId != null) {
      this.setStakedNodeId(props.stakedNodeId);
    }
    if (props.declineStakingReward != null) {
      this.setDeclineStakingReward(props.declineStakingReward);
    }
    if (props.alias != null) {
      this.setAlias(props.alias);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {AccountCreateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = (
      /** @type {HashgraphProto.proto.ICryptoCreateTransactionBody} */
      body.cryptoCreateAccount
    );
    let alias = void 0;
    if (create.alias != null && create.alias.length > 0) {
      if (create.alias.length === 20) {
        alias = EvmAddress.fromBytes(create.alias);
      }
    }
    return Transaction._fromProtobufTransactions(
      new _AccountCreateTransaction({
        key: create.key != null ? Key2._fromProtobufKey(create.key) : void 0,
        initialBalance: create.initialBalance != null ? Hbar.fromTinybars(create.initialBalance) : void 0,
        receiverSignatureRequired: create.receiverSigRequired != null ? create.receiverSigRequired : void 0,
        proxyAccountId: create.proxyAccountID != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          create.proxyAccountID
        ) : void 0,
        autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : void 0 : void 0,
        accountMemo: create.memo != null ? create.memo : void 0,
        maxAutomaticTokenAssociations: create.maxAutomaticTokenAssociations != null ? create.maxAutomaticTokenAssociations : void 0,
        stakedAccountId: create.stakedAccountId != null ? AccountId._fromProtobuf(create.stakedAccountId) : void 0,
        stakedNodeId: create.stakedNodeId != null ? create.stakedNodeId : void 0,
        declineStakingReward: create.declineReward == true,
        alias
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?Key}
   */
  get key() {
    return this._key;
  }
  /**
   * Set the key for this account.
   *
   * This is the key that must sign each transfer out of the account.
   *
   * If `receiverSignatureRequired` is true, then the key must also sign
   * any transfer into the account.
   *
   * @param {Key} key
   * @returns {this}
   */
  setKey(key) {
    this._requireNotFrozen();
    this._key = key;
    return this;
  }
  /**
   * @returns {?Hbar}
   */
  get initialBalance() {
    return this._initialBalance;
  }
  /**
   * Set the initial amount to transfer into this account.
   *
   * @param {number | string | Long | BigNumber | Hbar} initialBalance
   * @returns {this}
   */
  setInitialBalance(initialBalance) {
    this._requireNotFrozen();
    this._initialBalance = initialBalance instanceof Hbar ? initialBalance : new Hbar(initialBalance);
    return this;
  }
  /**
   * @returns {boolean}
   */
  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  /**
   * Set to true to require the key for this account to sign any transfer of
   * hbars to this account.
   *
   * @param {boolean} receiverSignatureRequired
   * @returns {this}
   */
  setReceiverSignatureRequired(receiverSignatureRequired) {
    this._requireNotFrozen();
    this._receiverSignatureRequired = receiverSignatureRequired;
    return this;
  }
  /**
   * @deprecated
   * @returns {?AccountId}
   */
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * @deprecated
   *
   * Set the ID of the account to which this account is proxy staked.
   * @param {AccountId} proxyAccountId
   * @returns {this}
   */
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = proxyAccountId;
    return this;
  }
  /**
   * @returns {Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this account.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?string}
   */
  get accountMemo() {
    return this._accountMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */
  setAccountMemo(memo) {
    this._requireNotFrozen();
    this._accountMemo = memo;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  /**
   * @param {Long | number} maxAutomaticTokenAssociations
   * @returns {this}
   */
  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
    this._requireNotFrozen();
    this._maxAutomaticTokenAssociations = typeof maxAutomaticTokenAssociations === "number" ? import_long26.default.fromNumber(maxAutomaticTokenAssociations) : maxAutomaticTokenAssociations;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  /**
   * @param {AccountId | string} stakedAccountId
   * @returns {this}
   */
  setStakedAccountId(stakedAccountId) {
    this._requireNotFrozen();
    this._stakedAccountId = typeof stakedAccountId === "string" ? AccountId.fromString(stakedAccountId) : stakedAccountId;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  /**
   * @param {Long | number} stakedNodeId
   * @returns {this}
   */
  setStakedNodeId(stakedNodeId) {
    this._requireNotFrozen();
    this._stakedNodeId = import_long26.default.fromValue(stakedNodeId);
    return this;
  }
  /**
   * @returns {boolean}
   */
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  /**
   * @param {boolean} declineStakingReward
   * @returns {this}
   */
  setDeclineStakingReward(declineStakingReward) {
    this._requireNotFrozen();
    this._declineStakingReward = declineStakingReward;
    return this;
  }
  /**
   * The bytes to be used as the account's alias.
   *
   * The bytes must be formatted as the calcluated last 20 bytes of the
   * keccak-256 of the ECDSA primitive key.
   *
   * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
   * delegatable_contract_id, are not supported.
   *
   * At most only one account can ever have a given alias on the network.
   *
   * @returns {?EvmAddress}
   */
  get alias() {
    return this._alias;
  }
  /**
   * The bytes to be used as the account's alias.
   *
   * The bytes must be formatted as the calcluated last 20 bytes of the
   * keccak-256 of the ECDSA primitive key.
   *
   * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
   * delegatable_contract_id, are not supported.
   *
   * At most only one account can ever have a given alias on the network.
   *
   * @param {string | EvmAddress} alias
   * @returns {this}
   */
  setAlias(alias) {
    if (typeof alias === "string") {
      if (alias.startsWith("0x") && alias.length == 42 || alias.length == 40) {
        this._alias = EvmAddress.fromString(alias);
      } else {
        throw new Error(
          'evmAddress must be a valid EVM address with or without "0x" prefix'
        );
      }
    } else {
      this._alias = alias;
    }
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.createAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoCreateAccount";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoCreateTransactionBody}
   */
  _makeTransactionData() {
    let alias = null;
    if (this._alias != null) {
      alias = this._alias.toBytes();
    }
    return {
      key: this._key != null ? this._key._toProtobufKey() : null,
      initialBalance: this._initialBalance != null ? this._initialBalance.toTinybars() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      receiveRecordThreshold: this._receiveRecordThreshold.toTinybars(),
      sendRecordThreshold: this._sendRecordThreshold.toTinybars(),
      receiverSigRequired: this._receiverSignatureRequired,
      memo: this._accountMemo,
      maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations != null ? this._maxAutomaticTokenAssociations.toInt() : null,
      stakedAccountId: this.stakedAccountId != null ? this.stakedAccountId._toProtobuf() : null,
      stakedNodeId: this.stakedNodeId,
      declineReward: this.declineStakingRewards,
      alias
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `AccountCreateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoCreateAccount",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  AccountCreateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/AccountDeleteTransaction.js
var AccountDeleteTransaction = class _AccountDeleteTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {AccountId} [props.accountId]
   * @param {AccountId} [props.transferAccountId]
   */
  constructor(props = {}) {
    super();
    this._accountId = null;
    this._transferAccountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.transferAccountId != null) {
      this.setTransferAccountId(props.transferAccountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {AccountDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const accountDelete = (
      /** @type {HashgraphProto.proto.ICryptoDeleteTransactionBody} */
      body.cryptoDelete
    );
    return Transaction._fromProtobufTransactions(
      new _AccountDeleteTransaction({
        accountId: accountDelete.deleteAccountID != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          accountDelete.deleteAccountID
        ) : void 0,
        transferAccountId: accountDelete.transferAccountID != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          accountDelete.transferAccountID
        ) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID which is being deleted in this transaction.
   *
   * @param {AccountId | string} accountId
   * @returns {AccountDeleteTransaction}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get transferAccountId() {
    return this._transferAccountId;
  }
  /**
   * Set the account ID which will receive all remaining hbars.
   *
   * @param {AccountId | string} transferAccountId
   * @returns {AccountDeleteTransaction}
   */
  setTransferAccountId(transferAccountId) {
    this._requireNotFrozen();
    this._transferAccountId = typeof transferAccountId === "string" ? AccountId.fromString(transferAccountId) : transferAccountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    if (this._transferAccountId != null) {
      this._transferAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.cryptoDelete(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoDelete";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoDeleteTransactionBody}
   */
  _makeTransactionData() {
    return {
      deleteAccountID: this._accountId != null ? this._accountId._toProtobuf() : null,
      transferAccountID: this._transferAccountId != null ? this._transferAccountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `AccountDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoDelete",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  AccountDeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/StakingInfo.js
var HashgraphProto18 = __toESM(require_lib(), 1);
var StakingInfo = class _StakingInfo {
  /**
   * @private
   * @param {object} props
   * @param {boolean} props.declineStakingReward
   * @param {?Timestamp} props.stakePeriodStart
   * @param {?Hbar} props.pendingReward
   * @param {?Hbar} props.stakedToMe
   * @param {?AccountId} props.stakedAccountId
   * @param {?Long} props.stakedNodeId
   */
  constructor(props) {
    this.declineStakingReward = props.declineStakingReward;
    this.stakePeriodStart = props.stakePeriodStart;
    this.pendingReward = props.pendingReward;
    this.stakedToMe = props.stakedToMe;
    this.stakedAccountId = props.stakedAccountId;
    this.stakedNodeId = props.stakedNodeId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IStakingInfo} info
   * @returns {StakingInfo}
   */
  static _fromProtobuf(info) {
    return new _StakingInfo({
      declineStakingReward: info.declineReward == true,
      stakePeriodStart: info.stakePeriodStart != null ? Timestamp._fromProtobuf(info.stakePeriodStart) : null,
      pendingReward: info.pendingReward != null ? Hbar.fromTinybars(info.pendingReward) : null,
      stakedToMe: info.stakedToMe != null ? Hbar.fromTinybars(info.stakedToMe) : null,
      stakedAccountId: info.stakedAccountId != null ? AccountId._fromProtobuf(info.stakedAccountId) : null,
      stakedNodeId: info.stakedNodeId != null ? info.stakedNodeId : null
    });
  }
  /**
   * @returns {HashgraphProto.proto.IStakingInfo}
   */
  _toProtobuf() {
    return {
      declineReward: this.declineStakingReward,
      stakePeriodStart: this.stakePeriodStart != null ? this.stakePeriodStart._toProtobuf() : null,
      pendingReward: this.pendingReward != null ? this.pendingReward.toTinybars() : null,
      stakedToMe: this.stakedToMe != null ? this.stakedToMe.toTinybars() : null,
      stakedAccountId: this.stakedAccountId != null ? this.stakedAccountId._toProtobuf() : null,
      stakedNodeId: this.stakedNodeId
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {StakingInfo}
   */
  static fromBytes(bytes3) {
    return _StakingInfo._fromProtobuf(
      HashgraphProto18.proto.StakingInfo.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto18.proto.StakingInfo.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @returns {StakingInfoJson}
   */
  toJSON() {
    return {
      declineStakingReward: this.declineStakingReward,
      stakePeriodStart: this.stakePeriodStart != null ? this.stakePeriodStart.toString() : null,
      pendingReward: this.pendingReward != null ? this.pendingReward.toString() : null,
      stakedToMe: this.stakedToMe != null ? this.stakedToMe.toString() : null,
      stakedAccountId: this.stakedAccountId != null ? this.stakedAccountId.toString() : null,
      stakedNodeId: this.stakedNodeId != null ? this.stakedNodeId.toString() : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/LiveHash.js
var LiveHash = class _LiveHash {
  /**
   * @private
   * @param {object} props
   * @param {AccountId} props.accountId
   * @param {Uint8Array} props.hash
   * @param {KeyList} props.keys
   * @param {Duration} props.duration
   */
  constructor(props) {
    this.accountId = props.accountId;
    this.hash = props.hash;
    this.keys = props.keys;
    this.duration = props.duration;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ILiveHash} liveHash
   * @returns {LiveHash}
   */
  static _fromProtobuf(liveHash) {
    const liveHash_ = (
      /** @type {HashgraphProto.proto.ILiveHash} */
      liveHash
    );
    return new _LiveHash({
      accountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        liveHash_.accountId
      ),
      hash: liveHash_.hash != null ? liveHash_.hash : new Uint8Array(),
      keys: liveHash_.keys != null ? KeyList2.__fromProtobufKeyList(liveHash_.keys) : new KeyList2(),
      duration: Duration2._fromProtobuf(
        /** @type {HashgraphProto.proto.IDuration} */
        liveHash_.duration
      )
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ILiveHash}
   */
  _toProtobuf() {
    return {
      accountId: this.accountId._toProtobuf(),
      hash: this.hash,
      keys: this.keys._toProtobufKey().keyList,
      duration: this.duration._toProtobuf()
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountInfo.js
var import_long28 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/account/TokenRelationship.js
var import_long27 = __toESM(require_long(), 1);
var TokenRelationship = class _TokenRelationship {
  /**
   * @param {object} props
   * @param {TokenId} props.tokenId
   * @param {string} props.symbol
   * @param {Long} props.balance
   * @param {boolean | null} props.isKycGranted
   * @param {boolean | null} props.isFrozen
   * @param {boolean | null} props.automaticAssociation
   */
  constructor(props) {
    this.tokenId = props.tokenId;
    this.symbol = props.symbol;
    this.balance = props.balance;
    this.isKycGranted = props.isKycGranted;
    this.isFrozen = props.isFrozen;
    this.automaticAssociation = props.automaticAssociation;
    Object.freeze(this);
  }
  /**
   * @param {HashgraphProto.proto.ITokenRelationship} relationship
   * @returns {TokenRelationship}
   */
  static _fromProtobuf(relationship) {
    const tokenId = TokenId._fromProtobuf(
      /** @type {HashgraphProto.proto.ITokenID} */
      relationship.tokenId
    );
    const isKycGranted = relationship.kycStatus == null || relationship.kycStatus === 0 ? null : relationship.kycStatus === 1;
    const isFrozen = relationship.freezeStatus == null || relationship.freezeStatus === 0 ? null : relationship.freezeStatus === 1;
    return new _TokenRelationship({
      tokenId,
      symbol: (
        /** @type {string} */
        relationship.symbol
      ),
      balance: relationship.balance != null ? relationship.balance instanceof import_long27.default ? relationship.balance : import_long27.default.fromValue(relationship.balance) : import_long27.default.ZERO,
      isKycGranted,
      isFrozen,
      automaticAssociation: relationship.automaticAssociation != null ? relationship.automaticAssociation : null
    });
  }
  /**
   * @returns {HashgraphProto.proto.ITokenRelationship}
   */
  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      symbol: this.symbol,
      balance: this.balance,
      kycStatus: this.isKycGranted == null ? 0 : this.isKycGranted ? 1 : 2,
      freezeStatus: this.isFrozen == null ? 0 : this.isFrozen ? 1 : 2,
      automaticAssociation: this.automaticAssociation
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenRelationshipMap.js
var TokenRelationshipMap = class _TokenRelationshipMap extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
  /**
   * @param {HashgraphProto.proto.ITokenRelationship[]} relationships
   * @returns {TokenRelationshipMap}
   */
  static _fromProtobuf(relationships) {
    const tokenRelationships = new _TokenRelationshipMap();
    for (const relationship of relationships) {
      const tokenId = TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        relationship.tokenId
      );
      tokenRelationships._set(
        tokenId,
        TokenRelationship._fromProtobuf(relationship)
      );
    }
    return tokenRelationships;
  }
  /**
   * @returns {HashgraphProto.proto.ITokenRelationship[]}
   */
  _toProtobuf() {
    const list = [];
    for (const [_, relationship] of this) {
      list.push(relationship._toProtobuf());
    }
    return list;
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountInfo.js
var HashgraphProto19 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/LedgerId.js
var LedgerId = class _LedgerId {
  /**
   * @hideconstructor
   * @internal
   * @param {Uint8Array} ledgerId
   */
  constructor(ledgerId) {
    this._ledgerId = ledgerId;
    Object.freeze(this);
  }
  /**
   * @param {string} ledgerId
   * @returns {LedgerId}
   */
  static fromString(ledgerId) {
    switch (ledgerId) {
      case NETNAMES[0]:
      case "0":
        return _LedgerId.MAINNET;
      case NETNAMES[1]:
      case "1":
        return _LedgerId.TESTNET;
      case NETNAMES[2]:
      case "2":
        return _LedgerId.PREVIEWNET;
      case NETNAMES[3]:
      case "3":
        return _LedgerId.LOCAL_NODE;
      default: {
        let ledgerIdDecoded = decode(ledgerId);
        if (ledgerIdDecoded.length == 0 && ledgerId.length != 0) {
          throw new Error("Default reached for fromString");
        } else {
          return new _LedgerId(ledgerIdDecoded);
        }
      }
    }
  }
  /**
   * If the ledger ID is a known value such as `[0]`, `[1]`, `[2]` this method
   * will instead return "mainnet", "testnet", or "previewnet", otherwise it will
   * hex encode the bytes.
   *
   * @returns {string}
   */
  toString() {
    if (this._ledgerId.length == 1) {
      switch (this._ledgerId[0]) {
        case 0:
          return NETNAMES[0];
        case 1:
          return NETNAMES[1];
        case 2:
          return NETNAMES[2];
        case 3:
          return NETNAMES[3];
        default:
          return encode(this._ledgerId);
      }
    } else {
      return encode(this._ledgerId);
    }
  }
  /**
   * Using the UTF-8 byte representation of "mainnet", "testnet",
   * or "previewnet" is NOT supported.
   *
   * @param {Uint8Array} bytes
   * @returns {LedgerId}
   */
  static fromBytes(bytes3) {
    return new _LedgerId(bytes3);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return this._ledgerId;
  }
  /**
   * @returns {boolean}
   */
  isMainnet() {
    return this.toString() == NETNAMES[0];
  }
  /**
   * @returns {boolean}
   */
  isTestnet() {
    return this.toString() == NETNAMES[1];
  }
  /**
   * @returns {boolean}
   */
  isPreviewnet() {
    return this.toString() == NETNAMES[2];
  }
  /**
   * @returns {boolean}
   */
  isLocalNode() {
    return this.toString() == NETNAMES[3];
  }
};
var NETNAMES = ["mainnet", "testnet", "previewnet", "local-node"];
LedgerId.MAINNET = new LedgerId(new Uint8Array([0]));
LedgerId.TESTNET = new LedgerId(new Uint8Array([1]));
LedgerId.PREVIEWNET = new LedgerId(new Uint8Array([2]));
LedgerId.LOCAL_NODE = new LedgerId(new Uint8Array([3]));

// node_modules/@hashgraph/sdk/src/account/AccountInfo.js
var AccountInfo = class _AccountInfo {
  /**
   * @private
   * @param {object} props
   * @param {AccountId} props.accountId
   * @param {?string} props.contractAccountId
   * @param {boolean} props.isDeleted
   * @param {?AccountId} props.proxyAccountId
   * @param {Hbar} props.proxyReceived
   * @param {Key} props.key
   * @param {Hbar} props.balance
   * @param {Hbar} props.sendRecordThreshold
   * @param {Hbar} props.receiveRecordThreshold
   * @param {boolean} props.isReceiverSignatureRequired
   * @param {Timestamp} props.expirationTime
   * @param {Duration} props.autoRenewPeriod
   * @param {LiveHash[]} props.liveHashes
   * @param {TokenRelationshipMap} props.tokenRelationships
   * @param {string} props.accountMemo
   * @param {Long} props.ownedNfts
   * @param {Long} props.maxAutomaticTokenAssociations
   * @param {PublicKey | null} props.aliasKey
   * @param {LedgerId | null} props.ledgerId
   * @param {HbarAllowance[]} props.hbarAllowances
   * @param {TokenAllowance[]} props.tokenAllowances
   * @param {TokenNftAllowance[]} props.nftAllowances
   * @param {?Long} props.ethereumNonce
   * @param {?StakingInfo} props.stakingInfo
   */
  constructor(props) {
    this.accountId = props.accountId;
    this.contractAccountId = props.contractAccountId;
    this.isDeleted = props.isDeleted;
    this.proxyAccountId = props.proxyAccountId;
    this.proxyReceived = props.proxyReceived;
    this.key = props.key;
    this.balance = props.balance;
    this.sendRecordThreshold = props.sendRecordThreshold;
    this.receiveRecordThreshold = props.receiveRecordThreshold;
    this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;
    this.expirationTime = props.expirationTime;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.liveHashes = props.liveHashes;
    this.tokenRelationships = props.tokenRelationships;
    this.accountMemo = props.accountMemo;
    this.ownedNfts = props.ownedNfts;
    this.maxAutomaticTokenAssociations = props.maxAutomaticTokenAssociations;
    this.aliasKey = props.aliasKey;
    this.ledgerId = props.ledgerId;
    this.hbarAllowances = props.hbarAllowances;
    this.tokenAllowances = props.tokenAllowances;
    this.nftAllowances = props.nftAllowances;
    this.ethereumNonce = props.ethereumNonce;
    this.stakingInfo = props.stakingInfo;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.CryptoGetInfoResponse.IAccountInfo} info
   * @returns {AccountInfo}
   */
  static _fromProtobuf(info) {
    let aliasKey = info.alias != null && info.alias.length > 0 ? Key2._fromProtobufKey(
      HashgraphProto19.proto.Key.decode(info.alias)
    ) : null;
    if (!(aliasKey instanceof PublicKey2)) {
      aliasKey = null;
    }
    const accountId = AccountId._fromProtobuf(
      /** @type {HashgraphProto.proto.IAccountID} */
      info.accountID
    );
    return new _AccountInfo({
      accountId,
      contractAccountId: info.contractAccountID != null ? info.contractAccountID : null,
      isDeleted: info.deleted != null ? info.deleted : false,
      key: Key2._fromProtobufKey(
        /** @type {HashgraphProto.proto.IKey} */
        info.key
      ),
      balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
      sendRecordThreshold: Hbar.fromTinybars(
        info.generateSendRecordThreshold != null ? info.generateSendRecordThreshold : 0
      ),
      receiveRecordThreshold: Hbar.fromTinybars(
        info.generateReceiveRecordThreshold != null ? info.generateReceiveRecordThreshold : 0
      ),
      isReceiverSignatureRequired: info.receiverSigRequired != null ? info.receiverSigRequired : false,
      expirationTime: Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.expirationTime
      ),
      autoRenewPeriod: info.autoRenewPeriod != null ? new Duration2(
        /** @type {Long} */
        info.autoRenewPeriod.seconds
      ) : new Duration2(0),
      proxyAccountId: info.proxyAccountID != null && import_long28.default.fromValue(
        /** @type {Long | number} */
        info.proxyAccountID.shardNum
      ).toInt() !== 0 && import_long28.default.fromValue(
        /** @type {Long | number} */
        info.proxyAccountID.realmNum
      ).toInt() !== 0 && import_long28.default.fromValue(
        /** @type {Long | number} */
        info.proxyAccountID.accountNum
      ).toInt() !== 0 ? AccountId._fromProtobuf(info.proxyAccountID) : null,
      proxyReceived: Hbar.fromTinybars(
        info.proxyReceived != null ? info.proxyReceived : 0
      ),
      liveHashes: (info.liveHashes != null ? info.liveHashes : []).map(
        (hash2) => LiveHash._fromProtobuf(hash2)
      ),
      tokenRelationships: TokenRelationshipMap._fromProtobuf(
        info.tokenRelationships != null ? info.tokenRelationships : []
      ),
      accountMemo: info.memo != null ? info.memo : "",
      ownedNfts: info.ownedNfts ? info.ownedNfts : import_long28.default.ZERO,
      maxAutomaticTokenAssociations: info.maxAutomaticTokenAssociations ? import_long28.default.fromNumber(info.maxAutomaticTokenAssociations) : import_long28.default.ZERO,
      aliasKey,
      ledgerId: info.ledgerId != null ? LedgerId.fromBytes(info.ledgerId) : null,
      hbarAllowances: [],
      tokenAllowances: [],
      nftAllowances: [],
      ethereumNonce: info.ethereumNonce != null ? info.ethereumNonce : null,
      stakingInfo: info.stakingInfo != null ? StakingInfo._fromProtobuf(info.stakingInfo) : null
    });
  }
  /**
   * @returns {HashgraphProto.proto.CryptoGetInfoResponse.IAccountInfo}
   */
  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      contractAccountID: this.contractAccountId,
      deleted: this.isDeleted,
      proxyAccountID: (
        // eslint-disable-next-line deprecation/deprecation
        this.proxyAccountId != null ? (
          // eslint-disable-next-line deprecation/deprecation
          this.proxyAccountId._toProtobuf()
        ) : null
      ),
      proxyReceived: this.proxyReceived.toTinybars(),
      key: this.key._toProtobufKey(),
      balance: this.balance.toTinybars(),
      generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),
      generateReceiveRecordThreshold: this.receiveRecordThreshold.toTinybars(),
      receiverSigRequired: this.isReceiverSignatureRequired,
      expirationTime: this.expirationTime._toProtobuf(),
      autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),
      liveHashes: this.liveHashes.map((hash2) => hash2._toProtobuf()),
      tokenRelationships: this.tokenRelationships != null ? this.tokenRelationships._toProtobuf() : null,
      memo: this.accountMemo,
      ownedNfts: this.ownedNfts,
      maxAutomaticTokenAssociations: this.maxAutomaticTokenAssociations.toInt(),
      alias: this.aliasKey != null ? HashgraphProto19.proto.Key.encode(
        this.aliasKey._toProtobufKey()
      ).finish() : null,
      ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
      ethereumNonce: this.ethereumNonce,
      stakingInfo: this.stakingInfo != null ? this.stakingInfo._toProtobuf() : null
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AccountInfo}
   */
  static fromBytes(bytes3) {
    return _AccountInfo._fromProtobuf(
      HashgraphProto19.proto.CryptoGetInfoResponse.AccountInfo.decode(
        bytes3
      )
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto19.proto.CryptoGetInfoResponse.AccountInfo.encode(
      this._toProtobuf()
    ).finish();
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @returns {AccountInfoJson}
   */
  toJSON() {
    return {
      balance: this.balance.toString(),
      accountId: this.accountId.toString(),
      contractAccountId: this.contractAccountId,
      isDeleted: this.isDeleted,
      proxyAccountId: (
        // eslint-disable-next-line deprecation/deprecation
        this.proxyAccountId != null ? (
          // eslint-disable-next-line deprecation/deprecation
          this.proxyAccountId.toString()
        ) : null
      ),
      proxyReceived: this.proxyReceived.toString(),
      key: this.key != null ? this.key.toString() : null,
      sendRecordThreshold: this.sendRecordThreshold.toString(),
      receiveRecordThreshold: this.receiveRecordThreshold.toString(),
      isReceiverSignatureRequired: this.isReceiverSignatureRequired,
      expirationTime: this.expirationTime.toString(),
      autoRenewPeriod: this.autoRenewPeriod.toString(),
      accountMemo: this.accountMemo,
      ownedNfts: this.ownedNfts.toString(),
      maxAutomaticTokenAssociations: this.maxAutomaticTokenAssociations.toString(),
      aliasKey: this.aliasKey != null ? this.aliasKey.toString() : null,
      ledgerId: this.ledgerId != null ? this.ledgerId.toString() : null,
      ethereumNonce: this.ethereumNonce != null ? this.ethereumNonce.toString() : null,
      stakingInfo: this.stakingInfo != null ? this.stakingInfo.toJSON() : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountInfoQuery.js
var AccountInfoQuery = class _AccountInfoQuery extends Query {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {AccountInfoQuery}
   */
  static _fromProtobuf(query) {
    const info = (
      /** @type {HashgraphProto.proto.ICryptoGetInfoQuery} */
      query.cryptoGetInfo
    );
    return new _AccountInfoQuery({
      accountId: info.accountID != null ? AccountId._fromProtobuf(info.accountID) : void 0
    });
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the info is being requested.
   *
   * @param {AccountId | string} accountId
   * @returns {AccountInfoQuery}
   */
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.getAccountInfo(request);
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    return super.getCost(client);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const cryptoGetInfo = (
      /** @type {HashgraphProto.proto.ICryptoGetInfoResponse} */
      response.cryptoGetInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      cryptoGetInfo.header
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<AccountInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const info = (
      /** @type {HashgraphProto.proto.ICryptoGetInfoResponse} */
      response.cryptoGetInfo
    );
    return Promise.resolve(
      AccountInfo._fromProtobuf(
        /** @type {HashgraphProto.proto.CryptoGetInfoResponse.IAccountInfo} */
        info.accountInfo
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      cryptoGetInfo: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `AccountInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("cryptoGetInfo", AccountInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/AccountInfoFlow.js
var AccountInfoFlow = class {
  /**
   * @param {Client} client
   * @param {AccountId | string} accountId
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {Promise<boolean>}
   */
  static async verifySignature(client, accountId, message, signature) {
    const info = await new AccountInfoQuery().setAccountId(accountId).execute(client);
    if (info.key instanceof KeyList2) {
      return false;
    }
    return (
      /** @type {PublicKey} */
      info.key.verify(message, signature)
    );
  }
  /**
   * @param {Client} client
   * @param {AccountId | string} accountId
   * @param {Transaction} transaction
   * @returns {Promise<boolean>}
   */
  static async verifyTransaction(client, accountId, transaction) {
    const info = await new AccountInfoQuery().setAccountId(accountId).execute(client);
    if (info.key instanceof KeyList2) {
      return false;
    }
    return (
      /** @type {PublicKey} */
      info.key.verifyTransaction(
        transaction
      )
    );
  }
  /**
   * @param {Signer} signer
   * @param {AccountId | string} accountId
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {Promise<boolean>}
   */
  static async verifySignatureWithSigner(signer, accountId, message, signature) {
    const info = await new AccountInfoQuery().setAccountId(accountId).executeWithSigner(signer);
    if (info.key instanceof KeyList2) {
      return false;
    }
    return (
      /** @type {PublicKey} */
      info.key.verify(message, signature)
    );
  }
  /**
   * @param {Signer} signer
   * @param {AccountId | string} accountId
   * @param {Transaction} transaction
   * @returns {Promise<boolean>}
   */
  static async verifyTransactionWithSigner(signer, accountId, transaction) {
    const info = await new AccountInfoQuery().setAccountId(accountId).executeWithSigner(signer);
    if (info.key instanceof KeyList2) {
      return false;
    }
    return (
      /** @type {PublicKey} */
      info.key.verifyTransaction(
        transaction
      )
    );
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountRecordsQuery.js
var AccountRecordsQuery = class _AccountRecordsQuery extends Query {
  /**
   * @param {object} [props]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {AccountRecordsQuery}
   */
  static _fromProtobuf(query) {
    const records = (
      /** @type {HashgraphProto.proto.ICryptoGetAccountRecordsQuery} */
      query.cryptoGetAccountRecords
    );
    return new _AccountRecordsQuery({
      accountId: records.accountID != null ? AccountId._fromProtobuf(records.accountID) : void 0
    });
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the records are being requested.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.getAccountRecords(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const cryptoGetAccountRecords = (
      /** @type {HashgraphProto.proto.ICryptoGetAccountRecordsResponse} */
      response.cryptoGetAccountRecords
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      cryptoGetAccountRecords.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<TransactionRecord[]>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const cryptoGetAccountRecords = (
      /** @type {HashgraphProto.proto.ICryptoGetAccountRecordsResponse} */
      response.cryptoGetAccountRecords
    );
    const records = (
      /** @type {HashgraphProto.proto.ITransactionRecord[]} */
      cryptoGetAccountRecords.records
    );
    return Promise.resolve(
      records.map(
        (record) => TransactionRecord._fromProtobuf({ transactionRecord: record })
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      cryptoGetAccountRecords: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `AccountRecordsQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set(
  "cryptoGetAccountRecords",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  AccountRecordsQuery._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/ProxyStaker.js
var ProxyStaker = class _ProxyStaker {
  /**
   * @private
   * @param {object} props
   * @param {AccountId} props.accountId
   * @param {number | string | Long | BigNumber | Hbar} props.amount
   */
  constructor(props) {
    this.accountId = props.accountId;
    this.amount = props.amount instanceof Hbar ? props.amount : new Hbar(props.amount);
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IProxyStaker} transfer
   * @returns {ProxyStaker}
   */
  static _fromProtobuf(transfer) {
    return new _ProxyStaker({
      accountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        transfer.accountID
      ),
      amount: Hbar.fromTinybars(
        transfer.amount != null ? transfer.amount : 0
      )
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IProxyStaker}
   */
  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      amount: this.amount.toTinybars()
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountStakersQuery.js
var AccountStakersQuery = class _AccountStakersQuery extends Query {
  /**
   * @param {object} [props]
   * @param {(AccountId | string)=} props.accountId
   */
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {AccountStakersQuery}
   */
  static _fromProtobuf(query) {
    const stakers = (
      /** @type {HashgraphProto.proto.ICryptoGetStakersQuery} */
      query.cryptoGetProxyStakers
    );
    return new _AccountStakersQuery({
      accountId: stakers.accountID != null ? AccountId._fromProtobuf(stakers.accountID) : void 0
    });
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the stakers are being requested.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.getStakersByAccountID(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const cryptoGetProxyStakers = (
      /** @type {HashgraphProto.proto.ICryptoGetStakersResponse} */
      response.cryptoGetProxyStakers
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      cryptoGetProxyStakers.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Promise<ProxyStaker[]>}
   */
  _mapResponse(response) {
    const cryptoGetProxyStakers = (
      /** @type {HashgraphProto.proto.ICryptoGetStakersResponse} */
      response.cryptoGetProxyStakers
    );
    const stakers = (
      /** @type {HashgraphProto.proto.IAllProxyStakers} */
      cryptoGetProxyStakers.stakers
    );
    return Promise.resolve(
      (stakers.proxyStaker != null ? stakers.proxyStaker : []).map(
        (staker) => ProxyStaker._fromProtobuf(staker)
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      cryptoGetProxyStakers: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `AccountStakersQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("cryptoGetProxyStakers", AccountStakersQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/AccountUpdateTransaction.js
var import_long29 = __toESM(require_long(), 1);
var AccountUpdateTransaction = class _AccountUpdateTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {AccountId} [props.accountId]
   * @param {Key} [props.key]
   * @param {boolean} [props.receiverSignatureRequired]
   * @param {AccountId} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {string} [props.accountMemo]
   * @param {Long | number} [props.maxAutomaticTokenAssociations]
   * @param {Key} [props.aliasKey]
   * @param {AccountId | string} [props.stakedAccountId]
   * @param {Long | number} [props.stakedNodeId]
   * @param {boolean} [props.declineStakingReward]
   */
  constructor(props = {}) {
    super();
    this._accountId = null;
    this._key = null;
    this._receiverSignatureRequired = false;
    this._proxyAccountId = null;
    this._autoRenewPeriod = null;
    this._expirationTime = null;
    this._accountMemo = null;
    this._maxAutomaticTokenAssociations = null;
    this._aliasKey = null;
    this._stakedAccountId = null;
    this._stakedNodeId = null;
    this._declineStakingReward = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.key != null) {
      this.setKey(props.key);
    }
    if (props.receiverSignatureRequired != null) {
      this.setReceiverSignatureRequired(props.receiverSignatureRequired);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.accountMemo != null) {
      this.setAccountMemo(props.accountMemo);
    }
    if (props.maxAutomaticTokenAssociations != null) {
      this.setMaxAutomaticTokenAssociations(
        props.maxAutomaticTokenAssociations
      );
    }
    if (props.stakedAccountId != null) {
      this.setStakedAccountId(props.stakedAccountId);
    }
    if (props.stakedNodeId != null) {
      this.setStakedNodeId(props.stakedNodeId);
    }
    if (props.declineStakingReward != null) {
      this.setDeclineStakingReward(props.declineStakingReward);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {AccountUpdateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = (
      /** @type {HashgraphProto.proto.ICryptoUpdateTransactionBody} */
      body.cryptoUpdateAccount
    );
    return Transaction._fromProtobufTransactions(
      new _AccountUpdateTransaction({
        accountId: update3.accountIDToUpdate != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          update3.accountIDToUpdate
        ) : void 0,
        key: update3.key != null ? Key2._fromProtobufKey(update3.key) : void 0,
        receiverSignatureRequired: update3.receiverSigRequiredWrapper != null ? update3.receiverSigRequiredWrapper.value != null ? update3.receiverSigRequiredWrapper.value : void 0 : void 0,
        proxyAccountId: update3.proxyAccountID != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          update3.proxyAccountID
        ) : void 0,
        autoRenewPeriod: update3.autoRenewPeriod != null ? update3.autoRenewPeriod.seconds != null ? update3.autoRenewPeriod.seconds : void 0 : void 0,
        expirationTime: update3.expirationTime != null ? Timestamp._fromProtobuf(update3.expirationTime) : void 0,
        accountMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0,
        maxAutomaticTokenAssociations: update3.maxAutomaticTokenAssociations != null && update3.maxAutomaticTokenAssociations.value != null ? import_long29.default.fromNumber(
          update3.maxAutomaticTokenAssociations.value
        ) : void 0,
        stakedAccountId: update3.stakedAccountId != null ? AccountId._fromProtobuf(update3.stakedAccountId) : void 0,
        stakedNodeId: update3.stakedNodeId != null ? update3.stakedNodeId : void 0,
        declineStakingReward: update3.declineReward != null ? update3.declineReward.value != null ? update3.declineReward.value : void 0 : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * Sets the account ID which is being updated in this transaction.
   *
   * @param {AccountId | string} accountId
   * @returns {AccountUpdateTransaction}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?Key}
   */
  get key() {
    return this._key;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setKey(key) {
    this._requireNotFrozen();
    this._key = key;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  /**
   * @param {boolean} receiverSignatureRequired
   * @returns {this}
   */
  setReceiverSignatureRequired(receiverSignatureRequired) {
    this._requireNotFrozen();
    this._receiverSignatureRequired = receiverSignatureRequired;
    return this;
  }
  /**
   * @deprecated
   * @returns {?AccountId}
   */
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * @deprecated
   * @param {AccountId} proxyAccountId
   * @returns {this}
   */
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = proxyAccountId;
    return this;
  }
  /**
   * @returns {?Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp | Date} expirationTime
   * @returns {this}
   */
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Date ? Timestamp.fromDate(expirationTime) : expirationTime;
    return this;
  }
  /**
   * @returns {?string}
   */
  get accountMemo() {
    return this._accountMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */
  setAccountMemo(memo) {
    this._requireNotFrozen();
    this._accountMemo = memo;
    return this;
  }
  /**
   * @returns {this}
   */
  clearAccountMemo() {
    this._requireNotFrozen();
    this._accountMemo = null;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  /**
   * @param {Long | number} maxAutomaticTokenAssociations
   * @returns {this}
   */
  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
    this._requireNotFrozen();
    this._maxAutomaticTokenAssociations = typeof maxAutomaticTokenAssociations === "number" ? import_long29.default.fromNumber(maxAutomaticTokenAssociations) : maxAutomaticTokenAssociations;
    return this;
  }
  /**
   * @deprecated - no longer supported
   * @returns {?Key}
   */
  get aliasKey() {
    return null;
  }
  /**
   * @deprecated - no longer supported
   * @param {Key} _
   * @returns {this}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setAliasKey(_) {
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  /**
   * @param {AccountId | string} stakedAccountId
   * @returns {this}
   */
  setStakedAccountId(stakedAccountId) {
    this._requireNotFrozen();
    this._stakedAccountId = typeof stakedAccountId === "string" ? AccountId.fromString(stakedAccountId) : stakedAccountId;
    return this;
  }
  /**
   * @returns {this}
   */
  clearStakedAccountId() {
    this._requireNotFrozen();
    this._stakedAccountId = new AccountId(0, 0, 0);
    return this;
  }
  /**
   * @returns {?Long}
   */
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  /**
   * @param {Long | number} stakedNodeId
   * @returns {this}
   */
  setStakedNodeId(stakedNodeId) {
    this._requireNotFrozen();
    this._stakedNodeId = import_long29.default.fromValue(stakedNodeId);
    return this;
  }
  /**
   * @returns {this}
   */
  clearStakedNodeId() {
    this._requireNotFrozen();
    this._stakedNodeId = import_long29.default.fromNumber(-1);
    return this;
  }
  /**
   * @returns {?boolean}
   */
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  /**
   * @param {boolean} declineStakingReward
   * @returns {this}
   */
  setDeclineStakingReward(declineStakingReward) {
    this._requireNotFrozen();
    this._declineStakingReward = declineStakingReward;
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.updateAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoUpdateAccount";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoUpdateTransactionBody}
   */
  _makeTransactionData() {
    return {
      accountIDToUpdate: this._accountId != null ? this._accountId._toProtobuf() : null,
      key: this._key != null ? this._key._toProtobufKey() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      receiverSigRequiredWrapper: this._receiverSignatureRequired == null ? null : {
        value: this._receiverSignatureRequired
      },
      memo: this._accountMemo != null ? {
        value: this._accountMemo
      } : null,
      maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations != null ? { value: this._maxAutomaticTokenAssociations.toInt() } : null,
      stakedAccountId: this.stakedAccountId != null ? this.stakedAccountId._toProtobuf() : null,
      stakedNodeId: this.stakedNodeId,
      declineReward: this.declineStakingRewards != null ? { value: this.declineStakingRewards } : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `AccountUpdateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoUpdateAccount",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  AccountUpdateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/address_book/IPv4AddressPart.js
var IPv4AddressPart = class {
  /**
   * @param {object} props
   * @param {number} [props.left]
   * @param {number} [props.right]
   */
  constructor(props = {}) {
    this._left = null;
    if (props.left != null) {
      this.setLeft(props.left);
    }
    this._right = null;
    if (props.right != null) {
      this.setRight(props.right);
    }
  }
  /**
   * @returns {?number}
   */
  get left() {
    return this._left;
  }
  /**
   * @param {number} part
   * @returns {this}
   */
  setLeft(part) {
    this._left = part;
    return this;
  }
  /**
   * @returns {?number}
   */
  get right() {
    return this._right;
  }
  /**
   * @param {number} part
   * @returns {this}
   */
  setRight(part) {
    this._right = part;
    return this;
  }
  /**
   * @returns {string}
   */
  toString() {
    if (this._left != null && this._right != null) {
      return `${this._left.toString()}.${this._right.toString()}`;
    } else {
      return "";
    }
  }
};

// node_modules/@hashgraph/sdk/src/address_book/IPv4Address.js
var IPv4Address = class _IPv4Address {
  /**
   * @param {object} props
   * @param {IPv4AddressPart} [props.network]
   * @param {IPv4AddressPart} [props.host]
   */
  constructor(props = {}) {
    this._network = null;
    if (props.network != null) {
      this.setNetwork(props.network);
    }
    this._host = null;
    if (props.host != null) {
      this.setHost(props.host);
    }
  }
  /**
   * @returns {?IPv4AddressPart}
   */
  get newtork() {
    return this._network;
  }
  /**
   * @param {IPv4AddressPart} part
   * @returns {this}
   */
  setNetwork(part) {
    this._network = part;
    return this;
  }
  /**
   * @returns {?IPv4AddressPart}
   */
  get host() {
    return this._host;
  }
  /**
   * @param {IPv4AddressPart} part
   * @returns {this}
   */
  setHost(part) {
    this._host = part;
    return this;
  }
  /**
   * @internal
   * @param {Uint8Array} bytes
   * @returns {IPv4Address}
   */
  static _fromProtobuf(bytes3) {
    return new _IPv4Address({
      network: new IPv4AddressPart().setLeft(bytes3[0]).setRight(bytes3[1]),
      host: new IPv4AddressPart().setLeft(bytes3[2]).setRight(bytes3[3])
    });
  }
  /**
   * @returns {Uint8Array}
   */
  _toProtobuf() {
    return Uint8Array.of(
      this._network != null && this._network._left != null ? this._network._left : 0,
      this._network != null && this._network.right != null ? this._network.right : 0,
      this._host != null && this._host.left != null ? this._host.left : 0,
      this._host != null && this._host.right != null ? this._host.right : 0
    );
  }
  /**
   * @returns {string}
   */
  toString() {
    if (this._network != null && this._host != null) {
      return `${this._network.toString()}.${this._host.toString()}`;
    } else {
      return "";
    }
  }
};

// node_modules/@hashgraph/sdk/src/address_book/Endpoint.js
var EndPoint = class _EndPoint {
  /**
   * @param {object} props
   * @param {IPv4Address} [props.address]
   * @param {number} [props.port]
   */
  constructor(props = {}) {
    this._address = null;
    if (props.address != null) {
      this.setAddress(props.address);
    }
    this._port = null;
    if (props.port != null) {
      this.setPort(props.port);
    }
  }
  /**
   * @returns {?IPv4Address}
   */
  get address() {
    return this.address;
  }
  /**
   * @param {IPv4Address} address
   * @returns {this}
   */
  setAddress(address) {
    this._address = address;
    return this;
  }
  /**
   * @returns {?number}
   */
  get port() {
    return this._port;
  }
  /**
   * @param {number} port
   * @returns {this}
   */
  setPort(port) {
    this._port = port;
    return this;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IServiceEndpoint} endpoint
   * @returns {EndPoint}
   */
  static _fromProtobuf(endpoint) {
    return new _EndPoint({
      address: endpoint.ipAddressV4 != null ? IPv4Address._fromProtobuf(endpoint.ipAddressV4) : void 0,
      port: endpoint.port != null ? endpoint.port : void 0
    });
  }
  /**
   * @returns {HashgraphProto.proto.IServiceEndpoint}
   */
  _toProtobuf() {
    return {
      ipAddressV4: this._address != null ? this._address._toProtobuf() : null,
      port: this._port
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return `${this._address != null ? this._address.toString() : ""}:${this._port != null ? this._port.toString() : ""}`;
  }
  /**
   * @returns {EndPointJson}
   */
  toJSON() {
    return {
      address: this._address != null ? this._address.toString() : null,
      port: this._port != null ? this._port.toString() : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/address_book/NodeAddress.js
var NodeAddress = class _NodeAddress {
  /**
   * @param {object} props
   * @param {string} [props.publicKey]
   * @param {Long} [props.nodeId]
   * @param {AccountId | string} [props.accountId]
   * @param {Uint8Array} [props.certHash]
   * @param {Endpoint[]} [props.addresses]
   * @param {string} [props.description]
   * @param {Long} [props.stake]
   */
  constructor(props = {}) {
    this._publicKey = null;
    if (props.publicKey != null) {
      this.setPublicKey(props.publicKey);
    }
    this._nodeId = null;
    if (props.nodeId != null) {
      this.setNodeId(props.nodeId);
    }
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    this._certHash = null;
    if (props.certHash != null) {
      this.setCertHash(props.certHash);
    }
    this._addresses = [];
    if (props.addresses != null) {
      this.setAddresses(props.addresses);
    }
    this._description = null;
    if (props.description != null) {
      this.setDescription(props.description);
    }
    this._stake = null;
    if (props.stake != null) {
      this.setStake(props.stake);
    }
  }
  /**
   * @returns {?string}
   */
  get publicKey() {
    return this._publicKey;
  }
  /**
   * @param {string} publicKey
   * @returns {this}
   */
  setPublicKey(publicKey) {
    this._publicKey = publicKey;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get nodeId() {
    return this._nodeId;
  }
  /**
   * @param {Long} nodeId
   * @returns {this}
   */
  setNodeId(nodeId) {
    this._nodeId = nodeId;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get certHash() {
    return this._certHash;
  }
  /**
   * @param {Uint8Array} certHash
   * @returns {this}
   */
  setCertHash(certHash) {
    this._certHash = certHash;
    return this;
  }
  /**
   * @returns {Endpoint[]}
   */
  get addresses() {
    return this._addresses;
  }
  /**
   * @param {Endpoint[]} addresses
   * @returns {this}
   */
  setAddresses(addresses) {
    this._addresses = addresses;
    return this;
  }
  /**
   * @returns {?string}
   */
  get description() {
    return this._description;
  }
  /**
   * @param {string} description
   * @returns {this}
   */
  setDescription(description) {
    this._description = description;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get stake() {
    return this._stake;
  }
  /**
   * @param {Long} stake
   * @returns {this}
   */
  setStake(stake) {
    this._stake = stake;
    return this;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.INodeAddress} nodeAddress
   * @returns {NodeAddress}
   */
  static _fromProtobuf(nodeAddress) {
    return new _NodeAddress({
      publicKey: nodeAddress.RSA_PubKey != null ? nodeAddress.RSA_PubKey : void 0,
      nodeId: nodeAddress.nodeId != null ? nodeAddress.nodeId : void 0,
      accountId: nodeAddress.nodeAccountId != null ? AccountId._fromProtobuf(nodeAddress.nodeAccountId) : void 0,
      certHash: nodeAddress.nodeCertHash != null ? nodeAddress.nodeCertHash : void 0,
      addresses: nodeAddress.serviceEndpoint != null ? nodeAddress.serviceEndpoint.map(
        (address) => EndPoint._fromProtobuf(address)
      ) : void 0,
      description: nodeAddress.description != null ? nodeAddress.description : void 0,
      stake: nodeAddress.stake != null ? nodeAddress.stake : void 0
    });
  }
  /**
   * @returns {HashgraphProto.proto.INodeAddress}
   */
  _toProtobuf() {
    return {
      RSA_PubKey: this._publicKey,
      nodeId: this._nodeId,
      nodeAccountId: this._accountId != null ? this._accountId._toProtobuf() : null,
      nodeCertHash: this._certHash,
      serviceEndpoint: this._addresses.map(
        (address) => address._toProtobuf()
      ),
      description: this._description,
      stake: this._stake
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @returns {NodeAddressJson}
   */
  toJSON() {
    return {
      publicKey: this._publicKey,
      nodeId: this._nodeId != null ? this._nodeId.toString() : null,
      accountId: this._accountId != null ? this._accountId.toString() : null,
      certHash: this._certHash != null ? decode7(this._certHash) : null,
      addresses: this._addresses.map((address) => address.toJSON()),
      description: this._description,
      stake: this._stake != null ? this._stake.toString() : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/address_book/NodeAddressBook.js
var HashgraphProto20 = __toESM(require_lib(), 1);
var NodeAddressBook = class _NodeAddressBook {
  /**
   * @param {object} props
   * @param {NodeAddress[]} [props.nodeAddresses]
   */
  constructor(props = {}) {
    this._nodeAddresses = [];
    if (props.nodeAddresses != null) {
      this.setNodeAddresses(props.nodeAddresses);
    }
  }
  /**
   * @returns {NodeAddress[]}
   */
  get nodeAddresses() {
    return this._nodeAddresses;
  }
  /**
   * @param {NodeAddress[]} nodeAddresses
   * @returns {this}
   */
  setNodeAddresses(nodeAddresses) {
    this._nodeAddresses = nodeAddresses;
    return this;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NodeAddressBook}
   */
  static fromBytes(bytes3) {
    return _NodeAddressBook._fromProtobuf(
      HashgraphProto20.proto.NodeAddressBook.decode(bytes3)
    );
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.INodeAddressBook} nodeAddressBook
   * @returns {NodeAddressBook}
   */
  static _fromProtobuf(nodeAddressBook) {
    return new _NodeAddressBook({
      nodeAddresses: nodeAddressBook.nodeAddress != null ? nodeAddressBook.nodeAddress.map(
        (nodeAddress) => NodeAddress._fromProtobuf(nodeAddress)
      ) : void 0
    });
  }
  /**
   * @returns {HashgraphProto.proto.INodeAddressBook}
   */
  _toProtobuf() {
    return {
      nodeAddress: this._nodeAddresses.map(
        (nodeAddress) => nodeAddress._toProtobuf()
      )
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @returns {NodeAddressBookJson}
   */
  toJSON() {
    return {
      nodeAddresses: this._nodeAddresses.map(
        (nodeAddress) => nodeAddress.toJSON()
      )
    };
  }
  toBytes() {
    return HashgraphProto20.proto.NodeAddressBook.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/network/AddressBookQuery.js
var HashgraphProto21 = __toESM(require_lib(), 1);
var AddressBookQuery = class extends Query {
  /**
   * @param {object} props
   * @param {FileId | string} [props.fileId]
   * @param {number} [props.limit]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    this._limit = null;
    if (props.limit != null) {
      this.setLimit(props.limit);
    }
    this._retryHandler = (error) => {
      if (error != null) {
        if (error instanceof Error) {
          return true;
        } else {
          switch (error.code) {
            case 13:
              return RST_STREAM.test(error.details.toString());
            case 5:
            case 8:
            case 14:
            case 17:
              return true;
            default:
              return false;
          }
        }
      }
      return false;
    };
    this._addresses = [];
    this._attempt = 0;
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * @param {FileId | string} fileId
   * @returns {AddressBookQuery}
   */
  setFileId(fileId) {
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @returns {?number}
   */
  get limit() {
    return this._limit;
  }
  /**
   * @param {number} limit
   * @returns {AddressBookQuery}
   */
  setLimit(limit) {
    this._limit = limit;
    return this;
  }
  /**
   * @param {number} attempts
   * @returns {this}
   */
  setMaxAttempts(attempts) {
    this._maxAttempts = attempts;
    return this;
  }
  /**
   * @param {number} backoff
   * @returns {this}
   */
  setMaxBackoff(backoff) {
    this._maxBackoff = backoff;
    return this;
  }
  /**
   * @param {Client<Channel>} client
   * @param {number=} requestTimeout
   * @returns {Promise<NodeAddressBook>}
   */
  execute(client, requestTimeout) {
    return new Promise((resolve, reject) => {
      this._makeServerStreamRequest(
        client,
        /** @type {(value: NodeAddressBook) => void} */
        resolve,
        reject,
        requestTimeout
      );
    });
  }
  /**
   * @private
   * @param {Client<Channel>} client
   * @param {(value: NodeAddressBook) => void} resolve
   * @param {(error: Error) => void} reject
   * @param {number=} requestTimeout
   */
  _makeServerStreamRequest(client, resolve, reject, requestTimeout) {
    const request = HashgraphProto21.com.hedera.mirror.api.proto.AddressBookQuery.encode({
      fileId: this._fileId != null ? this._fileId._toProtobuf() : null,
      limit: this._limit
    }).finish();
    client._mirrorNetwork.getNextMirrorNode().getChannel().makeServerStreamRequest(
      "NetworkService",
      "getNodes",
      request,
      (data) => {
        this._addresses.push(
          NodeAddress._fromProtobuf(
            HashgraphProto21.proto.NodeAddress.decode(data)
          )
        );
        if (this._limit != null && this._limit > 0) {
          this._limit = this._limit - 1;
        }
      },
      (error) => {
        const message = error instanceof Error ? error.message : error.details;
        if (this._attempt < this._maxAttempts && !client.isClientShutDown && this._retryHandler(error)) {
          const delay = Math.min(
            250 * 2 ** this._attempt,
            this._maxBackoff
          );
          if (this._attempt >= this._maxAttempts) {
            console.warn(
              `Error getting nodes from mirror for file ${this._fileId != null ? this._fileId.toString() : "UNKNOWN"} during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${message}`
            );
          }
          if (this._logger) {
            this._logger.debug(
              `Error getting nodes from mirror for file ${this._fileId != null ? this._fileId.toString() : "UNKNOWN"} during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${message}`
            );
          }
          this._attempt += 1;
          setTimeout(() => {
            this._makeServerStreamRequest(
              client,
              resolve,
              reject,
              requestTimeout
            );
          }, delay);
        } else {
          reject(new Error("failed to query address book"));
        }
      },
      () => {
        resolve(
          new NodeAddressBook({ nodeAddresses: this._addresses })
        );
      }
    );
  }
};
Cache_default2.setAddressBookQueryConstructor(() => new AddressBookQuery());

// node_modules/@hashgraph/sdk/src/contract/ContractByteCodeQuery.js
var ContractByteCodeQuery = class _ContractByteCodeQuery extends Query {
  /**
   * @param {object} props
   * @param {ContractId | string} [props.contractId]
   */
  constructor(props = {}) {
    super();
    this._contractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {ContractByteCodeQuery}
   */
  static _fromProtobuf(query) {
    const bytecode = (
      /** @type {HashgraphProto.proto.IContractGetBytecodeQuery} */
      query.contractGetBytecode
    );
    return new _ContractByteCodeQuery({
      contractId: bytecode.contractID != null ? ContractId._fromProtobuf(bytecode.contractID) : void 0
    });
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the info is being requested.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractByteCodeQuery}
   */
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.contractGetBytecode(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const contractGetBytecodeResponse = (
      /** @type {HashgraphProto.proto.IContractGetBytecodeResponse} */
      response.contractGetBytecodeResponse
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      contractGetBytecodeResponse.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Promise<Uint8Array>}
   */
  _mapResponse(response) {
    const contractGetBytecodeResponse = (
      /** @type {HashgraphProto.proto.IContractGetBytecodeResponse} */
      response.contractGetBytecodeResponse
    );
    return Promise.resolve(
      contractGetBytecodeResponse.bytecode != null ? contractGetBytecodeResponse.bytecode : new Uint8Array()
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      contractGetBytecode: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `ContractByteCodeQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("contractGetBytecode", ContractByteCodeQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/cryptography/keccak.js
var HEX_CHARS2 = "0123456789abcdef".split("");
var KECCAK_PADDING2 = [1, 256, 65536, 16777216];
var SHIFT2 = [0, 8, 16, 24];
var RC2 = [
  1,
  0,
  32898,
  0,
  32906,
  2147483648,
  2147516416,
  2147483648,
  32907,
  0,
  2147483649,
  0,
  2147516545,
  2147483648,
  32777,
  2147483648,
  138,
  0,
  136,
  0,
  2147516425,
  0,
  2147483658,
  0,
  2147516555,
  0,
  139,
  2147483648,
  32905,
  2147483648,
  32771,
  2147483648,
  32770,
  2147483648,
  128,
  2147483648,
  32778,
  0,
  2147483658,
  2147483648,
  2147516545,
  2147483648,
  32896,
  2147483648,
  2147483649,
  0,
  2147516424,
  2147483648
];
var Keccak2 = (bits) => ({
  blocks: [],
  reset: true,
  block: 0,
  start: 0,
  blockCount: 1600 - (bits << 1) >> 5,
  outputBlocks: bits >> 5,
  // @ts-ignore
  s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
});
var update2 = (state, message) => {
  var length = message.length, blocks = state.blocks, byteCount = state.blockCount << 2, blockCount = state.blockCount, outputBlocks = state.outputBlocks, s = state.s, index = 0, i, code;
  while (index < length) {
    if (state.reset) {
      state.reset = false;
      blocks[0] = state.block;
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    if (typeof message !== "string") {
      for (i = state.start; index < length && i < byteCount; ++index) {
        blocks[i >> 2] |= message[index] << SHIFT2[i++ & 3];
      }
    } else {
      for (i = state.start; index < length && i < byteCount; ++index) {
        code = message.charCodeAt(index);
        if (code < 128) {
          blocks[i >> 2] |= code << SHIFT2[i++ & 3];
        } else if (code < 2048) {
          blocks[i >> 2] |= (192 | code >> 6) << SHIFT2[i++ & 3];
          blocks[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
        } else if (code < 55296 || code >= 57344) {
          blocks[i >> 2] |= (224 | code >> 12) << SHIFT2[i++ & 3];
          blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
          blocks[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
        } else {
          code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
          blocks[i >> 2] |= (240 | code >> 18) << SHIFT2[i++ & 3];
          blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i++ & 3];
          blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
          blocks[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
        }
      }
    }
    state.lastByteIndex = i;
    if (i >= byteCount) {
      state.start = i - byteCount;
      state.block = blocks[blockCount];
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f2(s);
      state.reset = true;
    } else {
      state.start = i;
    }
  }
  i = state.lastByteIndex;
  blocks[i >> 2] |= KECCAK_PADDING2[i & 3];
  if (state.lastByteIndex === byteCount) {
    blocks[0] = blocks[blockCount];
    for (i = 1; i < blockCount + 1; ++i) {
      blocks[i] = 0;
    }
  }
  blocks[blockCount - 1] |= 2147483648;
  for (i = 0; i < blockCount; ++i) {
    s[i] ^= blocks[i];
  }
  f2(s);
  var hex = "";
  var block;
  var j = 0;
  i = 0;
  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      block = s[i];
      hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
    }
    if (j % blockCount === 0) {
      f2(s);
      i = 0;
    }
  }
  return "0x" + hex;
};
var f2 = (s) => {
  var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
  for (n = 0; n < 48; n += 2) {
    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    h = c8 ^ (c2 << 1 | c3 >>> 31);
    l = c9 ^ (c3 << 1 | c2 >>> 31);
    s[0] ^= h;
    s[1] ^= l;
    s[10] ^= h;
    s[11] ^= l;
    s[20] ^= h;
    s[21] ^= l;
    s[30] ^= h;
    s[31] ^= l;
    s[40] ^= h;
    s[41] ^= l;
    h = c0 ^ (c4 << 1 | c5 >>> 31);
    l = c1 ^ (c5 << 1 | c4 >>> 31);
    s[2] ^= h;
    s[3] ^= l;
    s[12] ^= h;
    s[13] ^= l;
    s[22] ^= h;
    s[23] ^= l;
    s[32] ^= h;
    s[33] ^= l;
    s[42] ^= h;
    s[43] ^= l;
    h = c2 ^ (c6 << 1 | c7 >>> 31);
    l = c3 ^ (c7 << 1 | c6 >>> 31);
    s[4] ^= h;
    s[5] ^= l;
    s[14] ^= h;
    s[15] ^= l;
    s[24] ^= h;
    s[25] ^= l;
    s[34] ^= h;
    s[35] ^= l;
    s[44] ^= h;
    s[45] ^= l;
    h = c4 ^ (c8 << 1 | c9 >>> 31);
    l = c5 ^ (c9 << 1 | c8 >>> 31);
    s[6] ^= h;
    s[7] ^= l;
    s[16] ^= h;
    s[17] ^= l;
    s[26] ^= h;
    s[27] ^= l;
    s[36] ^= h;
    s[37] ^= l;
    s[46] ^= h;
    s[47] ^= l;
    h = c6 ^ (c0 << 1 | c1 >>> 31);
    l = c7 ^ (c1 << 1 | c0 >>> 31);
    s[8] ^= h;
    s[9] ^= l;
    s[18] ^= h;
    s[19] ^= l;
    s[28] ^= h;
    s[29] ^= l;
    s[38] ^= h;
    s[39] ^= l;
    s[48] ^= h;
    s[49] ^= l;
    b0 = s[0];
    b1 = s[1];
    b32 = s[11] << 4 | s[10] >>> 28;
    b33 = s[10] << 4 | s[11] >>> 28;
    b14 = s[20] << 3 | s[21] >>> 29;
    b15 = s[21] << 3 | s[20] >>> 29;
    b46 = s[31] << 9 | s[30] >>> 23;
    b47 = s[30] << 9 | s[31] >>> 23;
    b28 = s[40] << 18 | s[41] >>> 14;
    b29 = s[41] << 18 | s[40] >>> 14;
    b20 = s[2] << 1 | s[3] >>> 31;
    b21 = s[3] << 1 | s[2] >>> 31;
    b2 = s[13] << 12 | s[12] >>> 20;
    b3 = s[12] << 12 | s[13] >>> 20;
    b34 = s[22] << 10 | s[23] >>> 22;
    b35 = s[23] << 10 | s[22] >>> 22;
    b16 = s[33] << 13 | s[32] >>> 19;
    b17 = s[32] << 13 | s[33] >>> 19;
    b48 = s[42] << 2 | s[43] >>> 30;
    b49 = s[43] << 2 | s[42] >>> 30;
    b40 = s[5] << 30 | s[4] >>> 2;
    b41 = s[4] << 30 | s[5] >>> 2;
    b22 = s[14] << 6 | s[15] >>> 26;
    b23 = s[15] << 6 | s[14] >>> 26;
    b4 = s[25] << 11 | s[24] >>> 21;
    b5 = s[24] << 11 | s[25] >>> 21;
    b36 = s[34] << 15 | s[35] >>> 17;
    b37 = s[35] << 15 | s[34] >>> 17;
    b18 = s[45] << 29 | s[44] >>> 3;
    b19 = s[44] << 29 | s[45] >>> 3;
    b10 = s[6] << 28 | s[7] >>> 4;
    b11 = s[7] << 28 | s[6] >>> 4;
    b42 = s[17] << 23 | s[16] >>> 9;
    b43 = s[16] << 23 | s[17] >>> 9;
    b24 = s[26] << 25 | s[27] >>> 7;
    b25 = s[27] << 25 | s[26] >>> 7;
    b6 = s[36] << 21 | s[37] >>> 11;
    b7 = s[37] << 21 | s[36] >>> 11;
    b38 = s[47] << 24 | s[46] >>> 8;
    b39 = s[46] << 24 | s[47] >>> 8;
    b30 = s[8] << 27 | s[9] >>> 5;
    b31 = s[9] << 27 | s[8] >>> 5;
    b12 = s[18] << 20 | s[19] >>> 12;
    b13 = s[19] << 20 | s[18] >>> 12;
    b44 = s[29] << 7 | s[28] >>> 25;
    b45 = s[28] << 7 | s[29] >>> 25;
    b26 = s[38] << 8 | s[39] >>> 24;
    b27 = s[39] << 8 | s[38] >>> 24;
    b8 = s[48] << 14 | s[49] >>> 18;
    b9 = s[49] << 14 | s[48] >>> 18;
    s[0] = b0 ^ ~b2 & b4;
    s[1] = b1 ^ ~b3 & b5;
    s[10] = b10 ^ ~b12 & b14;
    s[11] = b11 ^ ~b13 & b15;
    s[20] = b20 ^ ~b22 & b24;
    s[21] = b21 ^ ~b23 & b25;
    s[30] = b30 ^ ~b32 & b34;
    s[31] = b31 ^ ~b33 & b35;
    s[40] = b40 ^ ~b42 & b44;
    s[41] = b41 ^ ~b43 & b45;
    s[2] = b2 ^ ~b4 & b6;
    s[3] = b3 ^ ~b5 & b7;
    s[12] = b12 ^ ~b14 & b16;
    s[13] = b13 ^ ~b15 & b17;
    s[22] = b22 ^ ~b24 & b26;
    s[23] = b23 ^ ~b25 & b27;
    s[32] = b32 ^ ~b34 & b36;
    s[33] = b33 ^ ~b35 & b37;
    s[42] = b42 ^ ~b44 & b46;
    s[43] = b43 ^ ~b45 & b47;
    s[4] = b4 ^ ~b6 & b8;
    s[5] = b5 ^ ~b7 & b9;
    s[14] = b14 ^ ~b16 & b18;
    s[15] = b15 ^ ~b17 & b19;
    s[24] = b24 ^ ~b26 & b28;
    s[25] = b25 ^ ~b27 & b29;
    s[34] = b34 ^ ~b36 & b38;
    s[35] = b35 ^ ~b37 & b39;
    s[44] = b44 ^ ~b46 & b48;
    s[45] = b45 ^ ~b47 & b49;
    s[6] = b6 ^ ~b8 & b0;
    s[7] = b7 ^ ~b9 & b1;
    s[16] = b16 ^ ~b18 & b10;
    s[17] = b17 ^ ~b19 & b11;
    s[26] = b26 ^ ~b28 & b20;
    s[27] = b27 ^ ~b29 & b21;
    s[36] = b36 ^ ~b38 & b30;
    s[37] = b37 ^ ~b39 & b31;
    s[46] = b46 ^ ~b48 & b40;
    s[47] = b47 ^ ~b49 & b41;
    s[8] = b8 ^ ~b0 & b2;
    s[9] = b9 ^ ~b1 & b3;
    s[18] = b18 ^ ~b10 & b12;
    s[19] = b19 ^ ~b11 & b13;
    s[28] = b28 ^ ~b20 & b22;
    s[29] = b29 ^ ~b21 & b23;
    s[38] = b38 ^ ~b30 & b32;
    s[39] = b39 ^ ~b31 & b33;
    s[48] = b48 ^ ~b40 & b42;
    s[49] = b49 ^ ~b41 & b43;
    s[0] ^= RC2[n];
    s[1] ^= RC2[n + 1];
  }
};
var keccak2 = (bits) => (str) => {
  var msg;
  if (str.slice(0, 2) === "0x") {
    msg = [];
    for (var i = 2, l = str.length; i < l; i += 2)
      msg.push(parseInt(str.slice(i, i + 2), 16));
  } else {
    msg = str;
  }
  return update2(Keccak2(bits), msg);
};
var keccak2563 = keccak2(256);

// node_modules/@hashgraph/sdk/src/contract/ContractFunctionSelector.js
var ArgumentType = {
  uint8: 0,
  int8: 1,
  uint16: 2,
  int16: 3,
  uint24: 4,
  int24: 5,
  uint32: 6,
  int32: 7,
  uint40: 8,
  int40: 9,
  uint48: 10,
  int48: 11,
  uint56: 12,
  int56: 13,
  uint64: 14,
  int64: 15,
  uint72: 16,
  int72: 17,
  uint80: 18,
  int80: 19,
  uint88: 20,
  int88: 21,
  uint96: 22,
  int96: 23,
  uint104: 24,
  int104: 25,
  uint112: 26,
  int112: 27,
  uint120: 28,
  int120: 29,
  uint128: 30,
  int128: 31,
  uint136: 32,
  int136: 33,
  uint144: 34,
  int144: 35,
  uint152: 36,
  int152: 37,
  uint160: 38,
  int160: 39,
  uint168: 40,
  int168: 41,
  uint176: 42,
  int176: 43,
  uint184: 44,
  int184: 45,
  uint192: 46,
  int192: 47,
  uint200: 48,
  int200: 49,
  uint208: 50,
  int208: 51,
  uint216: 52,
  int216: 53,
  uint224: 54,
  int224: 55,
  uint232: 56,
  int232: 57,
  uint240: 58,
  int240: 59,
  uint248: 60,
  int248: 61,
  uint256: 62,
  int256: 63,
  string: 64,
  bool: 65,
  bytes: 66,
  bytes32: 67,
  address: 68,
  func: 69
};
var ContractFunctionSelector = class {
  /**
   * @param {string} [name]
   */
  constructor(name) {
    this.name = null;
    this._params = "";
    this._paramTypes = [];
    if (name != null) {
      this._name = name;
    }
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addString() {
    return this._addParam({ ty: ArgumentType.string, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addStringArray() {
    return this._addParam({ ty: ArgumentType.string, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addBytes() {
    return this._addParam({ ty: ArgumentType.bytes, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addBytes32() {
    return this._addParam({ ty: ArgumentType.bytes32, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addBytesArray() {
    return this._addParam({ ty: ArgumentType.bytes, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addBytes32Array() {
    return this._addParam({ ty: ArgumentType.bytes32, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt8() {
    return this._addParam({ ty: ArgumentType.int8, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint8() {
    return this._addParam({ ty: ArgumentType.uint8, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt16() {
    return this._addParam({ ty: ArgumentType.int16, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint16() {
    return this._addParam({ ty: ArgumentType.uint16, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt24() {
    return this._addParam({ ty: ArgumentType.int24, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint24() {
    return this._addParam({ ty: ArgumentType.uint24, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt32() {
    return this._addParam({ ty: ArgumentType.int32, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint32() {
    return this._addParam({ ty: ArgumentType.uint32, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt40() {
    return this._addParam({ ty: ArgumentType.int40, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint40() {
    return this._addParam({ ty: ArgumentType.uint40, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt48() {
    return this._addParam({ ty: ArgumentType.int48, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint48() {
    return this._addParam({ ty: ArgumentType.uint48, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt56() {
    return this._addParam({ ty: ArgumentType.int56, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint56() {
    return this._addParam({ ty: ArgumentType.uint56, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt64() {
    return this._addParam({ ty: ArgumentType.int64, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint64() {
    return this._addParam({ ty: ArgumentType.uint64, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt72() {
    return this._addParam({ ty: ArgumentType.int72, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint72() {
    return this._addParam({ ty: ArgumentType.uint72, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt80() {
    return this._addParam({ ty: ArgumentType.int80, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint80() {
    return this._addParam({ ty: ArgumentType.uint80, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt88() {
    return this._addParam({ ty: ArgumentType.int88, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint88() {
    return this._addParam({ ty: ArgumentType.uint88, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt96() {
    return this._addParam({ ty: ArgumentType.int96, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint96() {
    return this._addParam({ ty: ArgumentType.uint96, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt104() {
    return this._addParam({ ty: ArgumentType.int104, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint104() {
    return this._addParam({ ty: ArgumentType.uint104, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt112() {
    return this._addParam({ ty: ArgumentType.int112, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint112() {
    return this._addParam({ ty: ArgumentType.uint112, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt120() {
    return this._addParam({ ty: ArgumentType.int120, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint120() {
    return this._addParam({ ty: ArgumentType.uint120, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt128() {
    return this._addParam({ ty: ArgumentType.int128, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint128() {
    return this._addParam({ ty: ArgumentType.uint128, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt136() {
    return this._addParam({ ty: ArgumentType.int136, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint136() {
    return this._addParam({ ty: ArgumentType.uint136, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt144() {
    return this._addParam({ ty: ArgumentType.int144, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint144() {
    return this._addParam({ ty: ArgumentType.uint144, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt152() {
    return this._addParam({ ty: ArgumentType.int152, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint152() {
    return this._addParam({ ty: ArgumentType.uint152, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt160() {
    return this._addParam({ ty: ArgumentType.int160, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint160() {
    return this._addParam({ ty: ArgumentType.uint160, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt168() {
    return this._addParam({ ty: ArgumentType.int168, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint168() {
    return this._addParam({ ty: ArgumentType.uint168, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt176() {
    return this._addParam({ ty: ArgumentType.int176, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint176() {
    return this._addParam({ ty: ArgumentType.uint176, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt184() {
    return this._addParam({ ty: ArgumentType.int184, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint184() {
    return this._addParam({ ty: ArgumentType.uint184, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt192() {
    return this._addParam({ ty: ArgumentType.int192, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint192() {
    return this._addParam({ ty: ArgumentType.uint192, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt200() {
    return this._addParam({ ty: ArgumentType.int200, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint200() {
    return this._addParam({ ty: ArgumentType.uint200, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt208() {
    return this._addParam({ ty: ArgumentType.int208, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint208() {
    return this._addParam({ ty: ArgumentType.uint208, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt216() {
    return this._addParam({ ty: ArgumentType.int216, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint216() {
    return this._addParam({ ty: ArgumentType.uint216, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt224() {
    return this._addParam({ ty: ArgumentType.int224, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint224() {
    return this._addParam({ ty: ArgumentType.uint224, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt232() {
    return this._addParam({ ty: ArgumentType.int232, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint232() {
    return this._addParam({ ty: ArgumentType.uint232, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt240() {
    return this._addParam({ ty: ArgumentType.int240, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint240() {
    return this._addParam({ ty: ArgumentType.uint240, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt248() {
    return this._addParam({ ty: ArgumentType.int248, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint248() {
    return this._addParam({ ty: ArgumentType.uint248, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt256() {
    return this._addParam({ ty: ArgumentType.int256, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint256() {
    return this._addParam({ ty: ArgumentType.uint256, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt8Array() {
    return this._addParam({ ty: ArgumentType.int8, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint8Array() {
    return this._addParam({ ty: ArgumentType.uint8, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt16Array() {
    return this._addParam({ ty: ArgumentType.int16, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint16Array() {
    return this._addParam({ ty: ArgumentType.uint16, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt24Array() {
    return this._addParam({ ty: ArgumentType.int24, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint24Array() {
    return this._addParam({ ty: ArgumentType.uint24, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt32Array() {
    return this._addParam({ ty: ArgumentType.int32, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint32Array() {
    return this._addParam({ ty: ArgumentType.uint32, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt40Array() {
    return this._addParam({ ty: ArgumentType.int40, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint40Array() {
    return this._addParam({ ty: ArgumentType.uint40, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt48Array() {
    return this._addParam({ ty: ArgumentType.int48, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint48Array() {
    return this._addParam({ ty: ArgumentType.uint48, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt56Array() {
    return this._addParam({ ty: ArgumentType.int56, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint56Array() {
    return this._addParam({ ty: ArgumentType.uint56, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt64Array() {
    return this._addParam({ ty: ArgumentType.int64, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint64Array() {
    return this._addParam({ ty: ArgumentType.uint64, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt72Array() {
    return this._addParam({ ty: ArgumentType.int72, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint72Array() {
    return this._addParam({ ty: ArgumentType.uint72, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt80Array() {
    return this._addParam({ ty: ArgumentType.int80, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint80Array() {
    return this._addParam({ ty: ArgumentType.uint80, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt88Array() {
    return this._addParam({ ty: ArgumentType.int88, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint88Array() {
    return this._addParam({ ty: ArgumentType.uint88, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt96Array() {
    return this._addParam({ ty: ArgumentType.int96, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint96Array() {
    return this._addParam({ ty: ArgumentType.uint96, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt104Array() {
    return this._addParam({ ty: ArgumentType.int104, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint104Array() {
    return this._addParam({ ty: ArgumentType.uint104, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt112Array() {
    return this._addParam({ ty: ArgumentType.int112, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint112Array() {
    return this._addParam({ ty: ArgumentType.uint112, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt120Array() {
    return this._addParam({ ty: ArgumentType.int120, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint120Array() {
    return this._addParam({ ty: ArgumentType.uint120, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt128Array() {
    return this._addParam({ ty: ArgumentType.int128, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint128Array() {
    return this._addParam({ ty: ArgumentType.uint128, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt136Array() {
    return this._addParam({ ty: ArgumentType.int136, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint136Array() {
    return this._addParam({ ty: ArgumentType.uint136, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt144Array() {
    return this._addParam({ ty: ArgumentType.int144, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint144Array() {
    return this._addParam({ ty: ArgumentType.uint144, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt152Array() {
    return this._addParam({ ty: ArgumentType.int152, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint152Array() {
    return this._addParam({ ty: ArgumentType.uint152, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt160Array() {
    return this._addParam({ ty: ArgumentType.int160, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint160Array() {
    return this._addParam({ ty: ArgumentType.uint160, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt168Array() {
    return this._addParam({ ty: ArgumentType.int168, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint168Array() {
    return this._addParam({ ty: ArgumentType.uint168, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt176Array() {
    return this._addParam({ ty: ArgumentType.int176, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint176Array() {
    return this._addParam({ ty: ArgumentType.uint176, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt184Array() {
    return this._addParam({ ty: ArgumentType.int184, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint184Array() {
    return this._addParam({ ty: ArgumentType.uint184, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt192Array() {
    return this._addParam({ ty: ArgumentType.int192, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint192Array() {
    return this._addParam({ ty: ArgumentType.uint192, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt200Array() {
    return this._addParam({ ty: ArgumentType.int200, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint200Array() {
    return this._addParam({ ty: ArgumentType.uint200, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt208Array() {
    return this._addParam({ ty: ArgumentType.int208, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint208Array() {
    return this._addParam({ ty: ArgumentType.uint208, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt216Array() {
    return this._addParam({ ty: ArgumentType.int216, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint216Array() {
    return this._addParam({ ty: ArgumentType.uint216, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt224Array() {
    return this._addParam({ ty: ArgumentType.int224, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint224Array() {
    return this._addParam({ ty: ArgumentType.uint224, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt232Array() {
    return this._addParam({ ty: ArgumentType.int232, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint232Array() {
    return this._addParam({ ty: ArgumentType.uint232, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt240Array() {
    return this._addParam({ ty: ArgumentType.int240, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint240Array() {
    return this._addParam({ ty: ArgumentType.uint240, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt248Array() {
    return this._addParam({ ty: ArgumentType.int248, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint248Array() {
    return this._addParam({ ty: ArgumentType.uint248, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addInt256Array() {
    return this._addParam({ ty: ArgumentType.int256, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addUint256Array() {
    return this._addParam({ ty: ArgumentType.uint256, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addBool() {
    return this._addParam({ ty: ArgumentType.bool, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addAddress() {
    return this._addParam({ ty: ArgumentType.address, array: false });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addAddressArray() {
    return this._addParam({ ty: ArgumentType.address, array: true });
  }
  /**
   * @returns {ContractFunctionSelector}
   */
  addFunction() {
    return this._addParam({ ty: ArgumentType.func, array: false });
  }
  /**
   * @param {SolidityType} ty
   * @returns {ContractFunctionSelector}
   */
  _addParam(ty) {
    if (this._paramTypes.length > 0) {
      this._params += ",";
    }
    this._params += solidityTypeToString(ty);
    this._paramTypes.push(ty);
    return this;
  }
  /**
   * @param {string} [name]
   * @returns {Uint8Array}
   */
  _build(name) {
    if (name != null) {
      this._name = name;
    } else if (this._name == null) {
      throw new Error("`name` required for ContractFunctionSelector");
    }
    const func = encode(encode5(this.toString()));
    return decode(keccak2563(`0x${func}`)).slice(0, 4);
  }
  /**
   * @returns {string}
   */
  toString() {
    return `${this._name != null ? this._name.toString() : ""}(${this._params})`;
  }
};
function solidityTypeToString(ty) {
  let s = "";
  switch (ty.ty) {
    case ArgumentType.uint8:
      s = "uint8";
      break;
    case ArgumentType.int8:
      s = "int8";
      break;
    case ArgumentType.uint16:
      s = "uint16";
      break;
    case ArgumentType.int16:
      s = "int16";
      break;
    case ArgumentType.uint24:
      s = "uint24";
      break;
    case ArgumentType.int24:
      s = "int24";
      break;
    case ArgumentType.uint32:
      s = "uint32";
      break;
    case ArgumentType.int32:
      s = "int32";
      break;
    case ArgumentType.uint40:
      s = "uint40";
      break;
    case ArgumentType.int40:
      s = "int40";
      break;
    case ArgumentType.uint48:
      s = "uint48";
      break;
    case ArgumentType.int48:
      s = "int48";
      break;
    case ArgumentType.uint56:
      s = "uint56";
      break;
    case ArgumentType.int56:
      s = "int56";
      break;
    case ArgumentType.uint64:
      s = "uint64";
      break;
    case ArgumentType.int64:
      s = "int64";
      break;
    case ArgumentType.uint72:
      s = "uint72";
      break;
    case ArgumentType.int72:
      s = "int72";
      break;
    case ArgumentType.uint80:
      s = "uint80";
      break;
    case ArgumentType.int80:
      s = "int80";
      break;
    case ArgumentType.uint88:
      s = "uint88";
      break;
    case ArgumentType.int88:
      s = "int88";
      break;
    case ArgumentType.uint96:
      s = "uint96";
      break;
    case ArgumentType.int96:
      s = "int96";
      break;
    case ArgumentType.uint104:
      s = "uint104";
      break;
    case ArgumentType.int104:
      s = "int104";
      break;
    case ArgumentType.uint112:
      s = "uint112";
      break;
    case ArgumentType.int112:
      s = "int112";
      break;
    case ArgumentType.uint120:
      s = "uint120";
      break;
    case ArgumentType.int120:
      s = "int120";
      break;
    case ArgumentType.uint128:
      s = "uint128";
      break;
    case ArgumentType.int128:
      s = "int128";
      break;
    case ArgumentType.uint136:
      s = "uint136";
      break;
    case ArgumentType.int136:
      s = "int136";
      break;
    case ArgumentType.uint144:
      s = "uint144";
      break;
    case ArgumentType.int144:
      s = "int144";
      break;
    case ArgumentType.uint152:
      s = "uint152";
      break;
    case ArgumentType.int152:
      s = "int152";
      break;
    case ArgumentType.uint160:
      s = "uint160";
      break;
    case ArgumentType.int160:
      s = "int160";
      break;
    case ArgumentType.uint168:
      s = "uint168";
      break;
    case ArgumentType.int168:
      s = "int168";
      break;
    case ArgumentType.uint176:
      s = "uint176";
      break;
    case ArgumentType.int176:
      s = "int176";
      break;
    case ArgumentType.uint184:
      s = "uint184";
      break;
    case ArgumentType.int184:
      s = "int184";
      break;
    case ArgumentType.uint192:
      s = "uint192";
      break;
    case ArgumentType.int192:
      s = "int192";
      break;
    case ArgumentType.uint200:
      s = "uint200";
      break;
    case ArgumentType.int200:
      s = "int200";
      break;
    case ArgumentType.uint208:
      s = "uint208";
      break;
    case ArgumentType.int208:
      s = "int208";
      break;
    case ArgumentType.uint216:
      s = "uint216";
      break;
    case ArgumentType.int216:
      s = "int216";
      break;
    case ArgumentType.uint224:
      s = "uint224";
      break;
    case ArgumentType.int224:
      s = "int224";
      break;
    case ArgumentType.uint232:
      s = "uint232";
      break;
    case ArgumentType.int232:
      s = "int232";
      break;
    case ArgumentType.uint240:
      s = "uint240";
      break;
    case ArgumentType.int240:
      s = "int240";
      break;
    case ArgumentType.uint248:
      s = "uint248";
      break;
    case ArgumentType.int248:
      s = "int248";
      break;
    case ArgumentType.uint256:
      s = "uint256";
      break;
    case ArgumentType.int256:
      s = "int256";
      break;
    case ArgumentType.string:
      s = "string";
      break;
    case ArgumentType.bool:
      s = "bool";
      break;
    case ArgumentType.bytes:
      s = "bytes";
      break;
    case ArgumentType.bytes32:
      s = "bytes32";
      break;
    case ArgumentType.address:
      s = "address";
      break;
    case ArgumentType.func:
      s = "function";
      break;
    default:
      s = "";
      break;
  }
  if (ty.array) {
    s += "[]";
  }
  return s;
}

// node_modules/@hashgraph/sdk/src/contract/ContractFunctionParameters.js
var ContractFunctionParameters = class {
  constructor() {
    this._selector = new ContractFunctionSelector();
    this._arguments = [];
  }
  /**
   * @param {string} value
   * @returns {ContractFunctionParameters}
   */
  addString(value) {
    this._selector.addString();
    return this._addParam(value, true);
  }
  /**
   * @param {string[]} value
   * @returns {ContractFunctionParameters}
   */
  addStringArray(value) {
    this._selector.addStringArray();
    return this._addParam(value, true);
  }
  /**
   * @param {Uint8Array} value
   * @returns {ContractFunctionParameters}
   */
  addBytes(value) {
    this._selector.addBytes();
    return this._addParam(value, true);
  }
  /**
   * @param {Uint8Array} value
   * @returns {ContractFunctionParameters}
   */
  addBytes32(value) {
    if (value.length !== 32) {
      throw new Error(
        `addBytes32 expected array to be of length 32, but received ${value.length}`
      );
    }
    this._selector.addBytes32();
    return this._addParam(value, false);
  }
  /**
   * @param {Uint8Array[]} value
   * @returns {ContractFunctionParameters}
   */
  addBytesArray(value) {
    this._selector.addBytesArray();
    return this._addParam(value, true);
  }
  /**
   * @param {Uint8Array[]} value
   * @returns {ContractFunctionParameters}
   */
  addBytes32Array(value) {
    for (const [_, entry] of value.entries()) {
      if (entry.length !== 32) {
        throw new Error(
          `addBytes32 expected array to be of length 32, but received ${entry.length}`
        );
      }
    }
    this._selector.addBytes32Array();
    return this._addParam(value, true);
  }
  /**
   * @param {boolean} value
   * @returns {ContractFunctionParameters}
   */
  addBool(value) {
    this._selector.addBool();
    return this._addParam(value, false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt8(value) {
    this._selector.addInt8();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint8(value) {
    this._selector.addUint8();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt16(value) {
    this._selector.addInt16();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint16(value) {
    this._selector.addUint16();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt24(value) {
    this._selector.addInt24();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint24(value) {
    this._selector.addUint24();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt32(value) {
    this._selector.addInt32();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint32(value) {
    this._selector.addUint32();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt40(value) {
    this._selector.addInt40();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint40(value) {
    this._selector.addUint40();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt48(value) {
    this._selector.addInt48();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint48(value) {
    this._selector.addUint48();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt56(value) {
    this._selector.addInt56();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint56(value) {
    this._selector.addUint56();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt64(value) {
    this._selector.addInt64();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint64(value) {
    this._selector.addUint64();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt72(value) {
    this._selector.addInt72();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint72(value) {
    this._selector.addUint72();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt80(value) {
    this._selector.addInt80();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint80(value) {
    this._selector.addUint80();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt88(value) {
    this._selector.addInt88();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint88(value) {
    this._selector.addUint88();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt96(value) {
    this._selector.addInt96();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint96(value) {
    this._selector.addUint96();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt104(value) {
    this._selector.addInt104();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint104(value) {
    this._selector.addUint104();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt112(value) {
    this._selector.addInt112();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint112(value) {
    this._selector.addUint112();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt120(value) {
    this._selector.addInt120();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint120(value) {
    this._selector.addUint120();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt128(value) {
    this._selector.addInt128();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint128(value) {
    this._selector.addUint128();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt136(value) {
    this._selector.addInt136();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint136(value) {
    this._selector.addUint136();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt144(value) {
    this._selector.addInt144();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint144(value) {
    this._selector.addUint144();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt152(value) {
    this._selector.addInt152();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint152(value) {
    this._selector.addUint152();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt160(value) {
    this._selector.addInt160();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint160(value) {
    this._selector.addUint160();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt168(value) {
    this._selector.addInt168();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint168(value) {
    this._selector.addUint168();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt176(value) {
    this._selector.addInt176();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint176(value) {
    this._selector.addUint176();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt184(value) {
    this._selector.addInt184();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint184(value) {
    this._selector.addUint184();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt192(value) {
    this._selector.addInt192();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint192(value) {
    this._selector.addUint192();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt200(value) {
    this._selector.addInt200();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint200(value) {
    this._selector.addUint200();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt208(value) {
    this._selector.addInt208();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint208(value) {
    this._selector.addUint208();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt216(value) {
    this._selector.addInt216();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint216(value) {
    this._selector.addUint216();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt224(value) {
    this._selector.addInt224();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint224(value) {
    this._selector.addUint224();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt232(value) {
    this._selector.addInt232();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint232(value) {
    this._selector.addUint232();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt240(value) {
    this._selector.addInt240();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint240(value) {
    this._selector.addUint240();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt248(value) {
    this._selector.addInt248();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint248(value) {
    this._selector.addUint248();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addInt256(value) {
    this._selector.addInt256();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number | BigNumber | Long} value
   * @returns {ContractFunctionParameters}
   */
  addUint256(value) {
    this._selector.addUint256();
    return this._addParam(convertToBigNumber(value), false);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt8Array(value) {
    this._selector.addInt8Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint8Array(value) {
    this._selector.addUint8Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt16Array(value) {
    this._selector.addInt16Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint16Array(value) {
    this._selector.addUint16Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt24Array(value) {
    this._selector.addInt24Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint24Array(value) {
    this._selector.addUint24Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt32Array(value) {
    this._selector.addInt32Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint32Array(value) {
    this._selector.addUint32Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt40Array(value) {
    this._selector.addInt40Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint40Array(value) {
    this._selector.addUint40Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt48Array(value) {
    this._selector.addInt48Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint48Array(value) {
    this._selector.addUint48Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt56Array(value) {
    this._selector.addInt56Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint56Array(value) {
    this._selector.addUint56Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt64Array(value) {
    this._selector.addInt64Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint64Array(value) {
    this._selector.addUint64Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt72Array(value) {
    this._selector.addInt72Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint72Array(value) {
    this._selector.addUint72Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt80Array(value) {
    this._selector.addInt80Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint80Array(value) {
    this._selector.addUint80Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt88Array(value) {
    this._selector.addInt88Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint88Array(value) {
    this._selector.addUint88Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt96Array(value) {
    this._selector.addInt96Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint96Array(value) {
    this._selector.addUint96Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt104Array(value) {
    this._selector.addInt104Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint104Array(value) {
    this._selector.addUint104Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt112Array(value) {
    this._selector.addInt112Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint112Array(value) {
    this._selector.addUint112Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt120Array(value) {
    this._selector.addInt120Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint120Array(value) {
    this._selector.addUint120Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt128Array(value) {
    this._selector.addInt128Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint128Array(value) {
    this._selector.addUint128Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt136Array(value) {
    this._selector.addInt136Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint136Array(value) {
    this._selector.addUint136Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt144Array(value) {
    this._selector.addInt144Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint144Array(value) {
    this._selector.addUint144Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt152Array(value) {
    this._selector.addInt152Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint152Array(value) {
    this._selector.addUint152Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt160Array(value) {
    this._selector.addInt160Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint160Array(value) {
    this._selector.addUint160Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt168Array(value) {
    this._selector.addInt168Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint168Array(value) {
    this._selector.addUint168Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt176Array(value) {
    this._selector.addInt176Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint176Array(value) {
    this._selector.addUint176Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt184Array(value) {
    this._selector.addInt184Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint184Array(value) {
    this._selector.addUint184Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt192Array(value) {
    this._selector.addInt192Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint192Array(value) {
    this._selector.addUint192Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt200Array(value) {
    this._selector.addInt200Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint200Array(value) {
    this._selector.addUint200Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt208Array(value) {
    this._selector.addInt208Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint208Array(value) {
    this._selector.addUint208Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt216Array(value) {
    this._selector.addInt216Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint216Array(value) {
    this._selector.addUint216Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt224Array(value) {
    this._selector.addInt224Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint224Array(value) {
    this._selector.addUint224Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt232Array(value) {
    this._selector.addInt232Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint232Array(value) {
    this._selector.addUint232Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt240Array(value) {
    this._selector.addInt240Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint240Array(value) {
    this._selector.addUint240Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt248Array(value) {
    this._selector.addInt248Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint248Array(value) {
    this._selector.addUint248Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addInt256Array(value) {
    this._selector.addInt256Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {number[] | BigNumber[] | Long[]} value
   * @returns {ContractFunctionParameters}
   */
  addUint256Array(value) {
    this._selector.addUint256Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  /**
   * @param {string | EvmAddress} value
   * @returns {ContractFunctionParameters}
   */
  addAddress(value) {
    let address;
    if (typeof value === "string") {
      if (value.length !== 40 && value.length !== 42) {
        throw new Error(
          "`address` type requires parameter to be 40 or 42 characters"
        );
      }
      address = value;
    } else {
      address = value.toString();
    }
    const par = address.length === 40 ? decode(address) : decode(address.substring(2));
    this._selector.addAddress();
    return this._addParam(par, false);
  }
  /**
   * @param {string[] | EvmAddress[]} value
   * @returns {ContractFunctionParameters}
   */
  addAddressArray(value) {
    const par = [];
    for (const [_, entry] of value.entries()) {
      let address;
      if (typeof entry === "string") {
        if (entry.length !== 40 && entry.length !== 42) {
          throw new Error(
            "`address` type requires parameter to be 40 or 42 characters"
          );
        }
        address = entry;
      } else {
        address = entry.toString();
      }
      const buf = address.length === 40 ? decode(address) : decode(address.substring(2));
      par.push(buf);
    }
    this._selector.addAddressArray();
    return this._addParam(par, true);
  }
  /**
   * @param {string} address
   * @param {ContractFunctionSelector} selector
   * @returns {ContractFunctionParameters}
   */
  addFunction(address, selector) {
    const addressParam = decode(address);
    const functionSelector = selector._build();
    if (addressParam.length !== 20) {
      throw new Error(
        "`function` type requires parameter `address` to be exactly 20 bytes"
      );
    }
    this._selector.addFunction();
    const proto42 = new Uint8Array(24);
    proto42.set(addressParam, 0);
    proto42.set(functionSelector, 20);
    return this._addParam(proto42, false);
  }
  /**
   * @internal
   * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
   * @param {boolean} dynamic
   * @returns {ContractFunctionParameters}
   */
  _addParam(param, dynamic) {
    const index = this._selector._paramTypes.length - 1;
    const value = argumentToBytes(param, this._selector._paramTypes[index]);
    this._arguments.push({ dynamic, value });
    return this;
  }
  /**
   * @internal
   * @param {string=} name
   * @returns {Uint8Array}
   */
  _build(name) {
    const includeId = name != null;
    const nameOffset = includeId ? 4 : 0;
    const length = this._arguments.length === 0 ? nameOffset : this._arguments.length * 32 + this._arguments.map((arg) => arg.dynamic ? arg.value.length : 0).reduce((sum, value) => sum + value) + nameOffset;
    const func = new Uint8Array(length);
    if (includeId) {
      func.set(this._selector._build(name), 0);
    }
    let offset = 32 * this._arguments.length;
    for (const [i, { dynamic, value }] of this._arguments.entries()) {
      if (dynamic) {
        const view = safeView(func, nameOffset + i * 32 + 28);
        view.setUint32(0, offset);
        func.set(value, view.getUint32(0) + nameOffset);
        offset += value.length;
      } else {
        func.set(value, nameOffset + i * 32);
      }
    }
    return func;
  }
};
function argumentToBytes(param, ty) {
  let value = new Uint8Array(32);
  let valueView = safeView(value);
  let par;
  if (ty.array) {
    if (!Array.isArray(param)) {
      throw new TypeError(
        "SolidityType indicates type is array, but parameter is not an array"
      );
    }
    const values = [];
    for (const [_, p] of param.entries()) {
      const arg = argumentToBytes(p, { ty: ty.ty, array: false });
      values.push(arg);
    }
    const totalLengthOfValues = values.map((a) => a.length).reduce((total, current) => total + current, 0);
    switch (ty.ty) {
      case ArgumentType.uint8:
      case ArgumentType.int8:
      case ArgumentType.uint16:
      case ArgumentType.int16:
      case ArgumentType.uint24:
      case ArgumentType.int24:
      case ArgumentType.uint32:
      case ArgumentType.int32:
      case ArgumentType.uint40:
      case ArgumentType.int40:
      case ArgumentType.uint48:
      case ArgumentType.int48:
      case ArgumentType.uint56:
      case ArgumentType.int56:
      case ArgumentType.uint64:
      case ArgumentType.int64:
      case ArgumentType.uint72:
      case ArgumentType.int72:
      case ArgumentType.uint80:
      case ArgumentType.int80:
      case ArgumentType.uint88:
      case ArgumentType.int88:
      case ArgumentType.uint96:
      case ArgumentType.int96:
      case ArgumentType.uint104:
      case ArgumentType.int104:
      case ArgumentType.uint112:
      case ArgumentType.int112:
      case ArgumentType.uint120:
      case ArgumentType.int120:
      case ArgumentType.uint128:
      case ArgumentType.int128:
      case ArgumentType.uint136:
      case ArgumentType.int136:
      case ArgumentType.uint144:
      case ArgumentType.int144:
      case ArgumentType.uint152:
      case ArgumentType.int152:
      case ArgumentType.uint160:
      case ArgumentType.int160:
      case ArgumentType.uint168:
      case ArgumentType.int168:
      case ArgumentType.uint176:
      case ArgumentType.int176:
      case ArgumentType.uint184:
      case ArgumentType.int184:
      case ArgumentType.uint192:
      case ArgumentType.int192:
      case ArgumentType.uint200:
      case ArgumentType.int200:
      case ArgumentType.uint208:
      case ArgumentType.int208:
      case ArgumentType.uint216:
      case ArgumentType.int216:
      case ArgumentType.uint224:
      case ArgumentType.int224:
      case ArgumentType.uint232:
      case ArgumentType.int232:
      case ArgumentType.uint240:
      case ArgumentType.int240:
      case ArgumentType.uint248:
      case ArgumentType.int248:
      case ArgumentType.uint256:
      case ArgumentType.int256:
      case ArgumentType.bool:
      case ArgumentType.bytes32:
      case ArgumentType.address:
      case ArgumentType.func:
        value = new Uint8Array(totalLengthOfValues + 32);
        break;
      case ArgumentType.bytes:
      case ArgumentType.string:
        value = new Uint8Array(
          values.length * 32 + totalLengthOfValues + 32
        );
        break;
      default:
        throw new TypeError(
          `Expected param type to be ArgumentType, but received ${ty.ty}`
        );
    }
    valueView = safeView(value, 28);
    valueView.setUint32(0, values.length);
    let offset = 32 * values.length;
    for (const [i, e] of values.entries()) {
      switch (ty.ty) {
        case ArgumentType.uint8:
        case ArgumentType.int8:
        case ArgumentType.uint16:
        case ArgumentType.int16:
        case ArgumentType.uint24:
        case ArgumentType.int24:
        case ArgumentType.uint32:
        case ArgumentType.int32:
        case ArgumentType.uint40:
        case ArgumentType.int40:
        case ArgumentType.uint48:
        case ArgumentType.int48:
        case ArgumentType.uint56:
        case ArgumentType.int56:
        case ArgumentType.uint64:
        case ArgumentType.int64:
        case ArgumentType.uint72:
        case ArgumentType.int72:
        case ArgumentType.uint80:
        case ArgumentType.int80:
        case ArgumentType.uint88:
        case ArgumentType.int88:
        case ArgumentType.uint96:
        case ArgumentType.int96:
        case ArgumentType.uint104:
        case ArgumentType.int104:
        case ArgumentType.uint112:
        case ArgumentType.int112:
        case ArgumentType.uint120:
        case ArgumentType.int120:
        case ArgumentType.uint128:
        case ArgumentType.int128:
        case ArgumentType.uint136:
        case ArgumentType.int136:
        case ArgumentType.uint144:
        case ArgumentType.int144:
        case ArgumentType.uint152:
        case ArgumentType.int152:
        case ArgumentType.uint160:
        case ArgumentType.int160:
        case ArgumentType.uint168:
        case ArgumentType.int168:
        case ArgumentType.uint176:
        case ArgumentType.int176:
        case ArgumentType.uint184:
        case ArgumentType.int184:
        case ArgumentType.uint192:
        case ArgumentType.int192:
        case ArgumentType.uint200:
        case ArgumentType.int200:
        case ArgumentType.uint208:
        case ArgumentType.int208:
        case ArgumentType.uint216:
        case ArgumentType.int216:
        case ArgumentType.uint224:
        case ArgumentType.int224:
        case ArgumentType.uint232:
        case ArgumentType.int232:
        case ArgumentType.uint240:
        case ArgumentType.int240:
        case ArgumentType.uint248:
        case ArgumentType.int248:
        case ArgumentType.uint256:
        case ArgumentType.int256:
        case ArgumentType.bool:
        case ArgumentType.bytes32:
        case ArgumentType.address:
        case ArgumentType.func:
          value.set(e, i * 32 + 32);
          break;
        case ArgumentType.bytes:
        case ArgumentType.string:
          const view = safeView(value, (i + 1) * 32 + 28);
          view.setUint32(0, offset);
          value.set(e, view.getUint32(0) + 32);
          offset += e.length;
          break;
        default:
          throw new TypeError(
            `Expected param type to be ArgumentType, but received ${ty.ty}`
          );
      }
    }
    return value;
  }
  switch (ty.ty) {
    case ArgumentType.uint8:
    case ArgumentType.int8:
    case ArgumentType.uint16:
    case ArgumentType.int16:
    case ArgumentType.uint24:
    case ArgumentType.int24:
    case ArgumentType.uint32:
    case ArgumentType.int32:
    case ArgumentType.uint40:
    case ArgumentType.int40:
    case ArgumentType.uint48:
    case ArgumentType.int48:
    case ArgumentType.uint56:
    case ArgumentType.int56:
    case ArgumentType.uint64:
    case ArgumentType.int64:
    case ArgumentType.uint72:
    case ArgumentType.int72:
    case ArgumentType.uint80:
    case ArgumentType.int80:
    case ArgumentType.uint88:
    case ArgumentType.int88:
    case ArgumentType.uint96:
    case ArgumentType.int96:
    case ArgumentType.uint104:
    case ArgumentType.int104:
    case ArgumentType.uint112:
    case ArgumentType.int112:
    case ArgumentType.uint120:
    case ArgumentType.int120:
    case ArgumentType.uint128:
    case ArgumentType.int128:
    case ArgumentType.uint136:
    case ArgumentType.int136:
    case ArgumentType.uint144:
    case ArgumentType.int144:
    case ArgumentType.uint152:
    case ArgumentType.int152:
    case ArgumentType.uint160:
    case ArgumentType.int160:
    case ArgumentType.uint168:
    case ArgumentType.int168:
    case ArgumentType.uint176:
    case ArgumentType.int176:
    case ArgumentType.uint184:
    case ArgumentType.int184:
    case ArgumentType.uint192:
    case ArgumentType.int192:
    case ArgumentType.uint200:
    case ArgumentType.int200:
    case ArgumentType.uint208:
    case ArgumentType.int208:
    case ArgumentType.uint216:
    case ArgumentType.int216:
    case ArgumentType.uint224:
    case ArgumentType.int224:
    case ArgumentType.uint232:
    case ArgumentType.int232:
    case ArgumentType.uint240:
    case ArgumentType.int240:
    case ArgumentType.uint248:
    case ArgumentType.int248:
    case ArgumentType.int256:
    case ArgumentType.uint256: {
      let paramToHex = param.toString(16);
      if (param > 0 || param == 0) {
        paramToHex = "0x" + paramToHex;
      } else {
        paramToHex = paramToHex.slice(0, 1) + "0x" + paramToHex.slice(1);
      }
      const encodedData = defaultAbiCoder.encode(
        [solidityTypeToString(ty)],
        [paramToHex]
      );
      const dataToArrayify = arrayify(encodedData);
      return dataToArrayify;
    }
    case ArgumentType.address:
      value.set(
        /** @type {Uint8Array} */
        param,
        32 - 20
      );
      return value;
    case ArgumentType.bool:
      value[31] = /** @type {boolean} */
      param ? 1 : 0;
      return value;
    case ArgumentType.func:
      value.set(
        /** @type {Uint8Array} */
        param,
        32 - 24
      );
      return value;
    case ArgumentType.bytes32:
      value.set(
        /** @type {Uint8Array} */
        param,
        0
      );
      return value;
    case ArgumentType.bytes:
    case ArgumentType.string: {
      par = param instanceof Uint8Array ? param : encode5(
        /** @type {string} */
        param
      );
      if (Math.floor(par.length / 32) >= 0) {
        if (Math.floor(par.length % 32) !== 0) {
          value = new Uint8Array(
            (Math.floor(par.length / 32) + 1) * 32 + 32
          );
        } else {
          value = new Uint8Array(
            Math.floor(par.length / 32) * 32 + 32
          );
        }
      } else {
        value = new Uint8Array(64);
      }
      value.set(par, 32);
      valueView = safeView(value, 28);
      valueView.setUint32(0, par.length);
      return value;
    }
    default:
      throw new Error(`Unsupported argument type: ${ty.toString()}`);
  }
}

// node_modules/@hashgraph/sdk/src/contract/ContractCallQuery.js
var import_long30 = __toESM(require_long(), 1);
var HashgraphProto22 = __toESM(require_lib(), 1);
var ContractCallQuery = class _ContractCallQuery extends Query {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   * @param {number | Long} [props.gas]
   * @param {FunctionParameters | Uint8Array} [props.functionParameters]
   * @param {number | Long} [props.maxResultSize]
   * @param {AccountId | string} [props.senderAccountId]
   */
  constructor(props = {}) {
    super();
    this._contractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    this._gas = null;
    if (props.gas != null) {
      this.setGas(props.gas);
    }
    this._functionParameters = null;
    if (props.functionParameters != null) {
      if (props.functionParameters instanceof Uint8Array) {
        this.setFunctionParameters(props.functionParameters);
      } else {
        this.setFunction(
          props.functionParameters.name,
          props.functionParameters.parameters
        );
      }
    }
    this._maxResultSize = null;
    if (props.maxResultSize != null) {
      this.setMaxResultSize(props.maxResultSize);
    }
    this._senderAccountId = null;
    if (props.senderAccountId != null) {
      this.setSenderAccountId(props.senderAccountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {ContractCallQuery}
   */
  static _fromProtobuf(query) {
    const call = (
      /** @type {HashgraphProto.proto.IContractCallLocalQuery} */
      query.contractCallLocal
    );
    return new _ContractCallQuery({
      contractId: call.contractID != null ? ContractId._fromProtobuf(call.contractID) : void 0,
      gas: call.gas != null ? call.gas : void 0,
      functionParameters: call.functionParameters != null ? call.functionParameters : void 0,
      maxResultSize: call.maxResultSize != null ? call.maxResultSize : void 0
    });
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the call is being requested.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractCallQuery}
   */
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */
  get gas() {
    return this._gas;
  }
  /**
   * @param {number | Long} gas
   * @returns {ContractCallQuery}
   */
  setGas(gas) {
    this._gas = gas instanceof import_long30.default ? gas : import_long30.default.fromValue(gas);
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get senderAccountId() {
    return this._senderAccountId;
  }
  /**
   * @param {AccountId | string} senderAccountId
   * @returns {ContractCallQuery}
   */
  setSenderAccountId(senderAccountId) {
    this._senderAccountId = typeof senderAccountId === "string" ? AccountId.fromString(senderAccountId) : senderAccountId;
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get functionParameters() {
    return this._functionParameters;
  }
  /**
   * @param {Uint8Array} params
   * @returns {ContractCallQuery}
   */
  setFunctionParameters(params) {
    this._functionParameters = params;
    return this;
  }
  /**
   * @param {string} name
   * @param {?ContractFunctionParameters} [params]
   * @returns {ContractCallQuery}
   */
  setFunction(name, params) {
    this._functionParameters = (params != null ? params : new ContractFunctionParameters())._build(name);
    return this;
  }
  /**
   * @param {number | Long} size
   * @returns {ContractCallQuery}
   */
  setMaxResultSize(size) {
    this._maxResultSize = size instanceof import_long30.default ? size : import_long30.default.fromValue(size);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Error}
   */
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    const status = Status._fromCode(
      nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto22.proto.ResponseCodeEnum.OK
    );
    const call = (
      /**
       *@type {HashgraphProto.proto.IContractCallLocalResponse}
       */
      response.contractCallLocal
    );
    if (!call.functionResult) {
      return new PrecheckStatusError({
        status,
        transactionId: this._getTransactionId(),
        contractFunctionResult: null
      });
    }
    const contractFunctionResult = this._mapResponseSync(response);
    return new PrecheckStatusError({
      status,
      transactionId: this._getTransactionId(),
      contractFunctionResult
    });
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.contractCallLocalMethod(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const contractCallLocal = (
      /** @type {HashgraphProto.proto.IContractCallLocalResponse} */
      response.contractCallLocal
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      contractCallLocal.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Promise<ContractFunctionResult>}
   */
  _mapResponse(response) {
    const call = (
      /**
       *@type {HashgraphProto.proto.IContractCallLocalResponse}
       */
      response.contractCallLocal
    );
    return Promise.resolve(
      ContractFunctionResult._fromProtobuf(
        /**
         * @type {HashgraphProto.proto.IContractFunctionResult}
         */
        call.functionResult,
        false
      )
    );
  }
  /**
   * @private
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {ContractFunctionResult}
   */
  _mapResponseSync(response) {
    const call = (
      /**
       *@type {HashgraphProto.proto.IContractCallLocalResponse}
       */
      response.contractCallLocal
    );
    return ContractFunctionResult._fromProtobuf(
      /**
       * @type {HashgraphProto.proto.IContractFunctionResult}
       */
      call.functionResult,
      false
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      contractCallLocal: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
        gas: this._gas,
        maxResultSize: this._maxResultSize,
        functionParameters: this._functionParameters,
        senderId: this._senderAccountId != null ? this._senderAccountId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `ContractCallQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("contractCallLocal", ContractCallQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileCreateTransaction.js
var import_long31 = __toESM(require_long(), 1);
var FileCreateTransaction = class _FileCreateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {Key[] | KeyList} [props.keys]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Uint8Array | string} [props.contents]
   * @param {string} [props.fileMemo]
   */
  constructor(props = {}) {
    super();
    this._keys = null;
    this._expirationTime = new Timestamp(0, 0).plusNanos(
      import_long31.default.fromNumber(Date.now()).mul(1e6).add(DEFAULT_AUTO_RENEW_PERIOD.mul(1e9))
    );
    this._contents = null;
    this._fileMemo = null;
    this._defaultMaxTransactionFee = new Hbar(5);
    if (props.keys != null) {
      this.setKeys(props.keys);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.contents != null) {
      this.setContents(props.contents);
    }
    if (props.fileMemo && props.fileMemo != null) {
      this.setFileMemo(props.fileMemo);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {FileCreateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = (
      /** @type {HashgraphProto.proto.IFileCreateTransactionBody} */
      body.fileCreate
    );
    return Transaction._fromProtobufTransactions(
      new _FileCreateTransaction({
        keys: create.keys != null ? create.keys.keys != null ? create.keys.keys.map(
          (key) => Key2._fromProtobufKey(key)
        ) : void 0 : void 0,
        expirationTime: create.expirationTime != null ? Timestamp._fromProtobuf(create.expirationTime) : void 0,
        contents: create.contents != null ? create.contents : void 0,
        fileMemo: create.memo != null ? create.memo : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?Key[]}
   */
  get keys() {
    return this._keys;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {Key[] | KeyList} keys
   * @returns {this}
   */
  setKeys(keys) {
    this._requireNotFrozen();
    if (keys instanceof KeyList2 && keys.threshold != null) {
      throw new Error("Cannot set threshold key as file key");
    }
    this._keys = keys instanceof KeyList2 ? keys.toArray() : keys;
    return this;
  }
  /**
   * @returns {Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * Set the instant at which this file will expire, after which its contents will no longer be
   * available.
   *
   * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction
   * was invoked.
   *
   * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
   *
   * @param {Timestamp | Date} expirationTime
   * @returns {this}
   */
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get contents() {
    return this._contents;
  }
  /**
   * Set the given byte array as the file's contents.
   *
   * This may be omitted to create an empty file.
   *
   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
   * network; if you exceed this you may receive a HederaPreCheckStatusException
   * with Status#TransactionOversize.
   *
   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
   * transaction with the first chunk and then use FileAppendTransaction with
   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
   *
   * @param {Uint8Array | string} contents
   * @returns {this}
   */
  setContents(contents) {
    this._requireNotFrozen();
    this._contents = contents instanceof Uint8Array ? contents : encode5(contents);
    return this;
  }
  /**
   * @returns {?string}
   */
  get fileMemo() {
    return this._fileMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */
  setFileMemo(memo) {
    this._requireNotFrozen();
    this._fileMemo = memo;
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.file.createFile(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "fileCreate";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IFileCreateTransactionBody}
   */
  _makeTransactionData() {
    return {
      keys: this._keys != null ? {
        keys: this._keys.map((key) => key._toProtobufKey())
      } : null,
      expirationTime: this._expirationTime._toProtobuf(),
      contents: this._contents,
      memo: this._fileMemo
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `FileCreateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set("fileCreate", FileCreateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileAppendTransaction.js
var FileAppendTransaction = class _FileAppendTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   * @param {Uint8Array | string} [props.contents]
   * @param {number} [props.maxChunks]
   * @param {number} [props.chunkSize]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._contents = null;
    this._maxChunks = 20;
    this._chunkSize = 4096;
    this._defaultMaxTransactionFee = new Hbar(5);
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.contents != null) {
      this.setContents(props.contents);
    }
    if (props.maxChunks != null) {
      this.setMaxChunks(props.maxChunks);
    }
    if (props.chunkSize != null) {
      this.setChunkSize(props.chunkSize);
    }
    this._transactionIds = new List();
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {FileAppendTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const append = (
      /** @type {HashgraphProto.proto.IFileAppendTransactionBody} */
      body.fileAppend
    );
    let contents;
    const incrementValue = nodeIds.length > 0 ? nodeIds.length : 1;
    for (let i = 0; i < bodies.length; i += incrementValue) {
      const fileAppend = (
        /** @type {HashgraphProto.proto.IFileAppendTransactionBody} */
        bodies[i].fileAppend
      );
      if (fileAppend.contents == null) {
        break;
      }
      if (contents == null) {
        contents = new Uint8Array(
          /** @type {Uint8Array} */
          fileAppend.contents
        );
        continue;
      }
      const concat3 = new Uint8Array(
        contents.length + /** @type {Uint8Array} */
        fileAppend.contents.length
      );
      concat3.set(contents, 0);
      concat3.set(
        /** @type {Uint8Array} */
        fileAppend.contents,
        contents.length
      );
      contents = concat3;
    }
    return Transaction._fromProtobufTransactions(
      new _FileAppendTransaction({
        fileId: append.fileID != null ? FileId._fromProtobuf(
          /** @type {HashgraphProto.proto.IFileID} */
          append.fileID
        ) : void 0,
        contents
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {FileId | string} fileId
   * @returns {this}
   */
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get contents() {
    return this._contents;
  }
  /**
   * Set the given byte array as the file's contents.
   *
   * This may be omitted to append an empty file.
   *
   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
   * network; if you exceed this you may receive a HederaPreCheckStatusException
   * with Status#TransactionOversize.
   *
   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
   * transaction with the first chunk and then use FileAppendTransaction with
   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
   *
   * @param {Uint8Array | string} contents
   * @returns {this}
   */
  setContents(contents) {
    this._requireNotFrozen();
    this._contents = contents instanceof Uint8Array ? contents : encode5(contents);
    return this;
  }
  /**
   * @returns {?number}
   */
  get maxChunks() {
    return this._maxChunks;
  }
  /**
   * @param {number} maxChunks
   * @returns {this}
   */
  setMaxChunks(maxChunks) {
    this._requireNotFrozen();
    this._maxChunks = maxChunks;
    return this;
  }
  /**
   * @returns {?number}
   */
  get chunkSize() {
    return this._chunkSize;
  }
  /**
   * @param {number} chunkSize
   * @returns {this}
   */
  setChunkSize(chunkSize) {
    this._chunkSize = chunkSize;
    return this;
  }
  /**
   * Freeze this transaction from further modification to prepare for
   * signing or serialization.
   *
   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
   * nodes to prepare this transaction for.
   *
   * @param {?import("../client/Client.js").default<Channel, *>} client
   * @returns {this}
   */
  freezeWith(client) {
    super.freezeWith(client);
    if (this._contents == null) {
      return this;
    }
    const chunks = Math.floor(
      (this._contents.length + (this._chunkSize - 1)) / this._chunkSize
    );
    if (chunks > this._maxChunks) {
      throw new Error(
        `Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`
      );
    }
    let nextTransactionId = this._getTransactionId();
    this._transactionIds.locked = false;
    this._transactions.clear();
    this._transactionIds.clear();
    this._signedTransactions.clear();
    for (let chunk = 0; chunk < chunks; chunk++) {
      this._transactionIds.push(nextTransactionId);
      this._transactionIds.advance();
      for (const nodeAccountId of this._nodeAccountIds.list) {
        this._signedTransactions.push(
          this._makeSignedTransaction(nodeAccountId)
        );
      }
      nextTransactionId = new TransactionId(
        /** @type {AccountId} */
        nextTransactionId.accountId,
        new Timestamp(
          /** @type {Timestamp} */
          nextTransactionId.validStart.seconds,
          /** @type {Timestamp} */
          nextTransactionId.validStart.nanos.add(1)
        )
      );
    }
    this._transactionIds.advance();
    this._transactionIds.setLocked();
    return this;
  }
  /**
   * @returns {ScheduleCreateTransaction}
   */
  schedule() {
    this._requireNotFrozen();
    if (this._contents != null && this._contents.length > this._chunkSize) {
      throw new Error(
        `cannot schedule \`FileAppendTransaction\` with message over ${this._chunkSize} bytes`
      );
    }
    return super.schedule();
  }
  /**
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @param {number=} requestTimeout
   * @returns {Promise<TransactionResponse>}
   */
  async execute(client, requestTimeout) {
    return (await this.executeAll(client, requestTimeout))[0];
  }
  /**
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @param {number=} requestTimeout
   * @returns {Promise<TransactionResponse[]>}
   */
  async executeAll(client, requestTimeout) {
    if (!super._isFrozen()) {
      this.freezeWith(client);
    }
    const transactionId = this._getTransactionId();
    const operatorAccountId = client.operatorAccountId;
    if (operatorAccountId != null && operatorAccountId.equals(
      /** @type {AccountId} */
      transactionId.accountId
    )) {
      await super.signWithOperator(client);
    }
    const responses = [];
    let remainingTimeout = requestTimeout;
    for (let i = 0; i < this._transactionIds.length; i++) {
      const startTimestamp = Date.now();
      const response = await super.execute(client, remainingTimeout);
      if (remainingTimeout != null) {
        remainingTimeout = Date.now() - startTimestamp;
      }
      await response.getReceipt(client);
      responses.push(response);
    }
    return responses;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.file.appendContent(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "fileAppend";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IFileAppendTransactionBody}
   */
  _makeTransactionData() {
    const length = this._contents != null ? this._contents.length : 0;
    const startIndex = this._transactionIds.index * this._chunkSize;
    const endIndex = Math.min(startIndex + this._chunkSize, length);
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contents: this._contents != null ? this._contents.slice(startIndex, endIndex) : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `FileAppendTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set("fileAppend", FileAppendTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileDeleteTransaction.js
var FileDeleteTransaction = class _FileDeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {FileDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const fileDelete = (
      /** @type {HashgraphProto.proto.IFileDeleteTransactionBody} */
      body.fileDelete
    );
    return Transaction._fromProtobufTransactions(
      new _FileDeleteTransaction({
        fileId: fileDelete.fileID != null ? FileId._fromProtobuf(fileDelete.fileID) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * Set the file ID which is being deleted in this transaction.
   *
   * @param {FileId | string} fileId
   * @returns {FileDeleteTransaction}
   */
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.file.deleteFile(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "fileDelete";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IFileDeleteTransactionBody}
   */
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `FileDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set("fileDelete", FileDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractCreateTransaction.js
var import_long32 = __toESM(require_long(), 1);
var ContractCreateTransaction = class _ContractCreateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.bytecodeFileId]
   * @param {Uint8Array} [props.bytecode]
   * @param {Key} [props.adminKey]
   * @param {number | Long} [props.gas]
   * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
   * @param {AccountId | string} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {Uint8Array} [props.constructorParameters]
   * @param {string} [props.contractMemo]
   * @param {number} [props.maxAutomaticTokenAssociations]
   * @param {AccountId | string} [props.stakedAccountId]
   * @param {Long | number} [props.stakedNodeId]
   * @param {boolean} [props.declineStakingReward]
   * @param {AccountId} [props.autoRenewAccountId]
   */
  constructor(props = {}) {
    super();
    this._bytecodeFileId = null;
    this._bytecode = null;
    this._adminKey = null;
    this._gas = null;
    this._initialBalance = null;
    this._proxyAccountId = null;
    this._autoRenewPeriod = new Duration2(DEFAULT_AUTO_RENEW_PERIOD);
    this._constructorParameters = null;
    this._contractMemo = null;
    this._maxAutomaticTokenAssociations = null;
    this._defaultMaxTransactionFee = new Hbar(20);
    this._stakedAccountId = null;
    this._stakedNodeId = null;
    this._declineStakingReward = false;
    this._autoRenewAccountId = null;
    if (props.bytecodeFileId != null) {
      this.setBytecodeFileId(props.bytecodeFileId);
    }
    if (props.bytecode != null) {
      this.setBytecode(props.bytecode);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.gas != null) {
      this.setGas(props.gas);
    }
    if (props.initialBalance != null) {
      this.setInitialBalance(props.initialBalance);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.constructorParameters != null) {
      this.setConstructorParameters(props.constructorParameters);
    }
    if (props.contractMemo != null) {
      this.setContractMemo(props.contractMemo);
    }
    if (props.maxAutomaticTokenAssociations != null) {
      this.setMaxAutomaticTokenAssociations(
        props.maxAutomaticTokenAssociations
      );
    }
    if (props.stakedAccountId != null) {
      this.setStakedAccountId(props.stakedAccountId);
    }
    if (props.stakedNodeId != null) {
      this.setStakedNodeId(props.stakedNodeId);
    }
    if (props.declineStakingReward != null) {
      this.setDeclineStakingReward(props.declineStakingReward);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {ContractCreateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = (
      /** @type {HashgraphProto.proto.IContractCreateTransactionBody} */
      body.contractCreateInstance
    );
    return Transaction._fromProtobufTransactions(
      new _ContractCreateTransaction({
        bytecodeFileId: create.fileID != null ? FileId._fromProtobuf(
          /** @type {HashgraphProto.proto.IFileID} */
          create.fileID
        ) : void 0,
        adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
        gas: create.gas != null ? create.gas : void 0,
        initialBalance: create.initialBalance != null ? Hbar.fromTinybars(create.initialBalance) : void 0,
        proxyAccountId: create.proxyAccountID != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          create.proxyAccountID
        ) : void 0,
        autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : void 0 : void 0,
        constructorParameters: create.constructorParameters != null ? create.constructorParameters : void 0,
        contractMemo: create.memo != null ? create.memo : void 0,
        maxAutomaticTokenAssociations: create.maxAutomaticTokenAssociations != null ? create.maxAutomaticTokenAssociations : void 0,
        stakedAccountId: create.stakedAccountId != null ? AccountId._fromProtobuf(create.stakedAccountId) : void 0,
        stakedNodeId: create.stakedNodeId != null ? create.stakedNodeId : void 0,
        declineStakingReward: create.declineReward == true,
        autoRenewAccountId: create.autoRenewAccountId != null ? AccountId._fromProtobuf(create.autoRenewAccountId) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?FileId}
   */
  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  /**
   * @param {FileId | string} bytecodeFileId
   * @returns {this}
   */
  setBytecodeFileId(bytecodeFileId) {
    this._requireNotFrozen();
    this._bytecodeFileId = typeof bytecodeFileId === "string" ? FileId.fromString(bytecodeFileId) : bytecodeFileId.clone();
    this._bytecode = null;
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get bytecode() {
    return this._bytecode;
  }
  /**
   * @param {Uint8Array} bytecode
   * @returns {this}
   */
  setBytecode(bytecode) {
    this._requireNotFrozen();
    this._bytecode = bytecode;
    this._bytecodeFileId = null;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {this}
   */
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get gas() {
    return this._gas;
  }
  /**
   * @param {number | Long} gas
   * @returns {this}
   */
  setGas(gas) {
    this._requireNotFrozen();
    this._gas = gas instanceof import_long32.default ? gas : import_long32.default.fromValue(gas);
    return this;
  }
  /**
   * @returns {?Hbar}
   */
  get initialBalance() {
    return this._initialBalance;
  }
  /**
   * Set the initial amount to transfer into this contract.
   *
   * @param {number | string | Long | BigNumber | Hbar} initialBalance
   * @returns {this}
   */
  setInitialBalance(initialBalance) {
    this._requireNotFrozen();
    this._initialBalance = initialBalance instanceof Hbar ? initialBalance : new Hbar(initialBalance);
    return this;
  }
  /**
   * @deprecated
   * @returns {?AccountId}
   */
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * @deprecated
   * @param {AccountId | string} proxyAccountId
   * @returns {this}
   */
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = proxyAccountId instanceof AccountId ? proxyAccountId : AccountId.fromString(proxyAccountId);
    return this;
  }
  /**
   * @returns {Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * An account to charge for auto-renewal of this contract. If not set, or set to an
   * account with zero hbar balance, the contract's own hbar balance will be used to
   * cover auto-renewal fees.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get constructorParameters() {
    return this._constructorParameters;
  }
  /**
   * @param {Uint8Array | ContractFunctionParameters} constructorParameters
   * @returns {this}
   */
  setConstructorParameters(constructorParameters) {
    this._requireNotFrozen();
    this._constructorParameters = constructorParameters instanceof ContractFunctionParameters ? constructorParameters._build() : constructorParameters;
    return this;
  }
  /**
   * @returns {?string}
   */
  get contractMemo() {
    return this._contractMemo;
  }
  /**
   * @param {string} contractMemo
   * @returns {this}
   */
  setContractMemo(contractMemo) {
    this._requireNotFrozen();
    this._contractMemo = contractMemo;
    return this;
  }
  /**
   * @returns {?number}
   */
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  /**
   * @param {number} maxAutomaticTokenAssociations
   * @returns {this}
   */
  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
    this._maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  /**
   * @param {AccountId | string} stakedAccountId
   * @returns {this}
   */
  setStakedAccountId(stakedAccountId) {
    this._requireNotFrozen();
    this._stakedAccountId = typeof stakedAccountId === "string" ? AccountId.fromString(stakedAccountId) : stakedAccountId;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  /**
   * @param {Long | number} stakedNodeId
   * @returns {this}
   */
  setStakedNodeId(stakedNodeId) {
    this._requireNotFrozen();
    this._stakedNodeId = import_long32.default.fromValue(stakedNodeId);
    return this;
  }
  /**
   * @returns {boolean}
   */
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  /**
   * @param {boolean} declineStakingReward
   * @returns {this}
   */
  setDeclineStakingReward(declineStakingReward) {
    this._requireNotFrozen();
    this._declineStakingReward = declineStakingReward;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {string | AccountId} autoRenewAccountId
   * @returns {this}
   */
  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();
    this._autoRenewAccountId = typeof autoRenewAccountId === "string" ? AccountId.fromString(autoRenewAccountId) : autoRenewAccountId;
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._bytecodeFileId != null) {
      this._bytecodeFileId.validateChecksum(client);
    }
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.createContract(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "contractCreateInstance";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IContractCreateTransactionBody}
   */
  _makeTransactionData() {
    return {
      fileID: this._bytecodeFileId != null ? this._bytecodeFileId._toProtobuf() : null,
      initcode: this._bytecode,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      gas: this._gas,
      initialBalance: this._initialBalance != null ? this._initialBalance.toTinybars() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      constructorParameters: this._constructorParameters,
      memo: this._contractMemo,
      maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations,
      stakedAccountId: this.stakedAccountId != null ? this.stakedAccountId._toProtobuf() : null,
      stakedNodeId: this.stakedNodeId,
      declineReward: this.declineStakingRewards,
      autoRenewAccountId: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `ContractCreateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "contractCreateInstance",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  ContractCreateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/contract/ContractCreateFlow.js
var ContractCreateFlow = class {
  constructor() {
    this._bytecode = null;
    this._contractCreate = new ContractCreateTransaction();
    this._signerPublicKeys = /* @__PURE__ */ new Set();
    this._publicKeys = [];
    this._transactionSigners = [];
    this._maxChunks = null;
  }
  /**
   * @returns {number | null}
   */
  get maxChunks() {
    return this._maxChunks;
  }
  /**
   * @param {number} maxChunks
   * @returns {this}
   */
  setMaxChunks(maxChunks) {
    this._maxChunks = maxChunks;
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get bytecode() {
    return this._bytecode;
  }
  /**
   * @param {string | Uint8Array} bytecode
   * @returns {this}
   */
  setBytecode(bytecode) {
    this._bytecode = bytecode instanceof Uint8Array ? bytecode : encode5(bytecode);
    return this;
  }
  /**
   * @returns {?Key}
   */
  get adminKey() {
    return this._contractCreate.adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {this}
   */
  setAdminKey(adminKey) {
    this._contractCreate.setAdminKey(adminKey);
    return this;
  }
  /**
   * @returns {?Long}
   */
  get gas() {
    return this._contractCreate.gas;
  }
  /**
   * @param {number | Long} gas
   * @returns {this}
   */
  setGas(gas) {
    this._contractCreate.setGas(gas);
    return this;
  }
  /**
   * @returns {?Hbar}
   */
  get initialBalance() {
    return this._contractCreate.initialBalance;
  }
  /**
   * Set the initial amount to transfer into this contract.
   *
   * @param {number | string | Long | BigNumber | Hbar} initialBalance
   * @returns {this}
   */
  setInitialBalance(initialBalance) {
    this._contractCreate.setInitialBalance(initialBalance);
    return this;
  }
  /**
   * @deprecated
   * @returns {?AccountId}
   */
  get proxyAccountId() {
    return this._contractCreate.proxyAccountId;
  }
  /**
   * @deprecated
   * @param {AccountId | string} proxyAccountId
   * @returns {this}
   */
  setProxyAccountId(proxyAccountId) {
    this._contractCreate.setProxyAccountId(proxyAccountId);
    return this;
  }
  /**
   * @returns {Duration}
   */
  get autoRenewPeriod() {
    return this._contractCreate.autoRenewPeriod;
  }
  /**
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._contractCreate.setAutoRenewPeriod(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get constructorParameters() {
    return this._contractCreate.constructorParameters;
  }
  /**
   * @param {Uint8Array | ContractFunctionParameters} constructorParameters
   * @returns {this}
   */
  setConstructorParameters(constructorParameters) {
    this._contractCreate.setConstructorParameters(constructorParameters);
    return this;
  }
  /**
   * @returns {?string}
   */
  get contractMemo() {
    return this._contractCreate.contractMemo;
  }
  /**
   * @param {string} contractMemo
   * @returns {this}
   */
  setContractMemo(contractMemo) {
    this._contractCreate.setContractMemo(contractMemo);
    return this;
  }
  /**
   * @returns {?number}
   */
  get maxAutomaticTokenAssociation() {
    return this._contractCreate.maxAutomaticTokenAssociations;
  }
  /**
   * @param {number} maxAutomaticTokenAssociation
   * @returns {this}
   */
  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociation) {
    this._contractCreate.setMaxAutomaticTokenAssociations(
      maxAutomaticTokenAssociation
    );
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get stakedAccountId() {
    return this._contractCreate.stakedAccountId;
  }
  /**
   * @param {AccountId | string} stakedAccountId
   * @returns {this}
   */
  setStakedAccountId(stakedAccountId) {
    this._contractCreate.setStakedAccountId(stakedAccountId);
    return this;
  }
  /**
   * @returns {?Long}
   */
  get stakedNodeId() {
    return this._contractCreate.stakedNodeId;
  }
  /**
   * @param {Long | number} stakedNodeId
   * @returns {this}
   */
  setStakedNodeId(stakedNodeId) {
    this._contractCreate.setStakedNodeId(stakedNodeId);
    return this;
  }
  /**
   * @returns {boolean}
   */
  get declineStakingRewards() {
    return this._contractCreate.declineStakingRewards;
  }
  /**
   * @param {boolean} declineStakingReward
   * @returns {this}
   */
  setDeclineStakingReward(declineStakingReward) {
    this._contractCreate.setDeclineStakingReward(declineStakingReward);
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get autoRenewAccountId() {
    return this._contractCreate.autoRenewAccountId;
  }
  /**
   * @param {string | AccountId} autoRenewAccountId
   * @returns {this}
   */
  setAutoRenewAccountId(autoRenewAccountId) {
    this._contractCreate.setAutoRenewAccountId(autoRenewAccountId);
    return this;
  }
  /**
   * Sign the transaction with the private key
   * **NOTE**: This is a thin wrapper around `.signWith()`
   *
   * @param {PrivateKey} privateKey
   * @returns {this}
   */
  sign(privateKey) {
    return this.signWith(
      privateKey.publicKey,
      (message) => Promise.resolve(privateKey.sign(message))
    );
  }
  /**
   * Sign the transaction with the public key and signer function
   *
   * If sign on demand is enabled no signing will be done immediately, instead
   * the private key signing function and public key are saved to be used when
   * a user calls an exit condition method (not sure what a better name for this is)
   * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.
   *
   * @param {PublicKey} publicKey
   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   * @returns {this}
   */
  signWith(publicKey, transactionSigner) {
    const publicKeyData = publicKey.toBytesRaw();
    const publicKeyHex = encode(publicKeyData);
    if (this._signerPublicKeys.has(publicKeyHex)) {
      return this;
    }
    this._publicKeys.push(publicKey);
    this._transactionSigners.push(transactionSigner);
    return this;
  }
  /**
   * @template {Channel} ChannelT
   * @template {MirrorChannel} MirrorChannelT
   * @param {import("../client/Client.js").default<ChannelT, MirrorChannelT>} client
   * @param {number=} requestTimeout
   * @returns {Promise<TransactionResponse>}
   */
  async execute(client, requestTimeout) {
    if (this._bytecode == null) {
      throw new Error("cannot create contract with no bytecode");
    }
    const key = client.operatorPublicKey;
    const fileCreateTransaction = new FileCreateTransaction().setKeys(key != null ? [key] : []).setContents(
      this._bytecode.subarray(
        0,
        Math.min(this._bytecode.length, 2048)
      )
    ).freezeWith(client);
    await addSignersToTransaction(
      fileCreateTransaction,
      this._publicKeys,
      this._transactionSigners
    );
    let response = await fileCreateTransaction.execute(
      client,
      requestTimeout
    );
    const receipt = await response.getReceipt(client);
    const fileId = (
      /** @type {FileId} */
      receipt.fileId
    );
    if (this._bytecode.length > 2048) {
      const fileAppendTransaction = new FileAppendTransaction().setFileId(fileId).setContents(this._bytecode.subarray(2048)).freezeWith(client);
      await addSignersToTransaction(
        fileAppendTransaction,
        this._publicKeys,
        this._transactionSigners
      );
      await fileAppendTransaction.execute(client, requestTimeout);
    }
    this._contractCreate.setBytecodeFileId(fileId).freezeWith(client);
    await addSignersToTransaction(
      this._contractCreate,
      this._publicKeys,
      this._transactionSigners
    );
    response = await this._contractCreate.execute(client, requestTimeout);
    await response.getReceipt(client);
    if (key != null) {
      const fileDeleteTransaction = new FileDeleteTransaction().setFileId(fileId).freezeWith(client);
      await addSignersToTransaction(
        fileDeleteTransaction,
        this._publicKeys,
        this._transactionSigners
      );
      await (await fileDeleteTransaction.execute(client, requestTimeout)).getReceipt(client);
    }
    return response;
  }
  /**
   * @param {Signer} signer
   * @returns {Promise<TransactionResponse>}
   */
  async executeWithSigner(signer) {
    if (this._bytecode == null) {
      throw new Error("cannot create contract with no bytecode");
    }
    if (signer.getAccountKey == null) {
      throw new Error(
        "`Signer.getAccountKey()` is not implemented, but is required for `ContractCreateFlow`"
      );
    }
    const key = await signer.getAccountKey();
    let formattedPublicKey;
    if (key instanceof PublicKey2) {
      formattedPublicKey = key;
    } else {
      const propertyValues = Object.values(
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
        key._key._key._keyData
      );
      const keyArray = new Uint8Array(propertyValues);
      formattedPublicKey = PublicKey2.fromBytes(keyArray);
    }
    const fileCreateTransaction = await new FileCreateTransaction().setKeys(formattedPublicKey != null ? [formattedPublicKey] : []).setContents(
      this._bytecode.subarray(
        0,
        Math.min(this._bytecode.length, 2048)
      )
    ).freezeWithSigner(signer);
    await fileCreateTransaction.signWithSigner(signer);
    await addSignersToTransaction(
      fileCreateTransaction,
      this._publicKeys,
      this._transactionSigners
    );
    let response = await fileCreateTransaction.executeWithSigner(signer);
    const receipt = await response.getReceiptWithSigner(signer);
    const fileId = (
      /** @type {FileId} */
      receipt.fileId
    );
    if (this._bytecode.length > 2048) {
      let fileAppendTransaction = new FileAppendTransaction().setFileId(fileId).setContents(this._bytecode.subarray(2048));
      if (this._maxChunks != null) {
        fileAppendTransaction.setMaxChunks(this._maxChunks);
      }
      fileAppendTransaction = await fileAppendTransaction.freezeWithSigner(signer);
      await fileAppendTransaction.signWithSigner(signer);
      await addSignersToTransaction(
        fileAppendTransaction,
        this._publicKeys,
        this._transactionSigners
      );
      await fileAppendTransaction.executeWithSigner(signer);
    }
    this._contractCreate = await this._contractCreate.setBytecodeFileId(fileId).freezeWithSigner(signer);
    this._contractCreate = await this._contractCreate.signWithSigner(signer);
    await addSignersToTransaction(
      this._contractCreate,
      this._publicKeys,
      this._transactionSigners
    );
    response = await this._contractCreate.executeWithSigner(signer);
    await response.getReceiptWithSigner(signer);
    if (key != null) {
      const fileDeleteTransaction = await new FileDeleteTransaction().setFileId(fileId).freezeWithSigner(signer);
      await fileDeleteTransaction.signWithSigner(signer);
      await addSignersToTransaction(
        fileDeleteTransaction,
        this._publicKeys,
        this._transactionSigners
      );
      await (await fileDeleteTransaction.executeWithSigner(signer)).getReceiptWithSigner(signer);
    }
    return response;
  }
};
async function addSignersToTransaction(transaction, publicKeys, transactionSigners) {
  for (let i = 0; i < publicKeys.length; i++) {
    await transaction.signWith(publicKeys[i], transactionSigners[i]);
  }
}

// node_modules/@hashgraph/sdk/src/contract/ContractDeleteTransaction.js
var ContractDeleteTransaction = class _ContractDeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   * @param {ContractId | string} [props.transferContractId]
   * @param {AccountId | string} [props.transferAccountId]
   */
  constructor(props = {}) {
    super();
    this._contractId = null;
    this._transferAccountId = null;
    this._transferContractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.transferAccountId != null) {
      this.setTransferAccountId(props.transferAccountId);
    }
    if (props.transferContractId != null) {
      this.setTransferContractId(props.transferContractId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {ContractDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const contractDelete = (
      /** @type {HashgraphProto.proto.IContractDeleteTransactionBody} */
      body.contractDeleteInstance
    );
    return Transaction._fromProtobufTransactions(
      new _ContractDeleteTransaction({
        contractId: contractDelete.contractID != null ? ContractId._fromProtobuf(
          /** @type {HashgraphProto.proto.IContractID} */
          contractDelete.contractID
        ) : void 0,
        transferAccountId: contractDelete.transferAccountID != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          contractDelete.transferAccountID
        ) : void 0,
        transferContractId: contractDelete.transferContractID != null ? ContractId._fromProtobuf(
          /** @type {HashgraphProto.proto.IContractID} */
          contractDelete.transferContractID
        ) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * Sets the contract ID which is being deleted in this transaction.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractDeleteTransaction}
   */
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?ContractId}
   */
  get transferContractId() {
    return this._transferContractId;
  }
  /**
   * Sets the contract ID which will receive all remaining hbars.
   *
   * @param {ContractId | string} transferContractId
   * @returns {ContractDeleteTransaction}
   */
  setTransferContractId(transferContractId) {
    this._requireNotFrozen();
    this._transferContractId = transferContractId instanceof ContractId ? transferContractId : ContractId.fromString(transferContractId);
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get transferAccountId() {
    return this._transferAccountId;
  }
  /**
   * Sets the account ID which will receive all remaining hbars.
   *
   * @param {AccountId | string} transferAccountId
   * @returns {ContractDeleteTransaction}
   */
  setTransferAccountId(transferAccountId) {
    this._requireNotFrozen();
    this._transferAccountId = transferAccountId instanceof AccountId ? transferAccountId : AccountId.fromString(transferAccountId);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
    if (this._transferAccountId != null) {
      this._transferAccountId.validateChecksum(client);
    }
    if (this._transferContractId != null) {
      this._transferContractId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.deleteContract(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "contractDeleteInstance";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IContractDeleteTransactionBody}
   */
  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      transferAccountID: this._transferAccountId ? this._transferAccountId._toProtobuf() : null,
      transferContractID: this._transferContractId != null ? this._transferContractId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `ContractDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "contractDeleteInstance",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  ContractDeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/contract/ContractExecuteTransaction.js
var import_long33 = __toESM(require_long(), 1);
var ContractExecuteTransaction = class _ContractExecuteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   * @param {number | Long} [props.gas]
   * @param {number | string | Long | BigNumber | Hbar} [props.amount]
   * @param {Uint8Array} [props.functionParameters]
   * @param {FunctionParameters} [props.function]
   */
  constructor(props = {}) {
    super();
    this._contractId = null;
    this._gas = null;
    this._amount = null;
    this._functionParameters = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.gas != null) {
      this.setGas(props.gas);
    }
    if (props.amount != null) {
      this.setPayableAmount(props.amount);
    }
    if (props.functionParameters != null) {
      this.setFunctionParameters(props.functionParameters);
    } else if (props.function != null) {
      this.setFunction(props.function.name, props.function.parameters);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {ContractExecuteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const call = (
      /** @type {HashgraphProto.proto.IContractCallTransactionBody} */
      body.contractCall
    );
    return Transaction._fromProtobufTransactions(
      new _ContractExecuteTransaction({
        contractId: call.contractID != null ? ContractId._fromProtobuf(
          /** @type {HashgraphProto.proto.IContractID} */
          call.contractID
        ) : void 0,
        gas: call.gas != null ? call.gas : void 0,
        amount: call.amount != null ? Hbar.fromTinybars(call.amount) : void 0,
        functionParameters: call.functionParameters != null ? call.functionParameters : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * Sets the contract ID which is being executed in this transaction.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractExecuteTransaction}
   */
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */
  get gas() {
    return this._gas;
  }
  /**
   * Sets the amount of gas to use for the call.
   *
   * @param {number | Long} gas
   * @returns {ContractExecuteTransaction}
   */
  setGas(gas) {
    this._requireNotFrozen();
    this._gas = gas instanceof import_long33.default ? gas : import_long33.default.fromValue(gas);
    return this;
  }
  /**
   * @returns {?Hbar}
   */
  get payableAmount() {
    return this._amount;
  }
  /**
   * Sets the number of hbars to be sent with this function call.
   *
   * @param {number | string | Long | BigNumber | Hbar} amount
   * @returns {ContractExecuteTransaction}
   */
  setPayableAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof Hbar ? amount : new Hbar(amount);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get functionParameters() {
    return this._functionParameters;
  }
  /**
   * @param {Uint8Array} functionParameters
   * @returns {this}
   */
  setFunctionParameters(functionParameters) {
    this._requireNotFrozen();
    this._functionParameters = functionParameters;
    return this;
  }
  /**
   * @param {string} name
   * @param {ContractFunctionParameters} [functionParameters]
   * @returns {this}
   */
  setFunction(name, functionParameters) {
    this._requireNotFrozen();
    this._functionParameters = functionParameters != null ? functionParameters._build(name) : new ContractFunctionParameters()._build(name);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.contractCallMethod(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "contractCall";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IContractCallTransactionBody}
   */
  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      gas: this._gas,
      amount: this._amount != null ? this._amount.toTinybars() : null,
      functionParameters: this._functionParameters
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `ContractExecuteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "contractCall",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  ContractExecuteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/contract/ContractInfo.js
var import_long34 = __toESM(require_long(), 1);
var HashgraphProto23 = __toESM(require_lib(), 1);
var { proto: proto24 } = HashgraphProto23;
var ContractInfo = class _ContractInfo {
  /**
   * @private
   * @param {object} props
   * @param {ContractId} props.contractId
   * @param {AccountId} props.accountId
   * @param {string} props.contractAccountId
   * @param {?Key} props.adminKey
   * @param {Timestamp} props.expirationTime
   * @param {Duration} props.autoRenewPeriod
   * @param {?AccountId} props.autoRenewAccountId
   * @param {Long} props.storage
   * @param {string} props.contractMemo
   * @param {Hbar} props.balance
   * @param {boolean} props.isDeleted
   * @param {TokenRelationshipMap} props.tokenRelationships
   * @param {LedgerId|null} props.ledgerId
   * @param {?StakingInfo} props.stakingInfo
   */
  constructor(props) {
    this.contractId = props.contractId;
    this.accountId = props.accountId;
    this.contractAccountId = props.contractAccountId;
    this.adminKey = props.adminKey != null ? props.adminKey : null;
    this.expirationTime = props.expirationTime;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.autoRenewAccountId = props.autoRenewAccountId;
    this.storage = props.storage;
    this.contractMemo = props.contractMemo;
    this.balance = props.balance;
    this.isDeleted = props.isDeleted;
    this.tokenRelationships = props.tokenRelationships;
    this.ledgerId = props.ledgerId;
    this.stakingInfo = props.stakingInfo;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ContractGetInfoResponse.IContractInfo} info
   * @returns {ContractInfo}
   */
  static _fromProtobuf(info) {
    const autoRenewPeriod = (
      /** @type {Long | number} */
      /** @type {HashgraphProto.proto.IDuration} */
      info.autoRenewPeriod.seconds
    );
    return new _ContractInfo({
      contractId: ContractId._fromProtobuf(
        /** @type {HashgraphProto.proto.IContractID} */
        info.contractID
      ),
      accountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        info.accountID
      ),
      contractAccountId: info.contractAccountID != null ? info.contractAccountID : "",
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      expirationTime: Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.expirationTime
      ),
      autoRenewPeriod: new Duration2(autoRenewPeriod),
      autoRenewAccountId: info.autoRenewAccountId != null ? AccountId._fromProtobuf(info.autoRenewAccountId) : null,
      storage: info.storage != null ? info.storage instanceof import_long34.default ? info.storage : import_long34.default.fromValue(info.storage) : import_long34.default.ZERO,
      contractMemo: info.memo != null ? info.memo : "",
      balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
      isDeleted: (
        /** @type {boolean} */
        info.deleted
      ),
      tokenRelationships: TokenRelationshipMap._fromProtobuf(
        info.tokenRelationships != null ? info.tokenRelationships : []
      ),
      ledgerId: info.ledgerId != null ? LedgerId.fromBytes(info.ledgerId) : null,
      stakingInfo: info.stakingInfo != null ? StakingInfo._fromProtobuf(info.stakingInfo) : null
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ContractGetInfoResponse.IContractInfo}
   */
  _toProtobuf() {
    return {
      contractID: this.contractId._toProtobuf(),
      accountID: this.accountId._toProtobuf(),
      contractAccountID: this.contractAccountId,
      adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
      expirationTime: this.expirationTime._toProtobuf(),
      autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
      autoRenewAccountId: this.autoRenewAccountId != null ? this.autoRenewAccountId._toProtobuf() : null,
      storage: this.storage,
      memo: this.contractMemo,
      balance: this.balance.toTinybars(),
      deleted: this.isDeleted,
      tokenRelationships: this.tokenRelationships != null ? this.tokenRelationships._toProtobuf() : null,
      ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
      stakingInfo: this.stakingInfo != null ? this.stakingInfo._toProtobuf() : null
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ContractInfo}
   */
  static fromBytes(bytes3) {
    return _ContractInfo._fromProtobuf(
      proto24.ContractGetInfoResponse.ContractInfo.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return proto24.ContractGetInfoResponse.ContractInfo.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/contract/ContractInfoQuery.js
var ContractInfoQuery = class _ContractInfoQuery extends Query {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   */
  constructor(props = {}) {
    super();
    this._contractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {ContractInfoQuery}
   */
  static _fromProtobuf(query) {
    const info = (
      /** @type {HashgraphProto.proto.IContractGetInfoQuery} */
      query.contractGetInfo
    );
    return new _ContractInfoQuery({
      contractId: info.contractID != null ? ContractId._fromProtobuf(info.contractID) : void 0
    });
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the info is being requested.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractInfoQuery}
   */
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.getContractInfo(request);
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    return super.getCost(client);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const contractGetInfo = (
      /** @type {HashgraphProto.proto.IContractGetInfoResponse} */
      response.contractGetInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      contractGetInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<ContractInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const info = (
      /** @type {HashgraphProto.proto.IContractGetInfoResponse} */
      response.contractGetInfo
    );
    return Promise.resolve(
      ContractInfo._fromProtobuf(
        /** @type {HashgraphProto.proto.ContractGetInfoResponse.IContractInfo} */
        info.contractInfo
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      contractGetInfo: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `ContractInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("contractGetInfo", ContractInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractUpdateTransaction.js
var import_long35 = __toESM(require_long(), 1);
var ContractUpdateTransaction = class _ContractUpdateTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {ContractId | string} [props.contractId]
   * @param {FileId | string} [props.bytecodeFileId]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Key} [props.adminKey]
   * @param {AccountId | string} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.contractMemo]
   * @param {number} [props.maxAutomaticTokenAssociations]
   * @param {AccountId | string} [props.stakedAccountId]
   * @param {Long | number} [props.stakedNodeId]
   * @param {boolean} [props.declineStakingReward]
   * @param {AccountId} [props.autoRenewAccountId]
   */
  constructor(props = {}) {
    super();
    this._contractId = null;
    this._expirationTime = null;
    this._adminKey = null;
    this._proxyAccountId = null;
    this._autoRenewPeriod = null;
    this._bytecodeFileId = null;
    this._contractMemo = null;
    this._maxAutomaticTokenAssociations = null;
    this._stakedAccountId = null;
    this._stakedNodeId = null;
    this._declineStakingReward = null;
    this._autoRenewAccountId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.bytecodeFileId != null) {
      this.setBytecodeFileId(props.bytecodeFileId);
    }
    if (props.contractMemo != null) {
      this.setContractMemo(props.contractMemo);
    }
    if (props.maxAutomaticTokenAssociations != null) {
      this.setMaxAutomaticTokenAssociations(
        props.maxAutomaticTokenAssociations
      );
    }
    if (props.stakedAccountId != null) {
      this.setStakedAccountId(props.stakedAccountId);
    }
    if (props.stakedNodeId != null) {
      this.setStakedNodeId(props.stakedNodeId);
    }
    if (props.declineStakingReward != null) {
      this.setDeclineStakingReward(props.declineStakingReward);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {ContractUpdateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = (
      /** @type {HashgraphProto.proto.IContractUpdateTransactionBody} */
      body.contractUpdateInstance
    );
    let autoRenewPeriod = void 0;
    if (update3.autoRenewPeriod != null && update3.autoRenewPeriod.seconds != null) {
      autoRenewPeriod = update3.autoRenewPeriod.seconds;
    }
    let contractMemo = void 0;
    if (update3.memoWrapper != null && update3.memoWrapper.value != null) {
      contractMemo = update3.memoWrapper.value;
    }
    let maxAutomaticTokenAssociations = void 0;
    if (update3.maxAutomaticTokenAssociations != null && update3.maxAutomaticTokenAssociations.value != null) {
      maxAutomaticTokenAssociations = update3.maxAutomaticTokenAssociations.value;
    }
    return Transaction._fromProtobufTransactions(
      new _ContractUpdateTransaction({
        contractId: update3.contractID != null ? ContractId._fromProtobuf(
          /** @type {HashgraphProto.proto.IContractID} */
          update3.contractID
        ) : void 0,
        bytecodeFileId: update3.fileID != null ? FileId._fromProtobuf(
          /** @type {HashgraphProto.proto.IFileID} */
          update3.fileID
        ) : void 0,
        expirationTime: update3.expirationTime != null ? Timestamp._fromProtobuf(update3.expirationTime) : void 0,
        adminKey: update3.adminKey != null ? Key2._fromProtobufKey(update3.adminKey) : void 0,
        proxyAccountId: update3.proxyAccountID != null ? AccountId._fromProtobuf(
          /** @type {HashgraphProto.proto.IAccountID} */
          update3.proxyAccountID
        ) : void 0,
        autoRenewPeriod,
        contractMemo,
        maxAutomaticTokenAssociations,
        stakedAccountId: update3.stakedAccountId != null ? AccountId._fromProtobuf(update3.stakedAccountId) : void 0,
        stakedNodeId: update3.stakedNodeId != null ? update3.stakedNodeId : void 0,
        declineStakingReward: update3.declineReward != null && Boolean(update3.declineReward) == true,
        autoRenewAccountId: update3.autoRenewAccountId != null ? AccountId._fromProtobuf(update3.autoRenewAccountId) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * Sets the contract ID which is being deleted in this transaction.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractUpdateTransaction}
   */
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * Sets the contract ID which is being deleted in this transaction.
   *
   * @param {Timestamp | Date} expirationTime
   * @returns {ContractUpdateTransaction}
   */
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);
    return this;
  }
  /**
   * @returns {?Key}
   */
  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {this}
   */
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  /**
   * @deprecated
   * @returns {?AccountId}
   */
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * @deprecated
   * @param {AccountId | string} proxyAccountId
   * @returns {this}
   */
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = typeof proxyAccountId === "string" ? AccountId.fromString(proxyAccountId) : proxyAccountId.clone();
    return this;
  }
  /**
   * @returns {?Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?FileId}
   */
  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  /**
   * @param {FileId | string} bytecodeFileId
   * @returns {this}
   */
  setBytecodeFileId(bytecodeFileId) {
    console.warn("Deprecated: there is no replacement");
    this._requireNotFrozen();
    this._bytecodeFileId = typeof bytecodeFileId === "string" ? FileId.fromString(bytecodeFileId) : bytecodeFileId.clone();
    return this;
  }
  /**
   * @returns {?string}
   */
  get contractMemo() {
    return this._contractMemo;
  }
  /**
   * @param {string} contractMemo
   * @returns {this}
   */
  setContractMemo(contractMemo) {
    this._requireNotFrozen();
    this._contractMemo = contractMemo;
    return this;
  }
  /**
   * @returns {this}
   */
  clearContractMemo() {
    this._requireNotFrozen();
    this._contractMemo = null;
    return this;
  }
  /**
   * @returns {number | null}
   */
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  /**
   * @param {number} maxAutomaticTokenAssociations
   * @returns {this}
   */
  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
    this._requireNotFrozen();
    this._maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  /**
   * @param {AccountId | string} stakedAccountId
   * @returns {this}
   */
  setStakedAccountId(stakedAccountId) {
    this._requireNotFrozen();
    this._stakedAccountId = typeof stakedAccountId === "string" ? AccountId.fromString(stakedAccountId) : stakedAccountId;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  /**
   * @param {Long | number} stakedNodeId
   * @returns {this}
   */
  setStakedNodeId(stakedNodeId) {
    this._requireNotFrozen();
    this._stakedNodeId = import_long35.default.fromValue(stakedNodeId);
    return this;
  }
  /**
   * @returns {?boolean}
   */
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  /**
   * @param {boolean} declineStakingReward
   * @returns {this}
   */
  setDeclineStakingReward(declineStakingReward) {
    this._requireNotFrozen();
    this._declineStakingReward = declineStakingReward;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
   * account. Otherwise it updates the contract's auto-renew account to the referenced account.
   *
   * @param {string | AccountId} autoRenewAccountId
   * @returns {this}
   */
  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();
    this._autoRenewAccountId = typeof autoRenewAccountId === "string" ? AccountId.fromString(autoRenewAccountId) : autoRenewAccountId;
    return this;
  }
  /**
   * @returns {this}
   */
  clearAutoRenewAccountId() {
    this._autoRenewAccountId = new AccountId(0);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
    if (this._bytecodeFileId != null) {
      this._bytecodeFileId.validateChecksum(client);
    }
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.updateContract(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "contractUpdateInstance";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IContractUpdateTransactionBody}
   */
  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      fileID: this._bytecodeFileId ? this._bytecodeFileId._toProtobuf() : null,
      memoWrapper: this._contractMemo != null ? {
        value: this._contractMemo
      } : null,
      maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations != null ? {
        value: this._maxAutomaticTokenAssociations
      } : null,
      stakedAccountId: this.stakedAccountId != null ? this.stakedAccountId._toProtobuf() : null,
      stakedNodeId: this.stakedNodeId,
      declineReward: this.declineStakingRewards != null ? { value: this.declineStakingRewards } : null,
      autoRenewAccountId: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `ContractUpdateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "contractUpdateInstance",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  ContractUpdateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/CustomFee.js
var CustomFee = class {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.feeCollectorAccountId]
   * @param {boolean} [props.allCollectorsAreExempt]
   */
  constructor(props = {}) {
    this._feeCollectorAccountId = null;
    this._allCollectorsAreExempt = false;
    if (props.feeCollectorAccountId != null) {
      this.setFeeCollectorAccountId(props.feeCollectorAccountId);
    }
    if (props.allCollectorsAreExempt != null) {
      this.setAllCollectorsAreExempt(props.allCollectorsAreExempt);
    }
  }
  /**
   * @returns {?AccountId}
   */
  get feeCollectorAccountId() {
    return this._feeCollectorAccountId;
  }
  /**
   * @param {AccountId | string} feeCollectorAccountId
   * @returns {this}
   */
  setFeeCollectorAccountId(feeCollectorAccountId) {
    this._feeCollectorAccountId = typeof feeCollectorAccountId === "string" ? AccountId.fromString(feeCollectorAccountId) : feeCollectorAccountId;
    return this;
  }
  /**
   * @returns {boolean}
   */
  get allCollectorsAreExempt() {
    return this._allCollectorsAreExempt;
  }
  /**
   * @param {boolean} allCollectorsAreExempt
   * @returns {this}
   */
  setAllCollectorsAreExempt(allCollectorsAreExempt) {
    this._allCollectorsAreExempt = allCollectorsAreExempt;
    return this;
  }
  /**
   * @internal
   * @abstract
   * @param {HashgraphProto.proto.ICustomFee} info
   * @returns {CustomFee}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _fromProtobuf(info) {
    throw new Error("not implemented");
  }
  /**
   * @internal
   * @abstract
   * @returns {HashgraphProto.proto.ICustomFee}
   */
  _toProtobuf() {
    throw new Error("not implemented");
  }
};

// node_modules/@hashgraph/sdk/src/token/CustomFixedFee.js
var import_long36 = __toESM(require_long(), 1);
var CustomFixedFee = class _CustomFixedFee extends CustomFee {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.feeCollectorAccountId]
   * @param {boolean} [props.allCollectorsAreExempt]
   * @param {TokenId | string} [props.denominatingTokenId]
   * @param {Long | number} [props.amount]
   */
  constructor(props = {}) {
    super(props);
    this._denominatingTokenId = null;
    if (props.denominatingTokenId != null) {
      this.setDenominatingTokenId(props.denominatingTokenId);
    }
    this._amount = null;
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
  }
  /**
   * @param {Hbar} amount
   * @returns {CustomFixedFee}
   */
  setHbarAmount(amount) {
    this._amount = amount.toTinybars();
    this._denominatingTokenId = null;
    return this;
  }
  /**
   * @returns {TokenId | Hbar | null}
   */
  get hbarAmount() {
    return this._denominatingTokenId != null ? null : Hbar.fromTinybars(this._amount != null ? this._amount : 0);
  }
  /**
   * @returns {CustomFixedFee}
   */
  setDenominatingTokenToSameToken() {
    this._denominatingTokenId = new TokenId(0, 0, 0);
    return this;
  }
  /**
   * @returns {?TokenId}
   */
  get denominatingTokenId() {
    return this._denominatingTokenId;
  }
  /**
   * @param {TokenId | string} denominatingTokenId
   * @returns {CustomFixedFee}
   */
  setDenominatingTokenId(denominatingTokenId) {
    this._denominatingTokenId = typeof denominatingTokenId === "string" ? TokenId.fromString(denominatingTokenId) : denominatingTokenId;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {CustomFixedFee}
   */
  setAmount(amount) {
    this._amount = typeof amount === "number" ? import_long36.default.fromNumber(amount) : amount;
    return this;
  }
  /**
   * @internal
   * @override
   * @param {HashgraphProto.proto.ICustomFee} info
   * @returns {CustomFee}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _fromProtobuf(info) {
    const fee = (
      /** @type {HashgraphProto.proto.IFixedFee} */
      info.fixedFee
    );
    return new _CustomFixedFee({
      feeCollectorAccountId: info.feeCollectorAccountId != null ? AccountId._fromProtobuf(info.feeCollectorAccountId) : void 0,
      allCollectorsAreExempt: info.allCollectorsAreExempt != null ? info.allCollectorsAreExempt : void 0,
      denominatingTokenId: fee.denominatingTokenId != null ? TokenId._fromProtobuf(fee.denominatingTokenId) : void 0,
      amount: fee.amount != null ? fee.amount : void 0
    });
  }
  /**
   * @internal
   * @abstract
   * @returns {HashgraphProto.proto.ICustomFee}
   */
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      allCollectorsAreExempt: this.allCollectorsAreExempt,
      fixedFee: {
        denominatingTokenId: this._denominatingTokenId != null ? this._denominatingTokenId._toProtobuf() : null,
        amount: this._amount
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/FeeAssessmentMethod.js
var FeeAssessmentMethod = class _FeeAssessmentMethod {
  /**
   * @hideconstructor
   * @internal
   * @param {boolean} value
   */
  constructor(value) {
    this._value = value;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _FeeAssessmentMethod.Inclusive:
        return "INCLUSIVE";
      case _FeeAssessmentMethod.Exclusive:
        return "EXCLUSIVE";
      default:
        return `UNKNOWN (${this._value.toString()})`;
    }
  }
  /**
   * @internal
   * @param {boolean} value
   * @returns {FeeAssessmentMethod}
   */
  static _fromValue(value) {
    switch (value) {
      case false:
        return _FeeAssessmentMethod.Inclusive;
      case true:
        return _FeeAssessmentMethod.Exclusive;
    }
  }
  /**
   * @returns {boolean}
   */
  valueOf() {
    return this._value;
  }
};
FeeAssessmentMethod.Inclusive = new FeeAssessmentMethod(false);
FeeAssessmentMethod.Exclusive = new FeeAssessmentMethod(true);

// node_modules/@hashgraph/sdk/src/token/CustomFractionalFee.js
var import_long37 = __toESM(require_long(), 1);
var CustomFractionalFee = class _CustomFractionalFee extends CustomFee {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.feeCollectorAccountId]
   * @param {boolean} [props.allCollectorsAreExempt]
   * @param {Long | number} [props.numerator]
   * @param {Long | number} [props.denominator]
   * @param {Long | number} [props.min]
   * @param {Long | number} [props.max]
   * @param {FeeAssessmentMethod} [props.assessmentMethod]
   */
  constructor(props = {}) {
    super(props);
    this._numerator = null;
    if (props.numerator != null) {
      this.setNumerator(props.numerator);
    }
    this._denominator = null;
    if (props.denominator != null) {
      this.setDenominator(props.denominator);
    }
    this._min = null;
    if (props.min != null) {
      this.setMin(props.min);
    }
    this._max;
    if (props.max != null) {
      this.setMax(props.max);
    }
    this._assessmentMethod;
    if (props.assessmentMethod != null) {
      this.setAssessmentMethod(props.assessmentMethod);
    }
  }
  /**
   * @returns {?Long}
   */
  get numerator() {
    return this._numerator;
  }
  /**
   * @param {Long | number} numerator
   * @returns {CustomFractionalFee}
   */
  setNumerator(numerator) {
    this._numerator = typeof numerator === "number" ? import_long37.default.fromNumber(numerator) : numerator;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get denominator() {
    return this._denominator;
  }
  /**
   * @param {Long | number} denominator
   * @returns {CustomFractionalFee}
   */
  setDenominator(denominator) {
    this._denominator = typeof denominator === "number" ? import_long37.default.fromNumber(denominator) : denominator;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get min() {
    return this._min;
  }
  /**
   * @param {Long | number} min
   * @returns {CustomFractionalFee}
   */
  setMin(min) {
    this._min = typeof min === "number" ? import_long37.default.fromNumber(min) : min;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get max() {
    return this._max;
  }
  /**
   * @param {Long | number} max
   * @returns {CustomFractionalFee}
   */
  setMax(max) {
    this._max = typeof max === "number" ? import_long37.default.fromNumber(max) : max;
    return this;
  }
  /**
   * @returns {?FeeAssessmentMethod}
   */
  get assessmentMethod() {
    return this._assessmentMethod;
  }
  /**
   * @param {FeeAssessmentMethod} assessmentMethod
   * @returns {CustomFractionalFee}
   */
  setAssessmentMethod(assessmentMethod) {
    this._assessmentMethod = assessmentMethod;
    return this;
  }
  /**
   * @internal
   * @override
   * @param {HashgraphProto.proto.ICustomFee} info
   * @returns {CustomFee}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _fromProtobuf(info) {
    const fee = (
      /** @type {HashgraphProto.proto.IFractionalFee} */
      info.fractionalFee
    );
    const fractional = (
      /** @type {HashgraphProto.proto.IFraction} */
      fee.fractionalAmount
    );
    return new _CustomFractionalFee({
      feeCollectorAccountId: info.feeCollectorAccountId != null ? AccountId._fromProtobuf(info.feeCollectorAccountId) : void 0,
      allCollectorsAreExempt: info.allCollectorsAreExempt != null ? info.allCollectorsAreExempt : void 0,
      numerator: fractional.numerator != null ? fractional.numerator : void 0,
      denominator: fractional.denominator != null ? fractional.denominator : void 0,
      min: fee.minimumAmount != null ? fee.minimumAmount : void 0,
      max: fee.maximumAmount != null ? fee.maximumAmount : void 0,
      assessmentMethod: fee.netOfTransfers != null ? new FeeAssessmentMethod(fee.netOfTransfers) : void 0
    });
  }
  /**
   * @internal
   * @abstract
   * @returns {HashgraphProto.proto.ICustomFee}
   */
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      allCollectorsAreExempt: this.allCollectorsAreExempt,
      fractionalFee: {
        fractionalAmount: {
          numerator: this._numerator,
          denominator: this._denominator
        },
        minimumAmount: this._min,
        maximumAmount: this._max,
        netOfTransfers: this._assessmentMethod != null ? this._assessmentMethod.valueOf() : false
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/CustomRoyaltyFee.js
var import_long38 = __toESM(require_long(), 1);
var CustomRoyalyFee = class _CustomRoyalyFee extends CustomFee {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.feeCollectorAccountId]
   * @param {boolean} [props.allCollectorsAreExempt]
   * @param {Long | number} [props.numerator]
   * @param {Long | number} [props.denominator]
   * @param {CustomFixedFee} [props.fallbackFee]
   */
  constructor(props = {}) {
    super(props);
    this._fallbackFee = null;
    if (props.fallbackFee != null) {
      this.setFallbackFee(props.fallbackFee);
    }
    this._numerator = null;
    if (props.numerator != null) {
      this.setNumerator(props.numerator);
    }
    this._denominator = null;
    if (props.denominator != null) {
      this.setDenominator(props.denominator);
    }
  }
  /**
   * @returns {?CustomFixedFee}
   */
  get fallbackFee() {
    return this._fallbackFee;
  }
  /**
   * @param {CustomFixedFee} fallbackFee
   * @returns {CustomRoyalyFee}
   */
  setFallbackFee(fallbackFee) {
    this._fallbackFee = fallbackFee;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get numerator() {
    return this._numerator;
  }
  /**
   * @param {Long | number} numerator
   * @returns {CustomRoyalyFee}
   */
  setNumerator(numerator) {
    this._numerator = typeof numerator === "number" ? import_long38.default.fromNumber(numerator) : numerator;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get denominator() {
    return this._denominator;
  }
  /**
   * @param {Long | number} denominator
   * @returns {CustomRoyalyFee}
   */
  setDenominator(denominator) {
    this._denominator = typeof denominator === "number" ? import_long38.default.fromNumber(denominator) : denominator;
    return this;
  }
  /**
   * @internal
   * @override
   * @param {HashgraphProto.proto.ICustomFee} info
   * @returns {CustomFee}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _fromProtobuf(info) {
    const fee = (
      /** @type {HashgraphProto.proto.IRoyaltyFee} */
      info.royaltyFee
    );
    const fraction = (
      /** @type {HashgraphProto.proto.IFraction} */
      fee.exchangeValueFraction
    );
    return new _CustomRoyalyFee({
      feeCollectorAccountId: info.feeCollectorAccountId != null ? AccountId._fromProtobuf(info.feeCollectorAccountId) : void 0,
      allCollectorsAreExempt: info.allCollectorsAreExempt != null ? info.allCollectorsAreExempt : void 0,
      fallbackFee: fee.fallbackFee != null ? (
        /** @type {CustomFixedFee} */
        CustomFixedFee._fromProtobuf({
          fixedFee: fee.fallbackFee
        })
      ) : void 0,
      numerator: fraction.numerator != null ? fraction.numerator : void 0,
      denominator: fraction.denominator != null ? fraction.denominator : void 0
    });
  }
  /**
   * @internal
   * @abstract
   * @returns {HashgraphProto.proto.ICustomFee}
   */
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      allCollectorsAreExempt: this.allCollectorsAreExempt,
      royaltyFee: {
        exchangeValueFraction: {
          numerator: this._numerator,
          denominator: this._denominator
        },
        fallbackFee: this._fallbackFee != null ? this._fallbackFee._toProtobuf().fixedFee : null
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/contract/DelegateContractId.js
var DelegateContractId = class _DelegateContractId extends ContractId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   * @param {Uint8Array=} evmAddress
   */
  constructor(props, realm, num, evmAddress) {
    super(props, realm, num, evmAddress);
  }
  /**
   * @param {Long | number} shard
   * @param {Long | number} realm
   * @param {string} evmAddress
   * @returns {ContractId}
   */
  static fromEvmAddress(shard, realm, evmAddress) {
    return new _DelegateContractId(shard, realm, 0, decode(evmAddress));
  }
  /**
   * @param {string} text
   * @returns {DelegateContractId}
   */
  static fromString(text) {
    return new _DelegateContractId(ContractId.fromString(text));
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IContractID} id
   * @returns {DelegateContractId}
   */
  static _fromProtobuf(id2) {
    return new _DelegateContractId(ContractId._fromProtobuf(id2));
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DelegateContractId}
   */
  static fromBytes(bytes3) {
    return new _DelegateContractId(ContractId.fromBytes(bytes3));
  }
  /**
   * @param {string} address
   * @returns {DelegateContractId}
   */
  static fromSolidityAddress(address) {
    return new _DelegateContractId(ContractId.fromSolidityAddress(address));
  }
  /**
   * @returns {DelegateContractId}
   */
  clone() {
    const id2 = new _DelegateContractId(this);
    id2._checksum = this._checksum;
    return id2;
  }
  /**
   * @returns {HashgraphProto.proto.IKey}
   */
  _toProtobufKey() {
    return {
      delegatableContractId: this._toProtobuf()
    };
  }
  /**
   * @param {HashgraphProto.proto.IContractID} key
   * @returns {DelegateContractId}
   */
  static __fromProtobufKey(key) {
    return _DelegateContractId._fromProtobuf(key);
  }
};
Cache_default2.setDelegateContractId((key) => DelegateContractId.__fromProtobufKey(key));

// node_modules/@hashgraph/sdk/src/EthereumTransaction.js
var EthereumTransaction = class _EthereumTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {Uint8Array} [props.ethereumData]
   * @param {FileId} [props.callData]
   * @param {FileId} [props.callDataFileId]
   * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]
   */
  constructor(props = {}) {
    super();
    this._ethereumData = null;
    this._callDataFileId = null;
    this._maxGasAllowance = null;
    if (props.ethereumData != null) {
      this.setEthereumData(props.ethereumData);
    }
    if (props.callData != null) {
      this.setCallDataFileId(props.callData);
    }
    if (props.callDataFileId != null) {
      this.setCallDataFileId(props.callDataFileId);
    }
    if (props.maxGasAllowance != null) {
      this.setMaxGasAllowanceHbar(props.maxGasAllowance);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {EthereumTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const transaction = (
      /** @type {HashgraphProto.proto.IEthereumTransactionBody} */
      body.ethereumTransaction
    );
    return Transaction._fromProtobufTransactions(
      new _EthereumTransaction({
        ethereumData: transaction.ethereumData != null ? transaction.ethereumData : void 0,
        callData: transaction.callData != null ? FileId._fromProtobuf(transaction.callData) : void 0,
        maxGasAllowance: transaction.maxGasAllowance != null ? Hbar.fromTinybars(transaction.maxGasAllowance) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?(Uint8Array | FileId)}
   */
  get ethereumData() {
    return this._ethereumData;
  }
  /**
   * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
   * unless the callData field is set.
   *
   * @param {Uint8Array} ethereumData
   * @returns {this}
   */
  setEthereumData(ethereumData) {
    this._requireNotFrozen();
    this._ethereumData = ethereumData;
    return this;
  }
  /**
   * @deprecated - Use `callDataFileId` instead
   * @returns {?FileId}
   */
  get callData() {
    return this.callDataFileId;
  }
  /**
   * @deprecated - Use `setCallDataFileId()` instead
   *
   * For large transactions (for example contract create) this is the callData
   * of the callData. The data in the callData will be re-written with
   * the callData element as a zero length string with the original contents in
   * the referenced file at time of execution. The callData will need to be
   * "rehydrated" with the callData for signature validation to pass.
   * @param {FileId} callDataFileId
   * @returns {this}
   */
  setCallData(callDataFileId) {
    return this.setCallDataFileId(callDataFileId);
  }
  /**
   * @returns {?FileId}
   */
  get callDataFileId() {
    return this._callDataFileId;
  }
  /**
   * For large transactions (for example contract create) this is the callData
   * of the callData. The data in the callData will be re-written with
   * the callData element as a zero length string with the original contents in
   * the referenced file at time of execution. The callData will need to be
   * "rehydrated" with the callData for signature validation to pass.
   *
   * @param {FileId} callDataFileId
   * @returns {this}
   */
  setCallDataFileId(callDataFileId) {
    this._requireNotFrozen();
    this._callDataFileId = callDataFileId;
    return this;
  }
  /**
   * @returns {?Hbar}
   */
  get maxGasAllowance() {
    return this._maxGasAllowance;
  }
  /**
   * @deprecated -- use setMaxGasAllowanceHbar instead
   * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
   * @returns {this}
   */
  setMaxGasAllowance(maxGasAllowance) {
    return this.setMaxGasAllowanceHbar(maxGasAllowance);
  }
  /**
   * The maximum amount, in tinybars, that the payer of the hedera transaction
   * is willing to pay to complete the transaction.
   *
   * Ordinarily the account with the ECDSA alias corresponding to the public
   * key that is extracted from the ethereum_data signature is responsible for
   * fees that result from the execution of the transaction. If that amount of
   * authorized fees is not sufficient then the payer of the transaction can be
   * charged, up to but not exceeding this amount. If the ethereum_data
   * transaction authorized an amount that was insufficient then the payer will
   * only be charged the amount needed to make up the difference. If the gas
   * price in the transaction was set to zero then the payer will be assessed
   * the entire fee.
   *
   * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
   * @returns {this}
   */
  setMaxGasAllowanceHbar(maxGasAllowance) {
    this._requireNotFrozen();
    this._maxGasAllowance = maxGasAllowance instanceof Hbar ? maxGasAllowance : new Hbar(maxGasAllowance);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._ethereumData != null && this._ethereumData instanceof FileId) {
      this._ethereumData.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.smartContract.callEthereum(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "ethereumTransaction";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IEthereumTransactionBody}
   */
  _makeTransactionData() {
    return {
      ethereumData: this._ethereumData,
      callData: this._callDataFileId != null ? this._callDataFileId._toProtobuf() : null,
      maxGasAllowance: this._maxGasAllowance != null ? this._maxGasAllowance.toTinybars() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("./Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `EthereumTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "ethereumTransaction",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  EthereumTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/EthereumTransactionData.js
var EthereumTransactionData = class {
  /**
   * @protected
   * @param {object} props
   * @param {Uint8Array} props.callData
   */
  constructor(props) {
    this.callData = props.callData;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {EthereumTransactionData}
   */
  static fromBytes(bytes3) {
    if (bytes3.length === 0) {
      throw new Error("empty bytes");
    }
    switch (bytes3[0]) {
      case 1:
        return Cache_default2.ethereumTransactionDataEip2930FromBytes(bytes3);
      case 2:
        return Cache_default2.ethereumTransactionDataEip1559FromBytes(bytes3);
      default:
        return Cache_default2.ethereumTransactionDataLegacyFromBytes(bytes3);
    }
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    throw new Error("not implemented");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * @returns {string}
   */
  toString() {
    throw new Error("not implemented");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * @returns {{[key: string]: any}}
   */
  toJSON() {
    throw new Error("not implemented");
  }
};

// node_modules/@hashgraph/sdk/src/EthereumTransactionDataLegacy.js
var EthereumTransactionDataLegacy = class _EthereumTransactionDataLegacy extends EthereumTransactionData {
  /**
   * @private
   * @param {object} props
   * @param {Uint8Array} props.nonce
   * @param {Uint8Array} props.gasPrice
   * @param {Uint8Array} props.gasLimit
   * @param {Uint8Array} props.to
   * @param {Uint8Array} props.value
   * @param {Uint8Array} props.callData
   * @param {Uint8Array} props.v
   * @param {Uint8Array} props.r
   * @param {Uint8Array} props.s
   */
  constructor(props) {
    super(props);
    this.nonce = props.nonce;
    this.gasPrice = props.gasPrice;
    this.gasLimit = props.gasLimit;
    this.to = props.to;
    this.value = props.value;
    this.v = props.v;
    this.r = props.r;
    this.s = props.s;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {EthereumTransactionData}
   */
  static fromBytes(bytes3) {
    if (bytes3.length === 0) {
      throw new Error("empty bytes");
    }
    const decoded = (
      /** @type {string[]} */
      decode8(bytes3)
    );
    if (decoded.length != 9) {
      throw new Error("invalid ethereum transaction data");
    }
    return new _EthereumTransactionDataLegacy({
      nonce: decode(
        /** @type {string} */
        decoded[0]
      ),
      gasPrice: decode(
        /** @type {string} */
        decoded[1]
      ),
      gasLimit: decode(
        /** @type {string} */
        decoded[2]
      ),
      to: decode(
        /** @type {string} */
        decoded[3]
      ),
      value: decode(
        /** @type {string} */
        decoded[4]
      ),
      callData: decode(
        /** @type {string} */
        decoded[5]
      ),
      v: decode(
        /** @type {string} */
        decoded[6]
      ),
      r: decode(
        /** @type {string} */
        decoded[7]
      ),
      s: decode(
        /** @type {string} */
        decoded[8]
      )
    });
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return decode(
      encode6([
        this.nonce,
        this.gasPrice,
        this.gasLimit,
        this.to,
        this.value,
        this.callData,
        this.v,
        this.r,
        this.s
      ])
    );
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }
  /**
   * @returns {EthereumTransactionDataLegacyJSON}
   */
  toJSON() {
    return {
      nonce: encode(this.nonce),
      gasPrice: encode(this.gasPrice),
      gasLimit: encode(this.gasLimit),
      to: encode(this.to),
      value: encode(this.value),
      callData: encode(this.callData),
      v: encode(this.v),
      r: encode(this.r),
      s: encode(this.s)
    };
  }
};
Cache_default2.setEthereumTransactionDataLegacyFromBytes(
  (bytes3) => EthereumTransactionDataLegacy.fromBytes(bytes3)
);

// node_modules/@hashgraph/sdk/src/EthereumTransactionDataEip1559.js
var EthereumTransactionDataEip1559 = class _EthereumTransactionDataEip1559 extends EthereumTransactionData {
  /**
   * @private
   * @param {object} props
   * @param {Uint8Array} props.chainId
   * @param {Uint8Array} props.nonce
   * @param {Uint8Array} props.maxPriorityGas
   * @param {Uint8Array} props.maxGas
   * @param {Uint8Array} props.gasLimit
   * @param {Uint8Array} props.to
   * @param {Uint8Array} props.value
   * @param {Uint8Array} props.callData
   * @param {Uint8Array[]} props.accessList
   * @param {Uint8Array} props.recId
   * @param {Uint8Array} props.r
   * @param {Uint8Array} props.s
   */
  constructor(props) {
    super(props);
    this.chainId = props.chainId;
    this.nonce = props.nonce;
    this.maxPriorityGas = props.maxPriorityGas;
    this.maxGas = props.maxGas;
    this.gasLimit = props.gasLimit;
    this.to = props.to;
    this.value = props.value;
    this.accessList = props.accessList;
    this.recId = props.recId;
    this.r = props.r;
    this.s = props.s;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {EthereumTransactionData}
   */
  static fromBytes(bytes3) {
    if (bytes3.length === 0) {
      throw new Error("empty bytes");
    }
    const decoded = (
      /** @type {string[]} */
      decode8(bytes3.subarray(1))
    );
    if (!Array.isArray(decoded)) {
      throw new Error("ethereum data is not a list");
    }
    if (decoded.length != 12) {
      throw new Error("invalid ethereum transaction data");
    }
    return new _EthereumTransactionDataEip1559({
      chainId: decode(
        /** @type {string} */
        decoded[0]
      ),
      nonce: decode(
        /** @type {string} */
        decoded[1]
      ),
      maxPriorityGas: decode(
        /** @type {string} */
        decoded[2]
      ),
      maxGas: decode(
        /** @type {string} */
        decoded[3]
      ),
      gasLimit: decode(
        /** @type {string} */
        decoded[4]
      ),
      to: decode(
        /** @type {string} */
        decoded[5]
      ),
      value: decode(
        /** @type {string} */
        decoded[6]
      ),
      callData: decode(
        /** @type {string} */
        decoded[7]
      ),
      // @ts-ignore
      accessList: (
        /** @type {string[]} */
        decoded[8].map(
          (v) => decode(v)
        )
      ),
      recId: decode(
        /** @type {string} */
        decoded[9]
      ),
      r: decode(
        /** @type {string} */
        decoded[10]
      ),
      s: decode(
        /** @type {string} */
        decoded[11]
      )
    });
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    const encoded = encode6([
      this.chainId,
      this.nonce,
      this.maxPriorityGas,
      this.maxGas,
      this.gasLimit,
      this.to,
      this.value,
      this.callData,
      this.accessList,
      this.recId,
      this.r,
      this.s
    ]);
    return decode("02" + encoded.substring(2));
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }
  /**
   * @returns {EthereumTransactionDataEip1559JSON}
   */
  toJSON() {
    return {
      chainId: encode(this.chainId),
      nonce: encode(this.nonce),
      maxPriorityGas: encode(this.maxPriorityGas),
      maxGas: encode(this.maxGas),
      gasLimit: encode(this.gasLimit),
      to: encode(this.to),
      value: encode(this.value),
      callData: encode(this.callData),
      accessList: this.accessList.map((v) => encode(v)),
      recId: encode(this.recId),
      r: encode(this.r),
      s: encode(this.s)
    };
  }
};
Cache_default2.setEthereumTransactionDataEip1559FromBytes(
  (bytes3) => EthereumTransactionDataEip1559.fromBytes(bytes3)
);

// node_modules/@hashgraph/sdk/src/EthereumTransactionDataEip2930.js
var EthereumTransactionDataEip2930 = class _EthereumTransactionDataEip2930 extends EthereumTransactionData {
  /**
   * @private
   * @param {object} props
   * @param {Uint8Array} props.chainId
   * @param {Uint8Array} props.nonce
   * @param {Uint8Array} props.gasPrice
   * @param {Uint8Array} props.gasLimit
   * @param {Uint8Array} props.to
   * @param {Uint8Array} props.value
   * @param {Uint8Array} props.callData
   * @param {Uint8Array[]} props.accessList
   * @param {Uint8Array} props.recId
   * @param {Uint8Array} props.r
   * @param {Uint8Array} props.s
   */
  constructor(props) {
    super(props);
    this.chainId = props.chainId;
    this.nonce = props.nonce;
    this.gasPrice = props.gasPrice;
    this.gasLimit = props.gasLimit;
    this.to = props.to;
    this.value = props.value;
    this.accessList = props.accessList;
    this.recId = props.recId;
    this.r = props.r;
    this.s = props.s;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {EthereumTransactionData}
   */
  static fromBytes(bytes3) {
    if (bytes3.length === 0) {
      throw new Error("empty bytes");
    }
    const decoded = (
      /** @type {string[]} */
      decode8(bytes3.subarray(1))
    );
    if (!Array.isArray(decoded)) {
      throw new Error("ethereum data is not a list");
    }
    if (decoded.length !== 11) {
      throw new Error("invalid ethereum transaction data");
    }
    return new _EthereumTransactionDataEip2930({
      chainId: decode(
        /** @type {string} */
        decoded[0]
      ),
      nonce: decode(
        /** @type {string} */
        decoded[1]
      ),
      gasPrice: decode(
        /** @type {string} */
        decoded[2]
      ),
      gasLimit: decode(
        /** @type {string} */
        decoded[3]
      ),
      to: decode(
        /** @type {string} */
        decoded[4]
      ),
      value: decode(
        /** @type {string} */
        decoded[5]
      ),
      callData: decode(
        /** @type {string} */
        decoded[6]
      ),
      // @ts-ignore
      accessList: (
        /** @type {string[]} */
        decoded[7].map(
          (v) => decode(v)
        )
      ),
      recId: decode(
        /** @type {string} */
        decoded[8]
      ),
      r: decode(
        /** @type {string} */
        decoded[9]
      ),
      s: decode(
        /** @type {string} */
        decoded[10]
      )
    });
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    const encoded = encode6([
      this.chainId,
      this.nonce,
      this.gasPrice,
      this.gasLimit,
      this.to,
      this.value,
      this.callData,
      this.accessList,
      this.recId,
      this.r,
      this.s
    ]);
    return decode("01" + encoded.substring(2));
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }
  /**
   * @returns {EthereumTransactionDataEip2930JSON}
   */
  toJSON() {
    return {
      chainId: encode(this.chainId),
      nonce: encode(this.nonce),
      gasPrice: encode(this.gasPrice),
      gasLimit: encode(this.gasLimit),
      to: encode(this.to),
      value: encode(this.value),
      callData: encode(this.callData),
      accessList: this.accessList.map((v) => encode(v)),
      recId: encode(this.recId),
      r: encode(this.r),
      s: encode(this.s)
    };
  }
};
Cache_default2.setEthereumTransactionDataEip2930FromBytes(
  (bytes3) => EthereumTransactionDataEip2930.fromBytes(bytes3)
);

// node_modules/@hashgraph/sdk/src/EthereumFlow.js
var EthereumFlow = class {
  /**
   * @param {object} [props]
   * @param {Uint8Array} [props.ethereumData]
   * @param {FileId} [props.callData]
   * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]
   */
  constructor(props = {}) {
    this._ethereumData = null;
    this._callDataFileId = null;
    this._maxGasAllowance = null;
    if (props.ethereumData != null) {
      this.setEthereumData(props.ethereumData);
    }
    if (props.maxGasAllowance != null) {
      this.setMaxGasAllowanceHbar(props.maxGasAllowance);
    }
    this._maxChunks = null;
  }
  /**
   * @returns {number | null}
   */
  get maxChunks() {
    return this._maxChunks;
  }
  /**
   * @param {number} maxChunks
   * @returns {this}
   */
  setMaxChunks(maxChunks) {
    this._maxChunks = maxChunks;
    return this;
  }
  /**
   * @returns {?EthereumTransactionData}
   */
  get ethereumData() {
    return this._ethereumData;
  }
  /**
   * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
   * unless the callData field is set.
   *
   * @param {EthereumTransactionData | Uint8Array} ethereumData
   * @returns {this}
   */
  setEthereumData(ethereumData) {
    this._ethereumData = ethereumData instanceof Uint8Array ? EthereumTransactionData.fromBytes(ethereumData) : ethereumData;
    return this;
  }
  /**
   * @returns {?Hbar}
   */
  get maxGasAllowance() {
    return this._maxGasAllowance;
  }
  /**
   * @deprecated - use masGasAllowanceHbar instead.
   * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
   * @returns {this}
   */
  setMaxGasAllowance(maxGasAllowance) {
    return this.setMaxGasAllowanceHbar(maxGasAllowance);
  }
  /**
   * The maximum amount, in tinybars, that the payer of the hedera transaction
   * is willing to pay to complete the transaction.
   *
   * Ordinarily the account with the ECDSA alias corresponding to the public
   * key that is extracted from the ethereum_data signature is responsible for
   * fees that result from the execution of the transaction. If that amount of
   * authorized fees is not sufficient then the payer of the transaction can be
   * charged, up to but not exceeding this amount. If the ethereum_data
   * transaction authorized an amount that was insufficient then the payer will
   * only be charged the amount needed to make up the difference. If the gas
   * price in the transaction was set to zero then the payer will be assessed
   * the entire fee.
   *
   * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
   * @returns {this}
   */
  setMaxGasAllowanceHbar(maxGasAllowance) {
    this._maxGasAllowance = maxGasAllowance instanceof Hbar ? maxGasAllowance : new Hbar(maxGasAllowance);
    return this;
  }
  /**
   * @template {Channel} ChannelT
   * @template {MirrorChannel} MirrorChannelT
   * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
   * @returns {Promise<TransactionResponse>}
   */
  async execute(client) {
    if (this._ethereumData == null) {
      throw new Error(
        "cannot submit ethereum transaction with no ethereum data"
      );
    }
    const ethereumTransaction = new EthereumTransaction();
    const ethereumTransactionDataBytes = this._ethereumData.toBytes();
    if (this._maxGasAllowance != null) {
      ethereumTransaction.setMaxGasAllowanceHbar(this._maxGasAllowance);
    }
    if (this._callDataFileId != null) {
      if (this._ethereumData.callData.length === 0) {
        throw new Error(
          "call data file ID provided, but ethereum data already contains call data"
        );
      }
      ethereumTransaction.setEthereumData(ethereumTransactionDataBytes).setCallDataFileId(this._callDataFileId);
    } else if (ethereumTransactionDataBytes.length <= 5120) {
      ethereumTransaction.setEthereumData(ethereumTransactionDataBytes);
    } else {
      const fileId = await createFile(
        this._ethereumData.callData,
        client,
        this._maxChunks
      );
      this._ethereumData.callData = new Uint8Array();
      ethereumTransaction.setEthereumData(this._ethereumData.toBytes()).setCallDataFileId(fileId);
    }
    return ethereumTransaction.execute(client);
  }
};
async function createFile(callData, client, maxChunks) {
  const hexedCallData = encode(callData);
  const fileId = (
    /** @type {FileId} */
    (await (await new FileCreateTransaction().setContents(hexedCallData.substring(0, 4096)).setKeys(
      client.operatorPublicKey ? [client.operatorPublicKey] : []
    ).execute(client)).getReceipt(client)).fileId
  );
  if (callData.length > 4096) {
    let fileAppendTransaction = new FileAppendTransaction().setFileId(fileId).setContents(hexedCallData.substring(4096, hexedCallData.length));
    if (maxChunks != null) {
      fileAppendTransaction.setMaxChunks(maxChunks);
    }
    await (await fileAppendTransaction.execute(client)).getReceipt(client);
  }
  return fileId;
}

// node_modules/@hashgraph/sdk/src/ExchangeRates.js
var HashgraphProto24 = __toESM(require_lib(), 1);
var { proto: proto25 } = HashgraphProto24;
var ExchangeRates = class _ExchangeRates {
  /**
   * @private
   * @param {object} props
   * @param {ExchangeRate} props.currentRate
   * @param {ExchangeRate} props.nextRate
   */
  constructor(props) {
    this.currentRate = props.currentRate;
    this.nextRate = props.nextRate;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IExchangeRateSet} rateSet
   * @returns {ExchangeRates}
   */
  static _fromProtobuf(rateSet) {
    return new _ExchangeRates({
      currentRate: ExchangeRate._fromProtobuf(
        /** @type {HashgraphProto.proto.IExchangeRate} */
        rateSet.currentRate
      ),
      nextRate: ExchangeRate._fromProtobuf(
        /** @type {HashgraphProto.proto.IExchangeRate} */
        rateSet.nextRate
      )
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IExchangeRateSet}
   */
  _toProtobuf() {
    return {
      currentRate: this.currentRate._toProtobuf(),
      nextRate: this.nextRate._toProtobuf()
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ExchangeRates}
   */
  static fromBytes(bytes3) {
    return _ExchangeRates._fromProtobuf(proto25.ExchangeRateSet.decode(bytes3));
  }
};

// node_modules/@hashgraph/sdk/src/FeeComponents.js
var HashgraphProto25 = __toESM(require_lib(), 1);
var FeeComponents = class _FeeComponents {
  /**
   * @param {object} [props]
   * @param {Long} [props.min]
   * @param {Long} [props.max]
   * @param {Long} [props.constant]
   * @param {Long} [props.transactionBandwidthByte]
   * @param {Long} [props.transactionVerification]
   * @param {Long} [props.transactionRamByteHour]
   * @param {Long} [props.transactionStorageByteHour]
   * @param {Long} [props.contractTransactionGas]
   * @param {Long} [props.transferVolumeHbar]
   * @param {Long} [props.responseMemoryByte]
   * @param {Long} [props.responseDiskByte]
   */
  constructor(props = {}) {
    this.min = props.min;
    this.max = props.max;
    this.constant = props.constant;
    this.transactionBandwidthByte = props.transactionBandwidthByte;
    this.transactionVerification = props.transactionVerification;
    this.transactionRamByteHour = props.transactionRamByteHour;
    this.transactionStorageByteHour = props.transactionStorageByteHour;
    this.contractTransactionGas = props.contractTransactionGas;
    this.transferVolumeHbar = props.transferVolumeHbar;
    this.responseMemoryByte = props.responseMemoryByte;
    this.responseDiskByte = props.responseDiskByte;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FeeComponents}
   */
  static fromBytes(bytes3) {
    return _FeeComponents._fromProtobuf(
      HashgraphProto25.proto.FeeComponents.decode(bytes3)
    );
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IFeeComponents} feeComponents
   * @returns {FeeComponents}
   */
  static _fromProtobuf(feeComponents) {
    return new _FeeComponents({
      min: feeComponents.min != null ? feeComponents.min : void 0,
      max: feeComponents.max != null ? feeComponents.max : void 0,
      constant: feeComponents.constant != null ? feeComponents.constant : void 0,
      transactionBandwidthByte: feeComponents.bpt != null ? feeComponents.bpt : void 0,
      transactionVerification: feeComponents.vpt != null ? feeComponents.vpt : void 0,
      transactionRamByteHour: feeComponents.rbh != null ? feeComponents.rbh : void 0,
      transactionStorageByteHour: feeComponents.sbh != null ? feeComponents.sbh : void 0,
      contractTransactionGas: feeComponents.gas != null ? feeComponents.gas : void 0,
      transferVolumeHbar: feeComponents.tv != null ? feeComponents.tv : void 0,
      responseMemoryByte: feeComponents.bpr != null ? feeComponents.bpr : void 0,
      responseDiskByte: feeComponents.sbpr != null ? feeComponents.sbpr : void 0
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IFeeComponents}
   */
  _toProtobuf() {
    return {
      min: this.min != null ? this.min : void 0,
      max: this.max != null ? this.max : void 0,
      constant: this.constant != null ? this.constant : void 0,
      bpt: this.transactionBandwidthByte != null ? this.transactionBandwidthByte : void 0,
      vpt: this.transactionVerification != null ? this.transactionVerification : void 0,
      rbh: this.transactionRamByteHour != null ? this.transactionRamByteHour : void 0,
      sbh: this.transactionStorageByteHour != null ? this.transactionStorageByteHour : void 0,
      gas: this.contractTransactionGas != null ? this.contractTransactionGas : void 0,
      tv: this.transferVolumeHbar != null ? this.transferVolumeHbar : void 0,
      bpr: this.responseMemoryByte != null ? this.responseMemoryByte : void 0,
      sbpr: this.responseDiskByte != null ? this.responseDiskByte : void 0
    };
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto25.proto.FeeComponents.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/FeeData.js
var HashgraphProto26 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/FeeDataType.js
var FeeDataType = class _FeeDataType {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _FeeDataType.Default:
        return "DEFAULT";
      case _FeeDataType.TokenFungibleCommon:
        return "TOKEN_FUNGIBLE_COMMON";
      case _FeeDataType.TokenNonFungibleUnique:
        return "TOKEN_NON_FUNGIBLE_UNIQUE";
      case _FeeDataType.TokenFungibleCommonWithCustomFees:
        return "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES";
      case _FeeDataType.TokenNonFungibleUniqueWithCustomFees:
        return "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES";
      case _FeeDataType.ScheduleCreateContractCall:
        return "SCHEDULE_CREATE_CONTRACT_CALL";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @internal
   * @param {number} code
   * @returns {FeeDataType}
   */
  static _fromCode(code) {
    switch (code) {
      case 0:
        return _FeeDataType.Default;
      case 1:
        return _FeeDataType.TokenFungibleCommon;
      case 2:
        return _FeeDataType.TokenNonFungibleUnique;
      case 3:
        return _FeeDataType.TokenFungibleCommonWithCustomFees;
      case 4:
        return _FeeDataType.TokenNonFungibleUniqueWithCustomFees;
      case 5:
        return _FeeDataType.ScheduleCreateContractCall;
    }
    throw new Error(
      `(BUG) SubType.fromCode() does not handle code: ${code}`
    );
  }
  /**
   * @returns {HashgraphProto.proto.SubType}
   */
  valueOf() {
    return this._code;
  }
};
FeeDataType.Default = new FeeDataType(0);
FeeDataType.TokenFungibleCommon = new FeeDataType(1);
FeeDataType.TokenNonFungibleUnique = new FeeDataType(2);
FeeDataType.TokenFungibleCommonWithCustomFees = new FeeDataType(3);
FeeDataType.TokenNonFungibleUniqueWithCustomFees = new FeeDataType(4);
FeeDataType.ScheduleCreateContractCall = new FeeDataType(5);

// node_modules/@hashgraph/sdk/src/FeeData.js
var FeeData = class _FeeData {
  /**
   * @param {object} [props]
   * @param {FeeComponents} [props.nodedata]
   * @param {FeeComponents} [props.networkdata]
   * @param {FeeComponents} [props.servicedata]
   * @param {FeeDataType} [props.feeDataType]
   */
  constructor(props = {}) {
    this.nodedata = props.nodedata;
    this.networkdata = props.networkdata;
    this.servicedata = props.servicedata;
    this.feeDataType = props.feeDataType;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FeeData}
   */
  static fromBytes(bytes3) {
    return _FeeData._fromProtobuf(
      HashgraphProto26.proto.FeeData.decode(bytes3)
    );
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IFeeData} feeData
   * @returns {FeeData}
   */
  static _fromProtobuf(feeData) {
    return new _FeeData({
      nodedata: feeData.nodedata != null ? FeeComponents._fromProtobuf(feeData.nodedata) : void 0,
      networkdata: feeData.networkdata != null ? FeeComponents._fromProtobuf(feeData.networkdata) : void 0,
      servicedata: feeData.servicedata != null ? FeeComponents._fromProtobuf(feeData.servicedata) : void 0,
      feeDataType: feeData.subType != null ? FeeDataType._fromCode(feeData.subType) : void 0
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IFeeData}
   */
  _toProtobuf() {
    return {
      nodedata: this.nodedata != null ? this.nodedata._toProtobuf() : void 0,
      networkdata: this.networkdata != null ? this.networkdata._toProtobuf() : void 0,
      servicedata: this.servicedata != null ? this.servicedata._toProtobuf() : void 0,
      subType: this.feeDataType != null ? this.feeDataType.valueOf() : void 0
    };
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto26.proto.FeeData.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/FeeSchedule.js
var HashgraphProto28 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/TransactionFeeSchedule.js
var HashgraphProto27 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/src/RequestType.js
var RequestType = class _RequestType {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _RequestType.None:
        return "NONE";
      case _RequestType.CryptoTransfer:
        return "CryptoTransfer";
      case _RequestType.CryptoUpdate:
        return "CryptoUpdate";
      case _RequestType.CryptoDelete:
        return "CryptoDelete";
      case _RequestType.CryptoAddLiveHash:
        return "CryptoAddLiveHash";
      case _RequestType.CryptoDeleteLiveHash:
        return "CryptoDeleteLiveHash";
      case _RequestType.ContractCall:
        return "ContractCall";
      case _RequestType.ContractCreate:
        return "ContractCreate";
      case _RequestType.ContractUpdate:
        return "ContractUpdate";
      case _RequestType.FileCreate:
        return "FileCreate";
      case _RequestType.FileAppend:
        return "FileAppend";
      case _RequestType.FileUpdate:
        return "FileUpdate";
      case _RequestType.FileDelete:
        return "FileDelete";
      case _RequestType.CryptoGetAccountBalance:
        return "CryptoGetAccountBalance";
      case _RequestType.CryptoGetAccountRecords:
        return "CryptoGetAccountRecords";
      case _RequestType.CryptoGetInfo:
        return "CryptoGetInfo";
      case _RequestType.ContractCallLocal:
        return "ContractCallLocal";
      case _RequestType.ContractGetInfo:
        return "ContractGetInfo";
      case _RequestType.ContractGetBytecode:
        return "ContractGetBytecode";
      case _RequestType.GetBySolidityID:
        return "GetBySolidityID";
      case _RequestType.GetByKey:
        return "GetByKey";
      case _RequestType.CryptoGetLiveHash:
        return "CryptoGetLiveHash";
      case _RequestType.CryptoGetStakers:
        return "CryptoGetStakers";
      case _RequestType.FileGetContents:
        return "FileGetContents";
      case _RequestType.FileGetInfo:
        return "FileGetInfo";
      case _RequestType.TransactionGetRecord:
        return "TransactionGetRecord";
      case _RequestType.ContractGetRecords:
        return "ContractGetRecords";
      case _RequestType.CryptoCreate:
        return "CryptoCreate";
      case _RequestType.SystemDelete:
        return "SystemDelete";
      case _RequestType.SystemUndelete:
        return "SystemUndelete";
      case _RequestType.ContractDelete:
        return "ContractDelete";
      case _RequestType.Freeze:
        return "Freeze";
      case _RequestType.CreateTransactionRecord:
        return "CreateTransactionRecord";
      case _RequestType.CryptoAccountAutoRenew:
        return "CryptoAccountAutoRenew";
      case _RequestType.ContractAutoRenew:
        return "ContractAutoRenew";
      case _RequestType.GetVersionInfo:
        return "GetVersionInfo";
      case _RequestType.TransactionGetReceipt:
        return "TransactionGetReceipt";
      case _RequestType.ConsensusCreateTopic:
        return "ConsensusCreateTopic";
      case _RequestType.ConsensusUpdateTopic:
        return "ConsensusUpdateTopic";
      case _RequestType.ConsensusDeleteTopic:
        return "ConsensusDeleteTopic";
      case _RequestType.ConsensusGetTopicInfo:
        return "ConsensusGetTopicInfo";
      case _RequestType.ConsensusSubmitMessage:
        return "ConsensusSubmitMessage";
      case _RequestType.UncheckedSubmit:
        return "UncheckedSubmit";
      case _RequestType.TokenCreate:
        return "TokenCreate";
      case _RequestType.TokenGetInfo:
        return "TokenGetInfo";
      case _RequestType.TokenFreezeAccount:
        return "TokenFreezeAccount";
      case _RequestType.TokenUnfreezeAccount:
        return "TokenUnfreezeAccount";
      case _RequestType.TokenGrantKycToAccount:
        return "TokenGrantKycToAccount";
      case _RequestType.TokenRevokeKycFromAccount:
        return "TokenRevokeKycFromAccount";
      case _RequestType.TokenDelete:
        return "TokenDelete";
      case _RequestType.TokenUpdate:
        return "TokenUpdate";
      case _RequestType.TokenMint:
        return "TokenMint";
      case _RequestType.TokenBurn:
        return "TokenBurn";
      case _RequestType.TokenAccountWipe:
        return "TokenAccountWipe";
      case _RequestType.TokenAssociateToAccount:
        return "TokenAssociateToAccount";
      case _RequestType.TokenDissociateFromAccount:
        return "TokenDissociateFromAccount";
      case _RequestType.ScheduleCreate:
        return "ScheduleCreate";
      case _RequestType.ScheduleDelete:
        return "ScheduleDelete";
      case _RequestType.ScheduleSign:
        return "ScheduleSign";
      case _RequestType.ScheduleGetInfo:
        return "ScheduleGetInfo";
      case _RequestType.TokenGetAccountNftInfos:
        return "TokenGetAccountNftInfos";
      case _RequestType.TokenGetNftInfo:
        return "TokenGetNftInfo";
      case _RequestType.TokenGetNftInfos:
        return "TokenGetNftInfos";
      case _RequestType.TokenFeeScheduleUpdate:
        return "TokenFeeScheduleUpdate";
      case _RequestType.NetworkGetExecutionTime:
        return "NetworkGetExecutionTime";
      case _RequestType.TokenPause:
        return "TokenPause";
      case _RequestType.TokenUnpause:
        return "TokenUnpause";
      case _RequestType.CryptoApproveAllowance:
        return "CryptoApproveAllowance";
      case _RequestType.CryptoDeleteAllowance:
        return "CryptoDeleteAllowance";
      case _RequestType.GetAccountDetails:
        return "GetAccountDetails";
      case _RequestType.EthereumTransaction:
        return "EthereumTransaction";
      case _RequestType.NodeStakeUpdate:
        return "NodeStakeUpdate";
      case _RequestType.Prng:
        return "UtilPrng";
      case _RequestType.TransactionGetFastRecord:
        return "TransactionGetFastRecord";
      case _RequestType.TokenUpdateNfts:
        return "TokenUpdateNfts";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @internal
   * @param {number} code
   * @returns {RequestType}
   */
  static _fromCode(code) {
    switch (code) {
      case 0:
        return _RequestType.None;
      case 1:
        return _RequestType.CryptoTransfer;
      case 2:
        return _RequestType.CryptoUpdate;
      case 3:
        return _RequestType.CryptoDelete;
      case 4:
        return _RequestType.CryptoAddLiveHash;
      case 5:
        return _RequestType.CryptoDeleteLiveHash;
      case 6:
        return _RequestType.ContractCall;
      case 7:
        return _RequestType.ContractCreate;
      case 8:
        return _RequestType.ContractUpdate;
      case 9:
        return _RequestType.FileCreate;
      case 10:
        return _RequestType.FileAppend;
      case 11:
        return _RequestType.FileUpdate;
      case 12:
        return _RequestType.FileDelete;
      case 13:
        return _RequestType.CryptoGetAccountBalance;
      case 14:
        return _RequestType.CryptoGetAccountRecords;
      case 15:
        return _RequestType.CryptoGetInfo;
      case 16:
        return _RequestType.ContractCallLocal;
      case 17:
        return _RequestType.ContractGetInfo;
      case 18:
        return _RequestType.ContractGetBytecode;
      case 19:
        return _RequestType.GetBySolidityID;
      case 20:
        return _RequestType.GetByKey;
      case 21:
        return _RequestType.CryptoGetLiveHash;
      case 22:
        return _RequestType.CryptoGetStakers;
      case 23:
        return _RequestType.FileGetContents;
      case 24:
        return _RequestType.FileGetInfo;
      case 25:
        return _RequestType.TransactionGetRecord;
      case 26:
        return _RequestType.ContractGetRecords;
      case 27:
        return _RequestType.CryptoCreate;
      case 28:
        return _RequestType.SystemDelete;
      case 29:
        return _RequestType.SystemUndelete;
      case 30:
        return _RequestType.ContractDelete;
      case 31:
        return _RequestType.Freeze;
      case 32:
        return _RequestType.CreateTransactionRecord;
      case 33:
        return _RequestType.CryptoAccountAutoRenew;
      case 34:
        return _RequestType.ContractAutoRenew;
      case 35:
        return _RequestType.GetVersionInfo;
      case 36:
        return _RequestType.TransactionGetReceipt;
      case 50:
        return _RequestType.ConsensusCreateTopic;
      case 51:
        return _RequestType.ConsensusUpdateTopic;
      case 52:
        return _RequestType.ConsensusDeleteTopic;
      case 53:
        return _RequestType.ConsensusGetTopicInfo;
      case 54:
        return _RequestType.ConsensusSubmitMessage;
      case 55:
        return _RequestType.UncheckedSubmit;
      case 56:
        return _RequestType.TokenCreate;
      case 58:
        return _RequestType.TokenGetInfo;
      case 59:
        return _RequestType.TokenFreezeAccount;
      case 60:
        return _RequestType.TokenUnfreezeAccount;
      case 61:
        return _RequestType.TokenGrantKycToAccount;
      case 62:
        return _RequestType.TokenRevokeKycFromAccount;
      case 63:
        return _RequestType.TokenDelete;
      case 64:
        return _RequestType.TokenUpdate;
      case 65:
        return _RequestType.TokenMint;
      case 66:
        return _RequestType.TokenBurn;
      case 67:
        return _RequestType.TokenAccountWipe;
      case 68:
        return _RequestType.TokenAssociateToAccount;
      case 69:
        return _RequestType.TokenDissociateFromAccount;
      case 70:
        return _RequestType.ScheduleCreate;
      case 71:
        return _RequestType.ScheduleDelete;
      case 72:
        return _RequestType.ScheduleSign;
      case 73:
        return _RequestType.ScheduleGetInfo;
      case 74:
        return _RequestType.TokenGetAccountNftInfos;
      case 75:
        return _RequestType.TokenGetNftInfo;
      case 76:
        return _RequestType.TokenGetNftInfos;
      case 77:
        return _RequestType.TokenFeeScheduleUpdate;
      case 78:
        return _RequestType.NetworkGetExecutionTime;
      case 79:
        return _RequestType.TokenPause;
      case 80:
        return _RequestType.TokenUnpause;
      case 81:
        return _RequestType.CryptoApproveAllowance;
      case 82:
        return _RequestType.CryptoDeleteAllowance;
      case 83:
        return _RequestType.GetAccountDetails;
      case 84:
        return _RequestType.EthereumTransaction;
      case 85:
        return _RequestType.NodeStakeUpdate;
      case 86:
        return _RequestType.Prng;
      case 87:
        return _RequestType.TransactionGetFastRecord;
      case 88:
        return _RequestType.TokenUpdateNfts;
    }
    throw new Error(
      `(BUG) RequestType.fromCode() does not handle code: ${code}`
    );
  }
  /**
   * @returns {HashgraphProto.proto.HederaFunctionality}
   */
  valueOf() {
    return this._code;
  }
};
RequestType.None = new RequestType(0);
RequestType.CryptoTransfer = new RequestType(1);
RequestType.CryptoUpdate = new RequestType(2);
RequestType.CryptoDelete = new RequestType(3);
RequestType.CryptoAddLiveHash = new RequestType(4);
RequestType.CryptoDeleteLiveHash = new RequestType(5);
RequestType.ContractCall = new RequestType(6);
RequestType.ContractCreate = new RequestType(7);
RequestType.ContractUpdate = new RequestType(8);
RequestType.FileCreate = new RequestType(9);
RequestType.FileAppend = new RequestType(10);
RequestType.FileUpdate = new RequestType(11);
RequestType.FileDelete = new RequestType(12);
RequestType.CryptoGetAccountBalance = new RequestType(13);
RequestType.CryptoGetAccountRecords = new RequestType(14);
RequestType.CryptoGetInfo = new RequestType(15);
RequestType.ContractCallLocal = new RequestType(16);
RequestType.ContractGetInfo = new RequestType(17);
RequestType.ContractGetBytecode = new RequestType(18);
RequestType.GetBySolidityID = new RequestType(19);
RequestType.GetByKey = new RequestType(20);
RequestType.CryptoGetLiveHash = new RequestType(21);
RequestType.CryptoGetStakers = new RequestType(22);
RequestType.FileGetContents = new RequestType(23);
RequestType.FileGetInfo = new RequestType(24);
RequestType.TransactionGetRecord = new RequestType(25);
RequestType.ContractGetRecords = new RequestType(26);
RequestType.CryptoCreate = new RequestType(27);
RequestType.SystemDelete = new RequestType(28);
RequestType.SystemUndelete = new RequestType(29);
RequestType.ContractDelete = new RequestType(30);
RequestType.Freeze = new RequestType(31);
RequestType.CreateTransactionRecord = new RequestType(32);
RequestType.CryptoAccountAutoRenew = new RequestType(33);
RequestType.ContractAutoRenew = new RequestType(34);
RequestType.GetVersionInfo = new RequestType(35);
RequestType.TransactionGetReceipt = new RequestType(36);
RequestType.ConsensusCreateTopic = new RequestType(50);
RequestType.ConsensusUpdateTopic = new RequestType(51);
RequestType.ConsensusDeleteTopic = new RequestType(52);
RequestType.ConsensusGetTopicInfo = new RequestType(53);
RequestType.ConsensusSubmitMessage = new RequestType(54);
RequestType.UncheckedSubmit = new RequestType(55);
RequestType.TokenCreate = new RequestType(56);
RequestType.TokenGetInfo = new RequestType(58);
RequestType.TokenFreezeAccount = new RequestType(59);
RequestType.TokenUnfreezeAccount = new RequestType(60);
RequestType.TokenGrantKycToAccount = new RequestType(61);
RequestType.TokenRevokeKycFromAccount = new RequestType(62);
RequestType.TokenDelete = new RequestType(63);
RequestType.TokenUpdate = new RequestType(64);
RequestType.TokenMint = new RequestType(65);
RequestType.TokenBurn = new RequestType(66);
RequestType.TokenAccountWipe = new RequestType(67);
RequestType.TokenAssociateToAccount = new RequestType(68);
RequestType.TokenDissociateFromAccount = new RequestType(69);
RequestType.ScheduleCreate = new RequestType(70);
RequestType.ScheduleDelete = new RequestType(71);
RequestType.ScheduleSign = new RequestType(72);
RequestType.ScheduleGetInfo = new RequestType(73);
RequestType.TokenGetAccountNftInfos = new RequestType(74);
RequestType.TokenGetNftInfo = new RequestType(75);
RequestType.TokenGetNftInfos = new RequestType(76);
RequestType.TokenFeeScheduleUpdate = new RequestType(77);
RequestType.NetworkGetExecutionTime = new RequestType(78);
RequestType.TokenPause = new RequestType(79);
RequestType.TokenUnpause = new RequestType(80);
RequestType.CryptoApproveAllowance = new RequestType(81);
RequestType.CryptoDeleteAllowance = new RequestType(82);
RequestType.GetAccountDetails = new RequestType(83);
RequestType.EthereumTransaction = new RequestType(84);
RequestType.NodeStakeUpdate = new RequestType(85);
RequestType.Prng = new RequestType(86);
RequestType.TransactionGetFastRecord = new RequestType(87);
RequestType.TokenUpdateNfts = new RequestType(88);

// node_modules/@hashgraph/sdk/src/TransactionFeeSchedule.js
var TransactionFeeSchedule = class _TransactionFeeSchedule {
  /**
   * @param {object} [props]
   * @param {RequestType} [props.hederaFunctionality]
   * @param {FeeData} [props.feeData]
   * @param {FeeData[]} [props.fees]
   */
  constructor(props = {}) {
    this.hederaFunctionality = props.hederaFunctionality;
    this.feeData = props.feeData;
    this.fees = props.fees;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionFeeSchedule}
   */
  static fromBytes(bytes3) {
    return _TransactionFeeSchedule._fromProtobuf(
      HashgraphProto27.proto.TransactionFeeSchedule.decode(bytes3)
    );
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransactionFeeSchedule} transactionFeeSchedule
   * @returns {TransactionFeeSchedule}
   */
  static _fromProtobuf(transactionFeeSchedule) {
    return new _TransactionFeeSchedule({
      hederaFunctionality: transactionFeeSchedule.hederaFunctionality != null ? RequestType._fromCode(
        transactionFeeSchedule.hederaFunctionality
      ) : void 0,
      feeData: transactionFeeSchedule.feeData != null ? FeeData._fromProtobuf(transactionFeeSchedule.feeData) : void 0,
      fees: transactionFeeSchedule.fees != null ? transactionFeeSchedule.fees.map(
        (fee) => FeeData._fromProtobuf(fee)
      ) : void 0
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ITransactionFeeSchedule}
   */
  _toProtobuf() {
    return {
      hederaFunctionality: this.hederaFunctionality != null ? this.hederaFunctionality.valueOf() : void 0,
      feeData: this.feeData != null ? this.feeData._toProtobuf() : void 0,
      fees: this.fees != null ? this.fees.map((fee) => fee._toProtobuf()) : void 0
    };
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto27.proto.TransactionFeeSchedule.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/FeeSchedule.js
var FeeSchedule = class _FeeSchedule {
  /**
   * @param {object} [props]
   * @param {TransactionFeeSchedule[]} [props.transactionFeeSchedule]
   * @param {Timestamp} [props.expirationTime]
   */
  constructor(props = {}) {
    this.transactionFeeSchedule = props.transactionFeeSchedule;
    this.expirationTime = props.expirationTime;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FeeSchedule}
   */
  static fromBytes(bytes3) {
    return _FeeSchedule._fromProtobuf(
      HashgraphProto28.proto.FeeSchedule.decode(bytes3)
    );
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IFeeSchedule} feeSchedule
   * @returns {FeeSchedule}
   */
  static _fromProtobuf(feeSchedule) {
    return new _FeeSchedule({
      transactionFeeSchedule: feeSchedule.transactionFeeSchedule != null ? feeSchedule.transactionFeeSchedule.map(
        (schedule) => TransactionFeeSchedule._fromProtobuf(schedule)
      ) : void 0,
      expirationTime: feeSchedule.expiryTime != null ? Timestamp._fromProtobuf(feeSchedule.expiryTime) : void 0
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IFeeSchedule}
   */
  _toProtobuf() {
    return {
      transactionFeeSchedule: this.transactionFeeSchedule != null ? this.transactionFeeSchedule.map(
        (transaction) => transaction._toProtobuf()
      ) : void 0,
      expiryTime: this.expirationTime != null ? this.expirationTime._toProtobuf() : void 0
    };
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto28.proto.FeeSchedule.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/FeeSchedules.js
var HashgraphProto29 = __toESM(require_lib(), 1);
var FeeSchedules = class _FeeSchedules {
  /**
   * @param {object} [props]
   * @param {FeeSchedule} [props.currentFeeSchedule]
   * @param {FeeSchedule} [props.nextFeeSchedule]
   */
  constructor(props = {}) {
    this.current = props.currentFeeSchedule;
    this.next = props.nextFeeSchedule;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FeeSchedules}
   */
  static fromBytes(bytes3) {
    return _FeeSchedules._fromProtobuf(
      HashgraphProto29.proto.CurrentAndNextFeeSchedule.decode(bytes3)
    );
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ICurrentAndNextFeeSchedule} feeSchedules
   * @returns {FeeSchedules}
   */
  static _fromProtobuf(feeSchedules) {
    return new _FeeSchedules({
      currentFeeSchedule: feeSchedules.currentFeeSchedule != null ? FeeSchedule._fromProtobuf(feeSchedules.currentFeeSchedule) : void 0,
      nextFeeSchedule: feeSchedules.nextFeeSchedule != null ? FeeSchedule._fromProtobuf(feeSchedules.nextFeeSchedule) : void 0
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ICurrentAndNextFeeSchedule}
   */
  _toProtobuf() {
    return {
      currentFeeSchedule: this.current != null ? this.current._toProtobuf() : void 0,
      nextFeeSchedule: this.next != null ? this.next._toProtobuf() : void 0
    };
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto29.proto.CurrentAndNextFeeSchedule.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/file/FileContentsQuery.js
var FileContentsQuery = class _FileContentsQuery extends Query {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {FileContentsQuery}
   */
  static _fromProtobuf(query) {
    const contents = (
      /** @type {HashgraphProto.proto.IFileGetContentsQuery} */
      query.fileGetContents
    );
    return new _FileContentsQuery({
      fileId: contents.fileID != null ? FileId._fromProtobuf(contents.fileID) : void 0
    });
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.file.getFileContent(request);
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * Set the file ID for which the info is being requested.
   *
   * @param {FileId | string} fileId
   * @returns {FileContentsQuery}
   */
  setFileId(fileId) {
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const fileGetContents = (
      /** @type {HashgraphProto.proto.IFileGetContentsResponse} */
      response.fileGetContents
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      fileGetContents.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Promise<Uint8Array>}
   */
  _mapResponse(response) {
    const fileContentsResponse = (
      /** @type {HashgraphProto.proto.IFileGetContentsResponse} */
      response.fileGetContents
    );
    const fileConents = (
      /** @type {HashgraphProto.proto.FileGetContentsResponse.IFileContents} */
      fileContentsResponse.fileContents
    );
    const contents = (
      /** @type {Uint8Array} */
      fileConents.contents
    );
    return Promise.resolve(contents);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      fileGetContents: {
        header,
        fileID: this._fileId != null ? this._fileId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `FileContentsQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("fileGetContents", FileContentsQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileInfo.js
var import_long39 = __toESM(require_long(), 1);
var HashgraphProto30 = __toESM(require_lib(), 1);
var { proto: proto32 } = HashgraphProto30;
var FileInfo = class _FileInfo {
  /**
   * @private
   * @param {object} props
   * @param {FileId} props.fileId
   * @param {Long} props.size
   * @param {Timestamp} props.expirationTime
   * @param {boolean} props.isDeleted
   * @param {KeyList} props.keys
   * @param {string} props.fileMemo
   * @param {LedgerId|null} props.ledgerId
   */
  constructor(props) {
    this.fileId = props.fileId;
    this.size = props.size;
    this.expirationTime = props.expirationTime;
    this.isDeleted = props.isDeleted;
    this.keys = props.keys;
    this.fileMemo = props.fileMemo;
    this.ledgerId = props.ledgerId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.FileGetInfoResponse.IFileInfo} info
   * @returns {FileInfo}
   */
  static _fromProtobuf(info) {
    const size = (
      /** @type {Long | number} */
      info.size
    );
    return new _FileInfo({
      fileId: FileId._fromProtobuf(
        /** @type {HashgraphProto.proto.IFileID} */
        info.fileID
      ),
      size: size instanceof import_long39.default ? size : import_long39.default.fromValue(size),
      expirationTime: Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.expirationTime
      ),
      isDeleted: (
        /** @type {boolean} */
        info.deleted
      ),
      keys: info.keys != null ? KeyList2.__fromProtobufKeyList(info.keys) : new KeyList2(),
      fileMemo: info.memo != null ? info.memo : "",
      ledgerId: info.ledgerId != null ? LedgerId.fromBytes(info.ledgerId) : null
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.FileGetInfoResponse.IFileInfo}
   */
  _toProtobuf() {
    return {
      fileID: this.fileId._toProtobuf(),
      size: this.size,
      expirationTime: this.expirationTime._toProtobuf(),
      deleted: this.isDeleted,
      keys: this.keys._toProtobufKey().keyList,
      memo: this.fileMemo,
      ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FileInfo}
   */
  static fromBytes(bytes3) {
    return _FileInfo._fromProtobuf(
      HashgraphProto30.proto.FileGetInfoResponse.FileInfo.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return proto32.FileGetInfoResponse.FileInfo.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/file/FileInfoQuery.js
var FileInfoQuery = class _FileInfoQuery extends Query {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {FileInfoQuery}
   */
  static _fromProtobuf(query) {
    const info = (
      /** @type {HashgraphProto.proto.IFileGetInfoQuery} */
      query.fileGetInfo
    );
    return new _FileInfoQuery({
      fileId: info.fileID != null ? FileId._fromProtobuf(info.fileID) : void 0
    });
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * Set the file ID for which the info is being requested.
   *
   * @param {FileId | string} fileId
   * @returns {FileInfoQuery}
   */
  setFileId(fileId) {
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    return super.getCost(client);
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.file.getFileInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const fileGetInfo = (
      /** @type {HashgraphProto.proto.IFileGetInfoResponse} */
      response.fileGetInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      fileGetInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<FileInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const info = (
      /** @type {HashgraphProto.proto.IFileGetInfoResponse} */
      response.fileGetInfo
    );
    return Promise.resolve(
      FileInfo._fromProtobuf(
        /** @type {HashgraphProto.proto.IFileInfo} */
        info.fileInfo
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      fileGetInfo: {
        header,
        fileID: this._fileId != null ? this._fileId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `FileInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("fileGetInfo", FileInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileUpdateTransaction.js
var FileUpdateTransaction = class _FileUpdateTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {FileId | string} [props.fileId]
   * @param {Key[] | KeyList} [props.keys]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Uint8Array | string} [props.contents]
   * @param {string} [props.fileMemo]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._keys = null;
    this._expirationTime = null;
    this._contents = null;
    this._fileMemo = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.keys != null) {
      this.setKeys(props.keys);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.contents != null) {
      this.setContents(props.contents);
    }
    if (props.fileMemo && props.fileMemo != null) {
      this.setFileMemo(props.fileMemo);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {FileUpdateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = (
      /** @type {HashgraphProto.proto.IFileUpdateTransactionBody} */
      body.fileUpdate
    );
    return Transaction._fromProtobufTransactions(
      new _FileUpdateTransaction({
        fileId: update3.fileID != null ? FileId._fromProtobuf(update3.fileID) : void 0,
        keys: update3.keys != null ? update3.keys.keys != null ? update3.keys.keys.map(
          (key) => Key2._fromProtobufKey(key)
        ) : void 0 : void 0,
        expirationTime: update3.expirationTime != null ? Timestamp._fromProtobuf(update3.expirationTime) : void 0,
        contents: update3.contents != null ? update3.contents : void 0,
        fileMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {FileId | string} fileId
   * @returns {this}
   */
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @returns {?Key[]}
   */
  get keys() {
    return this._keys;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {Key[] | KeyList} keys
   * @returns {this}
   */
  setKeys(keys) {
    this._requireNotFrozen();
    if (keys instanceof KeyList2 && keys.threshold != null) {
      throw new Error("Cannot set threshold key as file key");
    }
    this._keys = keys instanceof KeyList2 ? keys.toArray() : keys;
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * Set the instant at which this file will expire, after which its contents will no longer be
   * available.
   *
   * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction
   * was invoked.
   *
   * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
   *
   * @param {Timestamp | Date} expirationTime
   * @returns {this}
   */
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get contents() {
    return this._contents;
  }
  /**
   * Set the given byte array as the file's contents.
   *
   * This may be omitted to update an empty file.
   *
   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
   * network; if you exceed this you may receive a HederaPreCheckStatusException
   * with Status#TransactionOversize.
   *
   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
   * transaction with the first chunk and then use FileAppendTransaction with
   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
   *
   * @param {Uint8Array | string} contents
   * @returns {this}
   */
  setContents(contents) {
    this._requireNotFrozen();
    this._contents = contents instanceof Uint8Array ? contents : encode5(contents);
    return this;
  }
  /**
   * @returns {?string}
   */
  get fileMemo() {
    return this._fileMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */
  setFileMemo(memo) {
    this._requireNotFrozen();
    this._fileMemo = memo;
    return this;
  }
  /**
   * @returns {this}
   */
  clearFileMemo() {
    this._requireNotFrozen();
    this._fileMemo = null;
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.file.updateFile(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "fileUpdate";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IFileUpdateTransactionBody}
   */
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      keys: this._keys != null ? {
        keys: this._keys.map((key) => key._toProtobufKey())
      } : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      contents: this._contents,
      memo: this._fileMemo != null ? {
        value: this._fileMemo
      } : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `FileUpdateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set("fileUpdate", FileUpdateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/FreezeType.js
var FreezeType = class _FreezeType {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _FreezeType.UnknownFreezeType:
        return "UNKNOWN_FREEZE_TYPE";
      case _FreezeType.FreezeOnly:
        return "FREEZE_ONLY";
      case _FreezeType.PrepareUpgrade:
        return "PREPARE_UPGRADE";
      case _FreezeType.FreezeUpgrade:
        return "FREEZE_UPGRADE";
      case _FreezeType.FreezeAbort:
        return "FREEZE_ABORT";
      case _FreezeType.TelemetryUpgrade:
        return "TELEMETRY_UPGRADE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @internal
   * @param {number} code
   * @returns {FreezeType}
   */
  static _fromCode(code) {
    switch (code) {
      case 0:
        return _FreezeType.UnknownFreezeType;
      case 1:
        return _FreezeType.FreezeOnly;
      case 2:
        return _FreezeType.PrepareUpgrade;
      case 3:
        return _FreezeType.FreezeUpgrade;
      case 4:
        return _FreezeType.FreezeAbort;
      case 5:
        return _FreezeType.TelemetryUpgrade;
      default:
        throw new Error(
          `(BUG) Status.fromCode() does not handle code: ${code}`
        );
    }
  }
  /**
   * @returns {HashgraphProto.proto.FreezeType}
   */
  valueOf() {
    return this._code;
  }
};
FreezeType.UnknownFreezeType = new FreezeType(0);
FreezeType.FreezeOnly = new FreezeType(1);
FreezeType.PrepareUpgrade = new FreezeType(2);
FreezeType.FreezeUpgrade = new FreezeType(3);
FreezeType.FreezeAbort = new FreezeType(4);
FreezeType.TelemetryUpgrade = new FreezeType(5);

// node_modules/@hashgraph/sdk/src/system/FreezeTransaction.js
var FreezeTransaction = class _FreezeTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {HourMinute} [props.startTime]
   * @param {HourMinute} [props.endTime]
   * @param {Timestamp} [props.startTimestamp]
   * @param {FileId} [props.updateFileId]
   * @param {FileId} [props.fileId]
   * @param {Uint8Array | string} [props.fileHash]
   * @param { FreezeType } [props.freezeType]
   */
  constructor(props = {}) {
    super();
    this._startTime = null;
    this._startTimestamp = null;
    this._endTime = null;
    this._fileId = null;
    this._fileHash = null;
    this._freezeType = null;
    if (props.startTime != null) {
      this.setStartTime(props.startTime.hour, props.startTime.minute);
    }
    if (props.endTime != null) {
      this.setEndTime(props.endTime.hour, props.endTime.minute);
    }
    if (props.startTimestamp != null) {
      this.setStartTimestamp(props.startTimestamp);
    }
    if (props.updateFileId != null) {
      this.setUpdateFileId(props.updateFileId);
    }
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.fileHash != null) {
      this.setFileHash(props.fileHash);
    }
    if (props.freezeType != null) {
      this.setFreezeType(props.freezeType);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {FreezeTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const freeze = (
      /** @type {HashgraphProto.proto.IFreezeTransactionBody} */
      body.freeze
    );
    return Transaction._fromProtobufTransactions(
      new _FreezeTransaction({
        startTime: freeze.startHour != null && freeze.startMin != null ? {
          hour: freeze.startHour,
          minute: freeze.startMin
        } : void 0,
        endTime: freeze.endHour != null && freeze.endMin != null ? {
          hour: freeze.endHour,
          minute: freeze.endMin
        } : void 0,
        startTimestamp: freeze.startTime != null ? Timestamp._fromProtobuf(freeze.startTime) : void 0,
        updateFileId: freeze.updateFile != null ? FileId._fromProtobuf(freeze.updateFile) : void 0,
        fileHash: freeze.fileHash != null ? freeze.fileHash : void 0,
        freezeType: freeze.freezeType != null ? FreezeType._fromCode(freeze.freezeType) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @deprecated - Use `startTimestamp` instead
   * @returns {?HourMinute}
   */
  get startTime() {
    return null;
  }
  /**
   * @deprecated - Use `startTimestamp` instead
   * @param {number | string} startHourOrString
   * @param {?number} startMinute
   * @returns {FreezeTransaction}
   */
  setStartTime(startHourOrString, startMinute) {
    this._requireNotFrozen();
    if (typeof startHourOrString === "string") {
      const split = startHourOrString.split(":");
      this._startTime = {
        hour: Number(split[0]),
        minute: Number(split[1])
      };
    } else {
      this._startTime = {
        hour: startHourOrString,
        minute: (
          /** @type {number} */
          startMinute
        )
      };
    }
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get startTimestamp() {
    return this._startTimestamp;
  }
  /**
   * @param {Timestamp} startTimestamp
   * @returns {FreezeTransaction}
   */
  setStartTimestamp(startTimestamp) {
    this._requireNotFrozen();
    this._startTimestamp = startTimestamp;
    return this;
  }
  /**
   * @deprecated
   * @returns {?HourMinute}
   */
  get endTime() {
    console.warn("`FreezeTransaction.endTime` is deprecated");
    return this._endTime;
  }
  /**
   * @deprecated
   * @param {number | string} endHourOrString
   * @param {?number} endMinute
   * @returns {FreezeTransaction}
   */
  setEndTime(endHourOrString, endMinute) {
    console.warn("`FreezeTransaction.endTime` is deprecated");
    this._requireNotFrozen();
    if (typeof endHourOrString === "string") {
      const split = endHourOrString.split(":");
      this._endTime = {
        hour: Number(split[0]),
        minute: Number(split[1])
      };
    } else {
      this._endTime = {
        hour: endHourOrString,
        minute: (
          /** @type {number} */
          endMinute
        )
      };
    }
    return this;
  }
  /**
   * @deprecated - Use `fileId` instead
   * @returns {?FileId}
   */
  get updateFileId() {
    return this.fileId;
  }
  /**
   * @deprecated - Use `setFileId()` instead
   * @param {FileId} updateFileId
   * @returns {FreezeTransaction}
   */
  setUpdateFileId(updateFileId) {
    return this.setFileId(updateFileId);
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * @param {FileId} fileId
   * @returns {FreezeTransaction}
   */
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = fileId;
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get fileHash() {
    return this._fileHash;
  }
  /**
   * @param {Uint8Array | string} fileHash
   * @returns {FreezeTransaction}
   */
  setFileHash(fileHash) {
    this._requireNotFrozen();
    this._fileHash = typeof fileHash === "string" ? decode(fileHash) : fileHash;
    return this;
  }
  /**
   * @returns {?FreezeType}
   */
  get freezeType() {
    return this._freezeType;
  }
  /**
   * @param {FreezeType} freezeType
   * @returns {FreezeTransaction}
   */
  setFreezeType(freezeType) {
    this._requireNotFrozen();
    this._freezeType = freezeType;
    return this;
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "freeze";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IFreezeTransactionBody}
   */
  _makeTransactionData() {
    return {
      startTime: this._startTimestamp != null ? this._startTimestamp._toProtobuf() : null,
      updateFile: this._fileId != null ? this._fileId._toProtobuf() : null,
      fileHash: this._fileHash,
      freezeType: this._freezeType != null ? this._freezeType.valueOf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `FreezeTransaction:${timestamp.toString()}`;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.freeze.freeze(request);
  }
};
TRANSACTION_REGISTRY.set("freeze", FreezeTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/LiveHashAddTransaction.js
var LiveHashAddTransaction = class _LiveHashAddTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {Uint8Array} [props.hash]
   * @param {Key[]} [props.keys]
   * @param {Duration | Long | number} [props.duration]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._hash = null;
    this._keys = null;
    this._duration = null;
    this._accountId = null;
    if (props.hash != null) {
      this.setHash(props.hash);
    }
    if (props.keys != null) {
      this.setKeys(props.keys);
    }
    if (props.duration != null) {
      this.setDuration(props.duration);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {LiveHashAddTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const hashes = (
      /** @type {HashgraphProto.proto.ICryptoAddLiveHashTransactionBody} */
      body.cryptoAddLiveHash
    );
    const liveHash_ = (
      /** @type {HashgraphProto.proto.ILiveHash} */
      hashes.liveHash
    );
    return Transaction._fromProtobufTransactions(
      new _LiveHashAddTransaction({
        hash: liveHash_.hash != null ? liveHash_.hash : void 0,
        keys: liveHash_.keys != null ? liveHash_.keys.keys != null ? liveHash_.keys.keys.map(
          (key) => Key2._fromProtobufKey(key)
        ) : void 0 : void 0,
        duration: liveHash_.duration != null ? liveHash_.duration.seconds != null ? liveHash_.duration.seconds : void 0 : void 0,
        accountId: liveHash_.accountId != null ? AccountId._fromProtobuf(liveHash_.accountId) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?Uint8Array}
   */
  get hash() {
    return this._hash;
  }
  /**
   * @param {Uint8Array} hash
   * @returns {LiveHashAddTransaction}
   */
  setHash(hash2) {
    this._requireNotFrozen();
    this._hash = hash2;
    return this;
  }
  /**
   * @returns {?Key[]}
   */
  get keys() {
    return this._keys;
  }
  /**
   * @param {Key[] | KeyList} keys
   * @returns {LiveHashAddTransaction}
   */
  setKeys(keys) {
    this._requireNotFrozen();
    this._keys = keys instanceof KeyList2 ? keys.toArray() : keys;
    return this;
  }
  /**
   * @returns {?Duration}
   */
  get duration() {
    return this._duration;
  }
  /**
   * @param {Duration | Long | number} duration
   * @returns {LiveHashAddTransaction}
   */
  setDuration(duration) {
    this._requireNotFrozen();
    this._duration = duration instanceof Duration2 ? duration : new Duration2(duration);
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {LiveHashAddTransaction}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.addLiveHash(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoAddLiveHash";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoAddLiveHashTransactionBody}
   */
  _makeTransactionData() {
    return {
      liveHash: {
        hash: this._hash,
        keys: this._keys != null ? {
          keys: this._keys.map(
            (key) => key._toProtobufKey()
          )
        } : void 0,
        duration: this._duration != null ? this._duration._toProtobuf() : null,
        accountId: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `LiveHashAddTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoAddLiveHash",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  LiveHashAddTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/LiveHashDeleteTransaction.js
var LiveHashDeleteTransaction = class _LiveHashDeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {Uint8Array} [props.hash]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._hash = null;
    this._accountId = null;
    if (props.hash != null) {
      this.setHash(props.hash);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {LiveHashDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const hashes = (
      /** @type {HashgraphProto.proto.ICryptoDeleteLiveHashTransactionBody} */
      body.cryptoDeleteLiveHash
    );
    return Transaction._fromProtobufTransactions(
      new _LiveHashDeleteTransaction({
        hash: hashes.liveHashToDelete != null ? hashes.liveHashToDelete : void 0,
        accountId: hashes.accountOfLiveHash != null ? AccountId._fromProtobuf(hashes.accountOfLiveHash) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?Uint8Array}
   */
  get hash() {
    return this._hash;
  }
  /**
   * @param {Uint8Array} hash
   * @returns {LiveHashDeleteTransaction}
   */
  setHash(hash2) {
    this._requireNotFrozen();
    this._hash = hash2;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {LiveHashDeleteTransaction}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.deleteLiveHash(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoDeleteLiveHash";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoDeleteLiveHashTransactionBody}
   */
  _makeTransactionData() {
    return {
      liveHashToDelete: this._hash,
      accountOfLiveHash: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `LiveHashDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoDeleteLiveHash",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  LiveHashDeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/LiveHashQuery.js
var LiveHashQuery = class _LiveHashQuery extends Query {
  /**
   * @param {object} [props]
   * @param {AccountId | string} [props.accountId]
   * @param {Uint8Array} [props.hash]
   */
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    this._hash = null;
    if (props.hash != null) {
      this.setHash(props.hash);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {LiveHashQuery}
   */
  static _fromProtobuf(query) {
    const hash2 = (
      /** @type {HashgraphProto.proto.ICryptoGetLiveHashQuery} */
      query.cryptoGetLiveHash
    );
    return new _LiveHashQuery({
      accountId: hash2.accountID != null ? AccountId._fromProtobuf(hash2.accountID) : void 0,
      hash: hash2.hash != null ? hash2.hash : void 0
    });
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account to which the livehash is associated.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._accountId = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */
  get liveHash() {
    return this._hash;
  }
  /**
   * Set the SHA-384 data in the livehash.
   *
   * @param {Uint8Array} hash
   * @returns {this}
   */
  setHash(hash2) {
    this._hash = hash2;
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.getLiveHash(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const cryptoGetLiveHash = (
      /** @type {HashgraphProto.proto.ICryptoGetLiveHashResponse} */
      response.cryptoGetLiveHash
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      cryptoGetLiveHash.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Promise<LiveHash>}
   */
  _mapResponse(response) {
    const hashes = (
      /** @type {HashgraphProto.proto.ICryptoGetLiveHashResponse} */
      response.cryptoGetLiveHash
    );
    return Promise.resolve(
      LiveHash._fromProtobuf(
        /** @type {HashgraphProto.proto.ILiveHash} */
        hashes.liveHash
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      cryptoGetLiveHash: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null,
        hash: this._hash
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `LiveHashQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("cryptoGetLiveHash", LiveHashQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/network/SemanticVersion.js
var HashgraphProto31 = __toESM(require_lib(), 1);
var SemanticVersion = class _SemanticVersion {
  /**
   * @private
   * @param {object} props
   * @param {number} props.major
   * @param {number} props.minor
   * @param {number} props.patch
   */
  constructor(props) {
    this.major = props.major;
    this.minor = props.minor;
    this.patch = props.patch;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ISemanticVersion} version
   * @returns {SemanticVersion}
   */
  static _fromProtobuf(version10) {
    return new _SemanticVersion({
      major: (
        /** @type {number} */
        version10.major
      ),
      minor: (
        /** @type {number} */
        version10.minor
      ),
      patch: (
        /** @type {number} */
        version10.patch
      )
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.ISemanticVersion}
   */
  _toProtobuf() {
    return {
      major: this.major,
      minor: this.minor,
      patch: this.patch
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {SemanticVersion}
   */
  static fromBytes(bytes3) {
    return _SemanticVersion._fromProtobuf(
      HashgraphProto31.proto.SemanticVersion.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto31.proto.SemanticVersion.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/network/NetworkVersionInfo.js
var HashgraphProto32 = __toESM(require_lib(), 1);
var NetworkVersionInfo = class _NetworkVersionInfo {
  /**
   * @private
   * @param {object} props
   * @param {SemanticVersion} props.protobufVersion
   * @param {SemanticVersion} props.servicesVesion
   */
  constructor(props) {
    this.protobufVersion = props.protobufVersion;
    this.servicesVesion = props.servicesVesion;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.INetworkGetVersionInfoResponse} info
   * @returns {NetworkVersionInfo}
   */
  static _fromProtobuf(info) {
    return new _NetworkVersionInfo({
      protobufVersion: SemanticVersion._fromProtobuf(
        /** @type {HashgraphProto.proto.ISemanticVersion} */
        info.hapiProtoVersion
      ),
      servicesVesion: SemanticVersion._fromProtobuf(
        /** @type {HashgraphProto.proto.ISemanticVersion} */
        info.hederaServicesVersion
      )
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.INetworkGetVersionInfoResponse}
   */
  _toProtobuf() {
    return {
      hapiProtoVersion: this.protobufVersion._toProtobuf(),
      hederaServicesVersion: this.servicesVesion._toProtobuf()
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NetworkVersionInfo}
   */
  static fromBytes(bytes3) {
    return _NetworkVersionInfo._fromProtobuf(
      HashgraphProto32.proto.NetworkGetVersionInfoResponse.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto32.proto.NetworkGetVersionInfoResponse.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/network/NetworkVersionInfoQuery.js
var NetworkVersionInfoQuery = class _NetworkVersionInfoQuery extends Query {
  constructor() {
    super();
  }
  /**
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {NetworkVersionInfoQuery}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _fromProtobuf(query) {
    return new _NetworkVersionInfoQuery();
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.network.getVersionInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const networkGetVersionInfo = (
      /** @type {HashgraphProto.proto.INetworkGetVersionInfoResponse} */
      response.networkGetVersionInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      networkGetVersionInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Promise<NetworkVersionInfo>}
   */
  _mapResponse(response) {
    const info = (
      /** @type {HashgraphProto.proto.INetworkGetVersionInfoResponse} */
      response.networkGetVersionInfo
    );
    return Promise.resolve(NetworkVersionInfo._fromProtobuf(info));
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      networkGetVersionInfo: {
        header
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `NetworkVersionInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set(
  "networkGetVersionInfo",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  NetworkVersionInfoQuery._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/Provider.js
var Provider_default = {};

// node_modules/@hashgraph/sdk/src/PrngTransaction.js
var PrngTransaction = class _PrngTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {?number } [props.range]
   */
  constructor(props = {}) {
    super();
    this._range = null;
    if (props.range != null) {
      this.setRange(props.range);
    }
  }
  /**
   * @param {number} newRange
   * @returns {this}
   */
  setRange(newRange) {
    this._range = newRange;
    return this;
  }
  get range() {
    return this._range;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._range != null && isNumber(this._range)) {
      this._validateChecksums(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.TransactionResponse>}
   */
  _execute(channel, request) {
    return channel.util.prng(request);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {PrngTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = (
      /** @type {HashgraphProto.proto.ITransactionBody} */
      bodies[0]
    );
    const transactionRange = (
      /** @type {HashgraphProto.proto.IUtilPrngTransactionBody} */
      body.utilPrng
    );
    return Transaction._fromProtobufTransactions(
      new _PrngTransaction({
        range: transactionRange.range
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "utilPrng";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IUtilPrngTransactionBody}
   */
  _makeTransactionData() {
    return {
      range: this.range
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("./Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `RandomGenerate:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "utilPrng",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  PrngTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/schedule/ScheduleCreateTransaction.js
var HashgraphProto33 = __toESM(require_lib(), 1);
var ScheduleCreateTransaction = class _ScheduleCreateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {Key} [props.adminKey]
   * @param {AccountId} [props.payerAccountID]
   * @param {string} [props.scheduleMemo]
   * @param {Timestamp} [props.expirationTime]
   * @param {boolean} [props.waitForExpiry]
   */
  constructor(props = {}) {
    super();
    this._adminKey = null;
    this._scheduledTransaction = null;
    this._payerAccountId = null;
    this._scheduleMemo = null;
    this._scheduledSignerPublicKeys = /* @__PURE__ */ new Set();
    this._expirationTime = null;
    this._waitForExpiry = null;
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.payerAccountID != null) {
      this.setPayerAccountId(props.payerAccountID);
    }
    if (props.scheduleMemo != null) {
      this.setScheduleMemo(props.scheduleMemo);
    }
    this._defaultMaxTransactionFee = new Hbar(5);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {ScheduleCreateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = (
      /** @type {HashgraphProto.proto.IScheduleCreateTransactionBody} */
      body.scheduleCreate
    );
    const scheduledTransaction = new _ScheduleCreateTransaction({
      adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
      payerAccountID: create.payerAccountID != null ? AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        create.payerAccountID
      ) : void 0,
      scheduleMemo: create.memo != null ? create.memo : void 0,
      waitForExpiry: create.waitForExpiry != null ? create.waitForExpiry : void 0,
      expirationTime: create.expirationTime != null ? Timestamp._fromProtobuf(create.expirationTime) : void 0
    });
    if (body.scheduleCreate != null) {
      const scheduleCreateBody = body.scheduleCreate.scheduledTransactionBody;
      const scheduleCreateBodyBytes = HashgraphProto33.proto.TransactionBody.encode(
        // @ts-ignore
        scheduleCreateBody
      ).finish();
      const signedScheduledCreateTransaction = HashgraphProto33.proto.SignedTransaction.encode({
        bodyBytes: scheduleCreateBodyBytes
      }).finish();
      const scheduleCreatetransaction = {
        signedTransactionBytes: signedScheduledCreateTransaction
      };
      const txlist = HashgraphProto33.proto.TransactionList.encode({
        transactionList: [scheduleCreatetransaction]
      }).finish();
      const finalScheduledDecodedTx = Transaction.fromBytes(txlist);
      scheduledTransaction._setScheduledTransaction(
        finalScheduledDecodedTx
      );
    }
    return Transaction._fromProtobufTransactions(
      scheduledTransaction,
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @internal
   * @param {Transaction} tx
   * @returns {this}
   */
  _setScheduledTransaction(tx) {
    this._scheduledTransaction = tx;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get adminKey() {
    return this._adminKey;
  }
  /**
   * Set the key for this account.
   *
   * This is the key that must sign each transfer out of the account.
   *
   * If `receiverSignatureRequired` is true, then the key must also sign
   * any transfer into the account.
   *
   * @param {Key} key
   * @returns {this}
   */
  setAdminKey(key) {
    this._requireNotFrozen();
    this._adminKey = key;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get payerAccountId() {
    return this._payerAccountId;
  }
  /**
   * @param {AccountId} account
   * @returns {this}
   */
  setPayerAccountId(account) {
    this._requireNotFrozen();
    this._payerAccountId = account;
    return this;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */
  setScheduleMemo(memo) {
    this._requireNotFrozen();
    this._scheduleMemo = memo;
    return this;
  }
  /**
   * @returns {?string}
   */
  get getScheduleMemo() {
    this._requireNotFrozen();
    return this._scheduleMemo;
  }
  /**
   * @param {Transaction} transaction
   * @returns {this}
   */
  setScheduledTransaction(transaction) {
    this._requireNotFrozen();
    transaction._requireNotFrozen();
    this._scheduledTransaction = transaction.schedule()._scheduledTransaction;
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._payerAccountId != null) {
      this._payerAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.schedule.createSchedule(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "scheduleCreate";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IScheduleCreateTransactionBody}
   */
  _makeTransactionData() {
    return {
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      payerAccountID: this._payerAccountId != null ? this._payerAccountId._toProtobuf() : null,
      scheduledTransactionBody: this._scheduledTransaction != null ? this._scheduledTransaction._getScheduledTransactionBody() : null,
      memo: this._scheduleMemo,
      waitForExpiry: this._waitForExpiry,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `ScheduleCreateTransaction:${timestamp.toString()}`;
  }
  /**
   * @param {?Timestamp} expirationTime
   * @returns {this}
   */
  setExpirationTime(expirationTime) {
    this._expirationTime = expirationTime;
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    this._requireNotFrozen();
    return this._expirationTime;
  }
  /**
   * @param {boolean} waitForExpiry
   * @returns {this}
   */
  setWaitForExpiry(waitForExpiry) {
    this._waitForExpiry = waitForExpiry;
    return this;
  }
  /**
   * @returns {?boolean}
   */
  get waitForExpiry() {
    this._requireNotFrozen();
    return this._waitForExpiry;
  }
};
TRANSACTION_REGISTRY.set(
  "scheduleCreate",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  ScheduleCreateTransaction._fromProtobuf
);
SCHEDULE_CREATE_TRANSACTION.push(() => new ScheduleCreateTransaction());

// node_modules/@hashgraph/sdk/src/schedule/ScheduleDeleteTransaction.js
var ScheduleDeleteTransaction = class _ScheduleDeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {ScheduleId | string} [props.scheduleId]
   */
  constructor(props = {}) {
    super();
    this._scheduleId = null;
    if (props.scheduleId != null) {
      this.setScheduleId(props.scheduleId);
    }
    this._defaultMaxTransactionFee = new Hbar(5);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {ScheduleDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const scheduleDelete = (
      /** @type {HashgraphProto.proto.IScheduleDeleteTransactionBody} */
      body.scheduleDelete
    );
    return Transaction._fromProtobufTransactions(
      new _ScheduleDeleteTransaction({
        scheduleId: scheduleDelete.scheduleID != null ? ScheduleId._fromProtobuf(
          /** @type {HashgraphProto.proto.IScheduleID} */
          scheduleDelete.scheduleID
        ) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?ScheduleId}
   */
  get scheduleId() {
    return this._scheduleId;
  }
  /**
   * @param {ScheduleId | string} scheduleId
   * @returns {this}
   */
  setScheduleId(scheduleId) {
    this._requireNotFrozen();
    this._scheduleId = typeof scheduleId === "string" ? ScheduleId.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.schedule.deleteSchedule(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "scheduleDelete";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IScheduleDeleteTransactionBody}
   */
  _makeTransactionData() {
    return {
      scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `ScheduleDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "scheduleDelete",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  ScheduleDeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/schedule/ScheduleInfo.js
var HashgraphProto34 = __toESM(require_lib(), 1);
var { proto: proto36 } = HashgraphProto34;
var ScheduleInfo = class _ScheduleInfo {
  /**
   * @private
   * @param {object} props
   * @param {ScheduleId} props.scheduleId;
   * @param {?AccountId} props.creatorAccountID;
   * @param {?AccountId} props.payerAccountID;
   * @param {?HashgraphProto.proto.ISchedulableTransactionBody} props.schedulableTransactionBody;
   * @param {?Key} props.adminKey
   * @param {?KeyList} props.signers;
   * @param {?string} props.scheduleMemo;
   * @param {?Timestamp} props.expirationTime;
   * @param {?Timestamp} props.executed;
   * @param {?Timestamp} props.deleted;
   * @param {?TransactionId} props.scheduledTransactionId;
   * @param {boolean} props.waitForExpiry;
   */
  constructor(props) {
    this.scheduleId = props.scheduleId;
    this.creatorAccountId = props.creatorAccountID;
    this.payerAccountId = props.payerAccountID;
    this.schedulableTransactionBody = props.schedulableTransactionBody;
    this.signers = props.signers;
    this.scheduleMemo = props.scheduleMemo;
    this.adminKey = props.adminKey != null ? props.adminKey : null;
    this.expirationTime = props.expirationTime;
    this.executed = props.executed;
    this.deleted = props.deleted;
    this.scheduledTransactionId = props.scheduledTransactionId;
    this.waitForExpiry = props.waitForExpiry;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IScheduleInfo} info
   * @returns {ScheduleInfo}
   */
  static _fromProtobuf(info) {
    return new _ScheduleInfo({
      scheduleId: ScheduleId._fromProtobuf(
        /** @type {HashgraphProto.proto.IScheduleID} */
        info.scheduleID
      ),
      creatorAccountID: info.creatorAccountID != null ? AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        info.creatorAccountID
      ) : null,
      payerAccountID: info.payerAccountID != null ? AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        info.payerAccountID
      ) : null,
      schedulableTransactionBody: info.scheduledTransactionBody != null ? info.scheduledTransactionBody : null,
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      signers: info.signers != null ? KeyList2.__fromProtobufKeyList(info.signers) : null,
      scheduleMemo: info.memo != null ? info.memo : null,
      expirationTime: info.expirationTime != null ? Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.expirationTime
      ) : null,
      executed: info.executionTime != null ? Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.executionTime
      ) : null,
      deleted: info.deletionTime != null ? Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.deletionTime
      ) : null,
      scheduledTransactionId: info.scheduledTransactionID != null ? TransactionId._fromProtobuf(info.scheduledTransactionID) : null,
      waitForExpiry: info.waitForExpiry != null ? info.waitForExpiry : false
    });
  }
  /**
   * @returns {HashgraphProto.proto.IScheduleInfo}
   */
  _toProtobuf() {
    return {
      scheduleID: this.scheduleId != null ? this.scheduleId._toProtobuf() : null,
      creatorAccountID: this.creatorAccountId != null ? this.creatorAccountId._toProtobuf() : null,
      payerAccountID: this.payerAccountId != null ? this.payerAccountId._toProtobuf() : null,
      scheduledTransactionBody: this.schedulableTransactionBody != null ? this.schedulableTransactionBody : null,
      adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
      signers: this.signers != null ? this.signers._toProtobufKey().keyList : null,
      memo: this.scheduleMemo != null ? this.scheduleMemo : "",
      expirationTime: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
      scheduledTransactionID: this.scheduledTransactionId != null ? this.scheduledTransactionId._toProtobuf() : null,
      waitForExpiry: this.waitForExpiry
    };
  }
  /**
   * @returns {Transaction}
   */
  get scheduledTransaction() {
    if (this.schedulableTransactionBody == null) {
      throw new Error("Scheduled transaction body is empty");
    }
    const scheduled = new proto36.SchedulableTransactionBody(
      this.schedulableTransactionBody
    );
    const data = (
      /** @type {NonNullable<HashgraphProto.proto.SchedulableTransactionBody["data"]>} */
      scheduled.data
    );
    return Transaction.fromBytes(
      proto36.TransactionList.encode({
        transactionList: [
          {
            signedTransactionBytes: proto36.SignedTransaction.encode({
              bodyBytes: proto36.TransactionBody.encode({
                transactionFee: this.schedulableTransactionBody.transactionFee,
                memo: this.schedulableTransactionBody.memo,
                [data]: scheduled[data]
              }).finish()
            }).finish()
          }
        ]
      }).finish()
    );
  }
};

// node_modules/@hashgraph/sdk/src/schedule/ScheduleInfoQuery.js
var ScheduleInfoQuery = class _ScheduleInfoQuery extends Query {
  /**
   * @param {object} properties
   * @param {ScheduleId | string} [properties.scheduleId]
   */
  constructor(properties = {}) {
    super();
    this._scheduleId = null;
    if (properties.scheduleId != null) {
      this.setScheduleId(properties.scheduleId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {ScheduleInfoQuery}
   */
  static _fromProtobuf(query) {
    const info = (
      /** @type {HashgraphProto.proto.IScheduleGetInfoQuery} */
      query.scheduleGetInfo
    );
    return new _ScheduleInfoQuery({
      scheduleId: info.scheduleID != null ? ScheduleId._fromProtobuf(info.scheduleID) : void 0
    });
  }
  /**
   * @returns {?ScheduleId}
   */
  get scheduleId() {
    return this._scheduleId;
  }
  /**
   *
   * @param {ScheduleId | string} scheduleId
   * @returns {ScheduleInfoQuery}
   */
  setScheduleId(scheduleId) {
    this._scheduleId = typeof scheduleId === "string" ? ScheduleId.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    return super.getCost(client);
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.schedule.getScheduleInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const scheduleGetInfo = (
      /** @type {HashgraphProto.proto.IScheduleGetInfoResponse} */
      response.scheduleGetInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      scheduleGetInfo.header
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<ScheduleInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const info = (
      /** @type {HashgraphProto.proto.IScheduleGetInfoResponse} */
      response.scheduleGetInfo
    );
    return Promise.resolve(
      ScheduleInfo._fromProtobuf(
        /** @type {HashgraphProto.proto.IScheduleInfo} */
        info.scheduleInfo
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      scheduleGetInfo: {
        header,
        scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `ScheduleInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("scheduleGetInfo", ScheduleInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/schedule/ScheduleSignTransaction.js
var ScheduleSignTransaction = class _ScheduleSignTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {ScheduleId | string} [props.scheduleId]
   */
  constructor(props = {}) {
    super();
    this._scheduleId = null;
    if (props.scheduleId != null) {
      this.setScheduleId(props.scheduleId);
    }
    this._defaultMaxTransactionFee = new Hbar(5);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {ScheduleSignTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const sign2 = (
      /** @type {HashgraphProto.proto.IScheduleSignTransactionBody} */
      body.scheduleSign
    );
    return Transaction._fromProtobufTransactions(
      new _ScheduleSignTransaction({
        scheduleId: sign2.scheduleID != null ? ScheduleId._fromProtobuf(sign2.scheduleID) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?ScheduleId}
   */
  get scheduleId() {
    return this._scheduleId;
  }
  /**
   * @param {ScheduleId | string} scheduleId
   * @returns {this}
   */
  setScheduleId(scheduleId) {
    this._requireNotFrozen();
    this._scheduleId = typeof scheduleId === "string" ? ScheduleId.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.schedule.signSchedule(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "scheduleSign";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IScheduleSignTransactionBody}
   */
  _makeTransactionData() {
    return {
      scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `ScheduleSignTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "scheduleSign",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  ScheduleSignTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/Signer.js
var Signer_default = {};

// node_modules/@hashgraph/sdk/src/SignerSignature.js
var SignerSignature = class {
  /**
   * @param {object} props
   * @param {PublicKey} props.publicKey
   * @param {Uint8Array} props.signature
   * @param {AccountId} props.accountId
   */
  constructor(props) {
    this.publicKey = props.publicKey;
    this.signature = props.signature;
    this.accountId = props.accountId;
  }
};

// node_modules/@hashgraph/sdk/src/topic/SubscriptionHandle.js
var SubscriptionHandle = class {
  constructor() {
    this._call = null;
  }
  /**
   * @param {() => void} call
   * @returns {void}
   */
  _setCall(call) {
    this._call = call;
  }
  unsubscribe() {
    if (this._call != null) {
      this._call();
    }
  }
};

// node_modules/@hashgraph/sdk/src/system/SystemDeleteTransaction.js
var SystemDeleteTransaction = class _SystemDeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   * @param {ContractId | string} [props.contractId]
   * @param {Timestamp} [props.expirationTime]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._contractId = null;
    this._expirationTime = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {SystemDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const systemDelete = (
      /** @type {HashgraphProto.proto.ISystemDeleteTransactionBody} */
      body.systemDelete
    );
    return Transaction._fromProtobufTransactions(
      new _SystemDeleteTransaction({
        fileId: systemDelete.fileID != null ? FileId._fromProtobuf(
          /** @type {HashgraphProto.proto.IFileID} */
          systemDelete.fileID
        ) : void 0,
        contractId: systemDelete.contractID != null ? ContractId._fromProtobuf(
          /** @type {HashgraphProto.proto.IContractID} */
          systemDelete.contractID
        ) : void 0,
        expirationTime: systemDelete.expirationTime != null ? Timestamp._fromProtobuf(systemDelete.expirationTime) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * @param {FileId | string} fileId
   * @returns {this}
   */
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = fileId instanceof FileId ? fileId : FileId.fromString(fileId);
    return this;
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * @param {ContractId | string} contractId
   * @returns {this}
   */
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = contractId instanceof ContractId ? contractId : ContractId.fromString(contractId);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp} expirationTime
   * @returns {SystemDeleteTransaction}
   */
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime;
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    if (this._fileId != null) {
      return channel.file.systemDelete(request);
    } else {
      return channel.smartContract.systemDelete(request);
    }
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "systemDelete";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ISystemDeleteTransactionBody}
   */
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `SystemDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set("systemDelete", SystemDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/system/SystemUndeleteTransaction.js
var SystemUndeleteTransaction = class _SystemUndeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   * @param {ContractId | string} [props.contractId]
   * @param {Timestamp} [props.expirationTime]
   */
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._contractId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {SystemUndeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const systemUndelete = (
      /** @type {HashgraphProto.proto.ISystemUndeleteTransactionBody} */
      body.systemUndelete
    );
    return Transaction._fromProtobufTransactions(
      new _SystemUndeleteTransaction({
        fileId: systemUndelete.fileID != null ? FileId._fromProtobuf(
          /** @type {HashgraphProto.proto.IFileID} */
          systemUndelete.fileID
        ) : void 0,
        contractId: systemUndelete.contractID != null ? ContractId._fromProtobuf(
          /** @type {HashgraphProto.proto.IContractID} */
          systemUndelete.contractID
        ) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?FileId}
   */
  get fileId() {
    return this._fileId;
  }
  /**
   * @param {FileId | string} fileId
   * @returns {this}
   */
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = fileId instanceof FileId ? fileId : FileId.fromString(fileId);
    return this;
  }
  /**
   * @returns {?ContractId}
   */
  get contractId() {
    return this._contractId;
  }
  /**
   * @param {ContractId | string} contractId
   * @returns {this}
   */
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = contractId instanceof ContractId ? contractId : ContractId.fromString(contractId);
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    if (this._fileId != null) {
      return channel.file.systemUndelete(request);
    } else {
      return channel.smartContract.systemUndelete(request);
    }
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "systemUndelete";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ISystemUndeleteTransactionBody}
   */
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `SystemUndeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "systemUndelete",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  SystemUndeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenAssociateTransaction.js
var TokenAssociateTransaction = class _TokenAssociateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {(TokenId | string)[]} [props.tokenIds]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._tokenIds = null;
    this._accountId = null;
    this._defaultMaxTransactionFee = new Hbar(5);
    if (props.tokenIds != null) {
      this.setTokenIds(props.tokenIds);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenAssociateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const associateToken = (
      /** @type {HashgraphProto.proto.ITokenAssociateTransactionBody} */
      body.tokenAssociate
    );
    return Transaction._fromProtobufTransactions(
      new _TokenAssociateTransaction({
        tokenIds: associateToken.tokens != null ? associateToken.tokens.map(
          (token) => TokenId._fromProtobuf(token)
        ) : void 0,
        accountId: associateToken.account != null ? AccountId._fromProtobuf(associateToken.account) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId[]}
   */
  get tokenIds() {
    return this._tokenIds;
  }
  /**
   * @param {(TokenId | string)[]} tokenIds
   * @returns {this}
   */
  setTokenIds(tokenIds) {
    this._requireNotFrozen();
    this._tokenIds = tokenIds.map(
      (tokenId) => typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone()
    );
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
      if (tokenId != null) {
        tokenId.validateChecksum(client);
      }
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.associateTokens(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenAssociate";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenAssociateTransactionBody}
   */
  _makeTransactionData() {
    return {
      tokens: this._tokenIds != null ? this._tokenIds.map((tokenId) => tokenId._toProtobuf()) : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenAssociateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenAssociate",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenAssociateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenBurnTransaction.js
var import_long40 = __toESM(require_long(), 1);
var TokenBurnTransaction = class _TokenBurnTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {Long | number} [props.amount]
   * @param {(Long | number)[]} [props.serials]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._amount = null;
    this._serials = [];
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    if (props.serials != null) {
      this.setSerials(props.serials);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenBurnTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const burnToken = (
      /** @type {HashgraphProto.proto.ITokenBurnTransactionBody} */
      body.tokenBurn
    );
    return Transaction._fromProtobufTransactions(
      new _TokenBurnTransaction({
        tokenId: burnToken.token != null ? TokenId._fromProtobuf(burnToken.token) : void 0,
        amount: burnToken.amount != null ? burnToken.amount : void 0,
        serials: burnToken.serialNumbers != null ? burnToken.serialNumbers : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */
  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {this}
   */
  setAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof import_long40.default ? amount : import_long40.default.fromValue(amount);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  /**
   * @returns {Long[]}
   */
  get serials() {
    return this._serials;
  }
  /**
   * @param {(Long | number)[]} serials
   * @returns {this}
   */
  setSerials(serials) {
    this._requireNotFrozen();
    this._serials = serials.map(
      (serial) => serial instanceof import_long40.default ? serial : import_long40.default.fromValue(serial)
    );
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.burnToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenBurn";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenBurnTransactionBody}
   */
  _makeTransactionData() {
    return {
      amount: this._amount,
      serialNumbers: this._serials,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenBurnTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenBurn",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenBurnTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenCreateTransaction.js
var import_long41 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/token/TokenType.js
var TokenType = class _TokenType {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _TokenType.FungibleCommon:
        return "FUNGIBLE_COMMON";
      case _TokenType.NonFungibleUnique:
        return "NON_FUNGIBLE_UNIQUE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @internal
   * @param {number} code
   * @returns {TokenType}
   */
  static _fromCode(code) {
    switch (code) {
      case 0:
        return _TokenType.FungibleCommon;
      case 1:
        return _TokenType.NonFungibleUnique;
    }
    throw new Error(
      `(BUG) TokenType.fromCode() does not handle code: ${code}`
    );
  }
  /**
   * @returns {HashgraphProto.proto.TokenType}
   */
  valueOf() {
    return this._code;
  }
};
TokenType.FungibleCommon = new TokenType(0);
TokenType.NonFungibleUnique = new TokenType(1);

// node_modules/@hashgraph/sdk/src/token/TokenSupplyType.js
var TokenSupplyType = class _TokenSupplyType {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _TokenSupplyType.Infinite:
        return "INFINITE";
      case _TokenSupplyType.Finite:
        return "FINITE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @internal
   * @param {number} code
   * @returns {TokenSupplyType}
   */
  static _fromCode(code) {
    switch (code) {
      case 0:
        return _TokenSupplyType.Infinite;
      case 1:
        return _TokenSupplyType.Finite;
    }
    throw new Error(
      `(BUG) TokenSupplyType.fromCode() does not handle code: ${code}`
    );
  }
  /**
   * @returns {HashgraphProto.proto.TokenSupplyType}
   */
  valueOf() {
    return this._code;
  }
};
TokenSupplyType.Infinite = new TokenSupplyType(0);
TokenSupplyType.Finite = new TokenSupplyType(1);

// node_modules/@hashgraph/sdk/src/token/TokenCreateTransaction.js
var TokenCreateTransaction = class _TokenCreateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {string} [props.tokenName]
   * @param {string} [props.tokenSymbol]
   * @param {Long | number} [props.decimals]
   * @param {Long | number} [props.initialSupply]
   * @param {AccountId | string} [props.treasuryAccountId]
   * @param {Key} [props.adminKey]
   * @param {Key} [props.kycKey]
   * @param {Key} [props.freezeKey]
   * @param {Key} [props.pauseKey]
   * @param {Key} [props.wipeKey]
   * @param {Key} [props.supplyKey]
   * @param {Key} [props.feeScheduleKey]
   * @param {boolean} [props.freezeDefault]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.tokenMemo]
   * @param {CustomFee[]} [props.customFees]
   * @param {TokenType} [props.tokenType]
   * @param {TokenSupplyType} [props.supplyType]
   * @param {Long | number} [props.maxSupply]
   */
  constructor(props = {}) {
    super();
    this._tokenName = null;
    this._tokenSymbol = null;
    this._decimals = null;
    this._initialSupply = null;
    this._treasuryAccountId = null;
    this._adminKey = null;
    this._kycKey = null;
    this._freezeKey = null;
    this._pauseKey = null;
    this._wipeKey = null;
    this._supplyKey = null;
    this._feeScheduleKey = null;
    this._freezeDefault = null;
    this._autoRenewAccountId = null;
    this._expirationTime = new Timestamp(
      Math.floor(
        Date.now() / 1e3 + DEFAULT_AUTO_RENEW_PERIOD.toNumber()
      ),
      0
    );
    this._autoRenewPeriod = new Duration2(DEFAULT_AUTO_RENEW_PERIOD);
    this._tokenMemo = null;
    this._customFees = [];
    this._tokenType = null;
    this._supplyType = null;
    this._maxSupply = null;
    this._defaultMaxTransactionFee = new Hbar(30);
    if (props.tokenName != null) {
      this.setTokenName(props.tokenName);
    }
    if (props.tokenSymbol != null) {
      this.setTokenSymbol(props.tokenSymbol);
    }
    if (props.decimals != null) {
      this.setDecimals(props.decimals);
    }
    if (props.initialSupply != null) {
      this.setInitialSupply(props.initialSupply);
    }
    if (props.treasuryAccountId != null) {
      this.setTreasuryAccountId(props.treasuryAccountId);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.kycKey != null) {
      this.setKycKey(props.kycKey);
    }
    if (props.freezeKey != null) {
      this.setFreezeKey(props.freezeKey);
    }
    if (props.pauseKey != null) {
      this.setPauseKey(props.pauseKey);
    }
    if (props.wipeKey != null) {
      this.setWipeKey(props.wipeKey);
    }
    if (props.supplyKey != null) {
      this.setSupplyKey(props.supplyKey);
    }
    if (props.feeScheduleKey != null) {
      this.setFeeScheduleKey(props.feeScheduleKey);
    }
    if (props.freezeDefault != null) {
      this.setFreezeDefault(props.freezeDefault);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.tokenMemo != null) {
      this.setTokenMemo(props.tokenMemo);
    }
    if (props.customFees != null) {
      this.setCustomFees(props.customFees);
    }
    if (props.tokenType != null) {
      this.setTokenType(props.tokenType);
    }
    if (props.supplyType != null) {
      this.setSupplyType(props.supplyType);
    }
    if (props.maxSupply != null) {
      this.setMaxSupply(props.maxSupply);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenCreateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = (
      /** @type {HashgraphProto.proto.ITokenCreateTransactionBody} */
      body.tokenCreation
    );
    return Transaction._fromProtobufTransactions(
      new _TokenCreateTransaction({
        tokenName: create.name != null ? create.name : void 0,
        tokenSymbol: create.symbol != null ? create.symbol : void 0,
        decimals: create.decimals != null ? create.decimals : void 0,
        initialSupply: create.initialSupply != null ? create.initialSupply : void 0,
        treasuryAccountId: create.treasury != null ? AccountId._fromProtobuf(create.treasury) : void 0,
        adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
        kycKey: create.kycKey != null ? Key2._fromProtobufKey(create.kycKey) : void 0,
        freezeKey: create.freezeKey != null ? Key2._fromProtobufKey(create.freezeKey) : void 0,
        pauseKey: create.pauseKey != null ? Key2._fromProtobufKey(create.pauseKey) : void 0,
        wipeKey: create.wipeKey != null ? Key2._fromProtobufKey(create.wipeKey) : void 0,
        supplyKey: create.supplyKey != null ? Key2._fromProtobufKey(create.supplyKey) : void 0,
        feeScheduleKey: create.feeScheduleKey != null ? Key2._fromProtobufKey(create.feeScheduleKey) : void 0,
        freezeDefault: create.freezeDefault != null ? create.freezeDefault : void 0,
        autoRenewAccountId: create.autoRenewAccount != null ? AccountId._fromProtobuf(create.autoRenewAccount) : void 0,
        expirationTime: create.expiry != null ? Timestamp._fromProtobuf(create.expiry) : void 0,
        autoRenewPeriod: create.autoRenewPeriod != null ? Duration2._fromProtobuf(create.autoRenewPeriod) : void 0,
        tokenMemo: create.memo != null ? create.memo : void 0,
        customFees: create.customFees != null ? create.customFees.map((fee) => {
          if (fee.fixedFee != null) {
            return CustomFixedFee._fromProtobuf(fee);
          } else if (fee.fractionalFee != null) {
            return CustomFractionalFee._fromProtobuf(fee);
          } else {
            return CustomRoyalyFee._fromProtobuf(fee);
          }
        }) : void 0,
        tokenType: create.tokenType != null ? TokenType._fromCode(create.tokenType) : void 0,
        supplyType: create.supplyType != null ? TokenSupplyType._fromCode(create.supplyType) : void 0,
        maxSupply: create.maxSupply != null ? create.maxSupply : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?string}
   */
  get tokenName() {
    return this._tokenName;
  }
  /**
   * @param {string} name
   * @returns {this}
   */
  setTokenName(name) {
    this._requireNotFrozen();
    this._tokenName = name;
    return this;
  }
  /**
   * @returns {?string}
   */
  get tokenSymbol() {
    return this._tokenSymbol;
  }
  /**
   * @param {string} symbol
   * @returns {this}
   */
  setTokenSymbol(symbol) {
    this._requireNotFrozen();
    this._tokenSymbol = symbol;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get decimals() {
    return this._decimals;
  }
  /**
   * @param {Long | number} decimals
   * @returns {this}
   */
  setDecimals(decimals) {
    this._requireNotFrozen();
    this._decimals = decimals instanceof import_long41.default ? decimals : import_long41.default.fromValue(decimals);
    return this;
  }
  /**
   * @returns {?Long}
   */
  get initialSupply() {
    return this._initialSupply;
  }
  /**
   * @param {Long | number} initialSupply
   * @returns {this}
   */
  setInitialSupply(initialSupply) {
    this._requireNotFrozen();
    this._initialSupply = import_long41.default.fromValue(initialSupply);
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */
  setTreasuryAccountId(id2) {
    this._requireNotFrozen();
    this._treasuryAccountId = typeof id2 === "string" ? AccountId.fromString(id2) : id2.clone();
    return this;
  }
  /**
   * @returns {?Key}
   */
  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setAdminKey(key) {
    this._requireNotFrozen();
    this._adminKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get kycKey() {
    return this._kycKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setKycKey(key) {
    this._requireNotFrozen();
    this._kycKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get freezeKey() {
    return this._freezeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setFreezeKey(key) {
    this._requireNotFrozen();
    this._freezeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get pauseKey() {
    return this._pauseKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setPauseKey(key) {
    this._requireNotFrozen();
    this._pauseKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get wipeKey() {
    return this._wipeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setWipeKey(key) {
    this._requireNotFrozen();
    this._wipeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get supplyKey() {
    return this._supplyKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setSupplyKey(key) {
    this._requireNotFrozen();
    this._supplyKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get feeScheduleKey() {
    return this._feeScheduleKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setFeeScheduleKey(key) {
    this._requireNotFrozen();
    this._feeScheduleKey = key;
    return this;
  }
  /**
   * @returns {?boolean}
   */
  get freezeDefault() {
    return this._freezeDefault;
  }
  /**
   * @param {boolean} freeze
   * @returns {this}
   */
  setFreezeDefault(freeze) {
    this._requireNotFrozen();
    this._freezeDefault = freeze;
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp | Date} time
   * @returns {this}
   */
  setExpirationTime(time) {
    this._requireNotFrozen();
    this._expirationTime = time instanceof Timestamp ? time : Timestamp.fromDate(time);
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */
  setAutoRenewAccountId(id2) {
    this._requireNotFrozen();
    this._autoRenewAccountId = id2 instanceof AccountId ? id2 : AccountId.fromString(id2);
    return this;
  }
  /**
   * @returns {?Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this token.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?string}
   */
  get tokenMemo() {
    return this._tokenMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */
  setTokenMemo(memo) {
    this._requireNotFrozen();
    this._tokenMemo = memo;
    return this;
  }
  /**
   * @returns {CustomFee[]}
   */
  get customFees() {
    return this._customFees;
  }
  /**
   * @param {CustomFee[]} customFees
   * @returns {this}
   */
  setCustomFees(customFees) {
    this._customFees = customFees;
    return this;
  }
  /**
   * @returns {?TokenType}
   */
  get tokenType() {
    return this._tokenType;
  }
  /**
   * @param {TokenType} tokenType
   * @returns {this}
   */
  setTokenType(tokenType) {
    this._tokenType = tokenType;
    return this;
  }
  /**
   * @returns {?TokenSupplyType}
   */
  get supplyType() {
    return this._supplyType;
  }
  /**
   * @param {TokenSupplyType} supplyType
   * @returns {this}
   */
  setSupplyType(supplyType) {
    this._supplyType = supplyType;
    return this;
  }
  /**
   * @returns {?Long}
   */
  get maxSupply() {
    return this._maxSupply;
  }
  /**
   * @param {Long | number} maxSupply
   * @returns {this}
   */
  setMaxSupply(maxSupply) {
    this._maxSupply = typeof maxSupply === "number" ? import_long41.default.fromNumber(maxSupply) : maxSupply;
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._treasuryAccountId != null) {
      this._treasuryAccountId.validateChecksum(client);
    }
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.createToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenCreation";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenCreateTransactionBody}
   */
  _makeTransactionData() {
    return {
      name: this._tokenName,
      symbol: this._tokenSymbol,
      decimals: this._decimals != null ? this._decimals.toInt() : null,
      initialSupply: this._initialSupply,
      treasury: this._treasuryAccountId != null ? this._treasuryAccountId._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
      freezeKey: this._freezeKey != null ? this._freezeKey._toProtobufKey() : null,
      pauseKey: this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
      wipeKey: this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
      supplyKey: this._supplyKey != null ? this._supplyKey._toProtobufKey() : null,
      feeScheduleKey: this._feeScheduleKey != null ? this._feeScheduleKey._toProtobufKey() : null,
      freezeDefault: this._freezeDefault,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      expiry: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      memo: this._tokenMemo,
      customFees: this.customFees.map((fee) => fee._toProtobuf()),
      tokenType: this._tokenType != null ? this._tokenType._code : null,
      supplyType: this._supplyType != null ? this._supplyType._code : null,
      maxSupply: this.maxSupply
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenCreateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenCreation",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenCreateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenDeleteTransaction.js
var TokenDeleteTransaction = class _TokenDeleteTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const deleteToken = (
      /** @type {HashgraphProto.proto.ITokenDeleteTransactionBody} */
      body.tokenDeletion
    );
    return Transaction._fromProtobufTransactions(
      new _TokenDeleteTransaction({
        tokenId: deleteToken.token != null ? TokenId._fromProtobuf(deleteToken.token) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.deleteToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenDeletion";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenDeleteTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenDeletion",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenDeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenDissociateTransaction.js
var TokenDissociateTransaction = class _TokenDissociateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {(TokenId | string)[]} [props.tokenIds]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._tokenIds = null;
    this._accountId = null;
    this._defaultMaxTransactionFee = new Hbar(5);
    if (props.tokenIds != null) {
      this.setTokenIds(props.tokenIds);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenDissociateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const dissociateToken = (
      /** @type {HashgraphProto.proto.ITokenDissociateTransactionBody} */
      body.tokenDissociate
    );
    return Transaction._fromProtobufTransactions(
      new _TokenDissociateTransaction({
        tokenIds: dissociateToken.tokens != null ? dissociateToken.tokens.map(
          (token) => TokenId._fromProtobuf(token)
        ) : void 0,
        accountId: dissociateToken.account != null ? AccountId._fromProtobuf(dissociateToken.account) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId[]}
   */
  get tokenIds() {
    return this._tokenIds;
  }
  /**
   * @param {(TokenId | string)[]} tokenIds
   * @returns {this}
   */
  setTokenIds(tokenIds) {
    this._requireNotFrozen();
    this._tokenIds = tokenIds.map(
      (tokenId) => typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone()
    );
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
      if (tokenId != null) {
        tokenId.validateChecksum(client);
      }
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.dissociateTokens(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenDissociate";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenDissociateTransactionBody}
   */
  _makeTransactionData() {
    return {
      tokens: this._tokenIds != null ? this._tokenIds.map((tokenId) => tokenId._toProtobuf()) : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenDissociateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenDissociate",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenDissociateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenFeeScheduleUpdateTransaction.js
var TokenFeeScheduleUpdateTransaction = class _TokenFeeScheduleUpdateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {CustomFee[]} [props.customFees]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._customFees = [];
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.customFees != null) {
      this.setCustomFees(props.customFees);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenFeeScheduleUpdateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const feeScheduleUpdate = (
      /** @type {HashgraphProto.proto.ITokenFeeScheduleUpdateTransactionBody} */
      body.tokenFeeScheduleUpdate
    );
    return Transaction._fromProtobufTransactions(
      new _TokenFeeScheduleUpdateTransaction({
        tokenId: feeScheduleUpdate.tokenId != null ? TokenId._fromProtobuf(feeScheduleUpdate.tokenId) : void 0,
        customFees: feeScheduleUpdate.customFees != null ? feeScheduleUpdate.customFees.map((fee) => {
          if (fee.fixedFee != null) {
            return CustomFixedFee._fromProtobuf(fee);
          } else if (fee.fractionalFee != null) {
            return CustomFractionalFee._fromProtobuf(fee);
          } else {
            return CustomRoyalyFee._fromProtobuf(fee);
          }
        }) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : TokenId._fromProtobuf(tokenId._toProtobuf());
    return this;
  }
  /**
   * @returns {CustomFee[]}
   */
  get customFees() {
    return this._customFees;
  }
  /**
   * @param {CustomFee[]} fees
   * @returns {this}
   */
  setCustomFees(fees) {
    this._requireNotFrozen();
    this._customFees = fees;
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.updateTokenFeeSchedule(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenFeeScheduleUpdate";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenFeeScheduleUpdateTransactionBody}
   */
  _makeTransactionData() {
    return {
      tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      customFees: this._customFees.map((fee) => fee._toProtobuf())
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenFeeScheduleUpdateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenFeeScheduleUpdate",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenFeeScheduleUpdateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenFreezeTransaction.js
var TokenFreezeTransaction = class _TokenFreezeTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenFreezeTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const freezeToken = (
      /** @type {HashgraphProto.proto.ITokenFreezeAccountTransactionBody} */
      body.tokenFreeze
    );
    return Transaction._fromProtobufTransactions(
      new _TokenFreezeTransaction({
        tokenId: freezeToken.token != null ? TokenId._fromProtobuf(freezeToken.token) : void 0,
        accountId: freezeToken.account != null ? AccountId._fromProtobuf(freezeToken.account) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.freezeTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenFreeze";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenFreezeAccountTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenFreezeTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenFreeze",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenFreezeTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenGrantKycTransaction.js
var TokenGrantKycTransaction = class _TokenGrantKycTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenGrantKycTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const grantKycToken = (
      /** @type {HashgraphProto.proto.ITokenGrantKycTransactionBody} */
      body.tokenGrantKyc
    );
    return Transaction._fromProtobufTransactions(
      new _TokenGrantKycTransaction({
        tokenId: grantKycToken.token != null ? TokenId._fromProtobuf(grantKycToken.token) : void 0,
        accountId: grantKycToken.account != null ? AccountId._fromProtobuf(grantKycToken.account) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.grantKycToTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenGrantKyc";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenGrantKycTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenGrantKycTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenGrantKyc",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenGrantKycTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenInfo.js
var import_long42 = __toESM(require_long(), 1);
var HashgraphProto35 = __toESM(require_lib(), 1);
var TokenInfo = class _TokenInfo {
  /**
   * @private
   * @param {object} props
   * @param {TokenId} props.tokenId;
   * @param {string} props.name;
   * @param {string} props.symbol;
   * @param {number} props.decimals;
   * @param {Long} props.totalSupply;
   * @param {AccountId | null} props.treasuryAccountId;
   * @param {Key | null} props.adminKey;
   * @param {Key | null} props.kycKey;
   * @param {Key | null} props.freezeKey;
   * @param {Key | null} props.pauseKey;
   * @param {Key | null} props.wipeKey;
   * @param {Key | null} props.supplyKey;
   * @param {Key | null} props.feeScheduleKey;
   * @param {boolean | null} props.defaultFreezeStatus;
   * @param {boolean | null} props.defaultKycStatus;
   * @param {boolean | null} props.pauseStatus;
   * @param {boolean} props.isDeleted;
   * @param {AccountId | null} props.autoRenewAccountId;
   * @param {Duration | null} props.autoRenewPeriod;
   * @param {Timestamp | null} props.expirationTime;
   * @param {string} props.tokenMemo;
   * @param {CustomFee[]} props.customFees;
   * @param {TokenType | null} props.tokenType;
   * @param {TokenSupplyType | null} props.supplyType;
   * @param {Long | null} props.maxSupply;
   * @param {LedgerId|null} props.ledgerId
   */
  constructor(props) {
    this.tokenId = props.tokenId;
    this.name = props.name;
    this.symbol = props.symbol;
    this.decimals = props.decimals;
    this.totalSupply = props.totalSupply;
    this.treasuryAccountId = props.treasuryAccountId;
    this.adminKey = props.adminKey;
    this.kycKey = props.kycKey;
    this.freezeKey = props.freezeKey;
    this.pauseKey = props.pauseKey;
    this.wipeKey = props.wipeKey;
    this.supplyKey = props.supplyKey;
    this.feeScheduleKey = props.feeScheduleKey;
    this.defaultFreezeStatus = props.defaultFreezeStatus;
    this.defaultKycStatus = props.defaultKycStatus;
    this.pauseStatus = props.pauseStatus;
    this.isDeleted = props.isDeleted;
    this.autoRenewAccountId = props.autoRenewAccountId;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.expirationTime = props.expirationTime;
    this.tokenMemo = props.tokenMemo;
    this.customFees = props.customFees;
    this.tokenType = props.tokenType;
    this.supplyType = props.supplyType;
    this.maxSupply = props.maxSupply;
    this.ledgerId = props.ledgerId;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITokenInfo} info
   * @returns {TokenInfo}
   */
  static _fromProtobuf(info) {
    const defaultFreezeStatus = (
      /** @type {HashgraphProto.proto.TokenFreezeStatus} */
      info.defaultFreezeStatus
    );
    const defaultKycStatus = (
      /** @type {HashgraphProto.proto.TokenKycStatus} */
      info.defaultKycStatus
    );
    const pauseStatus = (
      /**@type {HashgraphProto.proto.TokenPauseStatus} */
      info.pauseStatus
    );
    const autoRenewAccountId = info.autoRenewAccount != null ? AccountId._fromProtobuf(info.autoRenewAccount) : new AccountId(0);
    return new _TokenInfo({
      tokenId: TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        info.tokenId
      ),
      name: (
        /** @type {string} */
        info.name
      ),
      symbol: (
        /** @type {string} */
        info.symbol
      ),
      decimals: (
        /** @type {number} */
        info.decimals
      ),
      totalSupply: import_long42.default.fromValue(
        /** @type {Long} */
        info.totalSupply
      ),
      treasuryAccountId: info.treasury != null ? AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        info.treasury
      ) : null,
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      kycKey: info.kycKey != null ? Key2._fromProtobufKey(info.kycKey) : null,
      freezeKey: info.freezeKey != null ? Key2._fromProtobufKey(info.freezeKey) : null,
      pauseKey: info.pauseKey != null ? Key2._fromProtobufKey(info.pauseKey) : null,
      wipeKey: info.wipeKey != null ? Key2._fromProtobufKey(info.wipeKey) : null,
      supplyKey: info.supplyKey != null ? Key2._fromProtobufKey(info.supplyKey) : null,
      feeScheduleKey: info.feeScheduleKey != null ? Key2._fromProtobufKey(info.feeScheduleKey) : null,
      defaultFreezeStatus: defaultFreezeStatus === 0 ? null : defaultFreezeStatus == 1,
      defaultKycStatus: defaultKycStatus === 0 ? null : defaultKycStatus == 1,
      pauseStatus: pauseStatus === 0 ? null : pauseStatus == 1,
      isDeleted: (
        /** @type {boolean} */
        info.deleted
      ),
      autoRenewAccountId: !(autoRenewAccountId.shard.toInt() == 0 && autoRenewAccountId.realm.toInt() == 0 && autoRenewAccountId.num.toInt() == 0) ? autoRenewAccountId : null,
      autoRenewPeriod: info.autoRenewPeriod != null ? Duration2._fromProtobuf(
        /** @type {HashgraphProto.proto.IDuration} */
        info.autoRenewPeriod
      ) : null,
      expirationTime: info.expiry != null ? Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.expiry
      ) : null,
      tokenMemo: info.memo != null ? info.memo : "",
      customFees: info.customFees != null ? info.customFees.map((fee) => {
        if (fee.fixedFee != null) {
          return CustomFixedFee._fromProtobuf(fee);
        } else if (fee.fractionalFee != null) {
          return CustomFractionalFee._fromProtobuf(fee);
        } else {
          return CustomRoyalyFee._fromProtobuf(fee);
        }
      }) : [],
      tokenType: info.tokenType != null ? TokenType._fromCode(info.tokenType) : null,
      supplyType: info.supplyType != null ? TokenSupplyType._fromCode(info.supplyType) : null,
      maxSupply: info.maxSupply != null ? info.maxSupply : null,
      ledgerId: info.ledgerId != null ? LedgerId.fromBytes(info.ledgerId) : null
    });
  }
  /**
   * @returns {HashgraphProto.proto.ITokenInfo}
   */
  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      name: this.name,
      symbol: this.symbol,
      decimals: this.decimals,
      totalSupply: this.totalSupply,
      treasury: this.treasuryAccountId != null ? this.treasuryAccountId._toProtobuf() : null,
      adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
      kycKey: this.kycKey != null ? this.kycKey._toProtobufKey() : null,
      freezeKey: this.freezeKey != null ? this.freezeKey._toProtobufKey() : null,
      pauseKey: this.pauseKey != null ? this.pauseKey._toProtobufKey() : null,
      wipeKey: this.wipeKey != null ? this.wipeKey._toProtobufKey() : null,
      supplyKey: this.supplyKey != null ? this.supplyKey._toProtobufKey() : null,
      feeScheduleKey: this.feeScheduleKey != null ? this.feeScheduleKey._toProtobufKey() : null,
      defaultFreezeStatus: this.defaultFreezeStatus == null ? 0 : this.defaultFreezeStatus ? 1 : 2,
      defaultKycStatus: this.defaultKycStatus == null ? 0 : this.defaultKycStatus ? 1 : 2,
      pauseStatus: this.pauseStatus == null ? 0 : this.pauseStatus ? 1 : 2,
      deleted: this.isDeleted,
      autoRenewAccount: this.autoRenewAccountId != null ? this.autoRenewAccountId._toProtobuf() : void 0,
      autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
      expiry: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
      memo: this.tokenMemo,
      customFees: this.customFees.map((fee) => fee._toProtobuf()),
      tokenType: this.tokenType != null ? this.tokenType._code : null,
      supplyType: this.supplyType != null ? this.supplyType._code : null,
      maxSupply: this.maxSupply,
      ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TokenInfo}
   */
  static fromBytes(bytes3) {
    return _TokenInfo._fromProtobuf(
      HashgraphProto35.proto.TokenInfo.decode(bytes3)
    );
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto35.proto.TokenInfo.encode(
      this._toProtobuf()
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenInfoQuery.js
var TokenInfoQuery = class _TokenInfoQuery extends Query {
  /**
   * @param {object} properties
   * @param {TokenId | string} [properties.tokenId]
   */
  constructor(properties = {}) {
    super();
    this._tokenId = null;
    if (properties.tokenId != null) {
      this.setTokenId(properties.tokenId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {TokenInfoQuery}
   */
  static _fromProtobuf(query) {
    const info = (
      /** @type {HashgraphProto.proto.ITokenGetInfoQuery} */
      query.tokenGetInfo
    );
    return new _TokenInfoQuery({
      tokenId: info.token != null ? TokenId._fromProtobuf(info.token) : void 0
    });
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * Set the token ID for which the info is being requested.
   *
   * @param {TokenId | string} tokenId
   * @returns {TokenInfoQuery}
   */
  setTokenId(tokenId) {
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    return super.getCost(client);
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.token.getTokenInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const tokenGetInfo = (
      /** @type {HashgraphProto.proto.ITokenGetInfoResponse} */
      response.tokenGetInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      tokenGetInfo.header
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<TokenInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const info = (
      /** @type {HashgraphProto.proto.ITokenGetInfoResponse} */
      response.tokenGetInfo
    );
    return Promise.resolve(
      TokenInfo._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenInfo} */
        info.tokenInfo
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      tokenGetInfo: {
        header,
        token: this._tokenId != null ? this._tokenId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `TokenInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("tokenGetInfo", TokenInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenMintTransaction.js
var import_long43 = __toESM(require_long(), 1);
var TokenMintTransaction = class _TokenMintTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {Long | number} [props.amount]
   * @param {Uint8Array[]} [props.metadata]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._amount = null;
    this._metadata = [];
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    if (props.metadata != null) {
      this.setMetadata(props.metadata);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenMintTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const mintToken = (
      /** @type {HashgraphProto.proto.ITokenMintTransactionBody} */
      body.tokenMint
    );
    return Transaction._fromProtobufTransactions(
      new _TokenMintTransaction({
        tokenId: mintToken.token != null ? TokenId._fromProtobuf(mintToken.token) : void 0,
        amount: mintToken.amount != null ? mintToken.amount : void 0,
        metadata: mintToken.metadata != null ? mintToken.metadata : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */
  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {this}
   */
  setAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof import_long43.default ? amount : import_long43.default.fromValue(amount);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  /**
   * @returns {Uint8Array[]}
   */
  get metadata() {
    return this._metadata;
  }
  /**
   * @param {Uint8Array | string} metadata
   * @returns {this}
   */
  addMetadata(metadata) {
    this._requireNotFrozen();
    if (typeof metadata === "string") {
      console.warn(
        "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead."
      );
    }
    this._metadata.push(
      typeof metadata === "string" ? decode(metadata) : metadata
    );
    return this;
  }
  /**
   * @param {Uint8Array[]} metadata
   * @returns {this}
   */
  setMetadata(metadata) {
    this._requireNotFrozen();
    for (const data of metadata) {
      if (typeof data === "string") {
        console.warn(
          "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead."
        );
        break;
      }
    }
    this._metadata = metadata.map(
      (data) => typeof data === "string" ? decode(data) : data
    );
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.mintToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenMint";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenMintTransactionBody}
   */
  _makeTransactionData() {
    return {
      amount: this._amount,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      metadata: this._metadata
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenMintTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenMint",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenMintTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenNftInfo.js
var TokenNftInfo = class _TokenNftInfo {
  /**
   * @private
   * @param {object} props
   * @param {NftId} props.nftId
   * @param {AccountId} props.accountId
   * @param {Timestamp} props.creationTime
   * @param {Uint8Array | null} props.metadata
   * @param {LedgerId|null} props.ledgerId
   * @param {AccountId|null} props.spenderId
   */
  constructor(props) {
    this.nftId = props.nftId;
    this.accountId = props.accountId;
    this.creationTime = props.creationTime;
    this.metadata = props.metadata;
    this.ledgerId = props.ledgerId;
    this.spenderId = props.spenderId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITokenNftInfo} info
   * @returns {TokenNftInfo}
   */
  static _fromProtobuf(info) {
    return new _TokenNftInfo({
      nftId: NftId._fromProtobuf(
        /** @type {HashgraphProto.proto.INftID} */
        info.nftID
      ),
      accountId: AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        info.accountID
      ),
      creationTime: Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        info.creationTime
      ),
      metadata: info.metadata !== void 0 ? info.metadata : null,
      ledgerId: info.ledgerId != null ? LedgerId.fromBytes(info.ledgerId) : null,
      spenderId: info.spenderId != null ? AccountId._fromProtobuf(info.spenderId) : null
    });
  }
  /**
   * @returns {HashgraphProto.proto.ITokenNftInfo}
   */
  _toProtobuf() {
    return {
      nftID: this.nftId._toProtobuf(),
      accountID: this.accountId._toProtobuf(),
      creationTime: this.creationTime._toProtobuf(),
      metadata: this.metadata,
      ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
      spenderId: this.spenderId != null ? this.spenderId._toProtobuf() : null
    };
  }
  /**
   * @typedef {object} TokenNftInfoJson
   * @property {string} nftId
   * @property {string} accountId
   * @property {string} creationTime
   * @property {string | null} metadata
   * @property {string | null} ledgerId
   * @property {string | null} spenderId
   * @returns {TokenNftInfoJson}
   */
  toJson() {
    return {
      nftId: this.nftId.toString(),
      accountId: this.accountId.toString(),
      creationTime: this.creationTime.toString(),
      metadata: this.metadata != null ? encode(this.metadata) : null,
      ledgerId: this.ledgerId != null ? this.ledgerId.toString() : null,
      spenderId: this.spenderId != null ? this.spenderId.toString() : null
    };
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toJson());
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenNftInfoQuery.js
var import_long44 = __toESM(require_long(), 1);
var TokenNftInfoQuery = class _TokenNftInfoQuery extends Query {
  /**
   * @param {object} properties
   * @param {NftId | string} [properties.nftId]
   * @param {AccountId | string} [properties.accountId]
   * @param {TokenId | string} [properties.tokenId]
   * @param {Long | number} [properties.start]
   * @param {Long | number} [properties.end]
   */
  constructor(properties = {}) {
    super();
    this._nftId = null;
    if (properties.nftId != null) {
      this.setNftId(properties.nftId);
    }
    this._accountId = null;
    if (properties.accountId != null) {
      this.setAccountId(properties.accountId);
    }
    this._tokenId = null;
    if (properties.tokenId != null) {
      this.setTokenId(properties.tokenId);
    }
    this._start = null;
    if (properties.start != null) {
      this.setStart(properties.start);
    }
    this._end = null;
    if (properties.end != null) {
      this.setEnd(properties.end);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {TokenNftInfoQuery}
   */
  static _fromProtobuf(query) {
    if (query.tokenGetNftInfo != null) {
      const info = (
        /** @type {HashgraphProto.proto.ITokenGetNftInfoQuery} */
        query.tokenGetNftInfo
      );
      return new _TokenNftInfoQuery({
        nftId: info.nftID != null ? NftId._fromProtobuf(info.nftID) : void 0
      });
    } else if (query.tokenGetAccountNftInfos != null) {
      const info = (
        /** @type {HashgraphProto.proto.ITokenGetAccountNftInfosQuery} */
        query.tokenGetAccountNftInfos
      );
      return new _TokenNftInfoQuery({
        accountId: info.accountID != null ? AccountId._fromProtobuf(info.accountID) : void 0,
        start: info.start != null ? info.start : void 0,
        end: info.end != null ? info.end : void 0
      });
    } else {
      const info = (
        /** @type {HashgraphProto.proto.ITokenGetNftInfosQuery} */
        query.tokenGetNftInfos
      );
      return new _TokenNftInfoQuery({
        tokenId: info.tokenID != null ? TokenId._fromProtobuf(info.tokenID) : void 0,
        start: info.start != null ? info.start : void 0,
        end: info.end != null ? info.end : void 0
      });
    }
  }
  /**
   * @returns {?NftId}
   */
  get nftId() {
    return this._nftId;
  }
  /**
   * Set the token ID for which the info is being requested.
   *
   * @param {NftId | string} nftId
   * @returns {TokenNftInfoQuery}
   */
  setNftId(nftId) {
    this._nftId = typeof nftId === "string" ? NftId.fromString(nftId) : NftId._fromProtobuf(nftId._toProtobuf());
    return this;
  }
  /**
   * @deprecated with no replacement
   * @returns {?AccountId}
   */
  get accountId() {
    console.warn(
      "`TokenNftInfoQuery.accountId` is deprecated with no replacement"
    );
    return this._accountId;
  }
  /**
   * @deprecated with no replacement
   * Set the token ID for which the info is being requested.
   * @param {AccountId | string} accountId
   * @returns {TokenNftInfoQuery}
   */
  setAccountId(accountId) {
    console.warn(
      "`TokenNftInfoQuery.setAccountId()` is deprecated with no replacement"
    );
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : AccountId._fromProtobuf(accountId._toProtobuf());
    return this;
  }
  /**
   * @deprecated with no replacement
   * @returns {?TokenId}
   */
  get tokenId() {
    console.warn(
      "`TokenNftInfoQuery.tokenId` is deprecated with no replacement"
    );
    return this._tokenId;
  }
  /**
   * @deprecated with no replacement
   * Set the token ID for which the info is being requested.
   * @param {TokenId | string} tokenId
   * @returns {TokenNftInfoQuery}
   */
  setTokenId(tokenId) {
    console.warn(
      "`TokenNftInfoQuery.setTokenId()` is deprecated with no replacement"
    );
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : TokenId._fromProtobuf(tokenId._toProtobuf());
    return this;
  }
  /**
   * @deprecated with no replacement
   * @returns {?Long}
   */
  get start() {
    console.warn(
      "`TokenNftInfoQuery.start` is deprecated with no replacement"
    );
    return this._start;
  }
  /**
   * @deprecated with no replacement
   * Set the token ID for which the info is being requested.
   * @param {Long | number} start
   * @returns {TokenNftInfoQuery}
   */
  setStart(start) {
    console.warn(
      "`TokenNftInfoQuery.setStart()` is deprecated with no replacement"
    );
    this._start = typeof start === "number" ? import_long44.default.fromNumber(start) : start;
    return this;
  }
  /**
   * @deprecated with no replacement
   * @returns {?Long}
   */
  get end() {
    console.warn(
      "`TokenNftInfoQuery.end` is deprecated with no replacement"
    );
    return this._end;
  }
  /**
   * @deprecated with no replacement
   * Set the token ID for which the info is being requested.
   * @param {Long | number} end
   * @returns {TokenNftInfoQuery}
   */
  setEnd(end) {
    console.warn(
      "`TokenNftInfoQuery.setEnd()` is deprecated with no replacement"
    );
    this._end = typeof end === "number" ? import_long44.default.fromNumber(end) : end;
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    return super.getCost(client);
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.token.getTokenNftInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const infos = (
      /** @type {HashgraphProto.proto.ITokenGetNftInfoResponse} */
      response.tokenGetNftInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      infos.header
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<TokenNftInfo[]>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const nfts = [
      /** @type {HashgraphProto.proto.ITokenNftInfo} */
      /** @type {HashgraphProto.proto.ITokenGetNftInfoResponse} */
      response.tokenGetNftInfo.nft
    ];
    return Promise.resolve(
      nfts.map(
        (nft) => TokenNftInfo._fromProtobuf(
          /** @type {HashgraphProto.proto.ITokenNftInfo} */
          nft
        )
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      tokenGetNftInfo: {
        header,
        nftID: this._nftId != null ? this._nftId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `TokenNftInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("tokenGetNftInfo", TokenNftInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenPauseTransaction.js
var TokenPauseTransaction = class _TokenPauseTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenPauseTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const pauseToken = (
      /** @type {HashgraphProto.proto.ITokenPauseTransactionBody} */
      body.tokenPause
    );
    return Transaction._fromProtobufTransactions(
      new _TokenPauseTransaction({
        tokenId: pauseToken.token != null ? TokenId._fromProtobuf(pauseToken.token) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.pauseToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenPause";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenPauseTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenPauseTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenPause",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenPauseTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenRevokeKycTransaction.js
var TokenRevokeKycTransaction = class _TokenRevokeKycTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenRevokeKycTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const revokeKycToken = (
      /** @type {HashgraphProto.proto.ITokenRevokeKycTransactionBody} */
      body.tokenRevokeKyc
    );
    return Transaction._fromProtobufTransactions(
      new _TokenRevokeKycTransaction({
        tokenId: revokeKycToken.token != null ? TokenId._fromProtobuf(revokeKycToken.token) : void 0,
        accountId: revokeKycToken.account != null ? AccountId._fromProtobuf(revokeKycToken.account) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.revokeKycFromTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenRevokeKyc";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenRevokeKycTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenRevokeKycTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenRevokeKyc",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenRevokeKycTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenUnfreezeTransaction.js
var TokenUnfreezeTransaction = class _TokenUnfreezeTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenUnfreezeTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const unfreezeToken = (
      /** @type {HashgraphProto.proto.ITokenUnfreezeAccountTransactionBody} */
      body.tokenUnfreeze
    );
    return Transaction._fromProtobufTransactions(
      new _TokenUnfreezeTransaction({
        tokenId: unfreezeToken.token != null ? TokenId._fromProtobuf(unfreezeToken.token) : void 0,
        accountId: unfreezeToken.account != null ? AccountId._fromProtobuf(unfreezeToken.account) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.unfreezeTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenUnfreeze";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenUnfreezeAccountTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenUnfreezeTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenUnfreeze",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenUnfreezeTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenUnpauseTransaction.js
var TokenUnpauseTransaction = class _TokenUnpauseTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenUnpauseTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const unpauseToken = (
      /** @type {HashgraphProto.proto.ITokenUnpauseTransactionBody} */
      body.tokenUnpause
    );
    return Transaction._fromProtobufTransactions(
      new _TokenUnpauseTransaction({
        tokenId: unpauseToken.token != null ? TokenId._fromProtobuf(unpauseToken.token) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.unpauseToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenUnpause";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenUnpauseTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenUnpauseTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenUnpause",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenUnpauseTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenUpdateTransaction.js
var TokenUpdateTransaction = class _TokenUpdateTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {string} [props.tokenName]
   * @param {string} [props.tokenSymbol]
   * @param {AccountId | string} [props.treasuryAccountId]
   * @param {Key} [props.adminKey]
   * @param {Key} [props.kycKey]
   * @param {Key} [props.freezeKey]
   * @param {Key} [props.wipeKey]
   * @param {Key} [props.supplyKey]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.tokenMemo]
   * @param {Key} [props.feeScheduleKey]
   * @param {Key} [props.pauseKey]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._tokenName = null;
    this._tokenSymbol = null;
    this._treasuryAccountId = null;
    this._adminKey = null;
    this._kycKey = null;
    this._freezeKey = null;
    this._wipeKey = null;
    this._supplyKey = null;
    this._autoRenewAccountId = null;
    this._expirationTime = null;
    this._autoRenewPeriod = null;
    this._tokenMemo = null;
    this._feeScheduleKey = null;
    this._pauseKey = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.tokenName != null) {
      this.setTokenName(props.tokenName);
    }
    if (props.tokenSymbol != null) {
      this.setTokenSymbol(props.tokenSymbol);
    }
    if (props.treasuryAccountId != null) {
      this.setTreasuryAccountId(props.treasuryAccountId);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.kycKey != null) {
      this.setKycKey(props.kycKey);
    }
    if (props.freezeKey != null) {
      this.setFreezeKey(props.freezeKey);
    }
    if (props.wipeKey != null) {
      this.setWipeKey(props.wipeKey);
    }
    if (props.supplyKey != null) {
      this.setSupplyKey(props.supplyKey);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.tokenMemo != null) {
      this.setTokenMemo(props.tokenMemo);
    }
    if (props.feeScheduleKey != null) {
      this.setFeeScheduleKey(props.feeScheduleKey);
    }
    if (props.pauseKey != null) {
      this.setPauseKey(props.pauseKey);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenUpdateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = (
      /** @type {HashgraphProto.proto.ITokenUpdateTransactionBody} */
      body.tokenUpdate
    );
    return Transaction._fromProtobufTransactions(
      new _TokenUpdateTransaction({
        tokenId: update3.token != null ? TokenId._fromProtobuf(update3.token) : void 0,
        tokenName: update3.name != null ? update3.name : void 0,
        tokenSymbol: update3.symbol != null ? update3.symbol : void 0,
        treasuryAccountId: update3.treasury != null ? AccountId._fromProtobuf(update3.treasury) : void 0,
        adminKey: update3.adminKey != null ? Key2._fromProtobufKey(update3.adminKey) : void 0,
        kycKey: update3.kycKey != null ? Key2._fromProtobufKey(update3.kycKey) : void 0,
        freezeKey: update3.freezeKey != null ? Key2._fromProtobufKey(update3.freezeKey) : void 0,
        wipeKey: update3.wipeKey != null ? Key2._fromProtobufKey(update3.wipeKey) : void 0,
        supplyKey: update3.supplyKey != null ? Key2._fromProtobufKey(update3.supplyKey) : void 0,
        autoRenewAccountId: update3.autoRenewAccount != null ? AccountId._fromProtobuf(update3.autoRenewAccount) : void 0,
        expirationTime: update3.expiry != null ? Timestamp._fromProtobuf(update3.expiry) : void 0,
        autoRenewPeriod: update3.autoRenewPeriod != null ? Duration2._fromProtobuf(update3.autoRenewPeriod) : void 0,
        tokenMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0,
        feeScheduleKey: update3.feeScheduleKey != null ? Key2._fromProtobufKey(update3.feeScheduleKey) : void 0,
        pauseKey: update3.pauseKey != null ? Key2._fromProtobufKey(update3.pauseKey) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?string}
   */
  get tokenName() {
    return this._tokenName;
  }
  /**
   * @param {string} name
   * @returns {this}
   */
  setTokenName(name) {
    this._requireNotFrozen();
    this._tokenName = name;
    return this;
  }
  /**
   * @returns {?string}
   */
  get tokenSymbol() {
    return this._tokenSymbol;
  }
  /**
   * @param {string} symbol
   * @returns {this}
   */
  setTokenSymbol(symbol) {
    this._requireNotFrozen();
    this._tokenSymbol = symbol;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */
  setTreasuryAccountId(id2) {
    this._requireNotFrozen();
    this._treasuryAccountId = typeof id2 === "string" ? AccountId.fromString(id2) : id2.clone();
    return this;
  }
  /**
   * @returns {?Key}
   */
  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setAdminKey(key) {
    this._requireNotFrozen();
    this._adminKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get kycKey() {
    return this._kycKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setKycKey(key) {
    this._requireNotFrozen();
    this._kycKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get freezeKey() {
    return this._freezeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setFreezeKey(key) {
    this._requireNotFrozen();
    this._freezeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get wipeKey() {
    return this._wipeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setWipeKey(key) {
    this._requireNotFrozen();
    this._wipeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get supplyKey() {
    return this._supplyKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */
  setSupplyKey(key) {
    this._requireNotFrozen();
    this._supplyKey = key;
    return this;
  }
  /**
   * @deprecated
   * @param {Key} key
   * @returns {this}
   */
  setsupplyKey(key) {
    this._requireNotFrozen();
    this._supplyKey = key;
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp | Date} time
   * @returns {this}
   */
  setExpirationTime(time) {
    this._requireNotFrozen();
    this._expirationTime = time instanceof Timestamp ? time : Timestamp.fromDate(time);
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */
  setAutoRenewAccountId(id2) {
    this._requireNotFrozen();
    this._autoRenewAccountId = id2 instanceof AccountId ? id2 : AccountId.fromString(id2);
    return this;
  }
  /**
   * @returns {?Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this token.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?string}
   */
  get tokenMemo() {
    return this._tokenMemo;
  }
  /**
   * @param {string} tokenMemo
   * @returns {this}
   */
  setTokenMemo(tokenMemo) {
    this._requireNotFrozen();
    this._tokenMemo = tokenMemo;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get feeScheduleKey() {
    return this._feeScheduleKey;
  }
  /**
   * @param {Key} feeScheduleKey
   * @returns {this}
   */
  setFeeScheduleKey(feeScheduleKey) {
    this._requireNotFrozen();
    this._feeScheduleKey = feeScheduleKey;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get pauseKey() {
    return this._pauseKey;
  }
  /**
   * @param {Key} pauseKey
   * @returns {this}
   */
  setPauseKey(pauseKey) {
    this._requireNotFrozen();
    this._pauseKey = pauseKey;
    return this;
  }
  /**
   * @returns {this}
   */
  clearTokenMemo() {
    this._requireNotFrozen();
    this._tokenMemo = null;
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._treasuryAccountId != null) {
      this._treasuryAccountId.validateChecksum(client);
    }
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.updateToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenUpdate";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenUpdateTransactionBody}
   */
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      name: this.tokenName,
      symbol: this.tokenSymbol,
      treasury: this._treasuryAccountId != null ? this._treasuryAccountId._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
      freezeKey: this._freezeKey != null ? this._freezeKey._toProtobufKey() : null,
      pauseKey: this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
      wipeKey: this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
      supplyKey: this._supplyKey != null ? this._supplyKey._toProtobufKey() : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      expiry: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      memo: this._tokenMemo != null ? {
        value: this._tokenMemo
      } : null,
      feeScheduleKey: this._feeScheduleKey != null ? this._feeScheduleKey._toProtobufKey() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenUpdateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenUpdate",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenUpdateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/token/TokenWipeTransaction.js
var import_long45 = __toESM(require_long(), 1);
var TokenWipeTransaction = class _TokenWipeTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   * @param {Long | number} [props.amount]
   * @param {(Long | number)[]} [props.serials]
   */
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    this._serials = [];
    this._amount = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    if (props.serials != null) {
      this.setSerials(props.serials);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TokenWipeTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const wipeToken = (
      /** @type {HashgraphProto.proto.ITokenWipeAccountTransactionBody} */
      body.tokenWipe
    );
    return Transaction._fromProtobufTransactions(
      new _TokenWipeTransaction({
        tokenId: wipeToken.token != null ? TokenId._fromProtobuf(wipeToken.token) : void 0,
        accountId: wipeToken.account != null ? AccountId._fromProtobuf(wipeToken.account) : void 0,
        amount: wipeToken.amount != null ? wipeToken.amount : void 0,
        serials: wipeToken.serialNumbers != null ? wipeToken.serialNumbers : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TokenId}
   */
  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */
  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {this}
   */
  setAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof import_long45.default ? amount : import_long45.default.fromValue(amount);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  /**
   * @returns {Long[]}
   */
  get serials() {
    return this._serials;
  }
  /**
   * @param {(Long | number)[]} serials
   * @returns {this}
   */
  setSerials(serials) {
    this._requireNotFrozen();
    this._serials = serials.map(
      (serial) => typeof serial === "number" ? import_long45.default.fromNumber(serial) : serial
    );
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.token.wipeTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "tokenWipe";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ITokenWipeAccountTransactionBody}
   */
  _makeTransactionData() {
    return {
      amount: this._amount,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null,
      serialNumbers: this.serials
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TokenWipeTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "tokenWipe",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TokenWipeTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/topic/TopicCreateTransaction.js
var TopicCreateTransaction = class _TopicCreateTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {Key} [props.adminKey]
   * @param {Key} [props.submitKey]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {string} [props.topicMemo]
   */
  constructor(props = {}) {
    super();
    this._adminKey = null;
    this._submitKey = null;
    this._autoRenewAccountId = null;
    this._autoRenewPeriod = new Duration2(DEFAULT_AUTO_RENEW_PERIOD);
    this._topicMemo = null;
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.submitKey != null) {
      this.setSubmitKey(props.submitKey);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.topicMemo != null) {
      this.setTopicMemo(props.topicMemo);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TopicCreateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = (
      /** @type {HashgraphProto.proto.IConsensusCreateTopicTransactionBody} */
      body.consensusCreateTopic
    );
    return Transaction._fromProtobufTransactions(
      new _TopicCreateTransaction({
        adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
        submitKey: create.submitKey != null ? Key2._fromProtobufKey(create.submitKey) : void 0,
        autoRenewAccountId: create.autoRenewAccount != null ? AccountId._fromProtobuf(create.autoRenewAccount) : void 0,
        autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : void 0 : void 0,
        topicMemo: create.memo != null ? create.memo : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @deprecated  - Use `getTopicMemo()` instead
   * @returns {?string}
   */
  get topicMemo() {
    return this._topicMemo;
  }
  /**
   * @returns {?string}
   */
  getTopicMemo() {
    return this._topicMemo;
  }
  /**
   * @param {string} topicMemo
   * @returns {this}
   */
  setTopicMemo(topicMemo) {
    this._requireNotFrozen();
    this._topicMemo = topicMemo;
    return this;
  }
  /**
   * @deprecated  - Use `getAdminKey()` instead
   * @returns {?Key}
   */
  get adminKey() {
    return this._adminKey;
  }
  /**
   * @returns {?Key}
   */
  getAdminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {this}
   */
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  /**
   * @deprecated  - Use `getSubmitKey()` instead
   * @returns {?Key}
   */
  get submitKey() {
    return this._submitKey;
  }
  /**
   * @returns {?Key}
   */
  getSubmitKey() {
    return this._submitKey;
  }
  /**
   * @param {Key} submitKey
   * @returns {this}
   */
  setSubmitKey(submitKey) {
    this._requireNotFrozen();
    this._submitKey = submitKey;
    return this;
  }
  /**
   * @deprecated  - Use `getAutoRenewAccountId()` instead
   * @returns {?AccountId}
   */
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @returns {?AccountId}
   */
  getAutoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} autoRenewAccountId
   * @returns {this}
   */
  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();
    this._autoRenewAccountId = autoRenewAccountId instanceof AccountId ? autoRenewAccountId : AccountId.fromString(autoRenewAccountId);
    return this;
  }
  /**
   * @deprecated  - Use `getAutoRenewPeriod()` instead
   * @returns {Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * @returns {Duration}
   */
  getAutoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this account.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.consensus.createTopic(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "consensusCreateTopic";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IConsensusCreateTopicTransactionBody}
   */
  _makeTransactionData() {
    return {
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      submitKey: this._submitKey != null ? this._submitKey._toProtobufKey() : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      memo: this._topicMemo
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TopicCreateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "consensusCreateTopic",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TopicCreateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/topic/TopicDeleteTransaction.js
var TopicDeleteTransaction = class _TopicDeleteTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   */
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TopicDeleteTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const topicDelete = (
      /** @type {HashgraphProto.proto.IConsensusDeleteTopicTransactionBody} */
      body.consensusDeleteTopic
    );
    return Transaction._fromProtobufTransactions(
      new _TopicDeleteTransaction({
        topicId: topicDelete.topicID != null ? TopicId._fromProtobuf(topicDelete.topicID) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TopicId}
   */
  get topicId() {
    return this._topicId;
  }
  /**
   * Set the topic ID which is being deleted in this transaction.
   *
   * @param {TopicId | string} topicId
   * @returns {TopicDeleteTransaction}
   */
  setTopicId(topicId) {
    this._requireNotFrozen();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._topicId != null) {
      this._topicId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.consensus.deleteTopic(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "consensusDeleteTopic";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IConsensusDeleteTopicTransactionBody}
   */
  _makeTransactionData() {
    return {
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TopicDeleteTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "consensusDeleteTopic",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TopicDeleteTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/topic/TopicInfo.js
var import_long46 = __toESM(require_long(), 1);
var HashgraphProto36 = __toESM(require_lib(), 1);
var TopicInfo = class _TopicInfo {
  /**
   * @private
   * @param {object} props
   * @param {TopicId} props.topicId
   * @param {string} props.topicMemo
   * @param {Uint8Array} props.runningHash
   * @param {Long} props.sequenceNumber
   * @param {?Timestamp} props.expirationTime
   * @param {?Key} props.adminKey
   * @param {?Key} props.submitKey
   * @param {?Duration} props.autoRenewPeriod
   * @param {?AccountId} props.autoRenewAccountId
   * @param {LedgerId|null} props.ledgerId
   */
  constructor(props) {
    this.topicId = props.topicId;
    this.topicMemo = props.topicMemo;
    this.runningHash = props.runningHash;
    this.sequenceNumber = props.sequenceNumber;
    this.expirationTime = props.expirationTime;
    this.adminKey = props.adminKey;
    this.submitKey = props.submitKey;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.autoRenewAccountId = props.autoRenewAccountId;
    this.ledgerId = props.ledgerId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IConsensusGetTopicInfoResponse} infoResponse
   * @returns {TopicInfo}
   */
  static _fromProtobuf(infoResponse) {
    const info = (
      /** @type {HashgraphProto.proto.IConsensusTopicInfo} */
      infoResponse.topicInfo
    );
    return new _TopicInfo({
      topicId: TopicId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITopicID} */
        infoResponse.topicID
      ),
      topicMemo: info.memo != null ? info.memo : "",
      runningHash: info.runningHash != null ? info.runningHash : new Uint8Array(),
      sequenceNumber: info.sequenceNumber != null ? info.sequenceNumber instanceof import_long46.default ? info.sequenceNumber : import_long46.default.fromValue(info.sequenceNumber) : import_long46.default.ZERO,
      expirationTime: info.expirationTime != null ? Timestamp._fromProtobuf(info.expirationTime) : null,
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      submitKey: info.submitKey != null ? Key2._fromProtobufKey(info.submitKey) : null,
      autoRenewPeriod: info.autoRenewPeriod != null ? new Duration2(
        /** @type {Long} */
        info.autoRenewPeriod.seconds
      ) : null,
      autoRenewAccountId: info.autoRenewAccount != null ? AccountId._fromProtobuf(info.autoRenewAccount) : null,
      ledgerId: info.ledgerId != null ? LedgerId.fromBytes(info.ledgerId) : null
    });
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.IConsensusGetTopicInfoResponse}
   */
  _toProtobuf() {
    return {
      topicID: this.topicId._toProtobuf(),
      topicInfo: {
        memo: this.topicMemo,
        runningHash: this.runningHash,
        sequenceNumber: this.sequenceNumber,
        expirationTime: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
        adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
        submitKey: this.submitKey != null ? this.submitKey._toProtobufKey() : null,
        autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
        autoRenewAccount: this.autoRenewAccountId != null ? this.autoRenewAccountId._toProtobuf() : null
      }
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TopicInfo}
   */
  static fromBytes(bytes3) {
    return _TopicInfo._fromProtobuf({
      topicInfo: HashgraphProto36.proto.ConsensusTopicInfo.decode(bytes3)
    });
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    return HashgraphProto36.proto.ConsensusTopicInfo.encode(
      /** @type {HashgraphProto.proto.IConsensusTopicInfo} */
      this._toProtobuf().topicInfo
    ).finish();
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicInfoQuery.js
var TopicInfoQuery = class _TopicInfoQuery extends Query {
  /**
   * @param {object} [props]
   * @param {TopicId | string} [props.topicId]
   */
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.IQuery} query
   * @returns {TopicInfoQuery}
   */
  static _fromProtobuf(query) {
    const info = (
      /** @type {HashgraphProto.proto.IConsensusGetTopicInfoQuery} */
      query.consensusGetTopicInfo
    );
    return new _TopicInfoQuery({
      topicId: info.topicID != null ? TopicId._fromProtobuf(info.topicID) : void 0
    });
  }
  /**
   * @returns {?TopicId}
   */
  get topicId() {
    return this._topicId;
  }
  /**
   * Set the topic ID for which the info is being requested.
   *
   * @param {TopicId | string} topicId
   * @returns {TopicInfoQuery}
   */
  setTopicId(topicId) {
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */
  async getCost(client) {
    return super.getCost(client);
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._topicId != null) {
      this._topicId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return channel.consensus.getTopicInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {HashgraphProto.proto.IResponseHeader}
   */
  _mapResponseHeader(response) {
    const consensusGetTopicInfo = (
      /** @type {HashgraphProto.proto.IConsensusGetTopicInfoResponse} */
      response.consensusGetTopicInfo
    );
    return (
      /** @type {HashgraphProto.proto.IResponseHeader} */
      consensusGetTopicInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<TopicInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    return Promise.resolve(
      TopicInfo._fromProtobuf(
        /** @type {HashgraphProto.proto.IConsensusGetTopicInfoResponse} */
        response.consensusGetTopicInfo
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IQueryHeader} header
   * @returns {HashgraphProto.proto.IQuery}
   */
  _onMakeRequest(header) {
    return {
      consensusGetTopicInfo: {
        header,
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null
      }
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = this._paymentTransactionId != null && this._paymentTransactionId.validStart != null ? this._paymentTransactionId.validStart : this._timestamp;
    return `TopicInfoQuery:${timestamp.toString()}`;
  }
};
QUERY_REGISTRY.set("consensusGetTopicInfo", TopicInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/topic/TopicMessageChunk.js
var import_long47 = __toESM(require_long(), 1);
var TopicMessageChunk = class _TopicMessageChunk {
  /**
   * @private
   * @param {object} props
   * @param {Timestamp} props.consensusTimestamp
   * @param {Uint8Array} props.contents
   * @param {Uint8Array} props.runningHash
   * @param {Long} props.sequenceNumber
   */
  constructor(props) {
    this.consensusTimestamp = props.consensusTimestamp;
    this.contents = props.contents;
    this.runningHash = props.runningHash;
    this.sequenceNumber = props.sequenceNumber;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} response
   * @returns {TopicMessageChunk}
   */
  static _fromProtobuf(response) {
    return new _TopicMessageChunk({
      consensusTimestamp: Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        response.consensusTimestamp
      ),
      contents: response.message != null ? response.message : new Uint8Array(),
      runningHash: response.runningHash != null ? response.runningHash : new Uint8Array(),
      sequenceNumber: response.sequenceNumber != null ? response.sequenceNumber instanceof import_long47.default ? response.sequenceNumber : import_long47.default.fromValue(response.sequenceNumber) : import_long47.default.ZERO
    });
  }
  /**
   * @internal
   * @returns {com.hedera.mirror.api.proto.IConsensusTopicResponse}
   */
  _toProtobuf() {
    return {
      consensusTimestamp: this.consensusTimestamp._toProtobuf(),
      message: this.contents,
      runningHash: this.runningHash,
      sequenceNumber: this.sequenceNumber
    };
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicMessage.js
var import_long48 = __toESM(require_long(), 1);
var TopicMessage = class _TopicMessage {
  /**
   * @private
   * @param {object} props
   * @param {Timestamp} props.consensusTimestamp
   * @param {Uint8Array} props.contents
   * @param {Uint8Array} props.runningHash
   * @param {Long} props.sequenceNumber
   * @param {?TransactionId} props.initialTransactionId
   * @param {TopicMessageChunk[]} props.chunks
   */
  constructor(props) {
    this.consensusTimestamp = props.consensusTimestamp;
    this.contents = props.contents;
    this.runningHash = props.runningHash;
    this.sequenceNumber = props.sequenceNumber;
    this.chunks = props.chunks;
    this.initialTransactionId = props.initialTransactionId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} response
   * @returns {TopicMessage}
   */
  static _ofSingle(response) {
    return new _TopicMessage({
      consensusTimestamp: Timestamp._fromProtobuf(
        /** @type {HashgraphProto.proto.ITimestamp} */
        response.consensusTimestamp
      ),
      contents: response.message != null ? response.message : new Uint8Array(),
      runningHash: response.runningHash != null ? response.runningHash : new Uint8Array(),
      sequenceNumber: response.sequenceNumber != null ? response.sequenceNumber instanceof import_long48.default ? response.sequenceNumber : import_long48.default.fromNumber(response.sequenceNumber) : import_long48.default.ZERO,
      initialTransactionId: response.chunkInfo != null && response.chunkInfo.initialTransactionID != null ? TransactionId._fromProtobuf(
        response.chunkInfo.initialTransactionID
      ) : null,
      chunks: [TopicMessageChunk._fromProtobuf(response)]
    });
  }
  /**
   * @internal
   * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse[]} responses
   * @returns {TopicMessage}
   */
  static _ofMany(responses) {
    const length = responses.length;
    const last = (
      /** @type {com.hedera.mirror.api.proto.IConsensusTopicResponse} */
      responses[length - 1]
    );
    const consensusTimestamp = Timestamp._fromProtobuf(
      /** @type {HashgraphProto.proto.ITimestamp} */
      last.consensusTimestamp
    );
    const runningHash = (
      /** @type {Uint8Array} */
      last.runningHash
    );
    const sequenceNumber = last.sequenceNumber != null ? last.sequenceNumber instanceof import_long48.default ? last.sequenceNumber : import_long48.default.fromValue(last.sequenceNumber) : import_long48.default.ZERO;
    responses.sort(
      (a, b) => (a != null ? a.chunkInfo != null ? a.chunkInfo.number != null ? a.chunkInfo.number : 0 : 0 : 0) < (b != null ? b.chunkInfo != null ? b.chunkInfo.number != null ? b.chunkInfo.number : 0 : 0 : 0) ? -1 : 1
    );
    const chunks = responses.map(
      /**
       * @type {com.hedera.mirror.api.proto.IConsensusTopicResponse}
       */
      (m) => TopicMessageChunk._fromProtobuf(m)
    );
    const size = chunks.map((chunk) => chunk.contents.length).reduce((sum, current) => sum + current, 0);
    const contents = new Uint8Array(size);
    let offset = 0;
    responses.forEach((value) => {
      contents.set(
        /** @type {Uint8Array} */
        value.message,
        offset
      );
      offset += /** @type {Uint8Array} */
      value.message.length;
    });
    let initialTransactionId = null;
    if (responses.length > 0 && responses[0].chunkInfo != null && responses[0].chunkInfo.initialTransactionID != null) {
      initialTransactionId = TransactionId._fromProtobuf(
        responses[0].chunkInfo.initialTransactionID
      );
    }
    return new _TopicMessage({
      consensusTimestamp,
      contents,
      runningHash,
      sequenceNumber,
      chunks,
      initialTransactionId
    });
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicMessageQuery.js
var HashgraphProto37 = __toESM(require_lib(), 1);
var import_long49 = __toESM(require_long(), 1);
var TopicMessageQuery = class extends Query {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   * @param {Timestamp} [props.startTime]
   * @param {Timestamp} [props.endTime]
   * @param {(message: TopicMessage | null, error: Error)=> void} [props.errorHandler]
   * @param {() => void} [props.completionHandler]
   * @param {(error: MirrorError | Error | null) => boolean} [props.retryHandler]
   * @param {Long | number} [props.limit]
   */
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    this._startTime = null;
    if (props.startTime != null) {
      this.setStartTime(props.startTime);
    }
    this._endTime = null;
    if (props.endTime != null) {
      this.setEndTime(props.endTime);
    }
    this._limit = null;
    if (props.limit != null) {
      this.setLimit(props.limit);
    }
    this._errorHandler = (message, error) => {
      console.error(
        `Error attempting to subscribe to topic: ${this._topicId != null ? this._topicId.toString() : ""}`
      );
    };
    if (props.errorHandler != null) {
      this._errorHandler = props.errorHandler;
    }
    this._listener = null;
    this._completionHandler = () => {
      if (this._logger) {
        this._logger.info(
          `Subscription to topic ${this._topicId != null ? this._topicId.toString() : ""} complete`
        );
      }
    };
    if (props.completionHandler != null) {
      this._completionHandler = props.completionHandler;
    }
    this._retryHandler = (error) => {
      if (error != null) {
        if (error instanceof Error) {
          return true;
        } else {
          switch (error.code) {
            case 13:
              return RST_STREAM.test(error.details.toString());
            case 5:
            case 8:
            case 14:
            case 17:
              return true;
            default:
              return false;
          }
        }
      }
      return false;
    };
    if (props.retryHandler != null) {
      this._retryHandler = props.retryHandler;
    }
    this._attempt = 0;
    this._handle = null;
    this.setMaxBackoff(8e3);
  }
  /**
   * @returns {?TopicId}
   */
  get topicId() {
    return this._topicId;
  }
  /**
   * @param {TopicId | string} topicId
   * @returns {TopicMessageQuery}
   */
  setTopicId(topicId) {
    this.requireNotSubscribed();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get startTime() {
    return this._startTime;
  }
  /**
   * @param {Timestamp | Date | number} startTime
   * @returns {TopicMessageQuery}
   */
  setStartTime(startTime) {
    this.requireNotSubscribed();
    this._startTime = startTime instanceof Timestamp ? startTime : startTime instanceof Date ? Timestamp.fromDate(startTime) : new Timestamp(startTime, 0);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */
  get endTime() {
    return this._endTime;
  }
  /**
   * @param {Timestamp | Date | number} endTime
   * @returns {TopicMessageQuery}
   */
  setEndTime(endTime) {
    this.requireNotSubscribed();
    this._endTime = endTime instanceof Timestamp ? endTime : endTime instanceof Date ? Timestamp.fromDate(endTime) : new Timestamp(endTime, 0);
    return this;
  }
  /**
   * @returns {?Long}
   */
  get limit() {
    return this._limit;
  }
  /**
   * @param {Long | number} limit
   * @returns {TopicMessageQuery}
   */
  setLimit(limit) {
    this.requireNotSubscribed();
    this._limit = limit instanceof import_long49.default ? limit : import_long49.default.fromValue(limit);
    return this;
  }
  /**
   * @param {(message: TopicMessage | null, error: Error)=> void} errorHandler
   * @returns {TopicMessageQuery}
   */
  setErrorHandler(errorHandler) {
    this._errorHandler = errorHandler;
    return this;
  }
  /**
   * @param {() => void} completionHandler
   * @returns {TopicMessageQuery}
   */
  setCompletionHandler(completionHandler) {
    this.requireNotSubscribed();
    this._completionHandler = completionHandler;
    return this;
  }
  /**
   * @param {number} attempts
   * @returns {this}
   */
  setMaxAttempts(attempts) {
    this.requireNotSubscribed();
    this._maxAttempts = attempts;
    return this;
  }
  /**
   * @param {number} backoff
   * @returns {this}
   */
  setMaxBackoff(backoff) {
    this.requireNotSubscribed();
    this._maxBackoff = backoff;
    return this;
  }
  /**
   * @param {Client<Channel>} client
   * @param {((message: TopicMessage | null, error: Error) => void) | null} errorHandler
   * @param {(message: TopicMessage) => void} listener
   * @returns {SubscriptionHandle}
   */
  subscribe(client, errorHandler, listener) {
    this._handle = new SubscriptionHandle();
    this._listener = listener;
    if (errorHandler != null) {
      this._errorHandler = errorHandler;
    }
    this._makeServerStreamRequest(client);
    return this._handle;
  }
  /**
   * @private
   * @param {Client<Channel>} client
   * @returns {void}
   */
  _makeServerStreamRequest(client) {
    const list = /* @__PURE__ */ new Map();
    const request = HashgraphProto37.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode(
      {
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        consensusStartTime: this._startTime != null ? this._startTime._toProtobuf() : null,
        consensusEndTime: this._endTime != null ? this._endTime._toProtobuf() : null,
        limit: this._limit
      }
    ).finish();
    const cancel = client._mirrorNetwork.getNextMirrorNode().getChannel().makeServerStreamRequest(
      "ConsensusService",
      "subscribeTopic",
      request,
      (data) => {
        const message = HashgraphProto37.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(
          data
        );
        if (this._limit != null && this._limit.gt(0)) {
          this._limit = this._limit.sub(1);
        }
        this._startTime = Timestamp._fromProtobuf(
          /** @type {HashgraphProto.proto.ITimestamp} */
          message.consensusTimestamp
        ).plusNanos(1);
        if (message.chunkInfo == null || message.chunkInfo != null && message.chunkInfo.total === 1) {
          this._passTopicMessage(TopicMessage._ofSingle(message));
        } else {
          const chunkInfo = (
            /** @type {HashgraphProto.proto.IConsensusMessageChunkInfo} */
            message.chunkInfo
          );
          const initialTransactionID = (
            /** @type {HashgraphProto.proto.ITransactionID} */
            chunkInfo.initialTransactionID
          );
          const total = (
            /** @type {number} */
            chunkInfo.total
          );
          const transactionId = TransactionId._fromProtobuf(
            initialTransactionID
          ).toString();
          let responses = [];
          const temp = list.get(transactionId);
          if (temp == null) {
            list.set(transactionId, responses);
          } else {
            responses = temp;
          }
          responses.push(message);
          if (responses.length === total) {
            const topicMessage = TopicMessage._ofMany(responses);
            list.delete(transactionId);
            this._passTopicMessage(topicMessage);
          }
        }
      },
      (error) => {
        const message = error instanceof Error ? error.message : error.details;
        if (this._attempt < this._maxAttempts && this._retryHandler(error)) {
          const delay = Math.min(
            250 * 2 ** this._attempt,
            this._maxBackoff
          );
          console.warn(
            `Error subscribing to topic ${this._topicId != null ? this._topicId.toString() : "UNKNOWN"} during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${message}`
          );
          this._attempt += 1;
          setTimeout(() => {
            this._makeServerStreamRequest(client);
          }, delay);
        } else {
          this._errorHandler(null, new Error(message));
        }
      },
      this._completionHandler
    );
    if (this._handle != null) {
      this._handle._setCall(() => cancel());
    }
  }
  requireNotSubscribed() {
    if (this._handle != null) {
      throw new Error(
        "Cannot change fields on an already subscribed query"
      );
    }
  }
  /**
   * @private
   * @param {TopicMessage} topicMessage
   */
  _passTopicMessage(topicMessage) {
    try {
      if (this._listener != null) {
        this._listener(topicMessage);
      } else {
        throw new Error("(BUG) listener is unexpectedly not set");
      }
    } catch (error) {
      this._errorHandler(
        topicMessage,
        /** @type {Error} */
        error
      );
    }
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicMessageSubmitTransaction.js
var TopicMessageSubmitTransaction = class _TopicMessageSubmitTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   * @param {Uint8Array | string} [props.message]
   * @param {number} [props.maxChunks]
   * @param {number} [props.chunkSize]
   */
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    this._message = null;
    if (props.message != null) {
      this.setMessage(props.message);
    }
    this._maxChunks = 20;
    this._chunkSize = CHUNK_SIZE;
    if (props.maxChunks != null) {
      this.setMaxChunks(props.maxChunks);
    }
    if (props.chunkSize != null) {
      this.setChunkSize(props.chunkSize);
    }
    this._chunkInfo = null;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TopicMessageSubmitTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const message = (
      /** @type {HashgraphProto.proto.IConsensusSubmitMessageTransactionBody} */
      body.consensusSubmitMessage
    );
    return Transaction._fromProtobufTransactions(
      new _TopicMessageSubmitTransaction({
        topicId: message.topicID != null ? TopicId._fromProtobuf(message.topicID) : void 0,
        message: message.message != null ? message.message : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?TopicId}
   */
  get topicId() {
    return this._topicId;
  }
  /**
   * @param {TopicId | string} topicId
   * @returns {this}
   */
  setTopicId(topicId) {
    this._requireNotFrozen();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @deprecated  - Use `getMessage()` instead
   * @returns {?Uint8Array}
   */
  get message() {
    return this._message;
  }
  /**
   * @returns {?Uint8Array}
   */
  getMessage() {
    return this._message;
  }
  /**
   * @param {string | Uint8Array} message
   * @returns {this}
   */
  setMessage(message) {
    this._requireNotFrozen();
    message = requireStringOrUint8Array(message);
    this._message = message instanceof Uint8Array ? message : encode5(message);
    return this;
  }
  /**
   * @deprecated  - Use `getMaxChunks()` instead
   * @returns {?number}
   */
  get maxChunks() {
    return this._maxChunks;
  }
  /**
   * @returns {?number}
   */
  getMaxChunks() {
    return this._maxChunks;
  }
  /**
   * @param {number} maxChunks
   * @returns {this}
   */
  setMaxChunks(maxChunks) {
    this._requireNotFrozen();
    this._maxChunks = maxChunks;
    return this;
  }
  /**
   * @deprecated  - Use `getChunkSize()` instead
   * @returns {?number}
   */
  get chunkSize() {
    return this._chunkSize;
  }
  /**
   * @returns {?number}
   */
  getChunkSize() {
    return this._chunkSize;
  }
  /**
   * @param {number} chunkSize
   * @returns {this}
   */
  setChunkSize(chunkSize) {
    this._chunkSize = chunkSize;
    return this;
  }
  /**
   * Freeze this transaction from further modification to prepare for
   * signing or serialization.
   *
   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
   * nodes to prepare this transaction for.
   *
   * @param {?import("../client/Client.js").default<Channel, *>} client
   * @returns {this}
   */
  freezeWith(client) {
    super.freezeWith(client);
    if (this._message == null) {
      return this;
    }
    const chunks = Math.floor(
      (this._message.length + (this._chunkSize - 1)) / this._chunkSize
    );
    if (chunks > this._maxChunks) {
      throw new Error(
        `Message with size ${this._message.length} too long for ${this._maxChunks} chunks`
      );
    }
    const initialTransactionId = this._getTransactionId()._toProtobuf();
    let nextTransactionId = this._getTransactionId();
    this._transactionIds.locked = false;
    this._transactions.clear();
    this._transactionIds.clear();
    this._signedTransactions.clear();
    for (let chunk = 0; chunk < chunks; chunk++) {
      this._chunkInfo = {
        initialTransactionID: initialTransactionId,
        total: chunks,
        number: chunk + 1
      };
      this._transactionIds.push(nextTransactionId);
      this._transactionIds.advance();
      for (const nodeAccountId of this._nodeAccountIds.list) {
        this._signedTransactions.push(
          this._makeSignedTransaction(nodeAccountId)
        );
      }
      nextTransactionId = new TransactionId(
        /** @type {AccountId} */
        nextTransactionId.accountId,
        new Timestamp(
          /** @type {Timestamp} */
          nextTransactionId.validStart.seconds,
          /** @type {Timestamp} */
          nextTransactionId.validStart.nanos.add(1)
        )
      );
    }
    this._transactionIds.advance();
    this._chunkInfo = null;
    return this;
  }
  /**
   * @returns {ScheduleCreateTransaction}
   */
  schedule() {
    this._requireNotFrozen();
    if (this._message != null && this._message.length > this._chunkSize) {
      throw new Error(
        `cannot schedule \`TopicMessageSubmitTransaction\` with message over ${this._chunkSize} bytes`
      );
    }
    return super.schedule();
  }
  /**
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @param {number=} requestTimeout
   * @returns {Promise<TransactionResponse>}
   */
  async execute(client, requestTimeout) {
    return (await this.executeAll(client, requestTimeout))[0];
  }
  /**
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @param {number=} requestTimeout
   * @returns {Promise<TransactionResponse[]>}
   */
  async executeAll(client, requestTimeout) {
    if (!super._isFrozen()) {
      this.freezeWith(client);
    }
    const transactionId = this._getTransactionId();
    const operatorAccountId = client.operatorAccountId;
    if (operatorAccountId != null && operatorAccountId.equals(
      /** @type {AccountId} */
      transactionId.accountId
    )) {
      await super.signWithOperator(client);
    }
    const responses = [];
    let remainingTimeout = requestTimeout;
    for (let i = 0; i < this._transactionIds.length; i++) {
      const startTimestamp = Date.now();
      responses.push(await super.execute(client, remainingTimeout));
      if (remainingTimeout != null) {
        remainingTimeout = Date.now() - startTimestamp;
      }
    }
    return responses;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.consensus.submitMessage(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "consensusSubmitMessage";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IConsensusSubmitMessageTransactionBody}
   */
  _makeTransactionData() {
    if (this._chunkInfo != null && this._message != null) {
      const num = (
        /** @type {number} */
        this._chunkInfo.number
      );
      const startIndex = (num - 1) * this._chunkSize;
      let endIndex = startIndex + this._chunkSize;
      if (endIndex > this._message.length) {
        endIndex = this._message.length;
      }
      return {
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        message: this._message.slice(startIndex, endIndex),
        chunkInfo: this._chunkInfo
      };
    } else {
      return {
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        message: this._message
      };
    }
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TopicMessageSubmitTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "consensusSubmitMessage",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TopicMessageSubmitTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/topic/TopicUpdateTransaction.js
var TopicUpdateTransaction = class _TopicUpdateTransaction extends Transaction {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   * @param {Key} [props.adminKey]
   * @param {Key} [props.submitKey]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {string} [props.topicMemo]
   * @param {Timestamp | Date} [props.expirationTime]
   */
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    this._topicMemo = null;
    if (props.topicMemo != null) {
      this.setTopicMemo(props.topicMemo);
    }
    this._submitKey = null;
    if (props.submitKey != null) {
      this.setSubmitKey(props.submitKey);
    }
    this._adminKey = null;
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    this._autoRenewAccountId = null;
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    this._autoRenewPeriod = null;
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    this._expirationTime = null;
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TopicUpdateTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = (
      /** @type {HashgraphProto.proto.IConsensusUpdateTopicTransactionBody} */
      body.consensusUpdateTopic
    );
    return Transaction._fromProtobufTransactions(
      new _TopicUpdateTransaction({
        topicId: update3.topicID != null ? TopicId._fromProtobuf(update3.topicID) : void 0,
        adminKey: update3.adminKey != null ? Key2._fromProtobufKey(update3.adminKey) : void 0,
        submitKey: update3.submitKey != null ? Key2._fromProtobufKey(update3.submitKey) : void 0,
        autoRenewAccountId: update3.autoRenewAccount != null ? AccountId._fromProtobuf(update3.autoRenewAccount) : void 0,
        autoRenewPeriod: update3.autoRenewPeriod != null ? update3.autoRenewPeriod.seconds != null ? update3.autoRenewPeriod.seconds : void 0 : void 0,
        topicMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0,
        expirationTime: update3.expirationTime != null ? Timestamp._fromProtobuf(update3.expirationTime) : void 0
      }),
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {?Timestamp}
   */
  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp | Date | null} expirationTime
   * @returns {TopicUpdateTransaction}
   */
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Date ? Timestamp.fromDate(expirationTime) : expirationTime;
    return this;
  }
  /**
   * @returns {?TopicId}
   */
  get topicId() {
    return this._topicId;
  }
  /**
   * @param {TopicId | string} topicId
   * @returns {TopicUpdateTransaction}
   */
  setTopicId(topicId) {
    this._requireNotFrozen();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */
  clearTopicId() {
    this._requireNotFrozen();
    this._topicId = null;
    return this;
  }
  /**
   * @returns {?string}
   */
  get topicMemo() {
    return this._topicMemo;
  }
  /**
   * @param {string} topicMemo
   * @returns {TopicUpdateTransaction}
   */
  setTopicMemo(topicMemo) {
    this._requireNotFrozen();
    this._topicMemo = topicMemo;
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */
  clearTopicMemo() {
    this._requireNotFrozen();
    this._topicMemo = null;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {TopicUpdateTransaction}
   */
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */
  clearAdminKey() {
    this._requireNotFrozen();
    this._adminKey = null;
    return this;
  }
  /**
   * @returns {?Key}
   */
  get submitKey() {
    return this._submitKey;
  }
  /**
   * @param {Key} submitKey
   * @returns {TopicUpdateTransaction}
   */
  setSubmitKey(submitKey) {
    this._requireNotFrozen();
    this._submitKey = submitKey;
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */
  clearSubmitKey() {
    this._requireNotFrozen();
    this._submitKey = null;
    return this;
  }
  /**
   * @returns {?AccountId}
   */
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} autoRenewAccountId
   * @returns {TopicUpdateTransaction}
   */
  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();
    this._autoRenewAccountId = autoRenewAccountId instanceof AccountId ? autoRenewAccountId : AccountId.fromString(autoRenewAccountId);
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */
  clearAutoRenewAccountId() {
    this._requireNotFrozen();
    this._autoRenewAccountId = null;
    return this;
  }
  /**
   * @returns {?Duration}
   */
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this account.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {TopicUpdateTransaction}
   */
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration2 ? autoRenewPeriod : new Duration2(autoRenewPeriod);
    return this;
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    if (this._topicId != null) {
      this._topicId.validateChecksum(client);
    }
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.consensus.updateTopic(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "consensusUpdateTopic";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.IConsensusUpdateTopicTransactionBody}
   */
  _makeTransactionData() {
    return {
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      submitKey: this._submitKey != null ? this._submitKey._toProtobufKey() : null,
      memo: this._topicMemo != null ? {
        value: this._topicMemo
      } : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TopicUpdateTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "consensusUpdateTopic",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TopicUpdateTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/account/TransferTransaction.js
var import_long51 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/account/NullableTokenDecimalMap.js
var NullableTokenDecimalMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
};

// node_modules/@hashgraph/sdk/src/account/HbarTransferMap.js
var HbarTransferMap = class _HbarTransferMap extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
  /**
   * @param {HashgraphProto.proto.ITransferList} transfers
   * @returns {HbarTransferMap}
   */
  static _fromProtobuf(transfers) {
    const accountTransfers = new _HbarTransferMap();
    for (const transfer of transfers.accountAmounts != null ? transfers.accountAmounts : []) {
      const account = AccountId._fromProtobuf(
        /** @type {HashgraphProto.proto.IAccountID} */
        transfer.accountID
      );
      accountTransfers._set(
        account,
        Hbar.fromTinybars(
          /** @type {Long} */
          transfer.amount
        )
      );
    }
    return accountTransfers;
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenNftTransfer.js
var import_long50 = __toESM(require_long(), 1);
var TokenNftTransfer = class _TokenNftTransfer {
  /**
   * @internal
   * @param {object} props
   * @param {TokenId | string} props.tokenId
   * @param {AccountId | string} props.senderAccountId
   * @param {AccountId | string} props.receiverAccountId
   * @param {Long | number} props.serialNumber
   * @param {boolean} props.isApproved
   */
  constructor(props) {
    this.tokenId = props.tokenId instanceof TokenId ? props.tokenId : TokenId.fromString(props.tokenId);
    this.senderAccountId = props.senderAccountId instanceof AccountId ? props.senderAccountId : AccountId.fromString(props.senderAccountId);
    this.receiverAccountId = props.receiverAccountId instanceof AccountId ? props.receiverAccountId : AccountId.fromString(props.receiverAccountId);
    this.serialNumber = import_long50.default.fromValue(props.serialNumber);
    this.isApproved = props.isApproved;
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITokenTransferList[]} tokenTransfers
   * @returns {TokenNftTransfer[]}
   */
  static _fromProtobuf(tokenTransfers) {
    const transfers = [];
    for (const tokenTransfer of tokenTransfers) {
      const tokenId = TokenId._fromProtobuf(
        /** @type {HashgraphProto.proto.ITokenID} */
        tokenTransfer.token
      );
      for (const transfer of tokenTransfer.nftTransfers != null ? tokenTransfer.nftTransfers : []) {
        transfers.push(
          new _TokenNftTransfer({
            tokenId,
            senderAccountId: AccountId._fromProtobuf(
              /** @type {HashgraphProto.proto.IAccountID} */
              transfer.senderAccountID
            ),
            receiverAccountId: AccountId._fromProtobuf(
              /** @type {HashgraphProto.proto.IAccountID} */
              transfer.receiverAccountID
            ),
            serialNumber: transfer.serialNumber != null ? transfer.serialNumber : import_long50.default.ZERO,
            isApproved: transfer.isApproval == true
          })
        );
      }
    }
    return transfers;
  }
  /**
   * @internal
   * @returns {HashgraphProto.proto.INftTransfer}
   */
  _toProtobuf() {
    return {
      senderAccountID: this.senderAccountId._toProtobuf(),
      receiverAccountID: this.receiverAccountId._toProtobuf(),
      serialNumber: this.serialNumber,
      isApproval: this.isApproved
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/TransferTransaction.js
var TransferTransaction = class _TransferTransaction extends Transaction {
  /**
   * @param {object} [props]
   * @param {(TransferTokensInput)[]} [props.tokenTransfers]
   * @param {(TransferHbarInput)[]} [props.hbarTransfers]
   * @param {(TransferNftInput)[]} [props.nftTransfers]
   */
  constructor(props = {}) {
    super();
    this._tokenTransfers = [];
    this._hbarTransfers = [];
    this._nftTransfers = [];
    this._defaultMaxTransactionFee = new Hbar(1);
    for (const transfer of props.tokenTransfers != null ? props.tokenTransfers : []) {
      this.addTokenTransfer(
        transfer.tokenId,
        transfer.accountId,
        transfer.amount
      );
    }
    for (const transfer of props.hbarTransfers != null ? props.hbarTransfers : []) {
      this.addHbarTransfer(transfer.accountId, transfer.amount);
    }
    for (const transfer of props.nftTransfers != null ? props.nftTransfers : []) {
      this.addNftTransfer(
        transfer.tokenId,
        transfer.serial,
        transfer.sender,
        transfer.recipient
      );
    }
  }
  /**
   * @internal
   * @param {HashgraphProto.proto.ITransaction[]} transactions
   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {HashgraphProto.proto.ITransactionBody[]} bodies
   * @returns {TransferTransaction}
   */
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const cryptoTransfer = (
      /** @type {HashgraphProto.proto.ICryptoTransferTransactionBody} */
      body.cryptoTransfer
    );
    const transfers = new _TransferTransaction();
    transfers._tokenTransfers = TokenTransfer._fromProtobuf(
      cryptoTransfer.tokenTransfers != null ? cryptoTransfer.tokenTransfers : []
    );
    transfers._hbarTransfers = Transfer._fromProtobuf(
      cryptoTransfer.transfers != null ? cryptoTransfer.transfers.accountAmounts != null ? cryptoTransfer.transfers.accountAmounts : [] : []
    );
    transfers._nftTransfers = TokenNftTransfer._fromProtobuf(
      cryptoTransfer.tokenTransfers != null ? cryptoTransfer.tokenTransfers : []
    );
    return Transaction._fromProtobufTransactions(
      transfers,
      transactions,
      signedTransactions,
      transactionIds,
      nodeIds,
      bodies
    );
  }
  /**
   * @returns {TokenTransferMap}
   */
  get tokenTransfers() {
    const map = new TokenTransferMap();
    for (const transfer of this._tokenTransfers) {
      let transferMap = map.get(transfer.tokenId);
      if (transferMap != null) {
        transferMap._set(transfer.accountId, transfer.amount);
      } else {
        transferMap = new TokenTransferAccountMap();
        transferMap._set(transfer.accountId, transfer.amount);
        map._set(transfer.tokenId, transferMap);
      }
    }
    return map;
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} accountId
   * @param {number | Long} amount
   * @param {boolean} isApproved
   * @returns {this}
   */
  _addTokenTransfer(tokenId, accountId, amount, isApproved) {
    this._requireNotFrozen();
    const token = tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
    const account = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);
    const value = amount instanceof import_long51.default ? amount : import_long51.default.fromNumber(amount);
    for (const tokenTransfer of this._tokenTransfers) {
      if (tokenTransfer.tokenId.compare(token) === 0 && tokenTransfer.accountId.compare(account) === 0) {
        tokenTransfer.amount = tokenTransfer.amount.add(value);
        tokenTransfer.expectedDecimals = null;
        return this;
      }
    }
    this._tokenTransfers.push(
      new TokenTransfer({
        tokenId,
        accountId,
        expectedDecimals: null,
        amount,
        isApproved
      })
    );
    return this;
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} accountId
   * @param {number | Long} amount
   * @returns {this}
   */
  addTokenTransfer(tokenId, accountId, amount) {
    return this._addTokenTransfer(tokenId, accountId, amount, false);
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} accountId
   * @param {number | Long} amount
   * @returns {this}
   */
  addApprovedTokenTransfer(tokenId, accountId, amount) {
    return this._addTokenTransfer(tokenId, accountId, amount, true);
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} accountId
   * @param {number | Long} amount
   * @param {number} decimals
   * @returns {this}
   */
  addTokenTransferWithDecimals(tokenId, accountId, amount, decimals) {
    this._requireNotFrozen();
    const token = tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
    const account = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);
    const value = amount instanceof import_long51.default ? amount : import_long51.default.fromNumber(amount);
    let found = false;
    for (const tokenTransfer of this._tokenTransfers) {
      if (tokenTransfer.tokenId.compare(token) === 0) {
        if (tokenTransfer.expectedDecimals != null && tokenTransfer.expectedDecimals !== decimals) {
          throw new Error("expected decimals mis-match");
        } else {
          tokenTransfer.expectedDecimals = decimals;
        }
        if (tokenTransfer.accountId.compare(account) === 0) {
          tokenTransfer.amount = tokenTransfer.amount.add(value);
          tokenTransfer.expectedDecimals = decimals;
          found = true;
        }
      }
    }
    if (found) {
      return this;
    }
    this._tokenTransfers.push(
      new TokenTransfer({
        tokenId,
        accountId,
        expectedDecimals: decimals,
        amount,
        isApproved: false
      })
    );
    return this;
  }
  /**
   * @returns {NullableTokenDecimalMap}
   */
  get tokenIdDecimals() {
    const map = new NullableTokenDecimalMap();
    for (const transfer of this._tokenTransfers) {
      map._set(transfer.tokenId, transfer.expectedDecimals);
    }
    return map;
  }
  /**
   * @returns {HbarTransferMap}
   */
  get hbarTransfers() {
    const map = new HbarTransferMap();
    for (const transfer of this._hbarTransfers) {
      map._set(transfer.accountId, transfer.amount);
    }
    return map;
  }
  /**
   * @returns {Transfer[]}
   */
  get hbarTransfersList() {
    return this._hbarTransfers;
  }
  /**
   * @internal
   * @param {AccountId | string} accountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @param {boolean} isApproved
   * @returns {TransferTransaction}
   */
  _addHbarTransfer(accountId, amount, isApproved) {
    this._requireNotFrozen();
    const account = accountId instanceof AccountId ? accountId.clone() : AccountId.fromString(accountId);
    const hbars = amount instanceof Hbar ? amount : new Hbar(amount);
    for (const transfer of this._hbarTransfers) {
      if (transfer.accountId.compare(account) === 0) {
        transfer.amount = Hbar.fromTinybars(
          transfer.amount.toTinybars().add(hbars.toTinybars())
        );
        return this;
      }
    }
    this._hbarTransfers.push(
      new Transfer({
        accountId: account,
        amount: hbars,
        isApproved
      })
    );
    return this;
  }
  /**
   * @internal
   * @param {AccountId | string} accountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {TransferTransaction}
   */
  addHbarTransfer(accountId, amount) {
    return this._addHbarTransfer(accountId, amount, false);
  }
  /**
   * @internal
   * @param {AccountId | string} accountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {TransferTransaction}
   */
  addApprovedHbarTransfer(accountId, amount) {
    return this._addHbarTransfer(accountId, amount, true);
  }
  /**
   * @param {Client} client
   */
  _validateChecksums(client) {
    for (const transfer of this._hbarTransfers) {
      transfer.accountId.validateChecksum(client);
    }
    for (const transfer of this._tokenTransfers) {
      transfer.tokenId.validateChecksum(client);
      transfer.accountId.validateChecksum(client);
    }
    for (const transfer of this._nftTransfers) {
      transfer.tokenId.validateChecksum(client);
      transfer.senderAccountId.validateChecksum(client);
      transfer.receiverAccountId.validateChecksum(client);
    }
  }
  /**
   * @returns {TokenNftTransferMap}
   */
  get nftTransfers() {
    const map = new TokenNftTransferMap();
    for (const transfer of this._nftTransfers) {
      const transferList = map.get(transfer.tokenId);
      const nftTransfer = {
        sender: transfer.senderAccountId,
        recipient: transfer.receiverAccountId,
        serial: transfer.serialNumber,
        isApproved: transfer.isApproved
      };
      if (transferList != null) {
        transferList.push(nftTransfer);
      } else {
        map._set(transfer.tokenId, [nftTransfer]);
      }
    }
    return map;
  }
  /**
   * @param {boolean} isApproved
   * @param {NftId | TokenId | string} tokenIdOrNftId
   * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
   * @param {AccountId | string} receiverAccountIdOrSenderAccountId
   * @param {(AccountId | string)=} receiver
   * @returns {TransferTransaction}
   */
  _addNftTransfer(isApproved, tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver) {
    this._requireNotFrozen();
    let nftId;
    let senderAccountId;
    let receiverAccountId;
    if (tokenIdOrNftId instanceof NftId) {
      nftId = tokenIdOrNftId;
      senderAccountId = typeof senderAccountIdOrSerialNumber === "string" ? AccountId.fromString(senderAccountIdOrSerialNumber) : (
        /** @type {AccountId} */
        senderAccountIdOrSerialNumber
      );
      receiverAccountId = typeof receiverAccountIdOrSenderAccountId === "string" ? AccountId.fromString(receiverAccountIdOrSenderAccountId) : (
        /** @type {AccountId} */
        receiverAccountIdOrSenderAccountId
      );
    } else if (tokenIdOrNftId instanceof TokenId) {
      nftId = new NftId(
        tokenIdOrNftId,
        /** @type {Long} */
        senderAccountIdOrSerialNumber
      );
      senderAccountId = typeof receiverAccountIdOrSenderAccountId === "string" ? AccountId.fromString(receiverAccountIdOrSenderAccountId) : (
        /** @type {AccountId} */
        receiverAccountIdOrSenderAccountId
      );
      receiverAccountId = typeof receiver === "string" ? AccountId.fromString(receiver) : (
        /** @type {AccountId} */
        receiver
      );
    } else {
      try {
        nftId = NftId.fromString(tokenIdOrNftId);
        senderAccountId = typeof senderAccountIdOrSerialNumber === "string" ? AccountId.fromString(senderAccountIdOrSerialNumber) : (
          /** @type {AccountId} */
          senderAccountIdOrSerialNumber
        );
        receiverAccountId = typeof receiverAccountIdOrSenderAccountId === "string" ? AccountId.fromString(
          receiverAccountIdOrSenderAccountId
        ) : (
          /** @type {AccountId} */
          receiverAccountIdOrSenderAccountId
        );
      } catch (_) {
        const tokenId = TokenId.fromString(tokenIdOrNftId);
        nftId = new NftId(
          tokenId,
          /** @type {Long} */
          senderAccountIdOrSerialNumber
        );
        senderAccountId = typeof receiverAccountIdOrSenderAccountId === "string" ? AccountId.fromString(
          receiverAccountIdOrSenderAccountId
        ) : (
          /** @type {AccountId} */
          receiverAccountIdOrSenderAccountId
        );
        receiverAccountId = typeof receiver === "string" ? AccountId.fromString(receiver) : (
          /** @type {AccountId} */
          receiver
        );
      }
    }
    for (const nftTransfer of this._nftTransfers) {
      if (nftTransfer.tokenId.compare(nftId.tokenId) === 0 && nftTransfer.serialNumber.compare(nftId.serial) === 0) {
        nftTransfer.senderAccountId = senderAccountId;
        nftTransfer.receiverAccountId = receiverAccountId;
        return this;
      }
    }
    this._nftTransfers.push(
      new TokenNftTransfer({
        tokenId: nftId.tokenId,
        serialNumber: nftId.serial,
        senderAccountId,
        receiverAccountId,
        isApproved
      })
    );
    return this;
  }
  /**
   * @param {NftId | TokenId | string} tokenIdOrNftId
   * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
   * @param {AccountId | string} receiverAccountIdOrSenderAccountId
   * @param {(AccountId | string)=} receiver
   * @returns {TransferTransaction}
   */
  addNftTransfer(tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver) {
    return this._addNftTransfer(
      false,
      tokenIdOrNftId,
      senderAccountIdOrSerialNumber,
      receiverAccountIdOrSenderAccountId,
      receiver
    );
  }
  /**
   * @param {NftId | TokenId | string} tokenIdOrNftId
   * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
   * @param {AccountId | string} receiverAccountIdOrSenderAccountId
   * @param {(AccountId | string)=} receiver
   * @returns {TransferTransaction}
   */
  addApprovedNftTransfer(tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver) {
    return this._addNftTransfer(
      true,
      tokenIdOrNftId,
      senderAccountIdOrSerialNumber,
      receiverAccountIdOrSenderAccountId,
      receiver
    );
  }
  /**
   * @deprecated - Use `addApprovedHbarTransfer()` instead
   * @param {AccountId | string} accountId
   * @param {boolean} isApproved
   * @returns {TransferTransaction}
   */
  setHbarTransferApproval(accountId, isApproved) {
    const account = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId;
    for (const transfer of this._hbarTransfers) {
      if (transfer.accountId.compare(account) === 0) {
        transfer.isApproved = isApproved;
      }
    }
    return this;
  }
  /**
   * @deprecated - Use `addApprovedTokenTransfer()` instead
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} accountId
   * @param {boolean} isApproved
   * @returns {TransferTransaction}
   */
  setTokenTransferApproval(tokenId, accountId, isApproved) {
    const token = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
    const account = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId;
    for (const tokenTransfer of this._tokenTransfers) {
      if (tokenTransfer.tokenId.compare(token) === 0 && tokenTransfer.accountId.compare(account) === 0) {
        tokenTransfer.isApproved = isApproved;
      }
    }
    return this;
  }
  /**
   * @deprecated - Use `addApprovedNftTransfer()` instead
   * @param {NftId | string} nftId
   * @param {boolean} isApproved
   * @returns {TransferTransaction}
   */
  setNftTransferApproval(nftId, isApproved) {
    const nft = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
    for (const transfer of this._nftTransfers) {
      if (transfer.tokenId.compare(nft.tokenId) === 0 && transfer.serialNumber.compare(nft.serial) === 0) {
        transfer.isApproved = isApproved;
      }
    }
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.ITransaction} request
   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}
   */
  _execute(channel, request) {
    return channel.crypto.cryptoTransfer(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
   */
  _getTransactionDataCase() {
    return "cryptoTransfer";
  }
  /**
   * @override
   * @protected
   * @returns {HashgraphProto.proto.ICryptoTransferTransactionBody}
   */
  _makeTransactionData() {
    const tokenTransferList = [];
    this._tokenTransfers.sort((a, b) => {
      const compare3 = a.tokenId.compare(b.tokenId);
      if (compare3 !== 0) {
        return compare3;
      }
      return a.accountId.compare(b.accountId);
    });
    this._nftTransfers.sort((a, b) => {
      const senderComparision = a.senderAccountId.compare(
        b.senderAccountId
      );
      if (senderComparision != 0) {
        return senderComparision;
      }
      const recipientComparision = a.receiverAccountId.compare(
        b.receiverAccountId
      );
      if (recipientComparision != 0) {
        return recipientComparision;
      }
      return a.serialNumber.compare(b.serialNumber);
    });
    let i = 0;
    let j = 0;
    while (i < this._tokenTransfers.length || j < this._nftTransfers.length) {
      if (i < this._tokenTransfers.length && j < this._nftTransfers.length) {
        const iTokenId = this._tokenTransfers[i].tokenId;
        const jTokenId = this._nftTransfers[j].tokenId;
        const last = tokenTransferList.length > 0 ? tokenTransferList[tokenTransferList.length - 1] : null;
        const lastTokenId = last != null ? last.tokenId : null;
        if (last != null && lastTokenId != null && lastTokenId.compare(iTokenId) === 0) {
          last.transfers.push(this._tokenTransfers[i++]);
          continue;
        }
        if (last != null && lastTokenId != null && lastTokenId.compare(jTokenId) === 0) {
          last.nftTransfers.push(this._nftTransfers[j++]);
          continue;
        }
        const result = iTokenId.compare(jTokenId);
        if (result === 0) {
          tokenTransferList.push({
            tokenId: iTokenId,
            expectedDecimals: this._tokenTransfers[i].expectedDecimals,
            transfers: [this._tokenTransfers[i++]],
            nftTransfers: [this._nftTransfers[j++]]
          });
        } else if (result < 0) {
          tokenTransferList.push({
            tokenId: iTokenId,
            expectedDecimals: this._tokenTransfers[i].expectedDecimals,
            transfers: [this._tokenTransfers[i++]],
            nftTransfers: []
          });
        } else {
          tokenTransferList.push({
            tokenId: jTokenId,
            expectedDecimals: null,
            transfers: [],
            nftTransfers: [this._nftTransfers[j++]]
          });
        }
      } else if (i < this._tokenTransfers.length) {
        const iTokenId = this._tokenTransfers[i].tokenId;
        let last;
        for (const transfer of tokenTransferList) {
          if (transfer.tokenId.compare(iTokenId) === 0) {
            last = transfer;
          }
        }
        const lastTokenId = last != null ? last.tokenId : null;
        if (last != null && lastTokenId != null && lastTokenId.compare(iTokenId) === 0) {
          last.transfers.push(this._tokenTransfers[i++]);
          continue;
        }
        tokenTransferList.push({
          tokenId: iTokenId,
          expectedDecimals: this._tokenTransfers[i].expectedDecimals,
          transfers: [this._tokenTransfers[i++]],
          nftTransfers: []
        });
      } else if (j < this._nftTransfers.length) {
        const jTokenId = this._nftTransfers[j].tokenId;
        let last;
        for (const transfer of tokenTransferList) {
          if (transfer.tokenId.compare(jTokenId) === 0) {
            last = transfer;
          }
        }
        const lastTokenId = last != null ? last.tokenId : null;
        if (last != null && lastTokenId != null && lastTokenId.compare(jTokenId) === 0) {
          last.nftTransfers.push(this._nftTransfers[j++]);
          continue;
        }
        tokenTransferList.push({
          tokenId: jTokenId,
          expectedDecimals: null,
          transfers: [],
          nftTransfers: [this._nftTransfers[j++]]
        });
      }
    }
    this._hbarTransfers.sort((a, b) => a.accountId.compare(b.accountId));
    return {
      transfers: {
        accountAmounts: this._hbarTransfers.map((transfer) => {
          return {
            accountID: transfer.accountId._toProtobuf(),
            amount: transfer.amount.toTinybars(),
            isApproval: transfer.isApproved
          };
        })
      },
      tokenTransfers: tokenTransferList.map((tokenTransfer) => {
        return {
          token: tokenTransfer.tokenId._toProtobuf(),
          expectedDecimals: tokenTransfer.expectedDecimals != null ? { value: tokenTransfer.expectedDecimals } : null,
          transfers: tokenTransfer.transfers.map(
            (transfer) => transfer._toProtobuf()
          ),
          nftTransfers: tokenTransfer.nftTransfers.map(
            (transfer) => transfer._toProtobuf()
          )
        };
      })
    };
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    const timestamp = (
      /** @type {import("../Timestamp.js").default} */
      this._transactionIds.current.validStart
    );
    return `TransferTransaction:${timestamp.toString()}`;
  }
};
TRANSACTION_REGISTRY.set(
  "cryptoTransfer",
  // eslint-disable-next-line @typescript-eslint/unbound-method
  TransferTransaction._fromProtobuf
);

// node_modules/@hashgraph/sdk/src/Wallet.js
var Wallet = class _Wallet {
  /**
   * NOTE: When using string for private key, the string needs to contain DER headers
   *
   * @param {AccountId | string} accountId
   * @param {PrivateKey | string} privateKey
   * @param {Provider=} provider
   */
  constructor(accountId, privateKey, provider) {
    const key = typeof privateKey === "string" ? PrivateKey2.fromStringDer(privateKey) : privateKey;
    this.publicKey = key.publicKey;
    this.signer = (message) => Promise.resolve(key.sign(message));
    this.provider = provider;
    this.accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId;
  }
  /**
   * @returns {Promise<Wallet>}
   */
  static createRandomED25519() {
    const privateKey = PrivateKey2.generateED25519();
    const publicKey = privateKey.publicKey;
    const accountId = publicKey.toAccountId(0, 0);
    return Promise.resolve(new _Wallet(accountId, privateKey));
  }
  /**
   * @returns {Promise<Wallet>}
   */
  static createRandomECDSA() {
    const privateKey = PrivateKey2.generateECDSA();
    const publicKey = privateKey.publicKey;
    const accountId = publicKey.toAccountId(0, 0);
    return Promise.resolve(new _Wallet(accountId, privateKey));
  }
  /**
   * @returns {Provider=}
   */
  getProvider() {
    return this.provider;
  }
  /**
   * @abstract
   * @returns {AccountId}
   */
  getAccountId() {
    return this.accountId;
  }
  /**
   * @returns {Key}
   */
  getAccountKey() {
    return this.publicKey;
  }
  /**
   * @returns {LedgerId?}
   */
  getLedgerId() {
    return this.provider == null ? null : this.provider.getLedgerId();
  }
  /**
   * @abstract
   * @returns {{[key: string]: (string | AccountId)}}
   */
  getNetwork() {
    return this.provider == null ? {} : this.provider.getNetwork();
  }
  /**
   * @abstract
   * @returns {string[]}
   */
  getMirrorNetwork() {
    return this.provider == null ? [] : this.provider.getMirrorNetwork();
  }
  /**
   * @param {Uint8Array[]} messages
   * @returns {Promise<SignerSignature[]>}
   */
  async sign(messages) {
    const sigantures = [];
    for (const message of messages) {
      sigantures.push(
        new SignerSignature({
          publicKey: this.publicKey,
          signature: await this.signer(message),
          accountId: this.accountId
        })
      );
    }
    return sigantures;
  }
  /**
   * @returns {Promise<AccountBalance>}
   */
  getAccountBalance() {
    return this.call(
      new AccountBalanceQuery().setAccountId(this.accountId)
    );
  }
  /**
   * @abstract
   * @returns {Promise<AccountInfo>}
   */
  getAccountInfo() {
    return this.call(new AccountInfoQuery().setAccountId(this.accountId));
  }
  /**
   * @abstract
   * @returns {Promise<TransactionRecord[]>}
   */
  getAccountRecords() {
    return this.call(
      new AccountRecordsQuery().setAccountId(this.accountId)
    );
  }
  /**
   * @template {Transaction} T
   * @param {T} transaction
   * @returns {Promise<T>}
   */
  signTransaction(transaction) {
    return transaction.signWith(this.publicKey, this.signer);
  }
  /**
   * @template {Transaction} T
   * @param {T} transaction
   * @returns {Promise<T>}
   */
  checkTransaction(transaction) {
    const transactionId = transaction.transactionId;
    if (transactionId != null && transactionId.accountId != null && transactionId.accountId.compare(this.accountId) != 0) {
      throw new Error(
        "transaction's ID constructed with a different account ID"
      );
    }
    if (this.provider == null) {
      return Promise.resolve(transaction);
    }
    const nodeAccountIds = (transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []).map((nodeAccountId) => nodeAccountId.toString());
    const network = Object.values(this.provider.getNetwork()).map(
      (nodeAccountId) => nodeAccountId.toString()
    );
    if (!nodeAccountIds.reduce(
      (previous, current) => previous && network.includes(current),
      true
    )) {
      throw new Error(
        "Transaction already set node account IDs to values not within the current network"
      );
    }
    return Promise.resolve(transaction);
  }
  /**
   * @template {Transaction} T
   * @param {T} transaction
   * @returns {Promise<T>}
   */
  populateTransaction(transaction) {
    transaction._freezeWithAccountId(this.accountId);
    if (transaction.transactionId == null) {
      transaction.setTransactionId(
        TransactionId.generate(this.accountId)
      );
    }
    if (transaction.nodeAccountIds != null && transaction.nodeAccountIds.length != 0) {
      return Promise.resolve(transaction.freeze());
    }
    if (this.provider == null) {
      return Promise.resolve(transaction);
    }
    const nodeAccountIds = Object.values(this.provider.getNetwork()).map(
      (id2) => typeof id2 === "string" ? AccountId.fromString(id2) : id2
    );
    shuffle(nodeAccountIds);
    transaction.setNodeAccountIds(
      nodeAccountIds.slice(0, (nodeAccountIds.length + 3 - 1) / 3)
    );
    return Promise.resolve(transaction.freeze());
  }
  /**
   * @template RequestT
   * @template ResponseT
   * @template OutputT
   * @param {Executable<RequestT, ResponseT, OutputT>} request
   * @returns {Promise<OutputT>}
   */
  call(request) {
    if (this.provider == null) {
      throw new Error(
        "cannot send request with an wallet that doesn't contain a provider"
      );
    }
    return this.provider.call(
      request._setOperatorWith(
        this.accountId,
        this.publicKey,
        this.signer
      )
    );
  }
};

// node_modules/@hashgraph/sdk/src/logger/Logger.js
var import_pino = __toESM(require_browser(), 1);

// node_modules/@hashgraph/sdk/src/logger/LogLevel.js
var LogLevel2 = class _LogLevel {
  /**
   * @hideconstructor
   * @internal
   * @param {string} name
   */
  constructor(name) {
    this._name = name;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */
  toString() {
    switch (this) {
      case _LogLevel.Silent:
        return "silent";
      case _LogLevel.Trace:
        return "trace";
      case _LogLevel.Debug:
        return "debug";
      case _LogLevel.Info:
        return "info";
      case _LogLevel.Warn:
        return "warn";
      case _LogLevel.Error:
        return "error";
      case _LogLevel.Fatal:
        return "fatal";
      default:
        return `Unknown log level (${this._name})`;
    }
  }
  /**
   * @param {string} level
   * @returns {LogLevel}
   */
  static _fromString(level) {
    switch (level) {
      case "silent":
        return _LogLevel.Silent;
      case "trace":
        return _LogLevel.Trace;
      case "debug":
        return _LogLevel.Debug;
      case "info":
        return _LogLevel.Info;
      case "warn":
        return _LogLevel.Warn;
      case "error":
        return _LogLevel.Error;
      case "fatal":
        return _LogLevel.Fatal;
      default:
        throw new Error(`Unknown log level: ${level}`);
    }
  }
};
LogLevel2.Silent = new LogLevel2("silent");
LogLevel2.Trace = new LogLevel2("trace");
LogLevel2.Debug = new LogLevel2("debug");
LogLevel2.Info = new LogLevel2("info");
LogLevel2.Warn = new LogLevel2("warn");
LogLevel2.Error = new LogLevel2("error");
LogLevel2.Fatal = new LogLevel2("fatal");

// node_modules/@hashgraph/sdk/src/logger/Logger.js
var Logger2 = class {
  /**
   * @param {LogLevel} level
   */
  constructor(level) {
    this._logger = (0, import_pino.default)({
      level: level.toString(),
      transport: {
        target: "pino-pretty",
        options: {
          translateTime: "SYS:dd-mm-yyyy HH:MM:ss",
          ignore: "pid,hostname"
        }
      }
    });
    this._previousLevel = level;
  }
  /**
   * Set logger
   *
   * @public
   * @param {import("pino").Logger} logger
   * @returns {this}
   */
  setLogger(logger15) {
    this._logger = logger15;
    return this;
  }
  /**
   * Set log level
   *
   * @public
   * @param {LogLevel} level
   * @returns {this}
   */
  setLevel(level) {
    this._previousLevel = LogLevel2._fromString(this._logger.level);
    this._logger.level = level.toString();
    return this;
  }
  /**
   * Get logging level
   *
   * @public
   * @returns {LogLevel}
   */
  get level() {
    return LogLevel2._fromString(this._logger.level);
  }
  /**
   * Get logging level
   *
   * @public
   * @returns {{[level: number]: string}}
   */
  get levels() {
    return this._logger.levels.labels;
  }
  /**
   * Set silent mode on/off
   *
   * @public
   * @description If set to true, the logger will not display any log messages
   * - This can also be achieved by calling `.setLevel(LogLevel.Silent)`
   * @param {boolean} silent
   * @returns {this}
   */
  setSilent(silent) {
    if (silent) {
      this._logger.level = LogLevel2.Silent.toString();
    } else {
      this._logger.level = this._previousLevel.toString();
    }
    return this;
  }
  /**
   * Get silent mode
   *
   * @public
   * @returns {boolean}
   */
  get silent() {
    return this._logger.level == LogLevel2.Silent.toString();
  }
  /**
   * Log trace
   *
   * @public
   * @param {string} message
   * @returns {void}
   */
  trace(message) {
    this._logger.trace(message);
  }
  /**
   * Log debug
   *
   * @public
   * @param {string} message
   * @returns {void}
   */
  debug(message) {
    this._logger.debug(message);
  }
  /**
   * Log info
   *
   * @public
   * @param {string} message
   * @returns {void}
   */
  info(message) {
    this._logger.info(message);
  }
  /**
   * Log warn
   *
   * @public
   * @param {string} message
   * @returns {void}
   */
  warn(message) {
    this._logger.warn(message);
  }
  /**
   * Log error
   *
   * @public
   * @param {string} message
   * @returns {void}
   */
  error(message) {
    this._logger.error(message);
  }
  /**
   * Log fatal
   *
   * @public
   * @param {string} message
   * @returns {void}
   */
  fatal(message) {
    this._logger.fatal(message);
  }
};

// node_modules/@hashgraph/sdk/src/exports.js
var import_long52 = __toESM(require_long(), 1);

// node_modules/@hashgraph/sdk/src/query/CostQuery.js
var HashgraphProto38 = __toESM(require_lib(), 1);
var CostQuery = class extends Executable {
  /**
   * @param {import("./Query.js").default<OutputT>} query
   */
  constructor(query) {
    super();
    this._query = query;
    this._grpcDeadline = query._grpcDeadline;
    this._requestTimeout = query._requestTimeout;
    this._nodeAccountIds = query._nodeAccountIds.clone();
    this._operator = query._operator;
    this._header = null;
  }
  /**
   * @returns {TransactionId}
   */
  _getTransactionId() {
    return this._query._getTransactionId();
  }
  /**
   * @returns {string}
   */
  _getLogId() {
    return `CostQuery:${this._query._getLogId()}`;
  }
  /**
   * @abstract
   * @protected
   * @param {import("../client/Client.js").default<*, *>} client
   * @returns {Promise<void>}
   */
  async _beforeExecute(client) {
    if (client == null) {
      throw new Error("Cannot do CostQuery without Client");
    }
    const operator = this._operator != null ? this._operator : client._operator;
    if (operator == null) {
      throw new Error(
        "`client` must have an `operator` or an explicit payment transaction must be provided"
      );
    }
    if (this._query._nodeAccountIds.isEmpty) {
      this._query._nodeAccountIds.setList(
        client._network.getNodeAccountIdsForExecute()
      );
    }
    const transactionId = TransactionId.generate(operator.accountId);
    if (this._query.paymentTransactionId == null) {
      this._query.setPaymentTransactionId(transactionId);
    }
    const logId = this._getLogId();
    const nodeId = new AccountId(0);
    const paymentTransactionId = (
      /** @type {import("../transaction/TransactionId.js").default} */
      TransactionId.generate(new AccountId(0))
    );
    const paymentAmount = new Hbar(0);
    if (this._logger) {
      this._logger.debug(
        `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`
      );
    }
    this._header = {
      payment: await _makePaymentTransaction(
        paymentTransactionId,
        new AccountId(0),
        operator,
        paymentAmount
      ),
      responseType: HashgraphProto38.proto.ResponseType.COST_ANSWER
    };
  }
  /**
   * @abstract
   * @internal
   * @returns {Promise<HashgraphProto.proto.IQuery>}
   */
  _makeRequestAsync() {
    return Promise.resolve(
      this._query._onMakeRequest(
        /** @type {HashgraphProto.proto.IQueryHeader} */
        this._header
      )
    );
  }
  /**
   * @abstract
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {[Status, ExecutionState]}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _shouldRetry(request, response) {
    return this._query._shouldRetry(request, response);
  }
  /**
   * @abstract
   * @internal
   * @param {HashgraphProto.proto.IQuery} request
   * @param {HashgraphProto.proto.IResponse} response
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapStatusError(request, response) {
    return this._query._mapStatusError(request, response);
  }
  /**
   * @override
   * @internal
   * @param {HashgraphProto.proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<Hbar>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _mapResponse(response, nodeAccountId, request) {
    const cost = this._query._mapResponseHeader(response).cost;
    return Promise.resolve(
      Hbar.fromTinybars(
        /** @type {Long | number} */
        cost
      )
    );
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {HashgraphProto.proto.IQuery} request
   * @returns {Promise<HashgraphProto.proto.IResponse>}
   */
  _execute(channel, request) {
    return this._query._execute(channel, request);
  }
  /**
   * @param {HashgraphProto.proto.Query} request
   * @returns {Uint8Array}
   */
  _requestToBytes(request) {
    return this._query._requestToBytes(request);
  }
  /**
   * @param {HashgraphProto.proto.Response} response
   * @returns {Uint8Array}
   */
  _responseToBytes(response) {
    return this._query._responseToBytes(response);
  }
};
COST_QUERY.push((query) => new CostQuery(query));

// node_modules/@hashgraph/sdk/src/exports.js
var NetworkName = {
  Mainnet: "mainnet",
  Testnet: "testnet",
  Previewnet: "previewnet"
};

// node_modules/@hashgraph/sdk/src/ManagedNodeAddress.js
var HOST_AND_PORT = /^(\S+):(\d+)$/;
var ManagedNodeAddress = class _ManagedNodeAddress {
  /**
   * @param {object} props
   * @param {string} [props.address]
   * @param {string} [props.host]
   * @param {number | null} [props.port]
   */
  constructor(props = {}) {
    if (props.address != null) {
      const hostAndPortResult = HOST_AND_PORT.exec(props.address);
      if (hostAndPortResult == null) {
        throw new Error(`failed to parse address: ${props.address}`);
      }
      this._address = /** @type {string} */
      hostAndPortResult[1];
      this._port = hostAndPortResult[2] != null ? parseInt(
        /** @type {string }*/
        hostAndPortResult[2]
      ) : null;
    } else if (props.host != null && props.port != null) {
      this._address = props.host;
      this._port = props.port;
    } else {
      throw new Error(
        `failed to create a managed node address: ${JSON.stringify(
          props
        )}`
      );
    }
    Object.freeze(this);
  }
  /**
   * @param {string} address
   * @returns {ManagedNodeAddress};
   */
  static fromString(address) {
    return new _ManagedNodeAddress({ address });
  }
  toInsecure() {
    let port = this.port === 50212 ? 50211 : this.port;
    return new _ManagedNodeAddress({ host: this.address, port });
  }
  toSecure() {
    let port = this.port === 50211 ? 50212 : this.port;
    return new _ManagedNodeAddress({ host: this.address, port });
  }
  /**
   * @returns {string}
   */
  get address() {
    return this._address;
  }
  /**
   * @returns {number | null}
   */
  get port() {
    return this._port;
  }
  /**
   * @returns {boolean}
   */
  isTransportSecurity() {
    return this._port == 50212 || this._port == 443;
  }
  /**
   * @returns {string}
   */
  toString() {
    if (this.port == null) {
      return this.address;
    } else {
      return `${this.address}:${this.port}`;
    }
  }
};

// node_modules/@hashgraph/sdk/src/ManagedNode.js
var ManagedNode = class {
  /**
   * @param {object} props
   * @param {NewNode<ChannelT>=} [props.newNode]
   * @param {CloneNode<ChannelT>=} [props.cloneNode]
   */
  constructor(props = {}) {
    if (props.newNode != null) {
      this._address = typeof props.newNode.address === "string" ? ManagedNodeAddress.fromString(props.newNode.address) : props.newNode.address;
      this._cert = void 0;
      this._channel = null;
      this._channelInitFunction = props.newNode.channelInitFunction;
      this._lastUsed = Date.now();
      this._readmitTime = Date.now();
      this._useCount = 0;
      this._badGrpcStatusCount = 0;
      this._minBackoff = 8e3;
      this._maxBackoff = 1e3 * 60 * 60;
      this._currentBackoff = this._minBackoff;
    } else if (props.cloneNode != null) {
      this._address = props.cloneNode.address;
      this._cert = props.cloneNode.node._cert;
      this._channel = props.cloneNode.node._channel;
      this._channelInitFunction = props.cloneNode.node._channelInitFunction;
      this._currentBackoff = props.cloneNode.node._currentBackoff;
      this._lastUsed = props.cloneNode.node._lastUsed;
      this._readmitTime = props.cloneNode.node._readmitTime;
      this._useCount = props.cloneNode.node._useCount;
      this._badGrpcStatusCount = props.cloneNode.node._badGrpcStatusCount;
      this._minBackoff = props.cloneNode.node._minBackoff;
      this._maxBackoff = props.cloneNode.node._minBackoff;
    } else {
      throw new Error(
        `failed to create ManagedNode: ${JSON.stringify(props)}`
      );
    }
  }
  /**
   * @abstract
   * @returns {string}
   */
  // eslint-disable-next-line jsdoc/require-returns-check
  getKey() {
    throw new Error("not implemented");
  }
  /**
   * @param {string} ledgerId
   * @returns {this}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setCert(ledgerId) {
    return this;
  }
  /**
   * @returns {ManagedNodeAddress}
   */
  get address() {
    return this._address;
  }
  /**
   * @returns {number}
   */
  get attempts() {
    return this._badGrpcStatusCount;
  }
  /**
   * @returns {number}
   */
  get minBackoff() {
    return this._minBackoff;
  }
  /**
   * @param {number} minBackoff
   * @returns {this}
   */
  setMinBackoff(minBackoff) {
    if (this._currentBackoff <= minBackoff) {
      this._currentBackoff = minBackoff;
    }
    this._minBackoff = minBackoff;
    return this;
  }
  /**
   * @returns {number}
   */
  get maxBackoff() {
    return this._maxBackoff;
  }
  /**
   * @param {number} maxBackoff
   * @returns {this}
   */
  setMaxBackoff(maxBackoff) {
    if (this._currentBackoff <= maxBackoff) {
      this._currentBackoff = maxBackoff;
    }
    this._maxBackoff = maxBackoff;
    return this;
  }
  getChannel() {
    this._useCount++;
    this.__lastUsed = Date.now();
    if (this._channel != null) {
      return this._channel;
    }
    this._channel = this._channelInitFunction(
      this.address.toString(),
      this._cert
    );
    return this._channel;
  }
  /**
   * Determines if this node is healthy by checking if this node hasn't been
   * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`
   * and that value is only set in the `wait()` method, any node that has not
   * returned a bad gRPC status will always be considered healthy.
   *
   * @returns {boolean}
   */
  isHealthy() {
    return this._readmitTime <= Date.now();
  }
  increaseBackoff() {
    this._currentBackoff = Math.min(
      this._currentBackoff * 2,
      this._maxBackoff
    );
    this._readmitTime = Date.now() + this._currentBackoff;
  }
  decreaseBackoff() {
    this._currentBackoff = Math.max(
      this._currentBackoff / 2,
      this._minBackoff
    );
  }
  /**
   * @returns {number}
   */
  getRemainingTime() {
    return this._readmitTime - this._lastUsed;
  }
  /**
   * This is only ever called if the node itself is down.
   * A node returning a transaction with a bad status code does not indicate
   * the node is down, and hence this method will not be called.
   *
   * @returns {Promise<void>}
   */
  backoff() {
    return new Promise(
      (resolve) => setTimeout(resolve, this.getRemainingTime())
    );
  }
  /**
   * @param {ManagedNode<*>} node
   * @returns {number}
   */
  compare(node) {
    let comparison = this.getRemainingTime() - node.getRemainingTime();
    if (comparison != 0) {
      return comparison;
    }
    comparison = this._currentBackoff - node._currentBackoff;
    if (comparison != 0) {
      return comparison;
    }
    comparison = this._badGrpcStatusCount - node._badGrpcStatusCount;
    if (comparison != 0) {
      return comparison;
    }
    comparison = this._useCount - node._useCount;
    if (comparison != 0) {
      return comparison;
    }
    return this._lastUsed - node._lastUsed;
  }
  close() {
    if (this._channel != null) {
      this._channel.close();
    }
    this._channel = null;
  }
};

// node_modules/@hashgraph/sdk/src/NodeCerts.js
var PREVIEWNET_CERTS = {
  "0.0.3": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUenyqJ4UaFBbwokatcUqAwW3o3rswCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU4WhgPMjI5NTA2MDcyMjIxNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEm5b1+oG9R0qt
zM7UZnS5l/xxUNHIHq5+NAvtlviCpJL19jrW9+/UOy00Qqc6vS6tS1hS+dNJmpiZ
FN0EHew4VDR7ACnL4LDJKmIHWjQ0iwvZo5kCpO0r9BtPN5FvaSxyo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUeciBviJtjeuue0GPf1xllNw7qvYwCgYIKoZIzj0EAwMDaAAwZQIw
JeG0H2HdsI1VhOYmJmYlNeKCNgAk+LMorzPmsIInVBO2HK2IrKfpReWDS/m5j51V
AjEAxKBxDezJDqAZHTkTXCg+X9Q9V6J6M5yDy5IS90aCWEo+W8C1Hc6hkn2/NrvT
PhwK
-----END CERTIFICATE-----
`,
  "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUUfjO8LyXBdzrzbAe1Yl+d34IDsIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAERwfj4ZtD/wRb
f8h9NEMu2sQoLFK9Gc4SQ8o6j4ccLYGdgOoVoq4zzy4Jr7ZtCTuACfCfhp7wy8ra
+6cugccaSd6AzOKRSVZvQvkUTFKIoAOKwp6IhlU48rmi80MT07eyo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUCGhfVMP72Y0G5XUksE3dPgFHrzkwCgYIKoZIzj0EAwMDZwAwZAIw
cpX7irZWyuujWRYUs9kLNgB2YLQK+n8r1fH+tJg3+zkcZ2pzhGWmpUUZWOzsDqGC
AjBUbhlmrTc4LrEBN0EMiRYzfPD2kBZxusLBDIg/aDYERCMcsFvF1T9SsuasF/B+
cI8=
-----END CERTIFICATE-----
`,
  "0.0.5": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUIo4L+7xe/mUmpKy4qOAQEIxz8UMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEoFgCjb1/7BUJ
EXKIPJLlsOSp/39G8l92wOSr7h+Py7iwVwu68H2ykftMOq3tRwDRXZHz7ViqcIZ9
lfMcS8sbRtVm9tBbNciVUqTLWX9nHr/c4PhKEi+LdgtSUr2+hHiWo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUMR89BHC3yKC4YwUgyBVQUGBCprQwCgYIKoZIzj0EAwMDZwAwZAIw
Us2BdslcScIwcmxoB60K7/1BPfQI8ccDZIMosas6U2zhinTnRKik1T0i+uHhLl8e
AjA5apAwSPTnP7j3Bo/FOCkfjTqOjwp2lUqzDJYKolKsHX2sy8hX9MkYiY46SaJ1
P+0=
-----END CERTIFICATE-----
`,
  "0.0.6": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUWpji03mJsR/16MP8BrOfpNz7aQMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE+KDMC99Q1rWi
+FwlytGMS5qzTDytCvk+PzdONnDZ/weNSv4j3BXSo588IwhIxLtfcBlyo/+PmE1c
5qGFXuMoZjGr22VpvogkRgPejD+Gawb4A2XHkMCD8NmO66uPw97po1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUN1qEI4eQ+WHavb9ypGV417NvhGowCgYIKoZIzj0EAwMDaAAwZQIw
L0khkiDOiFRa3wx9l5JNjaSRePPc3ZaTaJQkPYeauMaLWEvmC/0e2/e9gPm5qJ8E
AjEAgXQMko3vNB8VRN4XjyFJa8p/muZ/tLA15wPnb/boUmiZ+njDDSaiu8tIQrTB
gHW6
-----END CERTIFICATE-----
`,
  "0.0.7": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUEJ7AJvrqDUBNKbssGoJtww3v+WowCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjAwWhgPMjI5NTA2MDcyMjIyMDBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEfgJ8w9GUWM3y
yusedZOFQrgXFVsdtRsMSHbqyVCN6+Wow6SIjy29GRMSP5R2aswupFgh6lXJRqnr
tY+hpRumFKsmSo+5+l8DBcql4rzs4utESTehM+Cq9LYc4A1z0UIRo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUMCm3UqSbT01Zr23hLzCGnXbDa+MwCgYIKoZIzj0EAwMDZwAwZAIw
FNcN7mKJo/bwpRT+y/KbYkCJsvljdbXzJOXXQ3e6J6R+0vLqcT25J/ry6pBZMUwR
AjAswu29z8KJCSxnWwnPpHDmkRT15zG/xS+pAmx3oeQSqp6ZD7qpdJE8zzhbfe5x
wAc=
-----END CERTIFICATE-----
`
};
var TESTNET_CERTS = {
  "0.0.3": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUMkNeM6Sbk9ZFYmRWZmSgTQHHWyUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAETLLoIMZjEhDP
KLHS7bJT4OTYGgR/8mB65yfx3KqMLYFF+q2SpWkIrYgUQLVEUEibVSnLlxRUzH7R
szcKynpTwh0W0yfWanZKQg+RWoKkEYlu2GvkUtJb8cRVM9NLmJUeo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUSrIepwFx8gZ8/G+WGaxs6GgkMtQwCgYIKoZIzj0EAwMDaQAwZgIx
AJxC0fjB1OrF9vkCKsfnPS3Z+1hscrZhEDG38NxdLEAfPQ5VmyrSBgJy11FBp8yB
0QIxAKzbge3Lf7iBMwYwm+2M/GiVgmHNMLdtrYuerWpdbYOHgRNAkyt57JoThn0u
Tzkd5Q==
-----END CERTIFICATE-----
`,
  "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUGLriiLPacglp6U+BtJcF9TI7xEUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEXhR9cb6mH9AE
GNSGk3OkxN1C/JW49ddYZ/XWD4InjS8D1kXmB1Y39v1mF0L1loG6lDT8Zp46zrj7
5zMONXZeD2b0mx5hHhtllPTpJ10Tlt9FDoyFbKwPRQ/SAPNADfuzo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUCaKtx8RZ1XJO9rmZMbIcFJZkcv4wCgYIKoZIzj0EAwMDaAAwZQIx
APhDW0VrNSmq8hODdhIVV4GyvpYhp3Fksg+sZr3DmUatwn+ptj+X+9IzgPl9QYE3
kAIwcy2ixgNkjC/DYVmgT4MpUnLneLK0gA23Vj2QwACaTH99H/ybqUH7srj0POB9
5wvV
-----END CERTIFICATE-----
`,
  "0.0.5": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUEMduome38hvAuIKoGjg/tHatQZMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEl1olzP1L4WgX
d7aujOXmTQZt3tEOGzkMa3S6qJwISLBI7Tb9KaW8zYIe9xWBVAwphCbD0wn9xpPV
wMr4uTn+JocugYBbe2YoUGzWTkxWnOEKXbh/nQJCe3XE/C0FY8fAo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQULfw7LVtTiUDVIvZwhhWW0soQtSQwCgYIKoZIzj0EAwMDaQAwZgIx
AID5v3Lo2zlnpFzTdJFqBpw6fV+vmpI+JBj61f264J/uHMbELiu2dwxhwWaMElX7
wQIxAJxccFr7Bf1KjaMyT2dq75zQzFuKDMj9x92yAqM2Gas/Yay+Ccpm8FBn7BFl
ke1Qwg==
-----END CERTIFICATE-----
`,
  "0.0.6": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUcCg/gZGxk/UjYkhW1jg4Zki+jfwwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU5WhgPMjI5NTA2MDcyMjIyNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEOSsXBZicyrxy
tHJHKh04Mvu6SKM49IC7rAXw5CjlOod5OTeHg0fa5vVoBME4mlWP+LsMMqf8welC
20b4wMwUC1Hnd66v8crX8L1wvZ9EmKLTvhTd65bS5zloMiSbpdF2o1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUgMMwqaGuUT6JCH0gsbqullaW6/QwCgYIKoZIzj0EAwMDaAAwZQIx
AMggJ1eMmT7C14z7wHCsOdDOgmzg733+a5dsuAcxknoz/sQLN8wqy1JxShWgEIA/
xwIweTDAX/4JZnr3mlSC57lYXbHk/c319VfN9Ybxg0FaDXa8tOqg7Ml6Uu3IGujQ
a3eY
-----END CERTIFICATE-----
`,
  "0.0.7": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUXADwhiD5acpA66GPoXuAevBfZBIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU5WhgPMjI5NTA2MDcyMjIyNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEBgLhLiGz8qWu
50vzxSyQkrmhpxuHBJhpGzA0WaUJdAUlaUOL1753ZxxA08wUmcozILNEnMaQ+ROn
+fuGctv90ZcrSekODjxjbKH2ntVLP8xwkBRCTJ0WRBNenxxBD438o1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUhYOOD/z3ty9O5GuSTXnyujIqBRgwCgYIKoZIzj0EAwMDaQAwZgIx
AMxbZ4gvkXaORauQFUPRYwOJrihWIA+3ttGDua//YfEbshytQ8b4L65W/1Xs8eOd
DwIxAImwTzRam8tScdOzmuGgPcML2lkETMpMA2rZYVyEL/VNktIxvB2oE+4M0v5l
r8IbTA==
-----END CERTIFICATE-----
`
};
var MAINNET_CERTS = {
  "0.0.3": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUZWoT9TlgbZy+syLbqZhO5++1cVgwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8NhDGK/dgWvD
RHEJ8af7CBDdhvujH5XIrLen33GTLY8DbJwJW2jdsLGx3+DRVVmeNQZxCbcGj0e2
IyypkG6s0mtnmeymD8mI3JU8m1aZiuIptZSH3Bw1BNn2hKU4x42co1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUbYGliiNtMkGaroQxXWCl+kYHDBwwCgYIKoZIzj0EAwMDZwAwZAIw
ImTOEYu0y73Ggt4NAjFFsN2sV7CsEL3NoJqJ7MZ6U+b3Ax1hnc1eE0oei6xH4VNF
AjBB4iZNvAn6Esiu4k+JPlYuMesplgMv33fU5GsfvLIovN8pOJDe0c+CUmsnfGbP
OsQ=
-----END CERTIFICATE-----
`,
  "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUEGWU0F4aKffY+le55ahQaScDYDwwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEqW6TqxMmjL3h
9AVBgfVaFRZlXUcyWa+QYhzxr8sksgJqfDbmGtdaHIdiL1qCPuC4v4G3qrAbXZRm
TYNo5Lz0X2ic5pES6DbacdjOgHH7TAY4BVKkuVrydln2jjhh7SmBo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUcBlY5a1rV0H1iQuJMwWxrTEWQ6MwCgYIKoZIzj0EAwMDZwAwZAIw
R+mY9B2U26yD44s03hjz4TlpkyXbVfmgL3Elqo3lrWDJtvT4zpjGjxg3Q1P3SpZQ
AjAy9DRVrZPzq8iq5Ir7B8XgLQH5QL7SQ3tUL1HzXJYOukvn9Ofr+QADhpb0oJLB
Kug=
-----END CERTIFICATE-----
`,
  "0.0.5": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUbxzfD3ihIK5snumqqKtqtcBPSSQwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEWoAjWmW7vpUr
U69wRbK9Firons4kRoin6N8lMjCD+xzsrsT6/wycpzC0F8fxfIvOYSMWRtinhOKl
ZAxp60OWYP87iH7RqWBAnHIJZj/znKTGd+8Sqp/RVQmButFHg/+Go1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUTMtwuDzI4Hun7SPp2Nb3scjUUXkwCgYIKoZIzj0EAwMDZwAwZAIw
HKAgaX39Lgc+4/xHXzZR9mi2p3pf6CDO85Xm56UR/t48HnBkRorR3TFCBXACeIIs
AjBtXglpDnRf6M+nVBlxLdwCQXiwr6vQJ9+dUo+suNkZ1JBmtHypyIqkG2yT4z9C
Lcs=
-----END CERTIFICATE-----
`,
  "0.0.6": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUPwXdJvpCJYO9lm6uQN3S1aBi3PswCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ4WhgPMjI5NTA2MDcyMjQyNDhaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8PwBQ0ywu+0t
eIYbaiKwzGEScQMOYFYAMw49++6bGRiH/XZjsypqlJWy3F/mB3+HNVZsqgB61Jpj
2p98Afkl57MYWhWM29t/x5qAQ8LhKGu2k+BOnCcvHDU2pR+fmFSOo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUgI4r3/iwzFN2wh76y/4XDBk7wgkwCgYIKoZIzj0EAwMDaQAwZgIx
ANAjwHdTWYMCCjrtb2NWzDpsKjf3m6ZcaxbEcM1ta/Zji/4x0+VRZa917CkfaEsr
LAIxAK/erPvIXRU9eNaK/TAQqppSRaF35G6iNnYjQZzfjTU2DczhT4oCjKzGoCHT
kI1zOg==
-----END CERTIFICATE-----
`,
  "0.0.7": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUXUGzJj13Ck2Cp0BKauLOdzgCPwIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ4WhgPMjI5NTA2MDcyMjQyNDhaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8Ee64Tbu53i/
KsuLOJG3GQ4e9gQ+9BtEy7U8kfFzRHh6Ejn7LOW38ZdKX1HP4zXuUusjNvytqDvr
7eclitqnegcEOkIeFK3wQwBoNILuq+r4LRVi19V+AIcl5w3qkJvIo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQU2tbfu7hd7USgbS2WsG/6BduKEAMwCgYIKoZIzj0EAwMDaAAwZQIw
Rw/BOLoScmU7P/1JnNPsGarmnvcuJrokAv1wk6j8s5LGuQHReX+d+O3RPLggwcAY
AjEAjoZnt9simul4cVcVy4G/0f39atanUva17gyzlYXEYx7B6UloxLeEcZhlbBf8
GjRf
-----END CERTIFICATE-----
`,
  "0.0.8": ``,
  "0.0.9": ``,
  "0.0.10": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUNauEDBCmP9igXLWtRpzkQqIGo/wwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDcxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ5WhgPMjI5NTA2MDcyMjQyNDlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA3MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjbkoJBshQXUy
qm5K8ldpTDR94Wk8iEM7QwHfceIxK5pPgaVGRkoJyVLSK5LMH4jyaIHUrtA0lIBQ
o0MsYkq7TOOm7+vo1Yrd8EMbu5StMb3gsXUrj7E/SBKIxULak6hCo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUyKHMzIBPRV/mrgG7tIjzOiw2xbUwCgYIKoZIzj0EAwMDaAAwZQIx
ANsigVtLgTdKWBPVJPstWA0H8yihf0/dmM3GO4qp5keGTWz/O3tnom4iDB6eSrcA
jwIwU82Dh+Wxl3kAD3YJH5VhlfHTm1rPlJETBHZgvPBOYqippao6+WZFEpn2/IDC
NTjn
-----END CERTIFICATE-----
`,
  "0.0.11": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUWtnJm2kswnXYu7/S5BnnTQiDRcUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDgxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjUwWhgPMjI5NTA2MDcyMjQyNTBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA4MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjY9Rl+s00xFV
tdTpAixLR4kJIGLfSLOdm+ofU/KuKMRSz5x1ORhIicppKZK24U5WLGXQU1fKLvxX
OmqwqL+6oAONmiHszqVdhWne4QPUba0yw7rf1/OI+IFF1HRK3shQo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUb/htoTodbq5hjP5RNlQ0rkKwWB0wCgYIKoZIzj0EAwMDZwAwZAIw
bO+9yArr21XKXjYHPadEAYINDxgXEC3W8e3X6MJsHCIZITddWWOyXRNFhz504vN0
AjB8aBuhrKcg1b4CrQDZQcosyVPUGIZKkXdQFfbVdivKrGZvqLS+GdPLd3v2MmHY
orA=
-----END CERTIFICATE-----
`,
  "0.0.12": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUHBsegV0bKtwpHRoOnnhbK7CTHxMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDkxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjUwWhgPMjI5NTA2MDcyMjQyNTBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA5MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEK+ZAs/00RXaj
buQJJy4zwr/YTj9h5V+vbY7sq9Z1RByEwTRRQOI3OuzzMq1EWKkVJKF/QF5b4yda
x6W9O/NT4EjBXH5XR5X1V6h7aT01YBqsxgMxuUP7kw9K+fW4k6Zao1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUKbecoYirLjf2O2oPkoggEE2P7FcwCgYIKoZIzj0EAwMDaQAwZgIx
AP67wsVOkeFo/9QRo+PnZhzEvjOZ/+IUoUhimdljcVwn79tzNP+obf7VW3Oq1wH7
4wIxAL65+WmMTMoI2cN7TCiL7G/W2ChDsASeHfaP/4e4ZViNONWotlY9i9aS3Kwt
LTea1Q==
-----END CERTIFICATE-----
`,
  "0.0.13": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUBNxMZRKru9jzFA8zsOAI4xkMFCMwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEwMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MFoYDzIyOTUwNjA3MjI0MjUwWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTAxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAShUi9sglwb
0U8QUrGOXJuHRXA9HP8RypkgNBwNRs1YcmPLcuwK70unWlkB81M44IQ7z/dG/0cW
hfFdRI5x4jAeiUFivmWmMLT6lJMPxJ0BkWTGVFVwI3SKcgSvHP9pNS2jVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSqIMCDzCKKwJJLCXhu9YJYPw6lsDAKBggqhkjOPQQDAwNnADBk
AjBl0bJG2A3443ybvrkKjWu8do6nDSR08/M49+19QfA1aDw0nb2sdCOE+xNitpQ9
7ngCMGuQHmnKA2EyOIVpNl2EtRoG+vdmLJQaoukhmCWjkGrQHkai473tGa9cRZ/8
+RZFzw==
-----END CERTIFICATE-----
`,
  "0.0.14": `-----BEGIN CERTIFICATE-----
MIICoTCCAiegAwIBAgIUJcQrEmPlIh0KWwiC2X6lZ/OdNs8wCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDExMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTExHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASxRizKJSbB
HmG2amvTHLCyExJngCh42agaFkv5Ab9mZYbqZPe0nUn/8RlVAvEiRNggCMYXC6MU
e4J6D1aeLhYaa0UY8Fmxd20NUjAOWhJgUXds4ILMMVG+pevofeC8AsujVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBS2Ic+LU/6Wssns4Yyf3N6E666xDzAKBggqhkjOPQQDAwNoADBl
AjAH0JMX48GD6vThA6FUsVnJmBID376PRZgxhuZvn9C0HawvNjZVQTkpzpYCwmia
dO4CMQCotakNxyiOxu/BbnPx6ld5+dqVCugsfqClhUhy8ROpNHfKxp3rW7HopowT
WiMlIyI=
-----END CERTIFICATE-----
`,
  "0.0.15": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUSFFNFv1iquxd5txlWA3PlkNju2EwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEyMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTIxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQus3nAPZkb
ja4Efo7iD4s8NLsFwEwQXQBgBGIJwtA2JRgLyXeWpuu125ib6qJzT8CHvQZhel3b
cwYWi4f2JpabMDepHELLxwZ9fILnAQ8GiHlzhrVq2NI15DI84dXVe4OjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSEO/JFC5/fDcT2gtipDMYMMTd96DAKBggqhkjOPQQDAwNnADBk
AjBalAU47XQL4ziHD8lj21pcp3+R5FKzn96HclMT/vraknCT1Sl+vCf6EYsqmi6Z
+RwCMDpxL6P6OMqyE+HzAeYQ4Fa7MYEQfZGMjka4zxetBLvIpwUCT4EAO8gv9GoU
wCBUzQ==
-----END CERTIFICATE-----
`,
  "0.0.16": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUdnkil4P+VthVMnqygVwGKLt7VfAwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEzMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTMxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAARUdz9ig/iA
hEAth2YinHKY6WM63BAxUVItzgk65l1T4wTzwoK4XEwclY5vIeFmZy2e0s95lWgq
SI68VS9gmJ3xp8Q9wOel/bvuF2tvNZmF393TeoNQQVHrQM1yJAx+nPyjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBTBFdNwHKSRDo6CxfA1aglY0N8joTAKBggqhkjOPQQDAwNnADBk
AjAqPIel58Rcl2kDxZxJPD9mK9xW4TU+d2NuP3n140TQ6nPlw1OwCPI7a4i3wfEe
08ICMBbrpNRdFZcvy76KoLPfTPvqbtWWaR/0tLZg4Rjj3x7SYgUg3vrVDmodHGkb
4T2Raw==
-----END CERTIFICATE-----
`,
  "0.0.17": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUDg+G4Ep+KEmIo+nCOY8DjFX60swwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE0MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MloYDzIyOTUwNjA3MjI0MjUyWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTQxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASCQRL5xUUh
1bsTXRPAf/qVFWEOxsJTiMlF3+UJ4MajWE5zmc2QNIzqj7NE24z3fNxgjViNK/8+
oBNQeqXfyJ/4etNMzTyG4JTsvWRAQ3aR1J4WDbfwpcgw6AIOKq9OLP6jVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQB9V2fygf48zyyVL3bnAxCLDUV9zAKBggqhkjOPQQDAwNnADBk
AjBonlThjjvi3fg7ODQcatPHBkp8Yon/p1ukm3YzYA3kitqroXU7BkmwRae2fbqD
TTICMHI+fAy+xWGwXAFNcvNTop11IIoszcgJJY+1Mc2Q/USk3pP6iezta+rvnaWu
7JySHg==
-----END CERTIFICATE-----
`,
  "0.0.18": `-----BEGIN CERTIFICATE-----
MIICojCCAiegAwIBAgIUBvI2Vq6O8yXNzbQlj6uQOdpd1lIwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE1MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MloYDzIyOTUwNjA3MjI0MjUyWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTUxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAR+jFDSzCdn
mMQpgz/vrmD/xioMioumUmyLAkB+voTNsMAOtiaDVbvJty3b4SJETv5tuZyaF5Gb
QAYuKsP7X8siCCVLZC9i9nCg46NHtuQkEmw1pzUUDmYFDfSV2tWedNqjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSqvCmoaVEp2d9WPctby+ooPMGmvTAKBggqhkjOPQQDAwNpADBm
AjEA9fQ2OFZa7fAQGGYydfVaUF0ObxKj3T+hyl0jiCKLe+hyxJSrXCFS2BM71UiG
ZMVxAjEAmCzESBzTVvl4Uv3TyActGTijTCqTNpN3gJmQbZYjKVtqf8Wxj9WeH0pM
E8BlA/qE
-----END CERTIFICATE-----
`,
  "0.0.19": `-----BEGIN CERTIFICATE-----
MIICojCCAiegAwIBAgIUZBwp7UPLJkDgngbUIx5xjbAn+7YwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE2MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1M1oYDzIyOTUwNjA3MjI0MjUzWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTYxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASCVYu2uF3T
kCkyRP0FfXVyyTA1z8DFqCKGrcODgGJuVAk59H6u8FIRsNipkb3BXFI0xGccok5X
T+t5bMaGDHYJ4fjU78UtPNmankQ5HoiMRJpy7Vn8mzizUzUqGpnhu6GjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQzE6RGn4YlIbdrl0niKWTtJzfXoTAKBggqhkjOPQQDAwNpADBm
AjEAobnXnwlNGNWoHscbl/ytUBSyjC7V11sLYJqtORSRX3k2+bFGsg4ltmOVjTdd
lXatAjEA/Ja3jufmdruqfLa6qigXuYI00YaI96sOwNhdHlnksYfqF41nDe4BsSW6
eQ6N5M9d
-----END CERTIFICATE-----
`,
  "0.0.20": `-----BEGIN CERTIFICATE-----
MIICoTCCAiegAwIBAgIUE1ZRB5n+Yby+Mwgb2xAcVfTZ53kwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE3MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1M1oYDzIyOTUwNjA3MjI0MjUzWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTcxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAR0OfTmHjxT
kBiU3GMa/bTvlTswCDAuFQGIIpMWHaf6V4ighzmn20jCg0AVFStb2q7YLRr4HUx8
ToMzsd7/yjl74BwJgfZnL75T/JInwyMgOBiCTXEf6qVDvhNzL4QJuVujVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQFKRUUmdFcDFQzBN9XqMvLgPd7NzAKBggqhkjOPQQDAwNoADBl
AjEA5MUUXSehY3KVIv/2LMgrqo1kPiV39fwYuLSnsMJ67wK8yN1NAkkycg6q2K6g
rBIvAjB3J3a40TINOZTYG+eQs+MSWyfANJLRuJTEOorXzMWM6+05+JYhPnLA8hke
CRfzmSw=
-----END CERTIFICATE-----
`
};

// node_modules/@hashgraph/sdk/src/Node.js
var Node = class _Node extends ManagedNode {
  /**
   * @param {object} props
   * @param {NewNode=} [props.newNode]
   * @param {CloneNode=} [props.cloneNode]
   */
  constructor(props = {}) {
    super(props);
    if (props.newNode != null) {
      this._accountId = props.newNode.accountId;
      this._nodeAddress = null;
    } else if (props.cloneNode != null) {
      this._accountId = props.cloneNode.node._accountId;
      this._nodeAddress = props.cloneNode.node._nodeAddress;
    } else {
      throw new Error(`failed to create node: ${JSON.stringify(props)}`);
    }
  }
  /**
   * @returns {string}
   */
  getKey() {
    return this._accountId.toString();
  }
  /**
   * @returns {ManagedNode<Channel>}
   */
  toInsecure() {
    return (
      /** @type {this} */
      new _Node({
        cloneNode: { node: this, address: this._address.toInsecure() }
      })
    );
  }
  /**
   * @returns {ManagedNode<Channel>}
   */
  toSecure() {
    return (
      /** @type {this} */
      new _Node({
        cloneNode: { node: this, address: this._address.toSecure() }
      })
    );
  }
  /**
   * @param {LedgerId|string} ledgerId
   * @returns {this}
   */
  setCert(ledgerId) {
    switch (ledgerId.toString()) {
      case "previewnet":
        this._cert = PREVIEWNET_CERTS[this._accountId.toString()];
        break;
      case "testnet":
        this._cert = TESTNET_CERTS[this._accountId.toString()];
        break;
      case "mainnet":
        this._cert = MAINNET_CERTS[this._accountId.toString()];
        break;
    }
    return this;
  }
  /**
   * @returns {AccountId}
   */
  get accountId() {
    return this._accountId;
  }
  /**
   * @returns {NodeAddress | null}
   */
  get nodeAddress() {
    return this._nodeAddress;
  }
  /**
   * @param {NodeAddress} nodeAddress
   * @returns {this}
   */
  setNodeAddress(nodeAddress) {
    this._nodeAddress = nodeAddress;
    return this;
  }
};

// node_modules/@hashgraph/sdk/src/address_book/AddressBooks.js
var HashgraphProto39 = __toESM(require_lib(), 1);
var PREVIEWNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
  HashgraphProto39.proto.NodeAddressBook.decode(
    decode(
      "0ad0070a0e33352e3233312e3230382e31343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340acf070a0d332e3231312e3234382e31373210a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ace070a0c34302e3132312e36342e343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ad1070a0d33352e3139392e31352e31373710a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad1070a0d332e3133332e3231332e31343610a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad0070a0c34302e37302e31312e32303210a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad2070a0e33352e3232352e3230312e31393510a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d35322e31352e3130352e31333010a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d3130342e34332e3234382e363310a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad2070a0e33352e3234372e3130392e31333510a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b35342e3234312e33382e3110a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b31332e38382e32322e343710a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330ad0070a0c33352e3233352e36352e353110a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d35342e3137372e35312e31323710a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad0070a0c31332e36342e3137302e343010a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d33342e3130362e3234372e363510a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33352e38332e38392e31373110a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad1070a0d31332e37382e3233322e31393210a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33342e3132352e32332e343910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390acf070a0b35302e31382e31372e393310a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390ad1070a0d32302e3135302e3133362e383910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939"
    )
  )
);
var TESTNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
  HashgraphProto39.proto.NodeAddressBook.decode(
    decode(
      "0a7f0a0c33342e39342e3130362e363110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a80010a0d35302e31382e3133322e32313110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a81010a0e3133382e39312e3134322e32313910a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a82010a0d33352e3233372e3131392e353510a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a7f0a0a332e3231322e362e313310a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d35322e3136382e37362e32343110a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d33352e3234352e32372e31393310a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a80010a0b35322e32302e31382e383610a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a81010a0c34302e37392e38332e31323410a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a82010a0d33342e38332e3131322e31313610a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35342e37302e3139322e333310a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35322e3138332e34352e363510a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a80010a0b33342e39342e3136302e3410a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e35342e3137362e3139392e31303910a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a82010a0d31332e36342e3138312e31333610a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e33342e3130362e3130322e32313810a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a82010a0d33352e3135352e34392e31343710a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a81010a0c31332e37382e3233382e333210a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a83010a0e33342e3133332e3139372e32333010a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e31342e3235322e32303710a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e3136352e31372e32333110a388031a05302e302e392806320218093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232"
    )
  )
);
var MAINNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
  HashgraphProto39.proto.NodeAddressBook.decode(
    decode(
      "0ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633435363165336332373863643635306538306334313363613434343233633163336331336366313437356636663639373664353937616534333262343961623432303836623739623834313332363035346238623364636635376438666364373962666330353831383363613234636434633163626335373465643131313765326635623762336336336365376230366439623465666366373337353633376234316665366635336338313162396465363134336633613532393537636466393536373735313230623333373033666635373632313430376162393537356263326433356330643434663039383366633165663633613466663532303966303730633932616631303632393536303163393662636564303634656331393031393730313963363831316334633864643830636234663461633731663961643736653761633839343536666266346630313166393061626432643930353336653832333436353166366265663932376533643564386237626634353930353039383362656361336162656632613964393761663334353737326137373430653936393932373562303138656130646632383661646436636539323365663930386662653736326137356632313131363836326462343464336463613164343462346432653864633130363663353030366262356137643935346164323535643462363033323733343735653531316165623438356430363961303637633061623563323435333863393333633036623561366165666139343030356332393135323133653463636461653663393432663632373266396464353238326436623839306631663230656664323339396364363734393234666135373034366163366461333265373339353161373331313365393166633262376666323965343835316238336666333966383362613965633666303863656664626236636262626666616266646661613931643933306637323030646134383133376333393463626431336537303165636463323631366664323162616436383161613466303031303230333031303030312804320218073a603665396138616263646364653665313134396133656265313766643538643839303538333961383664623732623036613365613230616131373666383638623235343838353261653432336437613963366237636666396537313436323961320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613163343037373135343330336363373263346662373639326333663934323531626465633132333961316637613839373261626539316133353332336662656361363235613766666165363430366338353564633261663231313039303062306466306536653664623736333634646661316666653835656461353637393336653239383562383536333461333261613532613635393964643663333062653166376136633562386635656563616632363231643861343539363832666364326462616164313536316431316633336663636237663535303061633536386431363564626561616365333238366432383934663634313239643738316436633732666437643539396339653164336166346161343333633233623931306661653463343834313634316636313532366164373837656265613533393837343136376539643361373363633066623135363432396431356563373633613664306630363131356137396239616637383364373762393864383330393661613437343366393734303864396531346263663464646666653435393137363838343762343063623864613763613337353235366432623933356430393566653235326661653831666636653337663834643761393064376535373061346638656633633764373636656564613437326630393230313939303135613839303832353961383733633534353466636262646361643265353238646538353435356234303833633764633461646335613938386530636464666463313539643564373132616264353434616137336563303239303839383134633938613434663236666330363434363539633138336533313834616132373266386431646330626661336530613536303438346362303535626134646262356363333339656338306264313164363432646333613730326538633730336162323139333038346439626436336630646665313261343333633235373665616637383163666164383637656637306264613631373638623262656631346635306336633362386230393666303230333031303030312805320218083a606464336233653763643361323537643832373665343635333533363162303138623730303931663438363635653832303031306538316563303539326236396264346265316662643765636435303964303730313364643034313238343266640ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623263636163363561643066633736343561383137626661626334383761643765343133313165376133313938623337666238343264383463333935623366363764366264383438663130633666303363323930653866376461613864303031613834343164633335326131393136306133313933653638623832656466313961653637363933613961333364346362383765373839613130373037313535313565613737326361613862383661353639623931633534353038333564396333353466306461636563393766653737303931623435623134373639386237663836303134323264636432323631653932386465346461633963343264636261666466393663303732333362613330323730373666333763393639653865643330623662356438663530333462653764393263353936663862653836316535316663633361323432626639643862653965326139653865306631353565626366663233656666613763643537633130353432383131643830373736633935383535323666646230656161333465653139353564353131313933393066653837336534633034646564643239313635383834623938623436333038373838616537666334643461613461386663396263323637346261333231343933623632343435356164343130633164653731626339356431643931666130663230313431386137393565333039656166323937623639396266323763396661323736336364353963656230323165313662383230306331303630663238313766643833636663373637313833343839343631653335393932393162333830643665393339626161346231393233326136613237326464653635316638303436666463333464623237366137373764366662326265633332353562326363323434623461663536366231303566333063363530366464616530656233646564646366393437626362396336306530303039383466336234613863366334656434626639306263313933326237663934646333616536623336303030386562393032303430663962303230333031303030312802320218053a603561383634313561303861306138323566336232656237353031303135353230326533313234336665343161303333333834653738633138633131653565386632303964343933623062326664343565303662333734663262363964663564370ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613365333762373663366364356636363232643639323434343464313263363737633339356632623539303266336262393862386138623530353561373037373036636130323863643735303630613264383730326432643862303439343762646366653061386331343161613238343462316530366536363139303031326538623633323661623066613331373937336263376362346432393439663231303861613034633462306339316261613537323866356235363232656337356162663537386131663762343165646532613637656264363963313865353831666466396336303230616330646539636132633331663063363436393030333331316662623563653764623439633738376531613764323761613432356565376238346461376536363933396639633830643065383266636535356530326466633862356337383431386132366161343336353036393837313962616663656366306264343930303061646463666134303537303862646265666262313937343964323264616230303765343464343565613233623130366638383334633135326532353036326434636632346666323533353663376562333732393130353339336662343962616239303461303266306630626234313763643931396433353238393031323865366262666634666163396639306465313138613937346632613664643031653033326137396231373866363066613166636262643032623537303466623436323935633135313930383136333733656464363633356338353639373866316239353033663166373362346230626538616261326564316665656164353939353362663832656664653933613334373161626435356364613362613861363733666262333739393734396662303036643030336630653633663636356333343631643261376232396463386232303462613539613635363638613436616532383738663030643166393439306466396532383066656266343331356561303465616135363861336139666434386336326336336236656364613639303230333031303030312803320218063a606434363430333938303337393230373965636364356134343331316361306463323262353065633839356235366535336431326232396637326463366462613363616665326535623831303466626461303338616635623434376430666231320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393361323135636334613761373232636165396331336162643633366466393963636565633661663964623436623639666135313637313665663530636532343930613938316530396162303139636132636234363831316235623631396431626431643565653666343661343263373737636264656536343261313438346563646635646464333732393634326333386336643433613838353838373434373566353832343434333636346330346466656439623839303435666230383565323563336566636234383431373333656666376335323963313339653639333530633263643739623263386431393637396137313265346538636166643332363735343162383332623365313061303132353564656636396466316539643362386438656166303331316465363764356531326232366464303164626264396433653432643335643964653237313330326530663166363964383763626337616361396538383637653964343238643363616230363636656234393064356662616233306266663366373835643033663230373261343362623962356535343635366135393263623631656166643561356566323834633763616563363666376634373332356363306434633164323766363631643861373438636135303731633036656631333464666639366634303836363838333636643436386132343738303031376530623536616261376661623433623362376330623737393036666165353438326633323831316332393265366231343435346531346238393438303161383661303363633437373934646430643734353237613732653432346564336166613034383939656362396136336632613961653732626537666139383961646630643635613332633835316439383031666334313034386466333335363466633762333137303765633866623830313430666537623761316661313230626131636236363033323463656666623462636332643962623764653063663534633831396632646433626365616465633963323566356531396463396231303230333031303030312806320218093a603365303261363732306334343636353965383633303564353562666565383230623335653635306665636163633535333039373435356532633465303332636339646564313662316262343464336235393262626163623663326266663165360ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303930323539663465336439663066333934323536353438653963373330386231306237333430336363393039346439376164313531623737303631373062393737326365623634643636326563656639303161386437643135643331396135396338623731303731616363643839356237633933363130646336393736663637633465313732396261383337336162376535326133663363386632363534393164646536396436653039393934373065373434353938313133316264393663333665363836353230336662326562643564353065616461666237323633393664656331643931373438393862346539626530346337346433303466656164643963626433323334633362376633333036633939636230633333396663323539363962343164353861326237636663313833326532323664383163313936333939336532323535613038376431363938633033643432313062643634353830363434643039356361373661613137393465646434306331633837623566383261386533396636303365393731313662613034353738653765383033343634393564373835643465663763663737313462396562366635663965306239613934663462373338383436313962393237346434613935656631353735346138396439376566356331613838623664363933653061383065626435333766633963663063613931643163363264393135646537656438313862393532653634633230303239336565386532383461343136613732613365313266633764343233623135386639623439363630636263323436366662656430666564326532346531303266646539343265623463666439346265633436643364393066633038633339666563626130336530636132343634616536363462393739353135626132396531663730326333666537303262653739333739366438656462313761613438633039323930623032343534396630363131663561653233656437653136343432646637643164616432323836633262623039643535323264643365643639386332663032303330313030303128093202180c3a606339373462623938326338313931336237333236643561336639646363343836313261313566376161643032663230376230663130636432303137613666626666353830336537636139626662343730396162323862366230396435623133660ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303962646438653834666164616133353332666334636530316138613137643463336232333266353061393739306532363236383465646334383233653831356131626435623230656365613762663536653239663662623762383331666233626636656663643134373566306238656435666662306231333835623936643136366236323966303339366138666566356630366534626361323565653461313334306565323633613464396262303230643866343732333036663364383836313338646537613031396530353962643061666339303263636261316132313361653264616136306338613031333735356665306134386530333466356234303233613264616465616138386335343836383335336163376137613364663132623266623634313837373465396231346265366561623863633237623838303132616436313632646137346530656562313631333539303566343337333734646162383538366437353061323662626433616332346165643837386334643533653635313037326338373165393464376163633537356339363733383137333461353366656166346437626136626364643234316363363435386336303837643836333032616132353163303466366435366239633332643764393636323437353065643035353738356430373733663433646330393962323863393232383131343865366338316632393766663964313636653030306163303462333132343138363737356663656637356635656261306331303332626631333064663663643761343632313164306466336530353834643932656136373334396438343930353038656234656638386635346338633364343836646538373139663130666139366665623835636337393630373663613738313331386565326439656439303363613133333630343063353961643931613464326636393865393130386165306564623962316362393561643333623139376666623138626431626138623536636265653261616539353835656365323038613165313462343835363436333032303330313030303128083202180b3a603937303834333033333130373866353638326337663332343464383263336233653238316139313837393537386465656163646363326132656265353431616631383831313561643265383338363565356635643234376234613138633165650ab50722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031320218033a603333373339306438666561313434616663313265383132353461323864616336656138323839333833366163303732656666643835653061373734383538306566323830393636343863356137663864626234636538313437363831353133370ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130306335376564623966663237366530323362323830323163623164383763646631393636623639386366343865346561616137633639323037376365656538636362323339613463393231353937653865383966376363303564336633313331353738393736633465333134343035643461346530336137323431306335633039636135323761643561383562393938363337653732613332653166626330643535343662323436356539653830366332646435303965623035306162356662323730363366643932383135623164643236383965323131316361656236663534396539346139663030663038323164346361366336613631313766356135333363393236336266303734613330643563626566353064316338633233383762636139373265646564613039383362356430613662353764636230303230303036383238623430653430373662343837306232346261643834303536656535326235663432326538383430303238633235303036333832643865396336363132323566346637366561373265333430363037653966633666336332303433333037366131636138636231356564303361633839363664303530376263646536383165346530323331656539663837643131316537623438616338663934643264383432623532646637336635373363633534313439363437393763363236393638666661653734313866336236313039623561306630396533323233663461346435653335303964643235303133386636626331376266366365636531373539343433306466313830613338653930616466326166666266616430633662386331623837663137386130363164636662666638623932633931363664383734633166663561663466626364626665386539643039393337306464663630626537343736333364333665653465623563643531663665336333333965313531653431626462356135636532633863393761306134336233636434636330383138383463383739663964326633373438343238633835373366313763393066336362643032303330313030303128073202180a3a603734306166366266373339653838336338386633333434633961306638623330316533396463393831633531363365306465326133666634326239396534323665643765353662363766343231383530333834356466363266343963396662300ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393133316161333638663933343532323966393762363235396363636166666561323365303063643565616430326533663639366331653731346565333933396461643836306533386266393561323937346639656234386539333433663861616334303565613935356430353332336531313762336231633934383133613361663432666538303832633364343362616631626434643833363765393364623030616436393665363237613130333661653533346630313165616435653536663337613666666534346236623965303939343031313932616435363061303334366234316138313030393566356632643766643332643665656236353562613735386336623532366331323933383661663731393763376135336165363033643632323833323235343936316631366430656661383037396137363835363138383862653733333439323231373935366262636166616562623631333563356662623234383464356234613566646630333336616330326532366331363532633162643865616633306461653164366433656230306637623466616238643634373866653864393565623931316466393636613064656134653532326462373662383936363537306563633561663039353136343234663061663566386565363665333836643536353037313339393731363961633337353733626635326664303538646539356162326666363865363831313161623233343035656139363462326262383864303263306631636165643731656364643465346534303835393438373666646238353030626335356337626130323036366530356162393864396637653034363664393730326562353765653337323266386663633835613735353035666633323632313730323838623738383732336164623937653464653536323063633930656164313338326663643735373138383966656662313165363737316263336636663366656231396337616335343238373864303361393032373035323663336565643234393465666635346531353363613966363839303230333031303030312801320218043a603765616236393661623935343336363538626331346666366234626534643932356364353162323230646632613164356336656531363061646166323961353165363934646533656531383463653232656164386437646239333231383266330ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a3202180d3a606132656363316232616539386264323862633161303864386633373161306434663734356337363864306337373339363235363265333433623235643833343235656565613765663865613134323935333432623865623738643332656333660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b3202180e3a603139366237623132303739376364623361396430303362393833643537646131303331303662313733306531376636376532633762616161646234333738396166313639366461313031316232353362636263383630333333383566303332380ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c3202180f3a603538343661353366343437353239666439636462373830346364333136383865643665656265336236336461326635663231316666626337333731393763663366316366626664613631626537643135313066306539323339383131376637340ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061386365616333363765623166316465356630643965663365616630646639623938343438666532303830383437363536326130363063353163323839373730623463616366653932636236353536393832336539363263326132633966656435336264333663613361313232646531633532356135383266323561346437643632386331613364356264623839333661656365373531306537353534656537303333303235633039326338323865656235373338626530326564393633646138316135393230353633346365393435343537376162383266343066313366316565353565306165373237653233633330323834623166343462393961636534646463356639616337616438386439666132323535393335623234646362613834303036343265313663663235333263306230643638393239303436303837313563343037366634366438346130653066656433366537366363646339363335356537613236313630393435633262353461653236636330306664303832333236333436656565656137646437356639313931316539396462636239396561346163366261303536633333323238643838316438353833316439636338373935393364613137343664643065653935646332623936666539336261666366663263643764393239353864373864663333663230356437313135656439666163346462366634636336306535366135343431646135623562353566613539393939303265393538613662366334346438313064646335363138313234316238376632326630353961363838306538303231373336643031383937646236353434396365383137613233373564303335353163623064653530376336303961306338303330656366346266646562323133633033646161373634613138323162373234333334663731663736386437616563623237373035326137303333373635663037323138303536633738663261383761663138333836643866363161356366636233663262613464643539393135663133643338363334643136393537353730323033303130303031280d320218103a603030306162636435396133306135333838633530306265363832663663613239343034363239356339323735383831633230643334626230643639306564613762333862366262643037613364643166646662366137303434626230396366660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e320218113a603933653238313031303462326231376230303935326235613431303264333365646230343363623136646533616433643364363832363066353562623065353837333765613539343463333338663763386362383863373833336663383630630ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f320218123a603934383235313739643163333934303137306233356432363665346366613830643737386335653966356261653764653833666638636334373431663362653336616336336431653761653439373261656466366263316533636632303638390ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030626531376339393634376365633635613434343037623533353835366233633362616566356235346635363561663538623834353662613863376365353335643561633732633631633434633736623363353763386538363438343136333762653130613833636665333963303932343736643064626534643663646364636437323061333062356266656235316130316131386635383263343566366338363939336663663764663138323933356465316438363930363034346463663335313836393335643962643765656137393532333532626562623465663961653066373636316537306134323337616661393839393636383763613438666366633562303064333830376630353462653066613863336266613432353033386265366566323935313634663232663733623765383863393465613962653861613466336132343563383962396431666435313932663761353062393538623265663831303462333666316266386664326366623238633134323138303063316334376534656639386166313530303730636336643639643137653865623932663138613661613161363532363661343935323338643130336638663639356235376563663337333635306130353230303837343537323162656138313536323739363763383037363336356466386334633761376434646438663263333835306331386662613731656236306536653864666264313936653035333766643730623334346563626363353330646663383364613666656466343964353161393034313935303262613964373063643335663163663363303639346532333534663930363466646266353335656232336332376330613433643062373863316638363763363164393836393564386465663762633261313062623636373463323266363661616230613931383133646466323763646238353263353965663739653162396531613037356661366565323761376533373734646266346232363436353432376536643561623931666537663066336137313738346563613138326235303230333031303030312810320218133a603038393039376465663031623037633764393734613537353532353161366161613061666236623332613534353334336432393138653732626164303433323163313131633234643432373538306633626131653236616139643735653632360ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613561643262373634336130346330353564326638636432353131623135313339666334353537353632313338386534396331313962326633393861636131313066363133393662306338363664653530363335323262623835343032373365313366366439346365316536303433386636616662303061616136343631326637313435653962636538626331613533623934313931336161373663396633613238333366616437636632383563376163326433376639396633633263646234396465346431353165363136373835363466323831663534313432346234316661376335316232613936303232383363376433326565303065623833386461313563333861666339366530363164393763656465323231363566663161613935396631633432373562326430393863343035383661353537396662623363623930303732373034313230613861363661353237306634666366643130383663393233363930613335653766643434356533336163303366313339633638363835353635373063646334616166323231303761366331613434323435366137633663373965653034303930653765356434663636626361363063613166343762366466623534336461633363626631396137373139613866353562366638336234613362386136366436303235366430613436353531666137303234626430353633316238613535383038373732353463326632663236386364633333643264626263666237333365396662653233336262396362353961623331613031343862323365386334323638306666313061663463373961346430383334366662373961393364393632393534386561663162623132343639386661656661346364643732343432633033613034623733333433326637343839303361333235633238336434353661623961653932316165376564333339316535643137383765666463323335343061376238356336393161653837306130376639306231316331336233326365343365616564313562333639363835636534393137376363393835303230333031303030312811320218143a603939666162633461646534653636326336653238323366346139366562323134343034383465356136643064333132623730633036386432326236323936333830376332333361343964626239383361376562623330653737303637373261340ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030386434356332316330633935656636356130323964353263393537666430663835663230313233646130333465363136373164646565353437356630373338326136366336366362346463353035303464646664333735383130383364663864313735373733306564386436663336346466346333366132363531353931393535646132303161323430376661386162396232333133383131323235613064613233306662653338306530393061613536656661346632303265633962343832336636353031643936616336393865626632366161636633656532643166333261373231633934376531303736636633356233373364613164383761333661313532653030653731303131373932323832653832356666313731633538333362383835373062666336646138343439653666393566386231323635616235353531393430333135353364316435373666393363343263306361363061616261633463386464313632643831313466326232313531313538336337323533396665353663343939613932396465336134306130643435633137633538396332643739383863653236656166633932613364333762376561303034326434336530336166613632373162323632353561366363636661653533373138323164383165306230356332353062353966306139303734316130653065383861303965643536633562393738306430393566303930366630623831643531323633393832616165303131333663303732643834346131316436646134623261363163363434653161623137663136666634386565323366656465383435326631653432653264333061303739306332356434323036306531643434613637316132656232336431313466363863373165333366313736646235386136386234333030353462633164323938336132336133326561366666393566613763346438653338306562323936653938623739363865636638343534643831376337333765656135646439323165623836633136633762323933303461346137656362653561336131303230333031303030312812320218153a606537396165396337313933643164326263393433383436346338616135663632323461653835323936366134336239383235383833663766373432633533393562643330393935383761393638363662393233396431656666336165353037610ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623035616265326162303066646430366339353565383637313062306530366631613932363234613438616431636263386466633666323231323936326230633330666462643238346133376335613337363538623633633336656138313632353631613865346639343663626535373232633032383830316630663238316337306638643838633763303061326632653239663539376237393938363965643833353664663537633437626539393434613261616666363530663962346262613064626335336463383830666462623639656134353139303564323830323230326638653239633034613736643237616632656237633534383438356266336634363934633930633431383130383838383433373932383438383335663738313637303764336538643736663465363766353738306263663038383133633535656336333961396264363234313738663565623134376435303061663335316539656631623165333432343834636132363064623763636261653438366631336366323635623562316162363838303636303038303533623230633364656463653737316339613038613033323061613963653435316562396439383361376234396361613130393666386164633039383331386463333865306537636566306438653564353537613036373536383561316339653235366132626339646261333232623362623331373263663731343037376263333830663861306134333361386266613766626663353966366230393365633862663665393339376330396231386531383034306331623536363836343733376338666137653239373935663361343538386464613763326261623439353636356363346139623833366532656239306336326133666361663539316662356638313830346337363138306536323666613236343461376465333435313164366334363637643938393337653237373333663464316539313338383333353465353466643733353137323165373666376235366333343833333838663461366238376232386165626562303230333031303030312813320218163a603962343038383566313362366163316337353336393262613366313739303061333838333165363934613061663937343934623834333838323039636235656662646339386136646162623265316337313833393166633133356264616163330ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396463643863306135336539306333353539353734663636323034313137643362353033653530613336643330393766616338343239653663656364333762623534303731383038663265653938323033356638353161306339626532313736333833613232653338633161626131363866333266393035373063623332333363666536323539383736363661663637623531346361656632316662386466366430666364333363663236303662393264646561353533366236303638643836373832653339626435633338343435393931643431396237643165633038353939343132633039343964316332343062333563313464633535323734646261373166666165393336313235613566383139663534313332653234333964346163353539373939366563653835653133646666333336316639313331663536636561633562396635353262343963663666396139616336653564636532646233363934363266393361663830653562353662366538626566613136326130363162346137363839326264633834363437333036633630303835386664643237303332373663326337303434303139386566643766653335343563663261623538306337346366643634343561616637626437663734356363323532656162643236356561626565383632343137313034653639343861353537353666646332323264663061313031353234646531633363303863636630343330313165633766653936346564643834353161313330313437633037333633613335663131666465656638663261326237363137353762343335386666383962373561343864363762646336303930363933653062623836373965636262393366666462336633656439366265633933656634363536653337313661623837636534366361386531323539633866656464653866326631656130663365623263343865393635353164653132333330333435373235663435656436396338353735623531363833616661343732363231383236646232326262326431633466316533363436346139303230333031303030312814320218173a60346630613033333466393737363738313632663830643936376637323139313431333630633062376637663033316233376336396536323137333933336564616434366263626139373636376565373262666435613933346261313532326330"
    )
  )
);

// node_modules/@hashgraph/sdk/src/client/ManagedNetwork.js
var ManagedNetwork = class {
  /**
   * @param {(address: string) => ChannelT} createNetworkChannel
   */
  constructor(createNetworkChannel) {
    this._network = /* @__PURE__ */ new Map();
    this._nodes = [];
    this._healthyNodes = [];
    this._createNetworkChannel = createNetworkChannel;
    this._ledgerId = null;
    this._minBackoff = 8e3;
    this._maxBackoff = 1e3 * 60 * 60;
    this._maxNodeAttempts = -1;
    this._nodeMinReadmitPeriod = this._minBackoff;
    this._nodeMaxReadmitPeriod = this._maxBackoff;
    this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;
  }
  /**
   * @deprecated
   * @param {string} networkName
   * @returns {this}
   */
  setNetworkName(networkName) {
    console.warn("Deprecated: Use `setLedgerId` instead");
    return this.setLedgerId(networkName);
  }
  /**
   * @deprecated
   * @returns {string | null}
   */
  get networkName() {
    console.warn("Deprecated: Use `ledgerId` instead");
    return this.ledgerId != null ? this.ledgerId.toString() : null;
  }
  /**
   * @param {string|LedgerId} ledgerId
   * @returns {this}
   */
  setLedgerId(ledgerId) {
    this._ledgerId = typeof ledgerId === "string" ? LedgerId.fromString(ledgerId) : ledgerId;
    return this;
  }
  /**
   * @returns {LedgerId | null}
   */
  get ledgerId() {
    return this._ledgerId != null ? this._ledgerId : null;
  }
  /**
   * @abstract
   * @param {[string, KeyT]} entry
   * @returns {NetworkNodeT}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createNodeFromNetworkEntry(entry) {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @param {Map<string, KeyT>} network
   * @returns {number[]}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _getNodesToRemove(network) {
    throw new Error("not implemented");
  }
  _removeDeadNodes() {
    if (this._maxNodeAttempts > 0) {
      for (let i = this._nodes.length - 1; i >= 0; i--) {
        const node = this._nodes[i];
        if (node._badGrpcStatusCount < this._maxNodeAttempts) {
          continue;
        }
        this._closeNode(i);
      }
    }
  }
  _readmitNodes() {
    const now = Date.now();
    if (this._earliestReadmitTime <= now) {
      let nextEarliestReadmitTime = Number.MAX_SAFE_INTEGER;
      let searchForNextEarliestReadmitTime = true;
      outer:
        for (let i = 0; i < this._nodes.length; i++) {
          for (let j = 0; j < this._healthyNodes.length; j++) {
            if (searchForNextEarliestReadmitTime && this._nodes[i]._readmitTime > now) {
              nextEarliestReadmitTime = Math.min(
                this._nodes[i]._readmitTime,
                nextEarliestReadmitTime
              );
            }
            if (this._nodes[i] == this._healthyNodes[j]) {
              continue outer;
            }
          }
          searchForNextEarliestReadmitTime = false;
          if (this._nodes[i]._readmitTime <= now) {
            this._healthyNodes.push(this._nodes[i]);
          }
        }
      this._earliestReadmitTime = Math.min(
        Math.max(nextEarliestReadmitTime, this._nodeMinReadmitPeriod),
        this._nodeMaxReadmitPeriod
      );
    }
  }
  /**
   * @param {number} count
   * @returns {NetworkNodeT[]}
   */
  _getNumberOfMostHealthyNodes(count) {
    this._removeDeadNodes();
    this._readmitNodes();
    const nodes = [];
    let healthyNodes = this._healthyNodes.slice();
    count = Math.min(count, healthyNodes.length);
    for (let i = 0; i < count; i++) {
      const nodeIndex = Math.floor(Math.random() * healthyNodes.length);
      const selectedNode = healthyNodes[nodeIndex];
      if (!selectedNode) {
        break;
      }
      nodes.push(selectedNode);
      healthyNodes = healthyNodes.filter(
        // eslint-disable-next-line ie11/no-loop-func
        (node) => node.getKey() !== selectedNode.getKey()
      );
    }
    return nodes;
  }
  /**
   * @param {number} i
   */
  _closeNode(i) {
    const node = this._nodes[i];
    node.close();
    this._removeNodeFromNetwork(node);
    this._nodes.splice(i, 1);
  }
  /**
   * @param {NetworkNodeT} node
   */
  _removeNodeFromNetwork(node) {
    const network = (
      /** @type {NetworkNodeT[]} */
      this._network.get(node.getKey())
    );
    for (let j = 0; j < network.length; j++) {
      if (network[j] === node) {
        network.splice(j, 1);
        break;
      }
    }
    if (network.length === 0) {
      this._network.delete(node.getKey());
    }
  }
  /**
   * @param {Map<string, KeyT>} network
   * @returns {this}
   */
  _setNetwork(network) {
    const newNodes = [];
    const newNodeKeys = /* @__PURE__ */ new Set();
    const newNodeAddresses = /* @__PURE__ */ new Set();
    const newHealthyNodes = [];
    const newNetwork = /* @__PURE__ */ new Map();
    for (const i of this._getNodesToRemove(network)) {
      this._closeNode(i);
    }
    for (const node of this._nodes) {
      newNodes.push(node);
      newNodeKeys.add(node.getKey());
      newNodeAddresses.add(node.address.toString());
    }
    for (const [key, value] of network) {
      if (newNodeKeys.has(value.toString()) && newNodeAddresses.has(key)) {
        continue;
      }
      newNodes.push(this._createNodeFromNetworkEntry([key, value]));
    }
    shuffle(newNodes);
    for (const node of newNodes) {
      if (!node.isHealthy()) {
        continue;
      }
      newHealthyNodes.push(node);
      const newNetworkNodes = newNetwork.has(node.getKey()) ? (
        /** @type {NetworkNodeT[]} */
        newNetwork.get(node.getKey())
      ) : [];
      newNetworkNodes.push(node);
      newNetwork.set(node.getKey(), newNetworkNodes);
    }
    this._nodes = newNodes;
    this._healthyNodes = newHealthyNodes;
    this._network = newNetwork;
    this._ledgerId = null;
    return this;
  }
  /**
   * @returns {number}
   */
  get maxNodeAttempts() {
    return this._maxNodeAttempts;
  }
  /**
   * @param {number} maxNodeAttempts
   * @returns {this}
   */
  setMaxNodeAttempts(maxNodeAttempts) {
    this._maxNodeAttempts = maxNodeAttempts;
    return this;
  }
  /**
   * @returns {number}
   */
  get minBackoff() {
    return this._minBackoff;
  }
  /**
   * @param {number} minBackoff
   * @returns {this}
   */
  setMinBackoff(minBackoff) {
    this._minBackoff = minBackoff;
    for (const node of this._nodes) {
      node.setMinBackoff(minBackoff);
    }
    return this;
  }
  /**
   * @returns {number}
   */
  get maxBackoff() {
    return this._maxBackoff;
  }
  /**
   * @param {number} maxBackoff
   * @returns {this}
   */
  setMaxBackoff(maxBackoff) {
    this._maxBackoff = maxBackoff;
    for (const node of this._nodes) {
      node.setMaxBackoff(maxBackoff);
    }
    return this;
  }
  /**
   * @returns {number}
   */
  get nodeMinReadmitPeriod() {
    return this._nodeMinReadmitPeriod;
  }
  /**
   * @param {number} nodeMinReadmitPeriod
   * @returns {this}
   */
  setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {
    this._nodeMinReadmitPeriod = nodeMinReadmitPeriod;
    this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;
    return this;
  }
  /**
   * @returns {number}
   */
  get nodeMaxReadmitPeriod() {
    return this._nodeMaxReadmitPeriod;
  }
  /**
   * @param {number} nodeMaxReadmitPeriod
   * @returns {this}
   */
  setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {
    this._nodeMaxReadmitPeriod = nodeMaxReadmitPeriod;
    return this;
  }
  /**
   * @param {KeyT=} key
   * @returns {NetworkNodeT}
   */
  getNode(key) {
    this._readmitNodes();
    if (key != null && key != void 0) {
      const lockedNodes = this._network.get(key.toString());
      if (lockedNodes) {
        const randomNodeAddress = Math.floor(
          Math.random() * lockedNodes.length
        );
        return (
          /** @type {NetworkNodeT[]} */
          lockedNodes[randomNodeAddress]
        );
      } else {
        const nodes = Array.from(this._network.keys());
        const randomNodeAccountId = nodes[Math.floor(Math.random() * nodes.length)];
        const randomNode = this._network.get(randomNodeAccountId);
        const randomNodeAddress = Math.floor(
          // @ts-ignore
          Math.random() * randomNode.length
        );
        return randomNode[randomNodeAddress];
      }
    } else {
      if (this._healthyNodes.length == 0) {
        throw new Error("failed to find a healthy working node");
      }
      return this._healthyNodes[Math.floor(Math.random() * this._healthyNodes.length)];
    }
  }
  /**
   * @param {NetworkNodeT} node
   */
  increaseBackoff(node) {
    node.increaseBackoff();
    for (let i = 0; i < this._healthyNodes.length; i++) {
      if (this._healthyNodes[i] == node) {
        this._healthyNodes.splice(i, 1);
      }
    }
  }
  /**
   * @param {NetworkNodeT} node
   */
  decreaseBackoff(node) {
    node.decreaseBackoff();
  }
  close() {
    for (const node of this._nodes) {
      node.close();
    }
    this._network.clear();
    this._nodes = [];
  }
};

// node_modules/@hashgraph/sdk/src/client/Network.js
var Network = class extends ManagedNetwork {
  /**
   * @param {(address: string) => Channel} createNetworkChannel
   */
  constructor(createNetworkChannel) {
    super(createNetworkChannel);
    this._maxNodesPerTransaction = -1;
    this._addressBook = null;
    this._transportSecurity = false;
  }
  /**
   * @param {{[key: string]: (string | AccountId)}} network
   */
  setNetwork(network) {
    this._setNetwork(
      // eslint-disable-next-line ie11/no-collection-args
      new Map(
        // eslint-disable-next-line ie11/no-collection-args
        Object.entries(network).map(([key, value]) => {
          return [
            key,
            typeof value === "string" ? AccountId.fromString(value) : value
          ];
        })
      )
    );
  }
  /**
   * @param {NodeAddressBook} addressBook
   * @returns {this}
   */
  setNetworkFromAddressBook(addressBook) {
    const network = {};
    const port = this.isTransportSecurity() ? 50212 : 50211;
    for (const nodeAddress of addressBook.nodeAddresses) {
      for (const endpoint of nodeAddress.addresses) {
        if (endpoint.port === port && nodeAddress.accountId != null) {
          network[endpoint.toString()] = nodeAddress.accountId;
        }
      }
    }
    this.setNetwork(network);
    return this;
  }
  /**
   * @returns {{[key: string]: (string | AccountId)}}
   */
  get network() {
    var n = {};
    for (const node of this._nodes) {
      n[node.address.toString()] = node.accountId;
    }
    return n;
  }
  /**
   * @param {string} networkName
   * @returns {this}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setNetworkName(networkName) {
    super.setLedgerId(networkName);
    switch (networkName) {
      case "mainnet":
        this._addressBook = MAINNET_ADDRESS_BOOK;
        break;
      case "testnet":
        this._addressBook = TESTNET_ADDRESS_BOOK;
        break;
      case "previewnet":
        this._addressBook = PREVIEWNET_ADDRESS_BOOK;
        break;
    }
    if (this._addressBook != null) {
      for (const node of this._nodes) {
        for (const address of this._addressBook.nodeAddresses) {
          if (address.accountId != null && address.accountId.toString() === node.accountId.toString()) {
            node.setNodeAddress(address);
          }
        }
      }
    }
    return this;
  }
  /**
   * @returns {string | null}
   */
  get networkName() {
    return this._ledgerId != null ? this._ledgerId.toString() : null;
  }
  /**
   * @abstract
   * @param {[string, (string | AccountId)]} entry
   * @returns {Node}
   */
  _createNodeFromNetworkEntry(entry) {
    const accountId = typeof entry[1] === "string" ? AccountId.fromString(entry[1]) : entry[1];
    return new Node({
      newNode: {
        address: entry[0],
        accountId,
        channelInitFunction: this._createNetworkChannel
      }
    }).setMinBackoff(this._minBackoff);
  }
  /**
   * @abstract
   * @param {Map<string, AccountId>} network
   * @returns {number[]}
   */
  _getNodesToRemove(network) {
    const indexes = [];
    for (let i = this._nodes.length - 1; i >= 0; i--) {
      const node = this._nodes[i];
      const accountId = network.get(node.address.toString());
      if (accountId == null || accountId.toString() !== node.accountId.toString()) {
        indexes.push(i);
      }
    }
    return indexes;
  }
  /**
   * @abstract
   * @param {[string, (string | AccountId)]} entry
   * @returns {boolean}
   */
  _checkNetworkContainsEntry(entry) {
    for (const node of this._nodes) {
      if (node.address.toString() === entry[0]) {
        return true;
      }
    }
    return false;
  }
  /**
   * @returns {number}
   */
  get maxNodesPerTransaction() {
    return this._maxNodesPerTransaction;
  }
  /**
   * @param {number} maxNodesPerTransaction
   * @returns {this}
   */
  setMaxNodesPerTransaction(maxNodesPerTransaction) {
    this._maxNodesPerTransaction = maxNodesPerTransaction;
    return this;
  }
  /**
   * @returns {number}
   */
  get maxNodeAttempts() {
    return this._maxNodeAttempts;
  }
  /**
   * @param {number} maxNodeAttempts
   * @returns {this}
   */
  setMaxNodeAttempts(maxNodeAttempts) {
    this._maxNodeAttempts = maxNodeAttempts;
    return this;
  }
  /**
   * @returns {boolean}
   */
  isTransportSecurity() {
    return this._transportSecurity;
  }
  /**
   * @param {boolean} transportSecurity
   * @returns {this}
   */
  setTransportSecurity(transportSecurity) {
    if (this._transportSecurity == transportSecurity) {
      return this;
    }
    this._network.clear();
    for (let i = 0; i < this._nodes.length; i++) {
      let node = this._nodes[i];
      node.close();
      node = /** @type {Node} */
      transportSecurity ? node.toSecure().setCert(
        this._ledgerId != null ? this._ledgerId.toString() : ""
      ) : node.toInsecure();
      this._nodes[i] = node;
      const nodes = this._network.get(node.getKey()) != null ? (
        /** @type {Node[]} */
        this._network.get(node.getKey())
      ) : [];
      nodes.push(node);
      this._network.set(node.getKey(), nodes);
    }
    this._healthyNodes = [...this._nodes];
    this._transportSecurity = transportSecurity;
    return this;
  }
  /**
   * @internal
   * @returns {number}
   */
  getNumberOfNodesForTransaction() {
    if (this._maxNodesPerTransaction > 0) {
      return this._maxNodesPerTransaction;
    }
    return this._nodes.length <= 9 ? this._nodes.length : Math.floor((this._nodes.length + 3 - 1) / 3);
  }
  /**
   * @internal
   * @returns {AccountId[]}
   */
  getNodeAccountIdsForExecute() {
    return this._getNumberOfMostHealthyNodes(
      this.getNumberOfNodesForTransaction()
    ).map((node) => node.accountId);
  }
};

// node_modules/@hashgraph/sdk/src/MirrorNode.js
var MirrorNode = class extends ManagedNode {
  /**
   * @param {object} props
   * @param {NewNode=} [props.newNode]
   * @param {CloneNode=} [props.cloneNode]
   */
  constructor(props = {}) {
    super(props);
  }
  /**
   * @returns {string}
   */
  getKey() {
    return this._address.toString();
  }
};

// node_modules/@hashgraph/sdk/src/client/MirrorNetwork.js
var MirrorNetwork = class extends ManagedNetwork {
  /**
   * @param {(address: string) => MirrorChannel} channelInitFunction
   */
  constructor(channelInitFunction) {
    super(channelInitFunction);
  }
  /**
   * @param {string[]} network
   */
  setNetwork(network) {
    this._setNetwork(new Map(network.map((address) => [address, address])));
  }
  /**
   * @returns {string[]}
   */
  get network() {
    var n = [];
    for (const node of this._nodes) {
      n.push(node.address.toString());
    }
    return n;
  }
  /**
   * @abstract
   * @param {[string, string]} entry
   * @returns {MirrorNode}
   */
  _createNodeFromNetworkEntry(entry) {
    return new MirrorNode({
      newNode: {
        address: entry[1],
        channelInitFunction: this._createNetworkChannel
      }
    }).setMinBackoff(this._minBackoff);
  }
  /**
   * @abstract
   * @param {Map<string, string>} network
   * @returns {number[]}
   */
  _getNodesToRemove(network) {
    const indexes = [];
    const values = Object.values(network);
    for (let i = this._nodes.length - 1; i >= 0; i--) {
      const node = this._nodes[i];
      if (!values.includes(node.address.toString())) {
        indexes.push(i);
      }
    }
    return indexes;
  }
  /**
   * @returns {MirrorNode}
   */
  getNextMirrorNode() {
    if (this._createNetworkChannel == null) {
      throw new Error("mirror network not supported on browser");
    }
    return this._getNumberOfMostHealthyNodes(1)[0];
  }
};

// node_modules/@hashgraph/sdk/src/client/Client.js
var Client = class {
  /**
   * @protected
   * @hideconstructor
   * @param {ClientConfiguration} [props]
   */
  constructor(props) {
    this._mirrorNetwork = new MirrorNetwork(
      this._createMirrorNetworkChannel()
    );
    this._network = new Network(this._createNetworkChannel());
    this._operator = null;
    this._defaultMaxTransactionFee = null;
    this._defaultMaxQueryPayment = new Hbar(1);
    if (props != null) {
      if (props.operator != null) {
        this.setOperator(
          props.operator.accountId,
          props.operator.privateKey
        );
      }
    }
    this._maxAttempts = null;
    this._signOnDemand = false;
    this._autoValidateChecksums = false;
    this._minBackoff = 250;
    this._maxBackoff = 8e3;
    this._defaultRegenerateTransactionId = true;
    this._requestTimeout = null;
    this._networkUpdatePeriod = 24 * 60 * 60 * 1e3;
    this._isShutdown = false;
    if (props != null && props.scheduleNetworkUpdate !== false) {
      this._initialNetworkUpdate();
      this._scheduleNetworkUpdate();
    }
    this._timer;
    this._logger = null;
  }
  /**
   * @deprecated
   * @param {NetworkName} networkName
   * @returns {this}
   */
  setNetworkName(networkName) {
    console.warn("Deprecated: Use `setLedgerId` instead");
    return this.setLedgerId(networkName);
  }
  /**
   * @deprecated
   * @returns {string | null}
   */
  get networkName() {
    console.warn("Deprecated: Use `ledgerId` instead");
    return this.ledgerId != null ? this.ledgerId.toString() : null;
  }
  /**
   * @param {string|LedgerId} ledgerId
   * @returns {this}
   */
  setLedgerId(ledgerId) {
    this._network.setLedgerId(
      typeof ledgerId === "string" ? LedgerId.fromString(ledgerId) : ledgerId
    );
    return this;
  }
  /**
   * @returns {LedgerId | null}
   */
  get ledgerId() {
    return this._network._ledgerId != null ? this._network.ledgerId : null;
  }
  /**
   * @param {{[key: string]: (string | AccountId)} | string} network
   * @returns {void}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setNetwork(network) {
    throw new Error("not implemented");
  }
  /**
   * @param {NodeAddressBook} addressBook
   * @returns {this}
   */
  setNetworkFromAddressBook(addressBook) {
    this._network.setNetworkFromAddressBook(addressBook);
    return this;
  }
  /**
   * @returns {{[key: string]: (string | AccountId)}}
   */
  get network() {
    return this._network.network;
  }
  /**
   * @param {string[] | string} mirrorNetwork
   * @returns {void}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setMirrorNetwork(mirrorNetwork) {
    throw new Error("not implemented");
  }
  /**
   * @returns {string[]}
   */
  get mirrorNetwork() {
    return this._mirrorNetwork.network;
  }
  /**
   * @returns {boolean}
   */
  get signOnDemand() {
    return this._signOnDemand;
  }
  /**
   * @param {boolean} signOnDemand
   */
  setSignOnDemand(signOnDemand) {
    this._signOnDemand = signOnDemand;
  }
  /**
   * @returns {boolean}
   */
  isTransportSecurity() {
    return this._network.isTransportSecurity();
  }
  /**
   * @param {boolean} transportSecurity
   * @returns {this}
   */
  setTransportSecurity(transportSecurity) {
    this._network.setTransportSecurity(transportSecurity);
    return this;
  }
  /**
   * Set the account that will, by default, pay for transactions and queries built with this client.
   * NOTE: When using string for private key, the string needs to contain DER headers
   *
   * @param {AccountId | string} accountId
   * @param {PrivateKey | string} privateKey
   * @returns {this}
   */
  setOperator(accountId, privateKey) {
    const key = typeof privateKey === "string" ? PrivateKey2.fromStringDer(privateKey) : privateKey;
    return this.setOperatorWith(
      accountId,
      key.publicKey,
      (message) => Promise.resolve(key.sign(message))
    );
  }
  /**
   * @returns {?ClientOperator}
   */
  getOperator() {
    return this._operator;
  }
  /**
   * Sets the account that will, by default, pay for transactions and queries built with
   * this client.
   *
   * @param {AccountId | string} accountId
   * @param {PublicKey | string} publicKey
   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   * @returns {this}
   */
  setOperatorWith(accountId, publicKey, transactionSigner) {
    const accountId_ = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);
    if (this._network._ledgerId != null) {
      accountId_.validateChecksum(this);
    }
    this._operator = {
      transactionSigner,
      accountId: accountId_,
      publicKey: publicKey instanceof PublicKey2 ? publicKey : PublicKey2.fromString(publicKey)
    };
    return this;
  }
  /**
   * @param {boolean} value
   * @returns {this}
   */
  setAutoValidateChecksums(value) {
    this._autoValidateChecksums = value;
    return this;
  }
  /**
   * @returns {boolean}
   */
  isAutoValidateChecksumsEnabled() {
    return this._autoValidateChecksums;
  }
  /**
   * @returns {?AccountId}
   */
  get operatorAccountId() {
    return this._operator != null ? this._operator.accountId : null;
  }
  /**
   * @returns {?PublicKey}
   */
  get operatorPublicKey() {
    return this._operator != null ? this._operator.publicKey : null;
  }
  /**
   * @returns {?Hbar}
   */
  get defaultMaxTransactionFee() {
    return this._defaultMaxTransactionFee;
  }
  /**
   * @deprecated - Use `defaultMaxTransactionFee` instead
   * @returns {?Hbar}
   */
  get maxTransactionFee() {
    return this.defaultMaxTransactionFee;
  }
  /**
   * Set the defaultimum fee to be paid for transactions
   * executed by this client.
   *
   * @param {Hbar} defaultMaxTransactionFee
   * @returns {this}
   */
  setDefaultMaxTransactionFee(defaultMaxTransactionFee) {
    if (defaultMaxTransactionFee.toTinybars().toInt() < 0) {
      throw new Error("defaultMaxTransactionFee must be non-negative");
    }
    this._defaultMaxTransactionFee = defaultMaxTransactionFee;
    return this;
  }
  /**
   * @deprecated - Use `setDefaultMaxTransactionFee()` instead
   * Set the maximum fee to be paid for transactions
   * executed by this client.
   * @param {Hbar} maxTransactionFee
   * @returns {this}
   */
  setMaxTransactionFee(maxTransactionFee) {
    return this.setDefaultMaxTransactionFee(maxTransactionFee);
  }
  /**
   * @returns {boolean}
   */
  get defaultRegenerateTransactionId() {
    return this._defaultRegenerateTransactionId;
  }
  /**
   * Set if a new transaction ID should be generated when a `TRANSACTION_EXPIRED` status
   * is returned.
   *
   * @param {boolean} defaultRegenerateTransactionId
   * @returns {this}
   */
  setDefaultRegenerateTransactionId(defaultRegenerateTransactionId) {
    this._defaultRegenerateTransactionId = defaultRegenerateTransactionId;
    return this;
  }
  /**
   * @returns {Hbar}
   */
  get defaultMaxQueryPayment() {
    return this._defaultMaxQueryPayment;
  }
  /**
   * @deprecated in a favor of defaultMaxQueryPayment
   * @returns {Hbar}
   */
  get maxQueryPayment() {
    return this.defaultMaxQueryPayment;
  }
  /**
   * Set the maximum payment allowable for queries.
   *
   * @param {Hbar} defaultMaxQueryPayment
   * @returns {Client<ChannelT, MirrorChannelT>}
   */
  setDefaultMaxQueryPayment(defaultMaxQueryPayment) {
    const isMaxQueryPaymentNegative = convertToNumber(defaultMaxQueryPayment.toTinybars()) < 0;
    if (isMaxQueryPaymentNegative) {
      throw new Error("defaultMaxQueryPayment must be non-negative");
    }
    this._defaultMaxQueryPayment = defaultMaxQueryPayment;
    return this;
  }
  /**
   * @deprecated in a favor of setDefaultMaxQueryPayment()
   * Set the maximum payment allowable for queries.
   * @param {Hbar} maxQueryPayment
   * @returns {Client<ChannelT, MirrorChannelT>}
   */
  setMaxQueryPayment(maxQueryPayment) {
    return this.setDefaultMaxQueryPayment(maxQueryPayment);
  }
  /**
   * @returns {number}
   */
  get maxAttempts() {
    return this._maxAttempts != null ? this._maxAttempts : 10;
  }
  /**
   * @param {number} maxAttempts
   * @returns {this}
   */
  setMaxAttempts(maxAttempts) {
    this._maxAttempts = maxAttempts;
    return this;
  }
  /**
   * @returns {number}
   */
  get maxNodeAttempts() {
    return this._network.maxNodeAttempts;
  }
  /**
   * @param {number} maxNodeAttempts
   * @returns {this}
   */
  setMaxNodeAttempts(maxNodeAttempts) {
    this._network.setMaxNodeAttempts(maxNodeAttempts);
    return this;
  }
  /**
   * @returns {number}
   */
  get nodeWaitTime() {
    return this._network.minBackoff;
  }
  /**
   * @param {number} nodeWaitTime
   * @returns {this}
   */
  setNodeWaitTime(nodeWaitTime) {
    this._network.setMinBackoff(nodeWaitTime);
    return this;
  }
  /**
   * @returns {number}
   */
  get maxNodesPerTransaction() {
    return this._network.maxNodesPerTransaction;
  }
  /**
   * @param {number} maxNodesPerTransaction
   * @returns {this}
   */
  setMaxNodesPerTransaction(maxNodesPerTransaction) {
    this._network.setMaxNodesPerTransaction(maxNodesPerTransaction);
    return this;
  }
  /**
   * @param {?number} minBackoff
   * @returns {this}
   */
  setMinBackoff(minBackoff) {
    if (minBackoff == null) {
      throw new Error("minBackoff cannot be null.");
    }
    if (minBackoff > this._maxBackoff) {
      throw new Error("minBackoff cannot be larger than maxBackoff.");
    }
    this._minBackoff = minBackoff;
    return this;
  }
  /**
   * @returns {number}
   */
  get minBackoff() {
    return this._minBackoff;
  }
  /**
   * @param {?number} maxBackoff
   * @returns {this}
   */
  setMaxBackoff(maxBackoff) {
    if (maxBackoff == null) {
      throw new Error("maxBackoff cannot be null.");
    } else if (maxBackoff < this._minBackoff) {
      throw new Error("maxBackoff cannot be smaller than minBackoff.");
    }
    this._maxBackoff = maxBackoff;
    return this;
  }
  /**
   * @returns {number}
   */
  get maxBackoff() {
    return this._maxBackoff;
  }
  /**
   * @param {number} nodeMinBackoff
   * @returns {this}
   */
  setNodeMinBackoff(nodeMinBackoff) {
    this._network.setMinBackoff(nodeMinBackoff);
    return this;
  }
  /**
   * @returns {number}
   */
  get nodeMinBackoff() {
    return this._network.minBackoff;
  }
  /**
   * @param {number} nodeMaxBackoff
   * @returns {this}
   */
  setNodeMaxBackoff(nodeMaxBackoff) {
    this._network.setMaxBackoff(nodeMaxBackoff);
    return this;
  }
  /**
   * @returns {number}
   */
  get nodeMaxBackoff() {
    return this._network.maxBackoff;
  }
  /**
   * @param {number} nodeMinReadmitPeriod
   * @returns {this}
   */
  setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {
    this._network.setNodeMinReadmitPeriod(nodeMinReadmitPeriod);
    return this;
  }
  /**
   * @returns {number}
   */
  get nodeMinReadmitPeriod() {
    return this._network.nodeMinReadmitPeriod;
  }
  /**
   * @param {number} nodeMaxReadmitPeriod
   * @returns {this}
   */
  setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {
    this._network.setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod);
    return this;
  }
  /**
   * @returns {number}
   */
  get nodeMaxReadmitPeriod() {
    return this._network.nodeMaxReadmitPeriod;
  }
  /**
   * @param {number} requestTimeout - Number of milliseconds
   * @returns {this}
   */
  setRequestTimeout(requestTimeout) {
    this._requestTimeout = requestTimeout;
    return this;
  }
  /**
   * @returns {?number}
   */
  get requestTimeout() {
    return this._requestTimeout;
  }
  /**
   * @returns {number}
   */
  get networkUpdatePeriod() {
    return this._networkUpdatePeriod;
  }
  /**
   * @param {number} networkUpdatePeriod
   * @returns {this}
   */
  setNetworkUpdatePeriod(networkUpdatePeriod) {
    clearTimeout(this._timer);
    this._networkUpdatePeriod = networkUpdatePeriod;
    this._scheduleNetworkUpdate();
    return this;
  }
  /**
   * Set logger
   *
   * @param {Logger} logger
   * @returns {this}
   */
  setLogger(logger15) {
    this._logger = logger15;
    return this;
  }
  /**
   * Get logger if set
   *
   * @returns {?Logger}
   */
  get logger() {
    return this._logger;
  }
  /**
   * @param {AccountId | string} accountId
   */
  async ping(accountId) {
    await new AccountBalanceQuery({ accountId }).setNodeAccountIds([
      accountId instanceof AccountId ? accountId : AccountId.fromString(accountId)
    ]).execute(this);
  }
  async pingAll() {
    for (const nodeAccountId of Object.values(this._network.network)) {
      await this.ping(nodeAccountId);
    }
  }
  /**
   * @returns {void}
   */
  close() {
    this._network.close();
    this._mirrorNetwork.close();
    this._isShutdown = true;
    clearTimeout(this._timer);
  }
  /**
   * @abstract
   * @returns {(address: string) => ChannelT}
   */
  _createNetworkChannel() {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @returns {(address: string) => MirrorChannelT}
   */
  _createMirrorNetworkChannel() {
    throw new Error("not implemented");
  }
  /**
   * @private
   */
  _scheduleNetworkUpdate() {
    this._timer = setTimeout(async () => {
      try {
        const addressBook = await Cache_default2.addressBookQueryConstructor().setFileId(FileId.ADDRESS_BOOK).execute(this);
        this.setNetworkFromAddressBook(addressBook);
        if (!this._isShutdown) {
          this._scheduleNetworkUpdate();
        }
      } catch (error) {
        if (this._logger) {
          this._logger.trace(
            `failed to update client address book: ${/** @type {Error} */
            error.toString()}`
          );
        }
      }
    }, this._networkUpdatePeriod);
  }
  /**
   * @private
   */
  _initialNetworkUpdate() {
    setTimeout(async () => {
      try {
        const addressBook = await Cache_default2.addressBookQueryConstructor().setFileId(FileId.ADDRESS_BOOK).execute(this);
        this.setNetworkFromAddressBook(addressBook);
      } catch (error) {
        if (this._logger) {
          this._logger.trace(
            `failed to update client address book: ${/** @type {Error} */
            error.toString()}`
          );
        }
      }
    }, 1e3);
  }
  /**
   * @returns {boolean}
   */
  get isClientShutDown() {
    return this._isShutdown;
  }
};

// node_modules/@hashgraph/sdk/src/channel/Channel.js
var HashgraphProto40 = __toESM(require_lib(), 1);
var { proto: proto41 } = HashgraphProto40;
var Channel = class {
  /**
   * @protected
   */
  constructor() {
    this._crypto = null;
    this._smartContract = null;
    this._file = null;
    this._consensus = null;
    this._freeze = null;
    this._network = null;
    this._token = null;
    this._schedule = null;
    this._util = null;
  }
  /**
   * @abstract
   * @returns {void}
   */
  close() {
    throw new Error("not implemented");
  }
  /**
   * @returns {HashgraphProto.proto.CryptoService}
   */
  get crypto() {
    if (this._crypto != null) {
      return this._crypto;
    }
    this._crypto = proto41.CryptoService.create(
      this._createUnaryClient("CryptoService")
    );
    return this._crypto;
  }
  /**
   * @returns {HashgraphProto.proto.SmartContractService}
   */
  get smartContract() {
    if (this._smartContract != null) {
      return this._smartContract;
    }
    this._smartContract = proto41.SmartContractService.create(
      this._createUnaryClient("SmartContractService")
    );
    return this._smartContract;
  }
  /**
   * @returns {HashgraphProto.proto.FileService}
   */
  get file() {
    if (this._file != null) {
      return this._file;
    }
    this._file = proto41.FileService.create(
      this._createUnaryClient("FileService")
    );
    return this._file;
  }
  /**
   * @returns {HashgraphProto.proto.ConsensusService}
   */
  get consensus() {
    if (this._consensus != null) {
      return this._consensus;
    }
    this._consensus = proto41.ConsensusService.create(
      this._createUnaryClient("ConsensusService")
    );
    return this._consensus;
  }
  /**
   * @returns {HashgraphProto.proto.FreezeService}
   */
  get freeze() {
    if (this._freeze != null) {
      return this._freeze;
    }
    this._freeze = proto41.FreezeService.create(
      this._createUnaryClient("FreezeService")
    );
    return this._freeze;
  }
  /**
   * @returns {HashgraphProto.proto.NetworkService}
   */
  get network() {
    if (this._network != null) {
      return this._network;
    }
    this._network = proto41.NetworkService.create(
      this._createUnaryClient("NetworkService")
    );
    return this._network;
  }
  /**
   * @returns {HashgraphProto.proto.TokenService}
   */
  get token() {
    if (this._token != null) {
      return this._token;
    }
    this._token = proto41.TokenService.create(
      this._createUnaryClient("TokenService")
    );
    return this._token;
  }
  /**
   * @returns {HashgraphProto.proto.ScheduleService}
   */
  get schedule() {
    if (this._schedule != null) {
      return this._schedule;
    }
    this._schedule = proto41.ScheduleService.create(
      this._createUnaryClient("ScheduleService")
    );
    return this._schedule;
  }
  /**
   * @returns {HashgraphProto.proto.UtilService}
   */
  get util() {
    if (this._util != null) {
      return this._util;
    }
    this._util = proto41.UtilService.create(
      this._createUnaryClient("UtilService")
    );
    return this._util;
  }
  /**
   * @abstract
   * @protected
   * @param {string} serviceName
   * @returns {import("protobufjs").RPCImpl}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createUnaryClient(serviceName) {
    throw new Error("not implemented");
  }
};
function encodeRequest(data) {
  const frame = new ArrayBuffer(data.byteLength + 5);
  new DataView(frame, 1, 4).setUint32(0, data.length);
  new Uint8Array(frame, 5).set(data);
  return frame;
}
function decodeUnaryResponse(data, byteOffset = 0, byteLength = data.byteLength) {
  const dataView = new DataView(data, byteOffset, byteLength);
  let dataOffset = 0;
  let unaryResponse = null;
  let status = 0;
  while (dataOffset < dataView.byteLength) {
    const frameByte = dataView.getUint8(dataOffset + 0);
    const frameType = frameByte >> 7;
    const frameByteLength = dataView.getUint32(dataOffset + 1);
    const frameOffset = dataOffset + 5;
    if (frameOffset + frameByteLength > dataView.byteLength) {
      throw new Error("(BUG) unexpected frame length past the boundary");
    }
    const frameData = new Uint8Array(
      data,
      dataView.byteOffset + frameOffset,
      frameByteLength
    );
    if (frameType === 0) {
      if (unaryResponse != null) {
        throw new Error(
          "(BUG) unexpectedly received more than one data frame"
        );
      }
      unaryResponse = frameData;
    } else if (frameType === 1) {
      const trailer = decode7(frameData);
      const [trailerName, trailerValue] = trailer.split(":");
      if (trailerName === "grpc-status") {
        status = parseInt(trailerValue);
      } else {
        throw new Error(`(BUG) unhandled trailer, ${trailer}`);
      }
    } else {
      throw new Error(`(BUG) unexpected frame type: ${frameType}`);
    }
    dataOffset += frameByteLength + 5;
  }
  if (status !== 0) {
    throw new Error(`(BUG) unhandled grpc-status: ${status}`);
  }
  if (unaryResponse == null) {
    throw new Error("(BUG) unexpectedly received no response");
  }
  return unaryResponse;
}

// node_modules/@hashgraph/sdk/src/channel/WebChannel.js
var WebChannel = class extends Channel {
  /**
   * @param {string} address
   */
  constructor(address) {
    super();
    this._address = address;
  }
  /**
   * @override
   * @returns {void}
   */
  close() {
  }
  /**
   * @override
   * @protected
   * @param {string} serviceName
   * @returns {import("protobufjs").RPCImpl}
   */
  _createUnaryClient(serviceName) {
    return async (method, requestData, callback) => {
      try {
        const response = await fetch(
          `${this._address}/proto.${serviceName}/${method.name}`,
          {
            method: "POST",
            headers: {
              "content-type": "application/grpc-web+proto",
              "x-user-agent": "hedera-sdk-js/v2",
              "x-grpc-web": "1"
            },
            body: encodeRequest(requestData)
          }
        );
        if (!response.ok) {
          const error = new HttpError(
            HttpStatus._fromValue(response.status)
          );
          callback(error, null);
        }
        const grpcStatus = response.headers.get("grpc-status");
        const grpcMessage = response.headers.get("grpc-message");
        if (grpcStatus != null && grpcMessage != null) {
          const error = new GrpcServiceError(
            GrpcStatus._fromValue(parseInt(grpcStatus))
          );
          error.message = grpcMessage;
          callback(error, null);
        }
        const responseBuffer = await response.arrayBuffer();
        const unaryResponse = decodeUnaryResponse(responseBuffer);
        callback(null, unaryResponse);
      } catch (error) {
        const err = new GrpcServiceError(
          // retry on grpc web errors
          GrpcStatus._fromValue(18)
        );
        callback(err, null);
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/constants/ClientConstants.js
var MAINNET = {
  "https://grpc-web.myhbarwallet.com:443": new AccountId(3),
  "https://node00.swirldslabs.com:443": new AccountId(3),
  "https://node01-00-grpc.swirlds.com:443": new AccountId(4),
  "https://node02.swirldslabs.com:443": new AccountId(5),
  "https://node03.swirldslabs.com:443": new AccountId(6),
  "https://node04.swirldslabs.com:443": new AccountId(7),
  "https://node05.swirldslabs.com:443": new AccountId(8),
  "https://node06.swirldslabs.com:443": new AccountId(9),
  "https://node07.swirldslabs.com:443": new AccountId(10),
  "https://node08.swirldslabs.com:443": new AccountId(11),
  "https://node09.swirldslabs.com:443": new AccountId(12),
  "https://node10.swirldslabs.com:443": new AccountId(13),
  "https://node11.swirldslabs.com:443": new AccountId(14),
  "https://node12.swirldslabs.com:443": new AccountId(15),
  "https://node13.swirldslabs.com:443": new AccountId(16),
  "https://node14.swirldslabs.com:443": new AccountId(17),
  "https://node15.swirldslabs.com:443": new AccountId(18),
  "https://node16.swirldslabs.com:443": new AccountId(19),
  "https://node17.swirldslabs.com:443": new AccountId(20),
  "https://node18.swirldslabs.com:443": new AccountId(21),
  "https://node19.swirldslabs.com:443": new AccountId(22),
  "https://node20.swirldslabs.com:443": new AccountId(23),
  "https://node21.swirldslabs.com:443": new AccountId(24),
  "https://node22.swirldslabs.com:443": new AccountId(25),
  "https://node23.swirldslabs.com:443": new AccountId(26),
  "https://node24.swirldslabs.com:443": new AccountId(27),
  "https://node25.swirldslabs.com:443": new AccountId(28),
  "https://node26.swirldslabs.com:443": new AccountId(29),
  "https://node27.swirldslabs.com:443": new AccountId(30),
  "https://node28.swirldslabs.com:443": new AccountId(31)
};
var WEB_TESTNET = {
  "https://testnet-node00-00-grpc.hedera.com:443": new AccountId(3),
  "https://testnet-node01-00-grpc.hedera.com:443": new AccountId(4),
  "https://testnet-node02-00-grpc.hedera.com:443": new AccountId(5),
  "https://testnet-node03-00-grpc.hedera.com:443": new AccountId(6),
  "https://testnet-node04-00-grpc.hedera.com:443": new AccountId(7),
  "https://testnet-node05-00-grpc.hedera.com:443": new AccountId(8),
  "https://testnet-node06-00-grpc.hedera.com:443": new AccountId(9)
};
var WEB_PREVIEWNET = {
  "https://previewnet-node00-00-grpc.hedera.com:443": new AccountId(3),
  "https://previewnet-node01-00-grpc.hedera.com:443": new AccountId(4),
  "https://previewnet-node02-00-grpc.hedera.com:443": new AccountId(5),
  "https://previewnet-node03-00-grpc.hedera.com:443": new AccountId(6),
  "https://previewnet-node04-00-grpc.hedera.com:443": new AccountId(7),
  "https://previewnet-node05-00-grpc.hedera.com:443": new AccountId(8),
  "https://previewnet-node06-00-grpc.hedera.com:443": new AccountId(9)
};
var NATIVE_TESTNET = {
  "https://grpc-web.testnet.myhbarwallet.com:443": new AccountId(3)
};
var NATIVE_PREVIEWNET = {
  "https://grpc-web.previewnet.myhbarwallet.com:443": new AccountId(3)
};

// node_modules/@hashgraph/sdk/src/client/WebClient.js
var Network2 = {
  /**
   * @param {string} name
   * @returns {{[key: string]: (string | AccountId)}}
   */
  fromName(name) {
    switch (name) {
      case "mainnet":
        return Network2.MAINNET;
      case "testnet":
        return Network2.TESTNET;
      case "previewnet":
        return Network2.PREVIEWNET;
      default:
        throw new Error(`unknown network name: ${name}`);
    }
  },
  MAINNET,
  TESTNET: WEB_TESTNET,
  PREVIEWNET: WEB_PREVIEWNET
};
var WebClient = class _WebClient extends Client {
  /**
   * @param {ClientConfiguration} [props]
   */
  constructor(props) {
    super(props);
    if (props != null) {
      if (typeof props.network === "string") {
        switch (props.network) {
          case "mainnet":
            this.setNetwork(Network2.MAINNET);
            this.setLedgerId(LedgerId.MAINNET);
            break;
          case "testnet":
            this.setNetwork(Network2.TESTNET);
            this.setLedgerId(LedgerId.TESTNET);
            break;
          case "previewnet":
            this.setNetwork(Network2.PREVIEWNET);
            this.setLedgerId(LedgerId.PREVIEWNET);
            break;
          default:
            throw new Error(
              // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
              `unknown network: ${props.network}`
            );
        }
      } else if (props.network != null) {
        this.setNetwork(props.network);
      }
    }
  }
  /**
   * @param {string | ClientConfiguration} data
   * @returns {WebClient}
   */
  static fromConfig(data) {
    return new _WebClient(
      typeof data === "string" ? (
        /** @type {ClientConfiguration | undefined} */
        JSON.parse(data)
      ) : data
    );
  }
  /**
   * Construct a client for a specific network.
   *
   * It is the responsibility of the caller to ensure that all nodes in the map are part of the
   * same Hedera network. Failure to do so will result in undefined behavior.
   *
   * The client will load balance all requests to Hedera using a simple round-robin scheme to
   * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be
   * tried.
   *
   * @param {{[key: string]: (string | AccountId)} | string} network
   * @returns {WebClient}
   */
  static forNetwork(network) {
    return new _WebClient({ network, scheduleNetworkUpdate: false });
  }
  /**
   * @param {string} network
   * @returns {WebClient}
   */
  static forName(network) {
    return new _WebClient({ network, scheduleNetworkUpdate: false });
  }
  /**
   * Construct a Hedera client pre-configured for Mainnet access.
   *
   * @returns {WebClient}
   */
  static forMainnet() {
    return new _WebClient({
      network: "mainnet",
      scheduleNetworkUpdate: false
    });
  }
  /**
   * Construct a Hedera client pre-configured for Testnet access.
   *
   * @returns {WebClient}
   */
  static forTestnet() {
    return new _WebClient({
      network: "testnet",
      scheduleNetworkUpdate: false
    });
  }
  /**
   * Construct a Hedera client pre-configured for Previewnet access.
   *
   * @returns {WebClient}
   */
  static forPreviewnet() {
    return new _WebClient({
      network: "previewnet",
      scheduleNetworkUpdate: false
    });
  }
  /**
   * @param {{[key: string]: (string | AccountId)} | string} network
   * @returns {void}
   */
  setNetwork(network) {
    if (typeof network === "string") {
      switch (network) {
        case "previewnet":
          this._network.setNetwork(Network2.PREVIEWNET);
          break;
        case "testnet":
          this._network.setNetwork(Network2.TESTNET);
          break;
        case "mainnet":
          this._network.setNetwork(Network2.MAINNET);
      }
    } else {
      this._network.setNetwork(network);
    }
  }
  /**
   * @param {string[] | string} mirrorNetwork
   * @returns {this}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setMirrorNetwork(mirrorNetwork) {
    if (typeof mirrorNetwork === "string") {
      this._mirrorNetwork.setNetwork([]);
    } else {
      this._mirrorNetwork.setNetwork(mirrorNetwork);
    }
    return this;
  }
  /**
   * @override
   * @returns {(address: string) => WebChannel}
   */
  _createNetworkChannel() {
    return (address) => new WebChannel(address);
  }
  /**
   * @override
   * @returns {(address: string) => *}
   */
  _createMirrorNetworkChannel() {
    return () => {
      throw new Error("mirror support is not supported in browsers");
    };
  }
};

export {
  BadKeyError,
  BadMnemonicReason_default,
  BadMnemonicError,
  HEDERA_PATH,
  SLIP44_ECDSA_HEDERA_PATH,
  SLIP44_ECDSA_ETH_PATH,
  Cache_default2 as Cache_default,
  Key2 as Key,
  PublicKey2 as PublicKey,
  EntityIdHelper_exports,
  Mnemonic2 as Mnemonic,
  PrivateKey2 as PrivateKey,
  KeyList2 as KeyList,
  HbarUnit,
  Hbar,
  StatusError,
  ReceiptStatusError,
  Status,
  EvmAddress,
  AccountId,
  Executable,
  Timestamp,
  TransactionId,
  PrecheckStatusError,
  MaxQueryPaymentExceeded,
  Query,
  ContractId,
  FileId,
  TopicId,
  TokenId,
  ScheduleId,
  ExchangeRate,
  TransactionReceipt,
  TransactionReceiptQuery,
  Transfer,
  ContractLogInfo,
  ContractNonceInfo,
  ContractFunctionResult,
  AssessedCustomFee,
  TransactionRecord,
  TransactionRecordQuery,
  TransactionResponse,
  Transaction,
  NftId,
  HbarAllowance,
  TokenAllowance,
  TokenNftAllowance,
  AccountAllowanceAdjustTransaction,
  AccountAllowanceApproveTransaction,
  AccountAllowanceDeleteTransaction,
  AccountBalance,
  AccountBalanceQuery,
  AccountCreateTransaction,
  AccountDeleteTransaction,
  LiveHash,
  LedgerId,
  AccountInfo,
  AccountInfoQuery,
  AccountInfoFlow,
  AccountRecordsQuery,
  ProxyStaker,
  AccountStakersQuery,
  AccountUpdateTransaction,
  AddressBookQuery,
  ContractByteCodeQuery,
  ContractFunctionSelector,
  ContractFunctionParameters,
  ContractCallQuery,
  FileCreateTransaction,
  FileAppendTransaction,
  FileDeleteTransaction,
  ContractCreateTransaction,
  ContractCreateFlow,
  ContractDeleteTransaction,
  ContractExecuteTransaction,
  ContractInfo,
  ContractInfoQuery,
  ContractUpdateTransaction,
  CustomFee,
  CustomFixedFee,
  FeeAssessmentMethod,
  CustomFractionalFee,
  CustomRoyalyFee,
  DelegateContractId,
  EthereumTransaction,
  EthereumTransactionData,
  EthereumTransactionDataLegacy,
  EthereumTransactionDataEip1559,
  EthereumTransactionDataEip2930,
  EthereumFlow,
  ExchangeRates,
  FeeComponents,
  FeeDataType,
  FeeData,
  RequestType,
  TransactionFeeSchedule,
  FeeSchedule,
  FeeSchedules,
  FileContentsQuery,
  FileInfo,
  FileInfoQuery,
  FileUpdateTransaction,
  FreezeType,
  FreezeTransaction,
  LiveHashAddTransaction,
  LiveHashDeleteTransaction,
  LiveHashQuery,
  SemanticVersion,
  NetworkVersionInfo,
  NetworkVersionInfoQuery,
  Provider_default,
  PrngTransaction,
  ScheduleCreateTransaction,
  ScheduleDeleteTransaction,
  ScheduleInfo,
  ScheduleInfoQuery,
  ScheduleSignTransaction,
  Signer_default,
  SignerSignature,
  SubscriptionHandle,
  SystemDeleteTransaction,
  SystemUndeleteTransaction,
  TokenAssociateTransaction,
  TokenBurnTransaction,
  TokenType,
  TokenSupplyType,
  TokenCreateTransaction,
  TokenDeleteTransaction,
  TokenDissociateTransaction,
  TokenFeeScheduleUpdateTransaction,
  TokenFreezeTransaction,
  TokenGrantKycTransaction,
  TokenInfo,
  TokenInfoQuery,
  TokenMintTransaction,
  TokenNftInfo,
  TokenNftInfoQuery,
  TokenPauseTransaction,
  TokenRevokeKycTransaction,
  TokenUnfreezeTransaction,
  TokenUnpauseTransaction,
  TokenUpdateTransaction,
  TokenWipeTransaction,
  TopicCreateTransaction,
  TopicDeleteTransaction,
  TopicInfo,
  TopicInfoQuery,
  TopicMessageChunk,
  TopicMessage,
  TopicMessageQuery,
  TopicMessageSubmitTransaction,
  TopicUpdateTransaction,
  TransferTransaction,
  Wallet,
  LogLevel2 as LogLevel,
  Logger2 as Logger,
  NetworkName,
  import_long52 as import_long,
  WebClient
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

pvtsutils/build/index.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2022 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)
*/
//# sourceMappingURL=chunk-AJONMJCP.js.map
